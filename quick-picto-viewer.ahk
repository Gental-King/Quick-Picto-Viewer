; Original script details:
;   Name:     AHK Picture Viewer
;   Version:  1.0.0 on Oct 4, 2010 by SBC
;   Platform: Windows XP or later
;   Author:   SBC - http://sites.google.com/site/littlescripting/
;   Found on: https://autohotkey.com/board/topic/58226-ahk-picture-viewer/
;
; New script details:
;   Name:     Quick Picto Viewer
;   Version:  [see change logs file]
;   Platform: Windows XP*, Windows 7 or later; Preferred is Windows 10.
;   Author:   Marius Șucan - http://marius.sucan.ro/
;   GitHub:   https://github.com/marius-sucan/Quick-Picto-Viewer
;
; *It can run on Windows XP, but various features might not work.
; You must provide all the following files found in Windows 10
; installations x32/x64 in the same folder with the QPV binary:
; api-ms-win-core-*-l1-1-0.dll [43 files]
; api-ms-win-crt-*-l1-1-0.dll [15 files]
; api-ms-win-core-file-l1-2-0.dll
; api-ms-win-core-file-l2-1-0.dll
; api-ms-win-core-localization-l1-2-0.dll
; api-ms-win-core-synch-l1-2-0.dll
; ucrtbase.dll
;
; The following DLLs are included in the Quick Picto Viewer package:
; FreeImage.dll
; msvcr100.dll
; sqlite3.dll
; vcomp140.dll
; vcruntime140.dll
;
; Script main functionalities:
; Display images and creates slideshows using GDI+ and FreeImage
; 85 supported image formats: jpeg, jpg, bmp, png, gif, tif, emf
; hdr, exr, webp, raw and many more...
;
; Original Licence: GPL. Please reffer to this page for more information. http://www.gnu.org/licenses/gpl.html
; Current licence: I do not know , I do not care. Licences are for obedient entities.
;
;@Ahk2Exe-AddResource LIB Lib\module-interface.ahk
;@Ahk2Exe-AddResource LIB Lib\module-fim-thumbs.ahk
;@Ahk2Exe-SetName Quick Picto Viewer
;@Ahk2Exe-SetDescription Quick Picto Viewer
;@Ahk2Exe-SetVersion 4.6.5
;@Ahk2Exe-SetCopyright Marius Şucan (2019-2020)
;@Ahk2Exe-SetCompanyName marius.sucan.ro
;@Ahk2Exe-SetMainIcon qpv-icon.ico
;
;___________ Auto Execute Section ____

#NoEnv
#NoTrayIcon
#MaxHotkeysPerInterval, 500
#MaxThreads, 255
#MaxThreadsPerHotkey, 1
#MaxThreadsBuffer, Off
#MaxMem, 9924
#IfTimeout, 35
#SingleInstance, off
#UseHook, Off
SetWorkingDir, %A_ScriptDir%
#Include Lib\Gdip_All.ahk           ; graphics display interface plus v1.1
#Include Lib\Gdi.ahk                ; graphics display interface
#Include Lib\SGdiPrint.ahk
; #Include Lib\guicontroltips.ahk
#Include Lib\freeimage-wrapper.ahk  ; used to load exotic file formats
#Include Lib\MCI.ahk                ; media controller interface [ used for audio annotations/files associated with images ]
#Include Lib\wia.ahk                ; windows image acquisition [ used for acquiring images from scanners ]
; #Include Lib\wic.ahk              ; windows image component ; I would like to finish this implementation one day...
#Include Lib\Class_SQLiteDB.ahk     ; use for slideshow databases and maintaining a list of viewed images [if activated]
#Include Lib\msgbox2.ahk
#Include Lib\file-get-prop-lib.ahk  ; used to get file properties on Alt+Enter [ File Information panel ]

SetWinDelay, 1
SetBatchLines, -1

Global PVhwnd := 1, hGDIwin := 1, hGDIthumbsWin := 1, pPen4 := "", pPen5 := "", pPen6 := "", unCompiledExePath := "", pBrushZ := ""
   , glPG := "", glOBM := "", glHbitmap := "", glHDC := "", pPen1 := "", pPen1d, pPen2 := "", pPen3 := "", AmbientalTexBrush := ""
   , pBrushHatch := "", pBrushWinBGR := "", pBrushA := "", pBrushB := "", pBrushC := "", pBrushD := "", currentPixFmt := ""
   , pBrushE := "", pBrushHatchLow, hGuiTip := 1, hSetWinGui := 1, undoSelLevelsArray := []
   , prevFullThumbsUpdate := 1, winGDIcreated := 0, ThumbsWinGDIcreated := 0, pBrushHatchLiw := ""
   , hPicOnGui1 := "", scriptStartTime := A_TickCount, lastEditRHChange :=1, doubleBlurPreviewArea := 0
   , newStaticFoldersListCache := [], lastEditRWChange := 1, QPVjournal := []
   , mainCompiledExe := "", mainCompiledPath := "", wasInitFIMlib := 0, hGDIselectWin, allowNextSlide := 1
   , filteredMap2mainList := [], thumbsCacheFolder := A_ScriptDir "\thumbs-cache"
   , resultedFilesList := [], currentFileIndex := "", maxFilesIndex := 0, gdiBitmapIDentire := 0
   , appTitle := "Quick Picto Viewer", FirstRun := 1, hSNDmediaFile := "", mouseToolTipWinCreated := 0
   , bckpResultedFilesList := [], bckpMaxFilesIndex := 0, DynamicFoldersList := ""
   , animGIFplaying := 0, startPageIndex := 0, RandyIMGids := [], SLDhasFiles := 0
   , IMGdecalageY := 1, IMGdecalageX := 1, imgQuality, usrFilesFilteru := ""
   , RandyIMGnow := 0, GDIPToken := "", gdiBitmapSmall := "", hSNDmedia := "", imgIndexEditing := 0
   , AprevGdiBitmap := "", BprevGdiBitmap := "", msgDisplayTime := 3000, gdiBitmapIDcall := ""
   , slideShowRunning := 0, CurrentSLD := "", markedSelectFile := 0, IMGlargerViewPort := 0
   , ResolutionWidth := "", ResolutionHeight := "", prevStartIndex := 1, mustReloadThumbsList := 0
   , gdiBitmap := "", mainSettingsFile := "quick-picto-viewer.ini", mainRecentsFile := "quick-picto-viewer-recents.ini"
   , mustOpenStartFolder := "", mainFavesFile := "quick-picto-viewer-favourites.ini"
   , RegExFilesPattern := "i)^(.\:\\).*(\.(ico|dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif))$"
   , RegExFIMformPtrn := "i)(.\\*\.(DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f))$"
   , saveTypesRegEX := "i)(.\.(bmp|j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp|gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|xpm))$"
   , saveTypesFriendly := ".BMP, .GIF, .HDP, .J2K, .JFIF, .JIF, .JNG, .JP2, .JPE, .JPG, .JXR, .PNG, .PPM, .TGA, .TIF, ..WDP, .WEBP or .XPM"
   , saveAlphaTypesRegEX := "i)(.\.(j2k|j2c|jp2|jxr|wdp|hdp|png|tga|tif|tiff|webp))$"
   , openFptrn1 := "*.png;*.bmp;*.gif;*.jpg;*.tif;*.tga;*.webp;*.jpeg", prevLoadedImageIndex := 0
   , openFptrn2 := "*.dds;*.emf;*.exr;*.g3;*.hdp;*.iff;*.j2c;*.j2k;*.jbg;*.jif;*.jng;*.jp2;*.jxr;*.koa;*.lbm;*.mng;*.pbm;*.pcd;*.pct;*.pcx;*.pfm;*.pgm;*.pic;*.ppm;*.psd;*.ras;*.sgi;*.wap;*.wbm;*.wbmp;*.wdp;*.wmf;*.xbm;*.xpm"
   , openFptrn3 := "*.3fr;*.arw;*.bay;*.bmq;*.cap;*.cine;*.cr2;*.crw;*.cs1;*.dc2;*.dcr;*.drf;*.dsc;*.erf;*.fff;*.hdr;*.ia;*.iiq;*.k25;*.kc2;*.kdc;*.mdc;*.mef;*.mos;*.mrw;*.nef;*.nrw;*.orf;*.pef;*.ptx;*.pxn;*.qtk;*.raf;*.raw;*.rdc;*.rw2;*.rwz;*.sr2;*.srf;*.x3f"
   , openFptrn4 := "*.tiff;*.targa;*.jpe;*.dib;*.pict;*.rle", userJpegQuality := 90
   , saveImgFormatsList := {1:"bmp", 2:"gif", 3:"hdp", 4:"j2k", 5:"jfif", 6:"jng", 7:"jp2", 8:"jpg", 9:"jxr", 10:"png", 11:"ppm", 12:"tga", 13:"tif", 14:"wdp", 15:"webp", 16:"xpm"}
   , dialogSaveFptrn := "Portable Network Graphics (*.png)|WebP (*.webp)|Common JPEG (*.jpg;*.jpeg)|TrueVision Targa (*.tga)|Tagged Image File Format (*.tif;*.tiff)|Non-animated Compuserve GIF (*.gif)|Windows Bitmap (*.bmp)|HD Photo (*.hdp)|JPEG File Interchange Format (*.jfif)|JNG (*.jng)|JPEG 2000 (*.jp2;*.j2k)|JPEG-XR (*.jxr)|Portable PixelMap (*.ppm)|WDP (*.wdp)|XPM (*.xpm)"
   , dialogSaveIndexes := {1:"png", 2:"webp", 3:"jpg", 4:"tga", 5:"tif", 6:"gif", 7:"bmp", 8:"hdp", 9:"jfif", 10:"jng", 11:"jp2", 12:"jxr", 13:"ppm", 14:"wdp", 15:"xpm"}
   , LargeUIfontValue := 14, AnyWindowOpen := 0, toolTipGuiCreated := 0, panelWinCollapsed :=0 
   , PrefsLargeFonts := 0, OSDbgrColor := "131209", OSDtextColor := "FFFEFA", initialCustomShapeCoords := ""
   , PasteFntSize := 35, OSDfntSize := 25, OSDFontName := "Arial", prevOpenFolderPath := ""
   , mustGenerateStaticFolders := 1, lastWinDrag := 1, img2resizePath := "", colorPickerModeNow := 0
   , prevFileMovePath := "", lastGIFdestroy := 1, prevAnimGIFwas := "", prevFilesSortMode
   , thumbsW := 300, thumbsH := 300, thumbsDisplaying := 0, scrollAxis := 0, userSeenSessionImagesArray := []
   , othumbsW := 300, othumbsH := 300, ForceRegenStaticFolders := 0, vPselRotation := 0
   , CountFilesFolderzList := 0, RecursiveStaticRescan := 0, imgSelLargerViewPort := 0
   , UsrMustInvertFilter := 0, userActionConflictingFile := 1, LastPrevFastDisplay := 0
   , prevFileSavePath := "", imgHUDbaseUnit := Round(OSDfntSize*2.5), lastLongOperationAbort := 1
   , lastOtherWinClose := 1, UsrCopyMoveOperation := 2, editingSelectionNow := 0
   , ForceNoColorMatrix := 0, prevFastDisplay := 1, hSNDmediaDuration, lastMenuBarUpdated := 1
   , imgSelX1 := 0, imgSelY1 := 0, imgSelX2 := -1, imgSelY2 := -1, adjustNowSel := 0
   , prevImgSelX1 := 0, prevImgSelY1 := 0, prevImgSelX2 := -1, prevImgSelY2 := -1, prevSelDotX := "", prevSelDotY := "", prevSelDotAx := "", prevSelDotAy := ""
   , selDotX := "", selDotY := "", selDotAx := "", selDotAy := "", selDotBx := "", selDotBy := "", selDotCx := "", selDotCy := "", selDotDx := "", selDotDy := ""
   , prcSelX1 := 0, prcSelX2 := 0.5, prcSelY1 := 0, prcSelY2 := 0.5, PannedFastDisplay := 1, pBrushF := ""
   , SelDotsSize := imgHUDbaseUnit//4, ViewPortBMPcache := "", startZeitIMGload := 0, cachedAllSessionsSeen := []
   , imageLoading := 0, PrevGuiSizeEvent := 0, imgSelOutViewPort := 0, prevGUIresize := 1
   , imgEditPanelOpened := 0, jpegDoCrop := 0, jpegDesiredOperation := 1, copyMoveDoLastOption := 0
   , rDesireWriteFMT := "jpg", FIMfailed2init := 0, prevMaxSelX := "", prevMaxSelY := "", prevDestPosX := "", prevDestPosY := ""
   , hCursBusy := DllCall("user32\LoadCursorW", "Ptr", NULL, "Int", 32514, "Ptr")  ; IDC_WAIT
   , CCLVO := "-E0x200 +Border -Hdr -Multi +ReadOnly Report AltSubmit gSetUIcolors", FontList := []
   , totalFramesIndex := "", pVwinTitle := "", AprevImgCall := "", BprevImgCall := "", prevSetWinPosX := "", prevSetWinPosY := ""
   , coreIMGzeitLoad := 0, desiredFrameIndex := 0, prevDrawingMode := 0, sqlFailedInit := 0, currentImgModified := 0
   , currIMGdetails := [], AbackupIMGdetails := [], BbackupIMGdetails := [], mainLoadedIMGdetails := []
   , diffIMGdecX := 0, diffIMGdecY := 0, prevGDIvpCache := "", oldZoomLevel := 0, fullPath2exe := "", hasMemThumbsCached := 0
   , hitTestSelectionPath := "", scrollBarHy := 0, scrollBarVx := 0, HistogramBMP := "", internalColorDepth := 0
   , drawModeBzeit := 1, drawModeAzeit := 1, drawModeCzeit := 1, prevColorAdjustZeit := 1, AutoCropBordersSize := 15
   , GDIfadeVPcache := "", executingCanceableOperation := 1, hCropCornersPic, UserMemBMP := "", userSearchString := ""
   , systemCores := 1, realSystemCores := 1, hasInitSpecialMode := 0, CountGIFframes := 0, prevSlideShowStop := 1
   , prevTryThumbsUpdate := 1, thumbsSizeQuality := 245, prevFullIndexThumbsUpdate := -1, userClipBMPpaste
   , UserNewWidth := 0, UserNewHeight := 0, UserNewDPI := 0, viewportStampBMP := "", tinyPrevAreaCoordY := 1
   , ThumbsStatusBarH := 0, activeSQLdb := "", SLDtypeLoaded := 0, sldsPattern := "i)(.\.(sld|sldb))$"
   , imgThumbsCacheIDsArray := [], imgThumbsCacheArray := [], viewportIDstampBMP := 0, qpvMainDll
   , prevVPselRotation, prevrotateSelBoundsKeepRatio, prevEllipseSelectMode, currentSelUndoLevel := 1
   , seenImagesDB := "", skipSeenImagesSlider := 0, hEditField := "", gdiBMPvPsize := "", maxGDIbmpSize := 533654021
   , GDIcacheSRCfileA := "", idGDIcacheSRCfileA := "", GDIcacheSRCfileB := "", idGDIcacheSRCfileB := "", prevOpenedWindow := []
   , startLongOperation := 1, thisIMGisDownScaled := 0, simpleOpRotationAngle := 1, UserTextArea := ""
   , runningLongOperation := 0, hasReachedMaxUndoLevels := 0, GIFframesPlayied := 0, allImagesWereSeen := 0
   , 2NDglHbitmap := "", 2NDglHDC := "", 2NDglOBM := "", 2NDglPG := "", mainThreadHwnd := "", imgDecLX := "", imgDecLY := ""
   , undoLevelsArray := [], currentUndoLevel := 0, maxUndoLevels := 50, undoLevelsRecorded := 0, hGDIinfosWin := ""
   , zeitSillyPrevent := 1, PrintPosX, PrintPosY, PrintPosW, PrintPosH, tinyPrevAreaCoordX := 1
   , hLVmainu := 0, tempBtnVisible := "null", tempBtnGuiBtnArray := [], lastRenameUndo := [], userMultiCoresLimit := 100
   , drawingShapeNow := 0, customShapePoints := "", prevResizedVPimgW := "", prevResizedVPimgH := "", PenuDrawLive := ""
   , initialDrawingStartCoords := [], drawingLiveMode := 0, cardinalCurveCustomShape := 0, openingPanelNow := 0
   , closedLineCustomShape := 1, tensionCurveCustomShape := 0.5, PanelDefineSelectionCoords := 0
   , SelectionCoordsType := 1, PasteInPlaceAlphaFile := "", infoBoxGdiCached := "", watchFolderDetails := ""
   , HUDobjNavBoxu := [], HUDobjHistoBoxu := [], globalhFIFimg := 0, userAddedFavesCount := 0, qpvCanvasHasInit := 0
   , maxFavesEntries := 54321, gdipLastError := 0, hasDrawnImageMap := 0, hasDrawnHistoMap := 0, coreDesiredPixFmt := "0xE200B"
   , isWinXP := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_2003" || A_OSVersion="WIN_2000") ? 1 : 0
   , QPVpid := GetCurrentProcessId(), preventUndoLevels := 0, maxMemUndoLevels := 979394
   , CurrentPanelTab := 0, debugModa := !A_IsCompiled, createdGDIobjsArray := [], countGDIobjects := 0
   , QPVregEntry := "HKEY_CURRENT_USER\SOFTWARE\Quick Picto Viewer"
   , appVersion := "4.6.5", vReleaseDate := "28/10/2020"

 ; User settings
   , askDeleteFiles := 1, enableThumbsCaching := 1, OnConvertKeepOriginals := 1
   , thumbsAratio := 3, thumbsZoomLevel := 1, zatAdjust := 0, lummyAdjust := 0
   , specialColorFXmode := 1, uiColorCurveFXmode := 2, uiColorCurveFXchannel := 4
   , WindowBgrColor := "010101", slideShowDelay := 3000, userMultiDelChoice := 2
   , IMGresizingMode := 1, SlideHowMode := 1, TouchScreenMode := 1
   , lumosAdjust := 1, GammosAdjust := 0, userimgQuality := 0
   , imgFxMode := 1, FlipImgH := 0, FlipImgV := 0, satAdjust := 1
   , imageAligned := 5, filesFilter := "", isAlwaysOnTop := 0
   , noTooltipMSGs := 0, zoomLevel := 1, skipDeadFiles := 0, userHQraw  := 0
   , isTitleBarHidden := 1, lumosGrayAdjust := 0, GammosGrayAdjust := 0
   , MustLoadSLDprefs := 0, animGIFsSupport := 1, move2recycler := 1
   , SLDcacheFilesList := 1, autoRemDeadEntry := 1, ResizeWithCrop := 1, ResizeMustPerform := 1
   , easySlideStoppage := 1, ResizeInPercentage := 0, usrAdaptiveThreshold := 1
   , ResizeKeepAratio := 1, ResizeQualityHigh := 1, ResizeRotationUser := "Rotate: 0°"
   , ResizeApplyEffects := 1, autoAdjustMode := 1, doSatAdjusts := 1, SimpleOperationsScaleXImgFactor := "100 %"
   , ResizeDestFolder, ResizeUseDestDir := 0, chnRdecalage := 0.0, chnGdecalage := 0.0
   , chnBdecalage := 0.0, alwaysOpenwithFIM := 0, bwDithering := 0, showHistogram := 0
   , userUnsprtWriteFMT := 1, userDesireWriteFMT := 9, hueAdjust := 0, syncSlideShow2Audios := 0
   , DisplayTimeUser := 3, FontBolded := 1, FontItalica := 0, showInfoBoxHUD := 0, usrAutoCropGenerateSelection := 0
   , usrTextureBGR := 0, realGammos := 1, imgThreshold := 0, relativeImgSelCoords := 1, usrAutoCropDeviation := 0
   , RenderOpaqueIMG := 0, vpIMGrotation := 0, usrTextAlign := "Left", autoPlaySNDs := 0, usrAutoCropDeviationSnap := 1
   , ResizeCropAfterRotation := 1, usrColorDepth := 1, ColorDepthDithering := 1, mediaSNDvolume := 80
   , borderAroundImage := 0, performAutoCropNow := 0, usrAutoCropColorTolerance := 5, usrAutoCropImgThreshold := 0.005 
   , SimpleOperationsDoCrop := 0, SimpleOperationsRotateAngle := 1, SimpleOperationsScaleYImgFactor := "100 %"
   , SimpleOperationsNoPromptOnSave := 0, SimpleOperationsFlipV := 0, SimpleOperationsFlipH := 0, doSlidesTransitions := 0
   , usrAutoCropDeviationPixels := 0, multilineStatusBar := 0, AutoCropAdaptiveMode := 1, allowGIFsPlayEntirely := 0
   , allowMultiCoreMode := 1, AutoDownScaleIMGs := 0, minimizeMemUsage := 0, GIFspeedDelay := 35
   , maxUserThreads := 30, maxMemThumbsCache := 300, resetImageViewOnChange := 0, FillAreaRemBGR := 0
   , FillAreaDoContour := 0, FillAreaContourThickness := 20, EraseAreaFader := 0, EraseAreaOpacity := 190
   , FillAreaOpacity := 250, FillAreaColor := OSDbgrColor, FillAreaShape := 1, FillAreaInverted := 0
   , FillAreaRoundedCaps := 1, FillAreaDoubleLine := 0, blurAreaOpacity := 250, blurAreaAmount := 10
   , PasteInPlaceCentered := 3, PasteInPlaceOpacity := 255, PasteInPlaceAdaptMode := 1, PasteInPlaceQuality := 1
   , PasteInPlaceOrientation := 1, showImgAnnotations := 0, blurAreaSoftEdges := 1, blurAreaInverted := 0
   , PasteInPlaceBlurAmount := 0, PasteInPlaceCropSel := 0

Global PasteInPlaceGamma := 0, PasteInPlaceSaturation := 0, PasteInPlaceHue := 0, PasteInPlaceLight := 0
   , EllipseSelectMode := 0, thumbsListViewMode := 1, FillAreaContourAlign := 2, FillAreaDashStyle := 1
   , adjustCanvasCentered := 1, adjustCanvasMode := 1, adjustCanvasNoBgr := 1, LimitSelectBoundsImg := 1
   , DrawLineAreaColor := "ff3366", DrawLineAreaDashStyle := 1, DrawLineAreaContourAlign := 1, DrawLineAreaKeepBounds := 1
   , DrawLineAreaContourThickness := 20, DrawLineAreaOpacity := 255, DrawLineAreaBorderTop := 1, DrawLineAreaBorderBottom := 0
   , DrawLineAreaBorderLeft := 1, DrawLineAreaBorderRight := 0, DrawLineAreaBorderCenter := 1, DrawLineAreaBorderArcA := 0
   , DrawLineAreaBorderArcC := 0, DrawLineAreaBorderArcD := 1, DrawLineAreaCapsStyle := 1, DrawLineAreaDoubles := 0
   , PasteInPlaceEraseInitial := 1, PasteInPlaceLivePreview := 1, DrawLineAreaBorderArcB := 0
   , PasteInPlaceToolMode := 0, NewDocUseColor := 1, PredefinedDocsSizes := 1, NewImageReverseDimensions := 0, FillAreaGlassy := 1
   , FillAreaColorMode := 1, FillAreaColorReversed := 0, FillArea2ndColor := "FF2211", FillArea2ndOpacity := 200, FillAreaGradientAngle := 0
   , FillAreaGradientSigma := 5, FillAreaGradientBlend := 100, FillAreaGradientScale := 100, FillAreaGradientWrapped := 1
   , thumbnailsListMode := 0, TextInAreaFontName := "Arial", TextInAreaFontSize := 15, TextInAreaBorderSize := 5
   , TextInAreaFontBold := 0, TextInAreaFontItalic := 0, TextInAreaFontUline := 0, TextInAreaAlign := 1, TextInAreaBgrUnified := 0
   , TextInAreaFontColor := "eeFFaa", TextInAreaFontOpacity := 250, TextInAreaRoundBoxBgr := 1, TextInAreaValign := 1
   , TextInAreaBgrColor := "229933", TextInAreaBgrOpacity := 100, TextInAreaOnlyBorder := 0, TextInAreaBlurAmount := 0
   , TextInAreaBorderOut := 1, TextInAreaBorderColor := "334400", TextInAreaBorderOpacity := "200", TextInAreaCharSpacing := 0
   , TextInAreaUsrMarginz := 0, TextInAreaBlurBorderAmount := 0, TextInAreaDoBlurs := 0, TextInAreaLineAngle := 0
   , TextInAreaFontLineSpacing := 0, TextInAreaCutOutMode := 0, TextInAreaBgrEntire := 0, TextInAreaFontStrike := 0
   , TextInAreaLivePreview := 1, showMainMenuBar := 1, markSearchMatches := 1, showSelectionGrid := 0, blurAreaTwice := 0
   , allowRecordHistory := 1, FillAreaLivePreview := 1, TextInAreaPaintBgr := 1, rotateSelBoundsKeepRatio := 1
   , highlightAlreadySeenImages := 1, useCachedSLDdata := 1, PreserveDateTimeOnSave := 0, PrintAdaptToFit := 1
   , PrintDimensionsXYWH := "0|0|50|50", PrintColorMode := 1, PrintOrientation := 0, PrintUseViewportColors := 1
   , userAllowWindowDrag := 0, FillAreaClosedPath := 1, FillAreaCustomShape := "", PasteInPlaceAlphaMaskMode := 1
   , PasteInPlaceAlphaMaskClrA := 0, PasteInPlaceAlphaMaskClrB := 255, closeEditPanelOnApply := 1, FillAreaCurveTension := 2
   , alphaMaskOffsetX := 0, alphaMaskOffsetY := 0, alphaMaskReplaceMode := 0, PasteInPlaceAlphaChannelFile := 5
   , blurAreaMode := 1, FillAreaBlendMode := 1, PasteInPlaceApplyColorFX := 0, blurAreaPixelizeAmount := 0
   , dynamicThumbsColumns := 1, thumbsColumns := 10, TextInAreaAutoWrap := 1, histogramMode := 2, cmrRAWtoneMapParamB := 0
   , showHUDnavIMG := 0, HUDnavBoxSize := 75, PrintTxtSize := 300, cmrRAWtoneMapAlgo := 1, cmrRAWtoneMapParamA := 1.85
   , mainWinPos := 0, mainWinMaximized := 2, mainWinSize := 0, UserExternalApp := "", UserExternalEditApp := ""
   , lockSelectionAspectRatio := 0, desiredSelAspectRatio := 0, adjustingSelDotNow := 0, cycleFavesOpenIMG := 0

EnvGet, realSystemCores, NUMBER_OF_PROCESSORS
addJournalEntry("Application started.`nCPU cores identified: " realSystemCores ".")

If (realSystemCores>100)
   realSystemCores := 100

RegRead, InitCheckReg, %QPVregEntry%, Running
RegRead, InitTimeReg, %QPVregEntry%, LastStartTime
If (Abs(A_TickCount - InitTimeReg)<600 && IsNumber(InitTimeReg) && InitCheckReg=1 && InitTimeReg>1)
{
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

If !A_IsCompiled
   Try Menu, Tray, Icon, qpv-icon.ico

DetectHiddenWindows, On
CoordMode, Mouse, Screen
CoordMode, ToolTip, Screen
OnExit, doCleanup

initCompiled(A_IsCompiled)
thisGDIPversion := Gdip_LibrarySubVersion()
GDIPToken := Gdip_Startup()
If (!GDIPToken || thisGDIPversion<1.85)
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+...`n`nThe program will now exit.`n`nRequired GDI+ library wrapper: v1.84 - extended compilation edition.
   hasInitSpecialMode := 1
   ForceExitNow()
   ExitApp
}

; RegRead, initArgu, %QPVregEntry%, initArgu
If (InitCheckReg=2)
{
   initExternalCoreMode()
   Return
}

RegWrite, REG_SZ, %QPVregEntry%, Running, 1
RegWrite, REG_SZ, %QPVregEntry%, LastStartTime, % A_TickCount
IniRead, FirstRun, % mainSettingsFile, General, FirstRun, @
If (FirstRun!=0)
{
   writeMainSettings()
   FirstRun := 0
   IniWrite, % FirstRun, % mainSettingsFile, General, FirstRun
} Else loadMainSettings()

Loop, 9
    OnMessage(255+A_Index, "PreventKeyPressBeep")   ; 0x100 to 0x108

Global interfaceThread
If !A_IsCompiled
   interfaceThread := ahkthread("#Include *i Lib\module-interface.ahk")
Else If (sz := GetRes(data, 0, "MODULE-INTERFACE.AHK", "LIB"))
   interfaceThread := ahkThread(StrGet(&data, sz, "utf-8"))

; the interface is a separate thread to allow users 
; enjoy a more responsive user interface when the main thread
; is busy processing

initGUI := interfaceThread.ahkFunction("BuildGUI")
If !initGUI
{
   MsgBox, 48, %appTitle%, ERROR: Unable to initialize the interface. The application will now exit...
   hasInitSpecialMode := 1
   ForceExitNow()
   Return
}
*/

createGDIPcanvas()
InitGDIpStuff()

Global multiCoreThumbsInitGood := "n",thumbThread1,thumbThread2,thumbThread3,thumbThread4,thumbThread5,thumbThread6,thumbThread7,thumbThread8,thumbThread9,thumbThread10,thumbThread11
,thumbThread12,thumbThread13,thumbThread14,thumbThread15,thumbThread16,thumbThread17,thumbThread18,thumbThread19,thumbThread20,thumbThread21
,thumbThread22,thumbThread23,thumbThread24,thumbThread25,thumbThread26,thumbThread27,thumbThread28,thumbThread29,thumbThread30,thumbThread31
,thumbThread32,thumbThread33,thumbThread34,thumbThread35,thumbThread36,thumbThread37,thumbThread38,thumbThread39,thumbThread40,thumbThread41
,thumbThread42,thumbThread43,thumbThread44,thumbThread45,thumbThread46,thumbThread47,thumbThread48,thumbThread49,thumbThread50,thumbThread51
,thumbThread52,thumbThread53,thumbThread54,thumbThread55,thumbThread56,thumbThread57,thumbThread58,thumbThread59,thumbThread60,thumbThread61
,thumbThread62,thumbThread63,thumbThread64,thumbThread65,thumbThread66,thumbThread67,thumbThread68,thumbThread69,thumbThread70,thumbThread71
,thumbThread72,thumbThread73,thumbThread74,thumbThread75,thumbThread76,thumbThread77,thumbThread78,thumbThread79,thumbThread80,thumbThread81
,thumbThread82,thumbThread83,thumbThread84,thumbThread85,thumbThread86,thumbThread87,thumbThread88,thumbThread89,thumbThread90,thumbThread91
,thumbThread92,thumbThread93,thumbThread94,thumbThread95,thumbThread96,thumbThread97,thumbThread98,thumbThread99,thumbThread100,

If (A_PtrSize=4)
{
   allowMultiCoreMode := 0
   minimizeMemUsage := 1
   maxUndoLevels := 2

}
coreDesiredPixFmt := (minimizeMemUsage=1) ? "0x21808" : "0xE200B"

; OnMessage(0x205, "WM_RBUTTONUP")
TriggerMenuBarUpdate()
addJournalEntry("Finished initialization of " appTitle " v" appVersion ".")
If (qpvCanvasHasInit=1)
   doWelcomeNow := intializeWithGivenArguments()

; MsgBox, % A_TickCount - scriptStartTime
If (doWelcomeNow=1 && qpvCanvasHasInit=1)
   SetTimer, drawWelcomeImg, -25

Return

;_____________________________________ Hotkeys _________________

identifyThisWin() {
  Static prevR, lastInvoked := 1
  If (A_TickCount - lastInvoked < 150)
     Return prevR

  prevR := WinActive("ahk_class AutoHotkeyGUI ahk_group QPVwindows") ? 1 : 0
  lastInvoked := A_TickCount
  Return prevR
}

HKifs(q:=0) {
   whichBitmap := useGdiBitmap() ? 1 : 0
   If (q="imgEditSolo")
      r := (!AnyWindowOpen && openingPanelNow!=1 && currentFileIndex=0 && !CurrentSLD && thumbsDisplaying!=1 && whichBitmap=1) ? 1 : 0
   Else If (q="imgsLoaded")
      r := (!AnyWindowOpen && openingPanelNow!=1 && CurrentSLD && maxFilesIndex>0) ? 1 : 0
   Else If (q="liveEdit")
      r := (AnyWindowOpen && openingPanelNow!=1 && imgEditPanelOpened=1 && whichBitmap=1) ? 1 : 0
   Else If (q="general")
      r := (!AnyWindowOpen && imgEditPanelOpened!=1) ? 1 : 0

   If (drawingShapeNow=1)
      r := 0

   Return r
}

#If (identifyThisWin()=1)
    ^vk4F::    ; Ctrl+O
       If HKifs("general")
          OpenDialogFiles()
    Return

    vk4F::    ; O
       imgPath := getIDimage(currentFileIndex)
       If HKifs("imgsLoaded")
          OpenThisFileMenu()
       Else If ((HKifs("general") && (!CurrentSLD || StrLen(gdiBitmap)<3)) && !FileRexists(imgPath))
          OpenDialogFiles()
    Return

    w::   ; to-do  to do
    ; coreDesiredPixFmt := "0x21808"
    ;         pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    ;         ToolTip, % pixFmt , , , 2
    ;         SoundBeep 
    ; ToolTip, % A_TickCount - startZeit , , , 2
    ; testWICwhatever()
   ; ; testWICresizeSpeed()
   ;     testArkive()
   Sleep, 1
    Return

    ^+vk4E::    ; Ctrl+Shift+N
       If HKifs("general")
          OpenNewQPVinstance()
    Return

    ^vk4E::    ; Ctrl+N
       If HKifs("general")
          PanelNewImage()
    Return

    +vkC0::    ; Shift+[~]
       If AnyWindowOpen
          Return

       PanelJournalWindow()
    Return

    F12::
       If HKifs("general")
          openPrefsPanelWindow()
    Return

    vk50::    ; P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingLines()
    Return

    +vk50::    ; Shift+P
       If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
          MenuStartDrawingShapes()
    Return

    ^vk50::    ; Ctrl+P
       If (!AnyWindowOpen && imageLoading!=1 && (HKifs("imgEditSolo") || HKifs("imgsLoaded")))
          PanelPrintImage()
    Return

    ^NumpadAdd::
    ^vkBB::    ; [=]
       changeOSDfontSize(1)
    Return

    ^NumpadSub::
    ^vkBD::   ; [-]
       changeOSDfontSize(-1)
    Return

    +vk4F::    ; Shift+O
       If HKifs("general")
          OpenFolders()
    Return

    ~F10::
    ~+F10::
    ~!F10::
       If (drawingShapeNow!=1)
          ToggleQuickBaru()
    Return

    ^AppsKey::
    +AppsKey::
    #AppsKey::
    !AppsKey::
    AppsKey::
       Suspend, Permit
       InitGuiContextMenu()
    Return

    ~Insert Up::
       If (HKifs("general") && imageLoading!=1)
          addNewFile2list()
    Return

    ^vk56 Up::   ; Ctrl+V
       If (HKifs("general") && imageLoading!=1)
          PasteClipboardIMG()
    Return

    +Esc::
       restartAppu()
    Return

    F1::
       AboutWindow()
    Return

    ^F4::
       If (drawingShapeNow=1)
       {
          stopDrawingShape()
          Return
       } Else If AnyWindowOpen
       {
          CloseWindow()
          Return
       } Else If (thumbsDisplaying=1)
       {
          If StrLen(UserMemBMP)>3
             MenuReturnIMGedit()
          Else
             ToggleThumbsMode()
          Return
       }

       closeDocuments()
    Return

    !F4::
    Esc::
       escRoutine()
    Return

    ~vk44 Up::   ; D
      If (HKifs("liveEdit") && AnyWindowOpen!=10)
         hideLivePreviewObject()
    ;   Else If (HKifs("liveEdit") && AnyWindowOpen=10)
    ;      tlbrToggleImgSelection()
    ;   Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
    ;   {
    ;      toggleImgSelection()
    ;      If (editingSelectionNow=1)
    ;         CreateGuiButton("Selection options,,BuildImgLiveEditMenu", 0, msgDisplayTime//1.5 + 500)
    ;   }
    Return

    vk4C::     ; L
      If ((HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && editingSelectionNow=1 && thumbsDisplaying!=1)
         toggleLimitSelection()
      Else If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         toggleListViewModeThumbs()
    Return

    +^vk56 Up::   ; Ctrl+Shift+V
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelPasteInPlace()
    Return

    ~^vk44 Up::   ; Ctrl+D
      If (HKifs("imgsLoaded") && ((thumbsDisplaying=1) || (editingSelectionNow!=1 && markedSelectFile)))
         dropFilesSelection()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         resetImgSelection()
    Return

    ~^vk43 Up::    ; Ctrl+C
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCopyFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CopyImage2clip()
    Return

    ~^vk58 Up::    ; Ctrl+X
      If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
         MenuExplorerCutFiles()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CutSelectedArea()
    Return

    ^vk5A::    ; Ctrl+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction()
    Return

    vk5A::    ; Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgNavBox()
    Return

    ^vk59::    ; Ctrl+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction()
    Return

    ^+vk5A::    ; Ctrl+Shift+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelUndoAct()
    Return

    ^+vk59::    ; Ctrl+Shift+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgSelRedoAct()
    Return

    ^!vk5A::    ; Ctrl+Alt+Z
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgUndoAction("j")
    Return

    ^!vk59::    ; Ctrl+Alt+Y
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ImgRedoAction("j")
    Return

    vk45::   ; E
      If (HKifs("liveEdit") && AnyWindowOpen!=10)
         livePreviewsImageEditing(1, 1)
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         ToggleEditImgSelection()
         If (editingSelectionNow=1)
            CreateGuiButton("Selection options,,BuildImgLiveEditMenu", 0, msgDisplayTime//1.5 + 500)
      }
    Return

    +vk45::   ; Shift+E
      imgLiveEdit := (HKifs("liveEdit") && (AnyWindowOpen=24 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=10)) ? 1 : 0
      If (HKifs("imgEditSolo") || imgLiveEdit=1 || HKifs("imgsLoaded"))
         toggleEllipseSelection()
    Return

    !vk45::   ; Alt+E
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelIMGselProperties()
    Return

    ~^vk53 Up::   ; Ctrl+S
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelSaveImg()
    Return

    +vk4C::     ; Shift+L
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelDrawLines()
    Return

    !BackSpace::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelFillSelectedArea()
    Return

    !vk59::   ; Alt+Y
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelImgAutoCrop()
    Return

    ~vk49::   ; I
      If HKifs("liveEdit")
      {
         flipSelectionWH()
      } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (thumbsDisplaying!=1)
            ToggleInfoBoxu()
         Else
            PanelImageInfos()
      }
    Return

    vkDB::   ; [
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(-1)
    Return

    vkDD::   ; ]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeLumos(1)
    Return

    +vkDB::   ; Shift + [
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(-1)
    Return

    +vkDD::   ; Shift + ]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeGammos(1)
    Return

    ^vkDB::   ; Ctrl + [
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(-1)
    Return

    ^vkDD::   ; Ctrl + ]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeSaturation(1)
    Return

    !vkDB::   ; Alt + [
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(-1)
    Return

    !vkDD::   ; Alt + ]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeRealGamma(1)
    Return

    vkDC Up::   ; \
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         MenuToggleColorAdjustments()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ResetImageView()
    Return

    ^vkDC Up::   ; Ctrl+\
      If (HKifs("liveEdit") && AnyWindowOpen=10)
         btnResetImageView()
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         HardResetImageView()
    Return

    +vkDC Up::   ; Shift+\
      If HKifs("liveEdit")
      {
         resetSelectionRotation()
      } Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1 && vPselRotation>0)
            resetSelectionRotation()
         Else
            toggleColorAdjustments()
      }
    Return

    vkBF Up::   ; /
    NumpadDiv Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         IMGresizingMode := 0
         ToggleImageSizingMode()
      }
    Return

    NumpadMult Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         ; IMGresizingMode := 3
         IMGdecalageX := IMGdecalageY := zoomLevel := 1
         ToggleImageSizingMode("custom")
      }
    Return

    +NumpadAdd::
    +vkBB::    ; [=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(1)
    Return

    +NumpadSub::
    +vkBD::   ; [-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         changeSelectZoom(-1)
    Return

    NumpadAdd::
    vkBB::    ; [=]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(1)
    Return

    NumpadSub::
    vkBD::   ; [-]
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ChangeZoom(-1)
    Return

    vk47::    ; G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(1)
    Return

    +vk47::    ; Shift+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgHistogram(-1)
    Return

    !vk47::    ; Alt+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleHistogramMode()
    Return

    ~^vk52 Up::     ; Ctrl+R
      If HKifs("imgsLoaded")
         PanelSimpleResizeRotate()
    Return

    ~!vk52 Up::     ; Alt+R
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ResizeIMGviewportSelection()
    Return

    vk52::     ; R
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         makeSquareSelection()
    Return

    +vk52::     ; Shift+R
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         MenuSelRotation()
    Return

    ^vk54 Up::     ; Ctrl+T
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelTransformSelectedArea()
    Return

    +vk54 Up::     ; Shift+T
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelInsertTextArea()
    Return

    +vk49 Up::     ; Shift+I
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         InvertSelectedArea()
    Return

    ^vk47 Up::     ; Ctrl+G
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         GraySelectedArea()
    Return

    +vk42 Up::     ; Shift+B
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelBlurSelectedArea()
    Return

    vk42 Up::     ; B
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ToggleImgFavourites(0, 0, 1)
    Return

    ~vk48::    ; H
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         TransformIMGh()
    Return

    ~vk56::    ; V
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         TransformIMGv()
    Return

    ~+vk48::    ; Shift+H
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaH()
    Return

    ~+vk56::    ; Shift+V
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         FlipSelectedAreaV()
    Return

    ~vk55 Up::  ;  U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         PanelColorsAdjusterWindow()
    Return

    ~!+vk55 Up::  ;  Alt+Shift+U
      If (HKifs("imgsLoaded") && markedSelectFile>1 && imgFxMode>1)
         batchApplyColorsOnFiles()
    Return

    ~+vk55 Up::    ; Shift+U
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ApplyColorAdjustsSelectedArea()
    Return

    vk46::     ; F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(-1)
    Return

    +vk46::     ; Shift+F
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgFX(1)
    Return

    +vk51::  ;  Shift+Q-
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgColorDepth(1)
    Return

    vk51::  ;   Q
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleImgColorDepth(-1)
    Return

    ~Delete Up::
      If ((HKifs("imgEditSolo") || HKifs("liveEdit")) && thumbsDisplaying!=1 && editingSelectionNow=1)
         PanelEraseSelectedArea()
      Else If HKifs("imgsLoaded")
         deleteKeyAction()
    Return

    ~+Delete Up::
      If HKifs("imgsLoaded")
      {
         If !markedSelectFile
         {
            DeletePicture()
            Sleep, 350
            If (maxFilesIndex>1)
               InListMultiEntriesRemover()
         } Else DeleteActivePicture()
      }
    Return

    vk41::     ; A
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         ToggleIMGalign()
    Return

    +vk41::     ; Shift+A
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         toggleImgSelectionAspectRatio()
    Return

    !vk41::     ; Alt+A
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         PanelAdjustImageCanvasSize()
    Return

    ^vk41::     ; Ctrl+A
      If HKifs("liveEdit")
         selectEntireImage()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
      {
         If (thumbsDisplaying=1 && HKifs("imgsLoaded"))
            selectAllFiles()
         Else
            selectEntireImage()
      }
    Return

    vk39::    ; 9
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(-1)
         Else
            changeImgRotationInVP(-1)
      }
    Return

    vk30::    ; 0
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         If (editingSelectionNow=1)
            changeSelRotation(1)
         Else
            changeImgRotationInVP(1)
      }
    Return

    Up::
    +Up::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("U")
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Upu", A_ThisHotkey)
    Return

    Down::
    +Down::
      If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("D")
      Else If HKifs("imgsLoaded")
         ThumbsNavigator("Down", A_ThisHotkey)
    Return

    ^WheelUp::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         IMGresizingMode := 4
         ChangeZoom(1, "WheelUp")
      }
    Return

    ^WheelDown::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
      {
         IMGresizingMode := 4
         ChangeZoom(-1, "WheelDown")
      }
    Return

    !Left::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 1)
    Return

    !Right::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 1)
    Return

    !Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 1)
    Return

    !Down::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 1)
    Return

    ^+Left::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-1, 2)
    Return

    ^+Right::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(1, 2)
    Return

    ^+Up::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(-2, 2)
    Return

    ^+Down::
      If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded"))
         arrowKeysAdjustSelectionArea(2, 2)
    Return

    F8::
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         openPreviousPanel()
    Return

    Space::
      If (drawingShapeNow=1)
         ToggleCardinalCurveMode()
      Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1 || markedSelectFile)
            markThisFileNow()
         Else If (imageLoading!=1 && IMGlargerViewPort=1 && IMGresizingMode=4 && slideShowRunning!=1)
            changeMcursor("move")
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - lastOtherWinClose>350) && (A_TickCount - prevSlideShowStop>950)
            InfoToggleSlideShowu()
      }
    Return 

    ^vk57::    ; Ctrl+W
      If HKifs("imgsLoaded")
         setImageWallpaper()
    Return

    +vk4E::    ; Shift+N
      If HKifs("imgsLoaded")
         PanelEditImgCaption()
    Return

    vk4E::    ; N
      If (HKifs("imgsLoaded") && thumbsDisplaying!=1)
         ToggleImgCaptions()
    Return

    ^vk31::   ; Ctrl+1
      If HKifs("imgsLoaded")
         SetTimer, ActSortName, -150
    Return

    ^vk32::   ; Ctrl+2
      If HKifs("imgsLoaded")
         SetTimer, ActSortPath, -150
    Return

    ^vk33::   ; Ctrl+3
      If HKifs("imgsLoaded")
         SetTimer, ActSortFileName, -150
    Return

    ^vk34::   ; Ctrl+4
      If HKifs("imgsLoaded")
         SetTimer, ActSortSize, -150
    Return

    ^vk35::   ; Ctrl+5
      If HKifs("imgsLoaded")
         SetTimer, ActSortModified, -150
    Return

    ^vk36::   ; Ctrl+6
      If HKifs("imgsLoaded")
         SetTimer, ActSortCreated, -150
    Return

    ^vk30::   ; Ctrl+0
      If HKifs("imgsLoaded")
         SetTimer, ReverseListNow, -150
    Return

    ~vk4A Up::    ; J
      If HKifs("imgsLoaded")
         PanelJump2index()
    Return

    ~+Insert Up::
      If HKifs("imgsLoaded")
         addNewFolder2list()
    Return

    ~Tab Up::
      If HKifs("liveEdit")
         toggleImgEditPanelWindow()
      Else If HKifs("imgsLoaded")
         markThisFileNow()
    Return

    ~+Tab Up::
    ~^Tab Up::
      If HKifs("imgsLoaded")
         dropFilesSelection()
    Return

    ~F11::
      If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         ToggleFullScreenMode()
    Return

    +Enter::
      If HKifs("liveEdit")
         applyIMGeditFunctionClose()
      Else If (HKifs("imgEditSolo") || HKifs("imgsLoaded"))
         CropImageInViewPortToSelection()
    Return

    ^Enter::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         OpenWithNewQPVinstance()
      Else If HKifs("imgsLoaded")
         OpenWithNewQPVinstance("single")
    Return

    Enter::
      If (drawingShapeNow=1)
         stopDrawingShape()
      Else If HKifs("liveEdit")
         applyIMGeditFunction()
      Else If (HKifs("imgsLoaded") && (A_TickCount - lastOtherWinClose>250))
         ToggleThumbsMode()
    Return

    !Enter::
      If HKifs("imgsLoaded")
         PanelImageInfos()
    Return

    ~vk43 Up::    ; C
      If HKifs("imgsLoaded")
         InvokeCopyFiles()
    Return

    ~^vk55 Up::    ; Ctrl+U
      If (HKifs("imgsLoaded") && RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         PanelStaticFolderzManager()
    Return

    ~!vk55 Up::    ; Alt+U
      If HKifs("imgsLoaded")
         PanelDynamicFolderzWindow()
    Return

    ~^vk4B Up::    ; Ctrl+K
      If HKifs("imgsLoaded")
         PanelFileFormatConverter()
    Return

    ~vk4B Up::    ; K
      If HKifs("imgsLoaded")
      {
         If RegExMatch(getIDimage(currentFileIndex), "i)(.\.(jpg|jpeg))$") || markedSelectFile
            PanelJpegPerformOperation()
      }
    Return

    ~+vk43 Up::     ; Shift+C
      If HKifs("imgsLoaded")
         CopyImagePath()
    Return

    ~^vk45 Up::   ; Ctrl+E
      If (HKifs("imgsLoaded") || HKifs("imgLiveEdit"))
         OpenThisFileFolder()
    Return

    ~^vk46 Up::   ; Ctrl+F
      If HKifs("imgsLoaded")
         PanelEnableFilesFilter()
    Return

    ~vk53::   ; S
      If HKifs("imgsLoaded")
      {
         If (skipSeenImagesSlider=1 && thumbsDisplaying=1)
            ToggleSeenIMGstatus()
         Else
            SwitchSlideModes()
      }
    Return

    ~+^vk53 Up::   ; Ctrl+Shift+S
      If HKifs("imgsLoaded")
         PanelSaveSlideShowu()
    Return

    vk54 Up::   ; T
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ChangeThumbsAratio()
         Else
            ToggleImageSizingMode()
      }
    Return

    ~+Space::
      If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1 || markedSelectFile)
            dropFilesSelection()
         Else If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If (A_TickCount - prevSlideShowStop>950)
            dummyInfoToggleSlideShowu()
     }
    Return

    ~^Space Up::
      If HKifs("imgsLoaded")
      {
         If (slideShowRunning=1)
            dummyInfoToggleSlideShowu("stop")
         Else If StrLen(filesFilter)>1
            coreEnableFiltru("") ; filesFilter := usrFilesFilteru := ""
         Else If (markedSelectFile>1)
            coreEnableFiltru("||Prev-Files-Selection||")
         Else
            activateFilesListFilterBasedOnFolder(currentFileIndex)
      }
    Return

    ~BackSpace::
      If (drawingShapeNow=1)
         reduceCustomShapePoints()
      Else If HKifs("imgsLoaded")
         PrevRandyPicture()
    Return

    ~+BackSpace::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         RandomPicture()
      }
    Return

    vkBE::    ; [,]
      If HKifs("imgsLoaded")
         IncreaseSlideSpeed()
    Return

    vkBC::   ; [.]
      If HKifs("imgsLoaded")
         DecreaseSlideSpeed()
    Return

    +vkBF Up::   ; Shift + /
      If HKifs("imgsLoaded")
         PanelDefineEntireSlideshowLength()
    Return

    ~F5 Up::
      If HKifs("imgsLoaded")
         RefreshImageFileAction()
    Return

    ~!F5 Up::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         DeepRefreshThumbsNow()
    Return

    ~+F5 Up::
      If HKifs("imgsLoaded")
         RefreshFilesList()
    Return

    ~^F5 Up::
      If HKifs("imgsLoaded")
         invertRecursiveness()
    Return

    ~F2 Up::
      If HKifs("imgsLoaded")
         PanelRenameThisFile()
    Return

    ~+F2 Up::
      If HKifs("imgsLoaded")
         SingularRenameFile()
    Return

    ~^F2 Up::
      If HKifs("imgsLoaded")
         PanelUpdateThisFileIndex()
    Return

    ~vk4D Up::     ; M
      If HKifs("imgsLoaded")
         PanelMoveCopyFiles()
    Return

    ^vk51::  ;  Ctrl+Q-
      If HKifs("imgsLoaded")
         ToggleImgDownScaling()
    Return

    vk58 Up::   ; X
      If HKifs("imgsLoaded")
         PlayAudioFileAssociatedNow()
    Return

    +vk58 Up::   ; Shift+X
      If HKifs("imgsLoaded")
         StopMediaPlaying()
    Return

    vk31::   ; 1
      If HKifs("imgsLoaded")
         ChangeVolume(-1)
    Return

    vk32::   ; 1
      If HKifs("imgsLoaded")
         ChangeVolume(1)
    Return

    ^Left::
      If HKifs("imgsLoaded")
         navSelectedFiles(-1)
    Return

    ^Right::
      If HKifs("imgsLoaded")
         navSelectedFiles(1)
    Return

    F3::
      If HKifs("imgsLoaded")
         searchNextIndex(1)
    Return

    +F3::
      If HKifs("imgsLoaded")
         searchNextIndex(-1)
    Return

    ^F3::
      If HKifs("imgsLoaded")
         PanelSearchIndex()
    Return

    WheelUp::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Upu", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(1, "WheelUp")
      Else If (HKifs("imgsLoaded"))
         PreviousPicture("key-" A_ThisHotkey)
    Return

    WheelDown::
      If (HKifs("imgsLoaded") && thumbsDisplaying=1)
         ThumbsNavigator("Down", A_ThisHotkey)
      Else If (HKifs("imgEditSolo") || HKifs("liveEdit") || HKifs("imgsLoaded")) && (IMGresizingMode=4 && thumbsDisplaying!=1)
         ChangeZoom(-1, "WheelDown")
      Else If (HKifs("imgsLoaded"))
         NextPicture("key-" A_ThisHotkey)
    Return

    Right::
    +Right::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("R")
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Right", A_ThisHotkey)
            Else
               NextPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("R")
    Return

    Left::
    +Left::
      If HKifs("imgsLoaded")
      {
         If (IMGlargerViewPort=1 && IMGresizingMode=4)
         {
            PanIMGonScreen("L")
         } Else
         {
            resetSlideshowTimer(0)
            If (thumbsDisplaying=1)
               ThumbsNavigator("Left", A_ThisHotkey)
            Else
               PreviousPicture("key-" A_ThisHotkey)
         }
      } Else If ((drawingShapeNow=1 || HKifs("imgEditSolo") || HKifs("liveEdit")) && IMGlargerViewPort=1 && IMGresizingMode=4)
         PanIMGonScreen("L")
    Return

    PgDn::
      If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-1, 1)
         arrowKeysAdjustSelectionArea(-1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else
            NextPicture()
      }
    Return

    PgUp::
      If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(1, 1)
         arrowKeysAdjustSelectionArea(1, 2)
      } Else If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else
            PreviousPicture()
      }
    Return

    +PgDn::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgDn", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(-1)
      }
    Return

    +PgUp::
      If HKifs("imgsLoaded")
      {
         resetSlideshowTimer(0)
         If (thumbsDisplaying=1)
            ThumbsNavigator("PgUp", A_ThisHotkey)
         Else If (totalFramesIndex>0 && thumbsDisplaying!=1)
            changeDesiredFrame(1)
      }
    Return

    ~^Home Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(-1)
    Return

    ~^End Up::
      If HKifs("imgsLoaded")
         jumpToFilesSelBorder(1)
    Return

    ~Home::
    ~+Home::
      If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(-2, 1)
         arrowKeysAdjustSelectionArea(-2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("Home", A_ThisHotkey)
         Else
            FirstPicture()
      }
    Return

    ~End::
    ~+End::
      If (HKifs("liveEdit") && editingSelectionNow=1)
      {
         arrowKeysAdjustSelectionArea(2, 1)
         arrowKeysAdjustSelectionArea(2, 2)
      } Else If HKifs("imgsLoaded")
      {
         If (thumbsDisplaying=1)
            ThumbsNavigator("End", A_ThisHotkey)
         Else
            LastPicture()
      }
    Return
#If

;____________ Functions __________________

initQPVmainDLL() {
   If qpvMainDll
      Return

   DllPath := FreeImage_FoxGetDllPath("qpvmain.dll")
   ; If (A_PtrSize=8)
   ;    DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\x64\Release\qpvmain.dll"
   ; Else
   ;    DllPath := "E:\Sucan twins\_small-apps\AutoHotkey\my scripts\fast-image-viewer\cPlusPlus\qpv-main\Release\qpvmain.dll"
   qpvMainDll := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")
}

intializeWithGivenArguments() {
   thisCounter := folderOpened := sldOpened := doWelcomeNow := 0
   Loop, 300
   {
      If (A_Index>=300)
      {
         doWelcomeNow := 1
      } Else If (RegExMatch(A_Args[A_Index], sldsPattern) && RegExMatch(A_Args[A_Index], "i)^(.\:\\..*)") && !sldOpened)
      {
         If FileExist(A_Args[A_Index])
            sldOpened := A_Args[A_Index]
      } Else If (RegExMatch(A_Args[A_Index], "i)^(fd\=\|?.\:\\..*)") && !folderOpened)
      {
         paramSet := SubStr(A_Args[A_Index], 4)
         If FolderExist(StrReplace(paramSet, "|"))
            folderOpened := paramSet
      } Else If (RegExMatch(A_Args[A_Index], RegExFilesPattern) && !folderOpened && !sldOpened)
      {
         filesListu .= A_Args[A_Index] "`n"
         thisCounter++
      } Else If RegExMatch(A_Args[A_Index], "i)^(.?qpv-debug)")
      {
         debugModa := 1
      } Else If RegExMatch(A_Args[A_Index], "i)^(set\_..*\=..*)")
      {
         paramSet := SubStr(A_Args[A_Index], 5, InStr(A_Args[A_Index], "=") - 5)
         paramSetValue := SubStr(A_Args[A_Index], InStr(A_Args[A_Index], "=") + 1)
         If (paramSet && paramSetValue!="")
            %paramSet% := paramSetValue
      }
   }

   If sldOpened
      OpenSLD(sldOpened)
   Else If folderOpened
      OpenFolders(folderOpened)
   Else If (thisCounter=1 && !sldOpened && !folderOpened)
      OpenArgFile(Trimmer(filesListu))
   Else If (thisCounter>1 && !sldOpened && !folderOpened)
      GuiDroppedFiles(filesListu, nona, none, thisCounter, 0)

   Return doWelcomeNow
}

OpenSLD(fileNamu, dontStartSlide:=0) {
  mustOpenStartFolder := ""
  If !FileExist(fileNamu)
  {
     showTOOLtip("ERROR: Failed to load files list...")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  mustRemQuotes := 1
  setImageLoading()
  ForceRegenStaticFolders := 0
  renewCurrentFilesList()
  newStaticFoldersListCache := []
  DynamicFoldersList := CurrentSLD := ""
  filesFilter := usrFilesFilteru := ""
  SLDhasFiles := 0
  zPlitPath(fileNamu, 0, OutFileName, OutDir)
  showTOOLtip("Loading slideshow, please wait...`n" OutFileName "`n" OutDir "\")
  setWindowTitle("Loading slideshow, please wait", 1)
  If RegExMatch(fileNamu, "i)(.\.sldb)$")
  {
     r := sldDataBaseOpen(fileNamu)
     If (maxFilesIndex>0 && r!=-1)
     {
        SLDcacheFilesList := 1
        mustGenerateStaticFolders := 0
        GenerateRandyList()
        SetTimer, ResetImgLoadStatus, -50
        CurrentSLD := fileNamu
        RecentFilesManager(CurrentSLD)
        SLDtypeLoaded := 3
        prevOpenFolderPath := OutDir
        INIaction(1, "prevOpenFolderPath", "General")
        RandomPicture()
        InfoToggleSlideShowu()
     } Else resetMainWin2Welcome()
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  FileReadLine, firstLine, % fileNamu, 1
  If InStr(firstLine, "[General]") 
  {
     mustRemQuotes := 0
     IniRead, testStaticFolderz, % fileNamu, Folders, Fi1, @
     IniRead, tstSLDcacheFilesList, % fileNamu, General, SLDcacheFilesList, @
     IniRead, testDynaFolderz, % fileNamu, DynamicFolderz, DF1, @
     If StrLen(testDynaFolderz)>4
        DynamicFoldersList := "|hexists|"
       ; DynamicFoldersList := coreLoadDynaFolders(fileNamu)

     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
  }

  mustGenerateStaticFolders := (InStr(firstLine, "[General]") && StrLen(testStaticFolderz)>8) ? 0 : 1
  If (tstSLDcacheFilesList=0)
     mustGenerateStaticFolders := 0

  If (SLDcacheFilesList=1 && InStr(firstLine, "[General]")) || !InStr(firstLine, "[General]")
     res := sldGenerateFilesList(fileNamu, 0, mustRemQuotes)

  prevOpenFolderPath := OutDir
  INIaction(1, "prevOpenFolderPath", "General")
  If (res="abandoned")
  {
     resetMainWin2Welcome()
     Return
  }

  If InStr(firstLine, "[General]") 
  {
     If (maxFilesIndex<3 && DynamicFoldersList="|hexists|")
        ReloadDynamicFolderz(fileNamu)

     If (MustLoadSLDprefs=1)
        readSlideSettings(fileNamu)
  }

  GenerateRandyList()
  CurrentSLD := fileNamu
  SLDtypeLoaded := 2
  currentFileIndex := 1
  RecentFilesManager(CurrentSLD)
  If (dontStartSlide=1)
  {
     SetTimer, RemoveTooltip, % -msgDisplayTime
     ResetImgLoadStatus()
     Return
  }

  ResetImgLoadStatus()
  If (maxFilesIndex>2)
  {
     RandomPicture()
     InfoToggleSlideShowu()
  } Else If (maxFilesIndex>0)
  {
     currentFileIndex := 1
     IDshowImage(1)
  } Else resetMainWin2Welcome()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

resetMainWin2Welcome() {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     If (maxFilesIndex>1 && userSeenSlideImages>1 && skipSeenImagesSlider=1)
     { 
        seenImagesDB.Exec("COMMIT TRANSACTION;")
        Sleep, -1
        seenImagesDB.Exec("BEGIN TRANSACTION;")
     }

     ForceRegenStaticFolders := SLDhasFiles := SLDtypeLoaded := 0
     editingSelectionNow := thumbsDisplaying := 0
     renewCurrentFilesList()
     bckpResultedFilesList := []
     filteredMap2mainList := []
     RandyIMGids := []
     updateUIctrl()
     newStaticFoldersListCache := []
     DynamicFoldersList := CurrentSLD := ""
     filesFilter := usrFilesFilteru := mustOpenStartFolder := ""
     ToggleVisibilityWindow("show", hGDIwin)
     interfaceThread.ahkassign("thumbsDisplaying", 0)
     interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
     ToggleVisibilityWindow("hide", hGDIthumbsWin)
     clearGivenGDIwin(glPG, glHDC, hGDIthumbsWin)
     clearGivenGDIwin(glPG, glHDC, hGDIwin)
     clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectWin)
     gdiBitmapIDcall := viewportIDstampBMP := AprevImgCall := BprevImgCall := ""
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     corePasteInPlaceActNow("kill")
     viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
     gdipObjectsStats(1, "QPV_ShowThumbnails")
     gdipObjectsStats(1)
     ForceRefreshNowThumbsList()
     prevOpenedWindow := ""
     drawWelcomeImg()
     SetTimer, ResetImgLoadStatus, -50
}

deleteKeyAction() {
    If !getIDimage(currentFileIndex)
       Return

    If (thumbsDisplaying!=1 && editingSelectionNow=1)
       PanelEraseSelectedArea()
    Else
       DeletePicture()
}

activateFilesListFilterBasedOnFolder(thisIndex) {
   r := getIDimage(thisIndex)
   zPlitPath(r, 0, OutFileName, OutDir)
   thisFilter := SubStr(OutDir, 3) "\"
   coreEnableFiltru(thisFilter)
}

escRoutine() {
  Sleep, -1
  Return
}

GenerateRandyList() {
   startZeit := A_TickCount
   RandyIMGids := []
   Loop, % maxFilesIndex
       RandyIMGids[A_Index] := A_Index
   RandyIMGids := Random_ShuffleArray(RandyIMGids)
   RandyIMGnow := 1
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
}

OpenThisFileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := getIDimage(currentFileIndex)
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       Try Run, "%folderu%"
       Catch wasError
       {
          If !AnyWindowOpen
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder...`n" folderu, 0, 0, "error")
       }
    }
}

OpenQPVfileFolder() {
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    resultu := getIDimage(currentFileIndex)
    If resultu
    {
       zPlitPath(resultu, 0, fileNamu, folderu)
       renewCurrentFilesList()
       mustOpenStartFolder := folderu
       currentFileIndex := doOpenStartFolder()
       dummyTimerDelayiedImageDisplay(50)
    }
}

setImageWallpaper() {
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If !RegExMatch(imgPath, "i)(.\.(bmp|jpg|jpeg|png|tif))$")
   {
      showTOOLtip("Converting Image file format for desktop wallpaper into JPEG...")
      file2save := mainCompiledPath "\wallpaper-" OutNameNoExt ".jpg"
      r := coreConvertImgFormat(imgPath, file2save)
      If !r
         imgPath := file2save
      ResetImgLoadStatus()
   }

   GetPhysicalCursorPos(mainX, mainY)
   ActiveMon := MWAGetMonitorMouseIsIn(mainX, mainY)
   If !ActiveMon
      ActiveMon := 1

   dw := new IDesktopWallpaper
   dw.GetMonitorDevicePathAt(ActiveMon - 1, MonitorID)
   dw.SetWallpaper(MonitorID, imgPath)
   dw := Delete IDesktopWallpaper
   showTOOLtip("Image file set as desktop wallpaper...`n" fileNamu "`n" folderu "\")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenThisFileMenu() {
  Static lastInvoked := 1

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, Ext)
  labelu := "QPVimage." Ext

  RegRead, regEntryA, HKEY_CLASSES_ROOT\.%Ext%
  If (regEntryA=labelu)
     testA := 1

  RegRead, regEntryB, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.%Ext%\UserChoice, ProgId
  If (regEntryB=labelu)
     testB := 1

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  isAssociated := (testA=1 && testB=1) ? 1 : 0
  newInstanceOption := (A_IsCompiled) ? 1 : 0
  InvokeOpenWithMenu(imgPath, newInstanceOption)
}

SoloOpenWithNewQPVinstance(dummy:=0) {
   OpenWithNewQPVinstance("single")
}

OpenWithNewQPVinstance(dummy:=0, givenList:=0, givenCount:=0) {
   filesElected := getSelectedFiles(0, 1)
   markedSelectFile := filesElected
   If (givenList && givenCount)
      filesElected := givenCount

   ; ToolTip, % givenCount "--" filesElected "--" givenList , , , 2
   If (filesElected>25 && dummy!="single")
   {
      msgBoxWrapper(appTitle ": WARNING", "You are not allowed to spawn in one go more than 25 instances of " appTitle ".", 0, 0, "error")
      Return
   }

   If (filesElected>5 && dummy!="single")
   {
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " filesElected ". Please confirm you want to spawn so many new instances of " appTitle ".", 4, 0, "question")
      If (msgResult="Yes")
         allGood := 1
   } Else allGood := 1

   maxLoops := (givenList && givenCount) ? givenCount + 2 : maxFilesIndex
   If (givenList && givenCount>0 && dummy!="single" && allGood=1)
   {
      Loop, Parse, givenList, `n
      {
         imgPath := Trimmer(A_LoopField)
         If StrLen(imgPath)>4
         {
            If (A_Index>1)
               Sleep, 700
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (markedSelectFile && filesElected>1 && dummy!="single" && allGood=1)
   {
      thisIndex := 0
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisIndex++
         imgPath := resultedFilesList[A_Index, 1]
         If StrLen(imgPath)>4
         {
            If (thisIndex>1)
               Sleep, 700
            OpenNewQPVinstance(imgPath)
         }
      }
   } Else If (!markedSelectFile || dummy="single")
   {
      imgPath := getIDimage(currentFileIndex)
      OpenNewQPVinstance(imgPath)
   }
}

OpenNewQPVinstance(imgPath:="") {
   imgPath := StrReplace(imgPath, "||")
   If FolderExist(imgPath)
      imgPath := "fd=" imgPath
   Else If !FileRexists(imgPath)
      imgPath := ""

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening a new instance of " appTitle "...", 0, 0, "error")
}

OpenWithDefaultApp() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the default application...", 0, 0, "error")
    }
}

OpenFileProperties() {
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    If !FileRexists(imgPath)
       informUserFileMissing()
    Sleep, 25
    If imgPath
    {
       Try Run, Properties "%imgPath%"
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the system file properties...", 0, 0, "error")
    }
}

InvokeOpenWithMenu(imgPath, newInstanceOption) {
    zPlitPath(imgPath, 0, OutFileName, OutDir)
    CurrentSLD := Trimmer(StrReplace(CurrentSLD, "|"))
    IniAction(0, "UserExternalApp", "General")
    pathu := "&X. " PathCompact(UserExternalApp, 28)
    If StrLen(Trimmer(UserExternalApp))<6
       pathu := "NONE CHOSEN"

    IniAction(0, "UserExternalEditApp", "General")
    pathu2 := "&Y. " PathCompact(UserExternalEditApp, 28)
    If StrLen(Trimmer(UserExternalEditApp))<6
       pathu2 := "NONE CHOSEN"
    CreateOpenWithMenu(imgPath)
    Menu, OpenWithMenu, Add,
    If (newInstanceOption=1 && !markedSelectFile)
       Menu, OpenWithMenu, Add, &0. Open file(s) in a new QPV instance, OpenWithNewQPVinstance
    Menu, OpenWithMenu, Add, &1. Open with default application, OpenWithDefaultApp
    Menu, OpenWithMenu, Add, &2. System «Open with» dialog, invokeSHopenWith
    Menu, OpenWithMenu, Add, &4. Explore containing folder`tCtrl+E, OpenThisFileFolder
    If (CurrentSLD!=OutDir)
       Menu, OpenWithMenu, Add, &5. Open containing folder in QPV, OpenQPVfileFolder
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Choose external application, browseExternalApp
    Menu, OpenWithMenu, Add, %pathu%, OpenImgWithUserExternApp
    Menu, OpenWithMenu, Add, &Choose external editor application, browseExternalEditApp
    Menu, OpenWithMenu, Add, %pathu2%, OpenImgWithUserEditExternApp
    If (!pathu || pathu="none chosen")
       Menu, OpenWithMenu, Disable, %pathu%
    If (!pathu2 || pathu2="none chosen")
       Menu, OpenWithMenu, Disable, %pathu2%
    Menu, OpenWithMenu, Add,
    Menu, OpenWithMenu, Add, &Cancel, dummy
    showThisMenu("OpenWithMenu")
}

browseExternalApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalApp := imgPath
      IniAction(1, "UserExternalApp", "General")
      OpenImgWithUserExternApp()
   }
}

browseExternalEditApp() {
   pattern := "Executable files (*.exe)"
   FileSelectFile, imgPath, 3, % prevOpenFolderPath, Choose EXE application file, % pattern
   If FileExist(imgPath)
   {
      UserExternalEditApp := imgPath
      IniAction(1, "UserExternalEditApp", "General")
      OpenImgWithUserEditExternApp()
   }
}

OpenImgWithUserEditExternApp() {
   destroyGDIfileCache()
   OpenImgWithUserExternApp("editor")
}

OpenImgWithUserExternApp(dummy:=0) {
   ; IniAction(0, "UserExternalApp", "General")
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   thisAPPpath := (dummy="editor") ? UserExternalEditApp : UserExternalApp
   If !FileExist(thisAPPpath)
   {
      zPlitPath(thisAPPpath, 0, fileNamu, folderu, OutNameNoExt)
      showTOOLtip("ERROR: The file of the external application does not seem to exist anymore...`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   Try Run, %thisAPPpath% "%imgPath%"
   Catch wasError
         msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the external application...", 0, 0, "error")
}

resetSlideshowTimer(showMsg, ignoreEasyStop:=0) {
   ; DestroyGIFuWin()
   If (slideShowRunning!=1 && showMsg!=1)
      Return

   If (easySlideStoppage=1 && slideShowRunning=1 && ignoreEasyStop=0)
      ToggleSlideShowu("stop")
   Else If (slideShowRunning=1)
      ToggleSlideShowu("start")

   If (showMsg=1)
   {
      friendly := (slideShowRunning=1) ? "RUNNING" : "STOPPED"
      delayu := DefineSlidesRate()
      etaTime := "Estimated time: " EstimateSlideShowLength()
      showTOOLtip("Slideshow speed: " delayu "`nTotal files: " groupDigits(maxFilesIndex) "`n" etaTime "`nSlideshow: " friendly)
      SetTimer, ResetImgLoadStatus, -50
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

IncreaseSlideSpeed() {
   If (slideShowDelay<1000)
   {
      slideShowDelay += 300
      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }
   
   slideShowDelay += 1000
   If (slideShowDelay>20000)
      slideShowDelay := 20000

   SetTimer, dummyChangeSlideSpeed, -50
}

DecreaseSlideSpeed() {
   If (slideShowDelay<1001)
   {
      slideShowDelay -= 300
      If (slideShowDelay<200)
         slideShowDelay := 100

      SetTimer, dummyChangeSlideSpeed, -50
      Return
   }

   slideShowDelay -= 1000
   SetTimer, dummyChangeSlideSpeed, -50
}

dummyChangeSlideSpeed() {
   resetSlideshowTimer(1, 1)
   INIaction(1, "slideShowDelay", "General")
}

CopyImagePath() {
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  showTOOLtip("Copying file path(s) to clipboard...")
  getSelectedFiles(0, 1)
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue
        file2rem := getIDimage(A_Index)
        file2rem := StrReplace(file2rem, "||")
        listu .= file2rem "`n"
        countTFilez++
     }

     If countTFilez
     {
        Try Clipboard := listu
        Catch wasError
            Sleep, 1

        infoText := wasError ? "ERROR: Failed to copy to clipboard the selected file paths...`nError code: " wasError : countTFilez " file paths were copied to clipboard..."
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  imgPath := StrReplace(imgPath, "||")
  Try Clipboard := imgPath
  Catch wasError
      Sleep, 1

  zPlitPath(imgPath, 0, fileNamu, folderu)
  infoText := wasError ? "ERROR: Failed to copy to clipboard the file path...`nError code: " wasError "`n" : "File path copied to clipboard...`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ClipboardSetFiles(PathToCopy, Method:="copy") {
; function from https://autohotkey.com/board/topic/23162-how-to-copy-a-file-to-the-clipboard/page-4
; by maraskan_user and Lexikos
; modified by Marius Șucan

   FileCount := 0
   PathLength := 0

   ; Count files and total string length
   For i, File in PathToCopy
   {
      FileCount++
      PathLength += StrLen(File)
   }

   pid := DllCall("GetCurrentProcessId","uint")
   hwnd := WinExist("ahk_pid " . pid)
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   hPath := DllCall("GlobalAlloc","uint",0x42,"uint",20 + (PathLength + FileCount + 1) * 2,"UPtr")
   pPath := DllCall("GlobalLock","UPtr",hPath)
   NumPut(20, pPath+0), pPath += 16 ; DROPFILES.pFiles = offset of file list
   NumPut(1, pPath+0), pPath += 4 ; fWide = 0 -->ANSI,fWide = 1 -->Unicode

   Offset := 0
   ; Rows are delimited by linefeeds (`r`n).
   for i, File in PathToCopy
       offset += StrPut(File, pPath + offset, StrLen(File)+1, "UTF-16") * 2

   If !DllCall("OpenClipboard","UPtr", hwnd)
      Return -1

   DllCall("GlobalUnlock","UPtr",hPath)
   DllCall("EmptyClipboard")
   err := DllCall("SetClipboardData","uint",0xF,"UPtr",hPath) ; 0xF = CF_HDROP

   ; Write Preferred DropEffect structure to clipboard to switch between copy/cut operations
   ; 0x42 = GMEM_MOVEABLE(0x2) | GMEM_ZEROINIT(0x40)
   mem := DllCall("GlobalAlloc","uint",0x42,"uint",4,"UPtr")
   str := DllCall("GlobalLock","UPtr",mem)

   if (Method="copy")
   {
      DllCall("RtlFillMemory","UPtr",str,"uint",1,"UChar",0x05)
   } else if (Method="cut")
   {
      DllCall("RtlFillMemory","UPtr",str,"uint",1,"UChar",0x02)
   } else
   {
      DllCall("CloseClipboard")
      return
   }

   DllCall("GlobalUnlock","UPtr",mem)

   cfFormat := DllCall("RegisterClipboardFormat","Str","Preferred DropEffect")
   DllCall("SetClipboardData","uint",cfFormat,"UPtr",mem)
   DllCall("CloseClipboard")
   return err
}

MenuExplorerCopyFiles() {
    CopyMoveFilesExplorer("copy")
}

MenuExplorerCutFiles() {
    destroyGDIfileCache()
    CopyMoveFilesExplorer("cut")
}

CopyMoveFilesExplorer(userOption:="copy") {
  userOption := (userOption="cut") ? "CUT" : "COPY"
  If (currentFileIndex=0)
     Return

  DestroyGIFuWin()
  If (slideShowRunning=1)
     ToggleSlideShowu()

  showTOOLtip("Copying file path(s) to clipboard...")
  getSelectedFiles(0, 1)
  newFilesList := []
  countTFilez := 0
  If (markedSelectFile>1)
  {
     Loop, % maxFilesIndex
     {
        isSelected := resultedFilesList[A_Index, 2]
        If (isSelected!=1)
           Continue

        file2rem := getIDimage(A_Index)
        file2rem := StrReplace(file2rem, "||")
        countTFilez++
        newFilesList[countTFilez] := file2rem
     }

     If countTFilez
     {
        dataHandle := ClipboardSetFiles(newFilesList, userOption)
        Sleep, 5
        Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
        infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store the selected files into the clipboard..." : "On " countTFilez " files " userOption " was applied.`nThese can now be pasted in any file manager."
        showTOOLtip(infoText)
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return
     } Else markedSelectFile := 0
  }

  imgPath := getIDimage(currentFileIndex)
  newFilesList[1] := Trimmer(StrReplace(imgPath, "||"))
  dataHandle := ClipboardSetFiles(newFilesList, userOption)
  zPlitPath(imgPath, 0, fileNamu, folderu)
  Sleep, 5
  Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
  infoText := (testClipType!=1 || !dataHandle) ? "ERROR: Failed to store files into clipboard..." : "File " userOption " [Explorer mode]...`n"
  showTOOLtip(infoText fileNamu "`n" folderu "\")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

CopyImage2clip(gimmeBMP:=0, mustCrop:=0) {
   If (thumbsDisplaying=1)
      Return "fail"

   imgPath := getIDimage(currentFileIndex)
   whichBitmap := useGdiBitmap()
   If (StrLen(whichBitmap)<3 || !imgPath)
   {
      showTOOLtip("WARNING: No image file is currently loaded...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return "fail"
   }

   If (gimmeBMP!=1)
   {
      DestroyGIFuWin()
      If (slideShowRunning=1)
         ToggleSlideShowu()
  }

  friendly := (editingSelectionNow=1) ? "selected area" : ""
  If (editingSelectionNow=1 && StrLen(whichBitmap)>2)
  {
     If testSelectOutsideImgEntirely(whichBitmap)
     {
        showTOOLtip("WARNING: Invalid image selection area...")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return "fail"
     }
  }

  setImageLoading()
  imgPath := getIDimage(currentFileIndex)
  If StrLen(whichBitmap)>2
  {
     If (gimmeBMP!=1)
        showTOOLtip("Copying image" friendly " to clipboard, please wait...")
    
     Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
     If (editingSelectionNow=1 && gimmeBMP!=1) || (editingSelectionNow=1 && mustCrop=1 && gimmeBMP=1)
        mustCrop := 2

     givenCoords := (mustCrop=2) ? 0 : "0|0|" imgW "|" imgH
     calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, givenCoords)
     If (mustCrop=2)
     {
        capSelectionRelativeCoords()
        imgSelX1 := X1, imgSelY1 := Y1
        imgSelX2 := X2, imgSelY2 := Y2
        dummyRefreshImgSelectionWindow()
     }

     ; RemoveTooltip()
     zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
     If StrLen(zBitmap)>2
     {
        decideGDIPimageFX(matrix, imageAttribs, pEffect)
        If pEffect
        {
           Gdip_BitmapApplyEffect(zBitmap, pEffect)
           Gdip_DisposeEffect(pEffect)
        }

        If imageAttribs
        {
           bluba := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, "0xE200B")
           If StrLen(bluba)>2
           {
              G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)
              r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap,,,,,,,,,,, imageAttribs)
              Gdip_DeleteGraphics(G2)
              If (r1!="fail" && G2)
              {
                 trGdip_DisposeImage(zBitmap, 1)
                 zBitmap := bluba
              }
           }
           Gdip_DisposeImageAttributes(imageAttribs)
        }

        Gdip_GetImageDimensions(zBitmap, qImgW, qImgH)
        pPath := createImgSelPath(0, 0, qImgW, qImgH, EllipseSelectMode)
        If (pPath && editingSelectionNow=1 && gimmeBMP!=1) || (pPath && mustCrop=2)
        {
           Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
           carvePathFromBitmap(zBitmap, pPath, 0, 0, 4)
           pB := Gdip_GetPathWorldBounds(pPath)
           pBx := clampInRange(pB.x, 0, qImgW - 1)
           pBy := clampInRange(pB.y, 0, qImgH -1)
           pBw := clampInRange(pB.w, pBx + 1, qImgW)
           pBh := clampInRange(pB.h, pBy + 1, qImgH)
           If zBitmap
              yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, pBx, pBy, pBw, pBh)
           If yBitmap
           {
              trGdip_DisposeImage(zBitmap, 1)
              zBitmap := yBitmap
           } Else addJournalEntry(A_ThisFunc "(): failed to crop image to selection area...")
        }

        flipBitmapAccordingToViewPort(zBitmap, 1)
        If (gimmeBMP!=1)
        {
           hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, zBitmap)
           trGdip_DisposeImage(zBitmap, 1)
           r := hBitmap ? Gdip_SetBitmapToClipboard(zBitmap, hBitmap) : addJournalEntry("get_last_err")
        } Else clipBMP := zBitmap

        Gdip_DeletePath(pPath)
     } Else r := clipBMP := "fail"
  } Else r := clipBMP := "fail"

  If (gimmeBMP!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     If r
        showTOOLtip("Failed to copy the image to clipboard... Error code: " r)
     Else
        showTOOLtip("Image " friendly " copied to clipboard...")

     SoundBeep, % r ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  } Else Return clipBMP
}

invertRecursiveness() {
   If (RegExMatch(CurrentSLD, sldsPattern) || !CurrentSLD)
      Return

   isPipe := InStr(CurrentSLD, "|") ? 1 : 0
   CurrentSLD := StrReplace(CurrentSLD, "|")
   DynamicFoldersList := StrReplace(DynamicFoldersList, "|")
   If (isPipe!=1)
   {
      CurrentSLD := "|" CurrentSLD
      DynamicFoldersList := "|" DynamicFoldersList
   }

   RefreshFilesList()
}

remFilesListFilter() {
   coreEnableFiltru("")
}

invertFilesFilter() {
   If (StrLen(filesFilter)<2 || !filesFilter)
      Return

   If askAboutFileSave(" and the files list filter will be inverted")
      Return

   isThat := InStr(usrFilesFilteru, "&") ? 1 : 0
   usrFilesFilteru := StrReplace(usrFilesFilteru, "&")
   If (isThat!=1)
      usrFilesFilteru := "&" usrFilesFilteru

   coreEnableFiltru(usrFilesFilteru)
}

dummyTimerReloadThisPicture(timeru:=0) {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (timeru>1)
     SetTimer, extraDummyReloadThisPicture, % -timeru, 950
}

extraDummyReloadThisPicture() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyReloadThisPicture, -15
     Return
  }
  ReloadThisPicture()
}

determineLClickstate() {
   If (slideShowRunning=1)
      Return 0

   LbtnDwn := interfaceThread.ahkgetvar.LbtnDwn
   If (GetKeyState("LButton") || LbtnDwn=1)
      Return 1
   Else
      Return 0
}

ReloadThisPicture() {
  SetTimer, dummyTimerDelayiedImageDisplay, Off
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     delayu := (A_TickCount - prevFastDisplay < 500) ? 90 : 550
     If (determineLClickstate()=1 || GetKeyState("Space", "P"))
     {
        dummyTimerReloadThisPicture(delayu)
        Return
     }
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

coreReloadThisPicture() {
  If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
  {
     r := IDshowImage(currentFileIndex, 2)
     If !r
        informUserFileMissing()
  }
}

FirstPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := 1
   dummyTimerDelayiedImageDisplay(50)
   showTOOLtip("Total images loaded: 1 / " maxFilesIndex)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

LastPicture() { 
   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex>1 && currentFileIndex!=maxFilesIndex)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return
   }

   currentFileIndex := maxFilesIndex
   dummyTimerDelayiedImageDisplay(50)
   showTOOLtip("Total images loaded: " maxFilesIndex)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SettingsGUIAGuiClose:
SettingsGUIAGuiEscape:
   CloseWindow()
Return

doCleanup:
   TrueCleanup()
Return

TrueCleanup(mustExit:=1) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 900) || (hasInitSpecialMode=1)
      Return

   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && skipSeenImagesSlider=1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")

   activeSQLdb.Close()
   seenImagesDB.Close()
   If AnyWindowOpen
   {
      CloseWindow()
      Sleep, 10
   }

   WinSet, Region, 0-0 w1 h1, ahk_id %PVhwnd%
   RegWrite, REG_SZ, %QPVregEntry%, Running, 0
   If StrLen(hitTestSelectionPath)>1
   {
      editingSelectionNow := 0
      Gdip_DeletePath(hitTestSelectionPath)
      hitTestSelectionPath := ""
   }

   lastInvoked := A_TickCount
   RemoveTooltip()
   DestroyGIFuWin()

   Sleep, 1
   If (wasInitFIMlib=1)
      FreeImage_FoxInit(0) ; Unload Dll

   disposeCacheIMGs()
   destroyGDIfileCache()
   discardViewPortCaches()
   Gdip_DeleteBrush(pBrushWinBGR)
   Gdip_DeleteBrush(pBrushHatch)
   Gdip_DeleteBrush(pBrushHatchLow)
   Gdip_DeleteBrush(pBrushHatchLiw)
   Gdip_DeleteBrush(pBrushA)
   Gdip_DeleteBrush(pBrushB)
   Gdip_DeleteBrush(pBrushC)
   Gdip_DeleteBrush(pBrushD)
   Gdip_DeleteBrush(pBrushE)
   Gdip_DeleteBrush(pBrushF)
   Gdip_DeleteBrush(pBrushZ)
   Gdip_DeleteBrush(AmbientalTexBrush)
   Gdip_DeletePen(pPen1)
   Gdip_DeletePen(pPen1d)
   Gdip_DeletePen(pPen2)
   Gdip_DeletePen(pPen3)
   Gdip_DeletePen(pPen4)
   Gdip_DeletePen(pPen5)

   mainGdipWinThumbsGrid(1)
   destroyGDIPcanvas()
   Sleep, 1
   GDIPToken := Gdip_Shutdown(GDIPToken)  
   lastInvoked := A_TickCount
   ; If (mustExit=1)
   ;    writeMainSettings()
   lastInvoked := A_TickCount
   fnOutputDebug("Proper exit. Main thread. PID=" QPVpid)
   ForceExitNow("yay")
}

ForceExitNow(dummy:=0) {
   If GDIPToken
      Gdip_Shutdown(GDIPToken)  
   Sleep, 5
   If (dummy!="yay")
      fnOutputDebug("Forced exit. Main thread. PID=" QPVpid)
   Process, Close, % QPVpid
   ExitApp
}

dummySetWindowTitle() {
    setWindowTitle("lol", 0, 1)
}

setWindowTitle(msg, forceThis:=0, useLast:=0) {
    Static prevSet, prevMsg, lastInvoked := 1
    If (A_TickCount - zeitSillyPrevent<200) || (drawingShapeNow=1)
       Return

    msg := StrReplace(msg, "`n", " | ")
    If (useLast!=1)
       addJournalEntry("WinTitle: " msg)

    infoSlideDelay := (slideShowRunning=1 && slideShowDelay<2950) ? 1 : 0
    thisMsg := (useLast=1 && StrLen(prevMsg)>3) ? prevMsg : msg
    If (useLast!=1)
       prevMsg := msg

    If (A_TickCount - lastInvoked<200) && (useLast!=1 && forceThis!=1)
    {
       SetTimer, dummySetWindowTitle, -350
       Return
    }

    If (prevSet!=thisMsg && runningLongOperation!=1 && infoSlideDelay=0 && animGIFplaying!=1 && hasInitSpecialMode!=1) || (forceThis=1)
    {
       prevSet := thisMsg
       WinSetTitle, ahk_id %PVhwnd%,, % thisMsg
       ; fnOutputDebug("WinTitle: " thisMsg)
       lastInvoked := A_TickCount
    }
}

fnOutputDebug(msg) {
   Static prevMsg

   If (debugModa=1)
   {
      If (prevMsg!=msg && slideShowRunning!=1 && slideShowDelay>300)
      {
         prevMsg := msg
         msg := StrReplace(msg, "User journal: wintitle:", "WinTitle:")
         msg := StrReplace(msg, "User journal: dialog box:", "Dialog box:")
         msg := StrReplace(msg, "User journal: osd:", "OSD:")
         OutputDebug, % "QPV: " Trim(msg)
      }
   }
}

MenuDummyToggleThumbsMode() {
   lastOtherWinClose := 5
   ToggleThumbsMode()
}

initAHKhThumbThreads() {
    Static multiCoreInit := 0

    If (multiCoreInit=1 || allowMultiCoreMode!=1 || minimizeMemUsage=1)
       Return

    addJournalEntry("Attempting to initialize " realSystemCores " threads for thumbnails generation...")
    initFIMGmodule()
    If (FIMfailed2init=1)
    {
       addJournalEntry("Failed to initialize the auxiliary threads because FreeImage failed to initialize...")
       multiCoreThumbsInitGood := 0
    } Else
    {
       ; SoundBeep 300, 100
       If A_IsCompiled
          r := GetRes(dataFile, 0, "MODULE-FIM-THUMBS.AHK", "LIB")

       Loop, % realSystemCores + 1
       {
           If !A_IsCompiled
              thumbThread%A_Index% := ahkthread("#Include *i Lib\module-fim-thumbs.ahk")
           Else If r
              thumbThread%A_Index% := ahkThread(StrGet(&dataFile, r, "utf-8"))
           Sleep, 1
       }

       Loop, % realSystemCores + 1
       {
           thumbThread%A_Index%.ahkFunction("initThisThread")
           Sleep, 1
       }

       Sleep, 5
       Loop, % realSystemCores + 1
           goodInit += thumbThread%A_Index%.ahkgetvar.wasInitFIMlib

       multiCoreThumbsInitGood := (goodInit>=realSystemCores+1) ? 1 : 0
       If (multiCoreThumbsInitGood=1)
          addJournalEntry("Succesfully initialized " goodInit " threads.")
       Else
          addJournalEntry("Failed to initialize the auxiliary threads (unknown cause).")
    }

    multiCoreInit := 1
}

getFolderDetails(pathu) {
   FileGetTime, fileMdate, % pathu, M
   FileGetTime, fileCdate, % pathu, C
   FileGetAttrib, fileAttribs, % pathu
   thisFolderDetails := "\" fileMdate "\" fileCdate "\" fileAttribs "\" pathu
   Return thisFolderDetails
}

ToggleThumbsMode() {
   Static multiCoreInit := 0, lastInvoked := 1, prevIndexu
   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (A_TickCount - lastInvoked<190) || (A_TickCount - lastOtherWinClose<190)
   {
      lastInvoked := A_TickCount
      Return
   }
 
   If (thumbsDisplaying=1 && currentFileIndex!=imgIndexEditing)
   {
      If askAboutFileSave(" and another image will be loaded")
      {
         MenuReturnIMGedit()
         Return
      }
   }

   If (SLDtypeLoaded=1 && FolderExist(StrReplace(CurrentSLD, "|")) && watchFolderDetails && maxFilesIndex>1 && thumbsDisplaying!=1)
   {
      thisFolderDetails := getFolderDetails(StrReplace(CurrentSLD, "|"))
      IF (thisFolderDetails!=watchFolderDetails && !markedSelectFile)
      {
         msgResult := msgBoxWrapper(appTitle ": Folder changed", "The folder currently opened seems to have been changed. Would you like to reload it?", 4, 0, "question")
         If InStr(msgResult, "yes")
            RefreshFilesList()
      }
      watchFolderDetails := thisFolderDetails
   }

   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   lastInvoked := A_TickCount
   If (maxFilesIndex<2 && thumbsDisplaying!=1)
   {
      showTOOLtip("WARNING: Insufficient files indexed for the list view mode...")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   interfaceThread.ahkassign("lastCloseInvoked", 0)
   thisIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
   clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectWin)
   If (thumbsDisplaying=1)
   {
      fnOutputDebug("Deactivating thumbs mode.. ")
      If (thisIndexu!=prevIndexu)
         FadeMainWindow()

      thumbsDisplaying := 0
      ; fnOutputDebug("Showing hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("show", hGDIwin)
      interfaceThread.ahkassign("thumbsDisplaying", 0)
      interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
      ; setTexHatchScale(zoomLevel)
      ; fnOutputDebug("Hiding hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("hide", hGDIthumbsWin)
      fnOutputDebug("Image view initialized...")
      dummyTimerDelayiedImageDisplay(50)
      If hSNDmediaFile
         MCI_Resume(hSNDmedia)
   } Else If (CurrentSLD && maxFilesIndex>1)
   {
      fnOutputDebug("Initializing thumbnails/list view mode...")
      prevLoadedImageIndex := currentFileIndex
      If (prevIndexu!=thisIndexu && noTooltipMSGs=0 && thumbnailsListMode!=1)
         CreateOSDinfoLine("Generating thumbnails, please wait...", 0, 1)

      prevIndexu := resultedFilesList[currentFileIndex, 1] currentFileIndex
      If (thumbnailsListMode!=1 && !isWinXP)
         initAHKhThumbThreads()

      If (getCaptionStyle(PVhwnd)=1)
         ToggleTitleBaruNow()
      If hSNDmediaFile
         MCI_Pause(hSNDmedia)
      ; setTexHatchScale(thumbsZoomLevel/2)

      ; fnOutputDebug("Hiding hGDIwin =  " hGDIwin " ")
      ToggleVisibilityWindow("hide", hGDIwin)
      ; fnOutputDebug("Showing hGDIthumbsWin =  " hGDIthumbsWin " ")
      ToggleVisibilityWindow("show", hGDIthumbsWin)
      fnOutputDebug("Recalculating thumbnail sizes...")
      recalculateThumbsSizes()
      UpdateThumbsScreen()
      fnOutputDebug("hGDIinfosWin cleaned...  " hGDIinfosWin "  -- G= " 2NDglPG "  -- hDC= " 2NDglHDC " ")
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
      RemoveTooltip()
   }

   SetTimer, TriggerMenuBarUpdate, -250
   lastInvoked := A_TickCount
}

TriggerMenuBarUpdate() {
   If (showMainMenuBar!=1)
      Return

   lastMenuBarUpdated := A_TickCount
   fnOutputDebug("Updating menu bar...")
   interfaceThread.ahkassign("thumbsDisplaying", thumbsDisplaying)
   interfaceThread.ahkPostFunction("UpdateMenuBar")
}

defineThumbsAratio() {
  friendly := (thumbsAratio=1) ? "Wide (1.81)" : "Tall (0.48)"
  If (thumbsAratio=3)
     friendly := "Square (1.00)"

  Return friendly
}

recalculateThumbsSizes() {
   If (thumbsAratio=1)
   {
      othumbsW := 300
      othumbsH := 165
   } Else If (thumbsAratio=2)
   {
      othumbsW := 144
      othumbsH := 300
   } Else If (thumbsAratio=3)
   {
      othumbsW := 300
      othumbsH := 300
   }
 
   If (thumbsZoomLevel<0.35)
     thumbsZoomLevel := 0.35
   Else If (thumbsZoomLevel>3)
     thumbsZoomLevel := 3
 
   thumbsH := Round(othumbsH*thumbsZoomLevel)
   thumbsW := Round(othumbsW*thumbsZoomLevel)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If (thumbsH>mainHeight || thumbsW>mainWidth)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//2 - 16, mainHeight//2 - 16, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
   }

   If (thumbsColumns>0 && dynamicThumbsColumns=0)
   {
      calcIMGdimensions(thumbsW, thumbsH, mainWidth//thumbsColumns, mainHeight, ResizedW, ResizedH)
      If ResizedH
         thumbsH := ResizedH
      If ResizedW
         thumbsW := ResizedW
      thumbsW := clampInRange(thumbsW, 80, 2048)
      thumbsH := clampInRange(thumbsH, 80, 2048)
   }

   If isInRange(max(thumbsW, thumbsH), 0, 150)
      thumbsSizeQuality := 125
   Else If isInRange(max(thumbsW, thumbsH), 151, 290)
      thumbsSizeQuality := 245
   Else If (max(thumbsW, thumbsH)>650)
      thumbsSizeQuality := 755
   Else
      thumbsSizeQuality := 500

   If (thumbnailsListMode=1)
   {
      Static theString := "WAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAWAW", prevDimensions, columnsPossible
      theseDimensions := mainWidth "=" mainHeight "=" OSDfntSize "=" OSDFontName
      If (prevDimensions!=theseDimensions)
      {
         xBitmap := trGdip_CreateBitmap(A_ThisFunc, 30, 30)
         G := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
         borderSize := Floor(OSDfntSize*1.15)//4.5
         txtOptions := "x" borderSize " y" borderSize A_Space " Left cEE090909 r1 s" OSDfntSize
         dimensions := Gdip_TextToGraphics(G, theString, txtOptions, OSDFontName, mainWidth, mainHeight, 0, 0)
         txtRes := StrSplit(dimensions, "|")
         txtResW := Ceil(txtRes[3]) + borderSize*2
         Gdip_DeleteGraphics(G)
         trGdip_DisposeImage(xBitmap, 1)
         columnsPossible := Round(mainWidth/txtResW)
         prevDimensions := mainWidth "=" mainHeight "=" OSDfntSize "=" OSDFontName
      }

      thumbsW := mainWidth//columnsPossible - 15
      If (thumbsListViewMode=1)
         thumbsH := Round((OSDfntSize//1.25 + imgHUDbaseUnit//9) * 2.5)
      Else
         thumbsH := Round((OSDfntSize//1.25 + imgHUDbaseUnit//9) * 3.55)
   }
}


ChangeThumbsAratio() {
  If (thumbsDisplaying!=1 || thumbnailsListMode=1)
     Return

  thumbsAratio++
  If (thumbsAratio>3)
     thumbsAratio := 1

  recalculateThumbsSizes()
  showTOOLtip("Thumbnails aspect ratio: " defineThumbsAratio() "`nSize: " thumbsW " x " thumbsH " (pixels)")
  SetTimer, RemoveTooltip, % -msgDisplayTime
  INIaction(1, "thumbsAratio", "General")
  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(90)
}

thumbsInfoYielder(ByRef maxItemsW, ByRef maxItemsH, ByRef maxItemsPage, ByRef maxPages, ByRef startIndex, ByRef mainWidth, ByRef mainHeight) {
   Static prevRealThumbsIndex := -1
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0) ; global vars:
   maxItemsW := mainWidth//thumbsW               ;    prevStartIndex
   If (maxItemsW<2)
      maxItemsW := mainWidth//Round(thumbsW*0.95)
   Else If (maxItemsW<4)
      maxItemsW := mainWidth//Round(thumbsW*0.9)

   maxItemsH := mainHeight//thumbsH              ;    startPageIndex
   If (maxItemsH<4)
      maxItemsH := mainHeight//Round(thumbsH*0.9)
   Else If (maxItemsH<10)
      maxItemsH := mainHeight//Round(thumbsH*0.95)

   If (maxItemsW<2)                                   ;    currentFileIndex ---
      maxItemsW := 1
   If (maxItemsH<2)
      maxItemsH := 1
 
   maxItemsPage := maxItemsW*maxItemsH
   maxPages := Ceil(maxFilesIndex/maxItemsPage)
   If (maxItemsH=1 && maxItemsW>1)
   {
      hasReversed := 1
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   maxItemsLine := maxItemsW ; *maxItemsH
   maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
   If (maxItemsW=1)
   {
      startIndex := Floor(currentFileIndex/maxItemsLine) * maxItemsLine
      If (startIndex<2)
         startIndex := 1

      ; ToolTip, % startIndex  " -- " prevRealThumbsIndex " || " maxItemsW " -- " maxItemsH , , , 2
      If isInRange(startIndex, prevRealThumbsIndex + maxItemsPage*2, prevRealThumbsIndex - maxItemsPage)
      {
         If isInRange(startIndex, prevRealThumbsIndex, prevRealThumbsIndex + maxItemsPage - maxItemsW)
            startIndex := prevRealThumbsIndex
         Else
            startIndex := (startIndex<prevRealThumbsIndex) ? startIndex : startIndex - maxItemsPage + maxItemsW
      } Else startIndex := Floor(currentFileIndex/maxItemsPage) * maxItemsPage

      maxTotalLines := Ceil(maxFilesIndex/maxItemsW)
      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := startIndex
   } Else
   {
      If (prevRealThumbsIndex=-1)
         prevRealThumbsIndex := currentFileIndex - maxItemsPage//2

      minIndex := prevRealThumbsIndex
      minIndex := ((minIndex//maxItemsLine) * maxItemsLine) + 1
      If (prevRealThumbsIndex != minIndex)
         prevRealThumbsIndex := minIndex
      
      maxIndex := prevRealThumbsIndex + maxItemsPage - 1
      ; DebugMsg("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; DebugMsg("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      ; fnOutputDebug("min/max Index: " minIndex " / " maxIndex)
      ; fnOutputDebug("prevRealThumbsIndex: " prevRealThumbsIndex)
      ; fnOutputDebug("diff check: " Abs(currentFileIndex-minIndex) " / " maxItemsLine " -------- " Abs(currentFileIndex-maxIndex) " / " maxItemsLine)
      If (Abs(currentFileIndex-minIndex) <= maxItemsLine) || (Abs(currentFileIndex-maxIndex) <= maxItemsLine) || (currentFileIndex>=minIndex && currentFileIndex<=maxIndex)
      { ; just scrolling
          If (currentFileIndex< minIndex)     ; scrolling up
          {
             startIndex := prevRealThumbsIndex-maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("1: startIndex: " startIndex)
          } Else If (currentFileIndex>maxIndex) ; scrolling down
          {
             startIndex := prevRealThumbsIndex+maxItemsLine
             prevRealThumbsIndex := startIndex
             ; fnOutputDebug("2: startIndex: " startIndex)
          } Else  ; when changing img index but not changing pages
          {
             startIndex := prevRealThumbsIndex
             ; fnOutputDebug("3: startIndex: " startIndex)
          }
      } Else ; this is for a jump
      {
         thisIndexu := currentFileIndex/maxFilesIndex
         startIndex := Floor(maxTotalLines*thisIndexu)*maxItemsW
         ; startIndex := ((currentFileIndex//maxItemsLine) * maxItemsLine) + 1
         prevRealThumbsIndex := startIndex
         ; fnOutputDebug("4: startIndex: " startIndex)
      }

      maxuStartIndex := (maxTotalLines - maxItemsH + 1)*maxItemsW - maxItemsW + 1
      maxuStartIndex := clampInRange(maxuStartIndex, maxItemsPage, maxFilesIndex - 1)
      ; maxuStartIndex := (maxFilesIndex>maxItemsPage) ? maxFilesIndex - maxItemsPage + 1 : maxFilesIndex - 1
      ; fnOutputDebug(startIndex  "s -- " prevRealThumbsIndex "p -- " maxuStartIndex " || " maxItemsW "w -- h" maxItemsH)
      startIndex := clampInRange(startIndex, 1, maxuStartIndex)
      prevRealThumbsIndex := clampInRange(prevRealThumbsIndex, 1, maxuStartIndex)
   }
   If (hasReversed=1)
   {
      tempu := maxItemsW
      maxItemsW := maxItemsH
      maxItemsH := tempu
   }

   ; DebugMsg("basics:`r`nmaxItemsPage: " maxItemsPage "`r`nmaxItemsLine: " maxItemsLine "`r`nmin: " minIndex "`r`nmax: " maxIndex "`r`ncurrentFileIndex : " currentFileIndex "`r`n")
   Return "a" startIndex maxItemsW maxItemsH maxItemsPage
}

DeepRefreshThumbsNow() {
   If (markedSelectFile>1)
      setForceRefreshThumbsFilesIndex(1)
   Else
      setForceRefreshThumbsFilesIndex(0)

   dummyTimerDelayiedImageDisplay(50)
}

RefreshThumbsList() {
   mustReloadThumbsList := 1
   dummyTimerDelayiedImageDisplay(50)
}

ForceRefreshNowThumbsList() {
   ; mustReloadThumbsList := 1
   prevStartIndex := -1
   ; dummyTimerDelayiedImageDisplay(50)
}

UpdateThumbsScreen(forceReload:=0) {
   Critical, on
   Static lastInvoked := 1, lastInvokeReload := 1
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   SetTimer, dummyTimerReloadThisPicture, Off
   thumbsDisplaying := 1
   Gdip_ResetClip(glPG)
   interfaceThread.ahkassign("thumbsDisplaying", 1)
   interfaceThread.ahkassign("maxFilesIndex", maxFilesIndex)
   startPageIndex := thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
   createGDIPcanvas(mainWidth, mainHeight)
   Gdip_ResetWorldTransform(glPG)
   IMGlargerViewPort := 0
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   mustShowNames := 0
   ;  ToolTip, % lastInvokeReload , , , 2
   If (A_TickCount - prevTryThumbsUpdate<200) && (mustReloadThumbsList!=1 && thumbnailsListMode!=1 && startPageIndex!=prevFullIndexThumbsUpdate)
   {
      ; lastInvokeReload++
      mustShowNames := 1
      ; If (startPageIndex!=prevFullIndexThumbsUpdate)
      prevFullThumbsUpdate := A_TickCount
      SetTimer, RefreshThumbsList, -300
   }

   mainGdipWinThumbsGrid(0, mustShowNames)
   If (mustShowNames!=1 && (prevStartIndex!=startPageIndex || mustReloadThumbsList=1 || forceReload=1))
   {
      r := QPV_ShowThumbnails()
      If r
         prevFullIndexThumbsUpdate := startPageIndex
      
      mustReloadThumbsList := 0
   } ; Else r := 1

   prevStartIndex := startPageIndex
   ; prevRealThumbsIndex := startIndex
   lastInvoked := A_TickCount
}

GDIwindowsPosCorrections(whichHwnd:="") {
    Static lastInvoked := 1
    If (A_OSVersion="WIN_7" || isWinXP=1) && (A_TickCount - lastInvoked>150) || (isWinXP=1 && editingSelectionNow=1)
    {
       GetPhysicalCursorPos(mainX, mainY)
       JEE_ClientToScreen(hPicOnGui1, 1, 1, mainX, mainY)
       If whichHwnd
       {
          WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
       } Else
       {
          WinMove, ahk_id %hGDIwin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIthumbsWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIselectWin%,, %mainX%, %mainY%
          WinMove, ahk_id %hGDIinfosWin%,, %mainX%, %mainY%
       }
       lastInvoked := A_TickCount
    } Else If (A_OSVersion="WIN_7" || isWinXP=1)
       SetTimer, GDIwindowsPosCorrections, -50
}

panIMGonScrollBar() {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()
   GetMouseCoord2wind(PVhwnd, oX, oY)
   oDx := IMGdecalageX
   oDy := IMGdecalageY

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (imageAligned=5)
      {
         prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
         prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      }
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      If (scrollAxis=1)
      {
         newDecX := (FlipImgH=1) ? -decX : decX
         IMGdecalageX := (A_Index=1) ? (newDecX + oDx)//2 : newDecX
         diffIMGdecX := mX - oX + 2
      } Else
      {
         newDecY := (FlipImgV=1) ? -decY : decY
         IMGdecalageY := (A_Index=1) ? (newDecY + oDy)//2 : newDecY
         diffIMGdecY := mY - oY + 2
      }

      If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
         coreReloadThisPicture()
      Else
         filterDelayiedImageDisplay()
      If (A_Index<3)
        Sleep, 50
   }
   diffIMGdecX := diffIMGdecY := 0
}

ThumbsScrollbar() {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   prevFileIndex := currentFileIndex
   While, (determineLClickstate()=1)
   {
      zeitSillyPrevent := A_TickCount
      GetMouseCoord2wind(PVhwnd, mX, mY)
      newIndex := ((mY-15)/mainHeight)*100
      newIndex := Ceil((maxFilesIndex/100)*newIndex)
      If (newIndex<1)
         newIndex := 1
      Else If (newIndex>maxFilesIndex)
         newIndex := maxFilesIndex-1

      currentFileIndex := newIndex
      filterDelayiedImageDisplay()
      mainGdipWinThumbsGrid(0, 1)
   }

   If (GetKeyState("Shift", "P"))
   {
      keyu := (currentFileIndex>prevFileIndex) ? "Down" : "Home"
      thumbsSelector(keyu, "+Shift", prevFileIndex)
   }

   dummyTimerDelayiedImageDisplay(250)
}


simplePanIMGonClick() {
   GetPhysicalCursorPos(oX, oY)
   oDx := IMGdecalageX
   oDy := IMGdecalageY
   lastInvoked := A_TickCount
   While, (GetKeyState("LButton", "P") || LbtnDwn=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      limitPanningDist(oDx, oDy)
      If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
         coreReloadThisPicture()
      Else
         filterDelayiedImageDisplay()
      ; ToolTip, % diffIMGdecX " == " diffIMGdecY , , , 2
      thisZeit := A_TickCount
      MouseGetPos,,, OutputVarWin
      If (OutputVarWin!=PVhwnd)
      {
         If (A_TickCount - lastInvoked>1550)
            Break
      } Else lastInvoked := A_TickCount
   }
   diffIMGdecX := diffIMGdecY := 0
   ResetImgLoadStatus()
}

limitPanningDist(ByRef oDx, ByRef oDy) {
   If (imageAligned=5)
   {
      If (oDx>0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := -imgDecLX//2
      Else If (oDx<0 && Abs(oDx)>Abs(imgDecLX//2))
         oDx := imgDecLX//2

      If (oDy>0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := -imgDecLY//2
      Else If (oDy<0 && Abs(oDy)>Abs(imgDecLY//2))
         oDy := imgDecLY//2
   } Else
   {
      If (oDx>=0)
         oDx := 0
      Else If (oDx<imgDecLX)
         oDx := imgDecLX

      If (oDy>=0)
         oDy := 0
      Else If (oDy<imgDecLY)
         oDy := imgDecLY
   }
}

panIMGonClick() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If isWinXP
   {
      simplePanIMGonClick()
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   Sleep, 0
   GetPhysicalCursorPos(oX, oY)
   newPosZeit := A_TickCount
   oDx := IMGdecalageX, oDy := IMGdecalageY
   zX := oX, zY := oY
   thisZeit := A_TickCount
   While, (determineLClickstate()=1)
   {
      Sleep, 2
      GetPhysicalCursorPos(mX, mY)
      skipLoop := (isInRange(mX, zX - 5, zX + 5) && isInRange(mY, zY - 5, zY + 5)) ? 1 : 0
      diffIMGdecX := Dx := mX - oX + 2
      diffIMGdecY := Dy := mY - oY + 2
      IMGdecalageX := (FlipImgH=1) ? oDx - Dx : oDx + Dx
      IMGdecalageY := (FlipImgV=1) ? oDy - Dy : oDy + Dy
      ; ToolTip, % diffIMGdecX "--" diffIMGdecY " || " IMGdecalageX "--" IMGdecalageY " || " odX "--" odY , , , 2
      If (A_TickCount - newPosZeit>950) || (mX=oX && mY=oY)
      {
         newPosZeit := A_TickCount
         zX := mX, zY := mY
         If (skipLoop=1)
            Continue
      } Else If (skipLoop=1)
         Continue

      MouseMove, % oX, % oY, 0
      oDx := IMGdecalageX, oDy := IMGdecalageY
      limitPanningDist(oDx, oDy)
      If (A_TickCount - thisZeit>15) || (drawModeAzeit<100) || (drawModeBzeit<100)
      {
         ; If (A_TickCount - thisZeit>95)
         zeitSillyPrevent := A_TickCount
         If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
            coreReloadThisPicture()
         Else
            filterDelayiedImageDisplay()
         thisZeit := A_TickCount
      }
   }
   diffIMGdecX := diffIMGdecY := 0
   dummyTimerReloadThisPicture(70)
   SetTimer, ResetImgLoadStatus, -100
}

winSwipeAction(thisCtrlClicked) {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   didSomething := 1
   infoImgEditingMode := (StrLen(UserMemBMP)>2 && editingSelectionNow=1) || (imgEditPanelOpened=1) ? 1 : 0
   GetPhysicalCursorPos(oX, oY)
   If (IMGlargerViewPort=1 && thumbsDisplaying!=1 && thisCtrlClicked="PicOnGUI2b")
   {
      SetTimer, panIMGonClick, -15
      Return 0
   }

   lowerLimitRatio := (IMGresizingMode=4) ? 0.4 : 0.2
   While, (determineLClickstate()=1)
   {
      GetPhysicalCursorPos(mX, mY)
      diffx := Abs(mX - oX)
      diffy := Abs(mY - oY)
      dirX := (mX - oX) < 0 ? -1 : 1
      dirY := (mY - oY) < 0 ? -1 : 1
      ratioDiffs := diffx/diffy
      If (diffx>45 || diffy>45) && (ratioDiffs<lowerLimitRatio || ratioDiffs>3)
      {
         Sleep, 5
         zeitSillyPrevent := A_TickCount
         swipeAct := (ratioDiffs<lowerLimitRatio) ? 1 : 2
         If (ratioDiffs="")
            swipeAct := 0
         ; ToolTip, % swipeAct " - " thisCtrlClicked " - " ratioDiffs 
      } Else swipeAct := 0 ;  Tooltip
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   If !swipeAct
   {
      zeitSillyPrevent := 1
      If (thisCtrlClicked="PicOnGUI3")
      {
         ; If (imgEditPanelOpened=1)
         ;    ImgRedoAction()
         If (infoImgEditingMode!=1)
            GoNextSlide()
         Else didSomething := 0
      } Else If (thisCtrlClicked="PicOnGUI1" )
      {
         ; If (imgEditPanelOpened=1)
         ;    ImgUndoAction()
         If (infoImgEditingMode!=1)
            GoPrevSlide()
         Else didSomething := 0
      } Else If (thisCtrlClicked="PicOnGUI2a" || thisCtrlClicked="PicOnGUI2c")
      {
         regSize := (editingSelectionNow=1) ? 7 : 5
         If (oY<mainHeight//regSize)
            ChangeZoom(1)
         Else If (oY>mainHeight - mainHeight//regSize)
            ChangeZoom(-1)
      } Else didSomething := 0
   } Else If (swipeAct=1)
   {
      stepFactor := (diffy/mainHeight)*1.65 + 1.25
      ChangeZoom(dirY, 0, stepFactor)
   } Else If (swipeAct=2 && infoImgEditingMode!=1)
   {
      If (dirX=1)
         GoNextSlide()
      Else If (dirX=-1)
         GoPrevSlide()
      Else didSomething := 0
   } Else didSomething := 0

   If !didSomething
      zeitSillyPrevent := 1

   Return didSomething
}

GetMouseCoord2wind(hwnd, ByRef nx, ByRef ny) {
    ; CoordMode, Mouse, Screen
    MouseGetPos, ox, oy
    JEE_ScreenToClient(hwnd, ox, oy, nx, ny)
}

dummyAutoClearSelectionHighlight() {
    GetMouseCoord2wind(hGDIwin, mX, mY)
    Gdip_SetPenWidth(pPen1d, SelDotsSize)
    hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
    If !hitB
    {
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
       pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
       Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
       r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
   }
}

LrydWinUpdt(hwnd, HDCu, opacity:=255) {
  GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
  If (A_OSVersion="WIN_7" || isWinXP=1)
  {
     GetPhysicalCursorPos(mainX, mainY)
     JEE_ClientToScreen(hPicOnGui1, 1, 1, xPos, yPos)
     ; WinMove, ahk_id %whichHwnd%,, %mainX%, %mainY%
  } Else xPox := yPos := 0
  r := UpdateLayeredWindow(hwnd, HDCu, xPos, yPos, mainWidth, mainHeight, opacity)
  Return r
}

MouseMoveResponder() {
  Static prevState := "C"

  If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1 && drawingShapeNow!=1)
  {
     ; ToolTip, % SelDotsSize , , , 2
     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     GetMouseCoord2wind(hGDIwin, mX, mY)
     hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
     Gdip_SetPenWidth(pPen1d, SelDotsSize)
     hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
     If (hitB=1)
        thisState := "B"
     Else If (hitA=1)
        thisState := "A"
     Else
        thisState := "C"

     If (thisState="B" && prevState!=thisState)
     {
        ; changeMcursor("finger")
        prevState := "B"
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
        Gdip_SetPenWidth(pPen1d, SelDotsSize//2)
        Gdip_DrawPath(2NDglPG, pPen1d, hitTestSelectionPath)
        r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
     } Else If (thisState="A" && prevState!=thisState)
     {
        ; changeMcursor("move")
        prevState := "A"
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
        pathBounds := Gdip_GetPathWorldBounds(hitTestSelectionPath)
        Gdip_FillEllipse(2NDglPG, pBrushD, pathBounds.x + pathBounds.w//2 - SelDotsSize//3, pathBounds.y + pathBounds.h//2 - SelDotsSize//3, SelDotsSize*0.7, SelDotsSize*0.7)
        Gdip_FillPath(2NDglPG, pBrushF, hitTestSelectionPath)
        r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
        SetTimer, dummyAutoClearSelectionHighlight, -150
     } Else If (thisState="C" && prevState!=thisState)
     {
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevState := "C"
     }
  } Else
  {
     If (prevState!="C")
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     prevState := "C"
  }
}

applyIMGeditFunctionClose() {
   applyIMGeditFunction()
   Sleep, 2
   CloseWindow()
   CreateGuiButton("Undo action,,ImgUndoAction||Reopen panel,,openPreviousPanel", 0, msgDisplayTime//1.5 + 500)
}

applyIMGeditFunction() {
    ; recordSelUndoLevelNow()
    If (AnyWindowOpen=24 || AnyWindowOpen=31)
       BtnPasteInSelectedArea()
    Else If (AnyWindowOpen=30)
       BtnDrawLinesSelectedArea()
    Else If (AnyWindowOpen=32)
       BtnInsertTextSelectedArea()
    Else If (AnyWindowOpen=23)
       BtnFillSelectedArea()
    Else If (AnyWindowOpen=25)
       BtnEraseSelectedArea()
    Else If (AnyWindowOpen=10) ; colors adjustments
       BtnCloseWindow()
    SetTimer, RemoveTooltip, -300
}

livePreviewsImageEditing(directCall:=0, hideHUD:=0) {
   Static toggleThisu := 0
   If (hideHUD=2 && imgEditPanelOpened=1 && directCall=1 && toggleThisu!=1)
   {
      toggleThisu := 1
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIselectwin)
      Return
   }

   If (imgEditPanelOpened!=1)
      Return

   toggleThisu := 0
   If (directCall=1 || scrollBarHy>0 || scrollBarVx>0)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   If (directCall=1)
      setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      corePasteInPlaceActNow(0, 0)
   Else If (AnyWindowOpen=30)
      coreDrawLinesSelectionArea()
   Else If (AnyWindowOpen=23)
      coreFillSelectedArea()
   Else If (AnyWindowOpen=32)
      livePreviewInsertTextinArea()
   Else If (AnyWindowOpen=25)
      liveEraserPreview()

   If (hideHUD!=1 && AnyWindowOpen!=32)
      livePreviewsImageEditingDrawSelectionBox()

   If (directCall=1)
   {
      Gdip_ResetWorldTransform(2NDglPG)
      r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
   }

   If (scrollBarHy>0)
   {
      Gdip_SetClipRect(2NDglPG, 0, scrollBarHy, mainWidth, mainHeight - scrollBarHy)
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG)
   }

   If (scrollBarVx>0)
   {
      Gdip_SetClipRect(2NDglPG, scrollBarVx, 0, mainWidth - scrollBarVx, mainHeight)
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG)
   }

   If (scrollBarHy>0 || scrollBarVx>0)
      Gdip_ResetClip(2NDglPG)
}

livePreviewsImageEditingDrawSelectionBox() {
   dotsSize := SelDotsSize
   vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx)
   vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy)
   vPimgSelX := min(selDotX, selDotAx) + dotsSize//2
   vPimgSelY := min(selDotY, selDotAy) + dotsSize//2
 
   whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
   Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
   If (vPselRotation!=0)
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)

   If (imgEditPanelOpened=1)
   {
      Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
      Gdip_FillEllipse(2NDglPG, pBrushA, SelDotDx + 5, SelDotDy + 5, dotsSize, dotsSize)
   }

   thisThick := dotsSize//5 + 1
   Gdip_SetPenWidth(pPen4, thisThick)
   Gdip_SetPenWidth(pPen1d, thisThick)
   ImgSelPath := createImgSelPath(vPimgSelX, vPimgSelY, vPimgSelW, vPimgSelH, EllipseSelectMode)
   If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=24)
   {
      Gdip_RotatePathAtCenter(ImgSelPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
      Gdip_DrawPath(2NDglPG, pPen4, ImgSelPath)
   }

   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//3, vPimgSelY + thisThick//3, vPimgSelW, vPimgSelH)
   Gdip_DrawPath(2NDglPG, pPen1d, ImgSelPath)
   Gdip_DrawRectangle(2NDglPG, pPen4, vPimgSelX + thisThick//2, vPimgSelY + thisThick//2, vPimgSelW, vPimgSelH)
   Gdip_DeletePath(ImgSelPath)
}

selectFileLongTap() {
   If (determineLClickstate() && (A_TickCount - lastOtherWinClose>350))
      markThisFileNow(currentFileIndex)
}

WinClickAction(mainParam:=0, thisCtrlClicked:=0) {
   Critical, on
   Static thisZeit := 1, prevTippu := 1, anotherZeit := 1
        , lastInvoked := 1, lastInvoked2 := 1, lastInvokedSwipe := 1

   ; ToolTip, % mainParam " -- " thisCtrlClicked,,,2
   If (A_TickCount - lastLongOperationAbort < 550) || (A_TickCount - executingCanceableOperation < 550)
      Return

   If (AnyWindowOpen=1 || AnyWindowOpen=33 || AnyWindowOpen=39)
   {
      CloseWindow()
      Return
   } Else If (AnyWindowOpen=26)
   {
      ; respond to clicks in viewport for panels with region based previews
      tinyPrevAreaCoordX := tinyPrevAreaCoordY := "C"
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (TouchScreenMode=1 && thumbsDisplaying=1)
      SetTimer, selectFileLongTap, Off

   If AnyWindowOpen
   {
      ; handle clicks in the viewport when another GUI is open
      If (imgEditPanelOpened!=1)
      {
         SoundPlay, *-1
         WinActivate, ahk_id %hSetWinGui%
         Return
      }
   }

   If (imageLoading=1 && thumbsDisplaying=1)
      Return

   MouseGetPos, , , OutputVarWin
   If (toolTipGuiCreated=1)
      RemoveTooltip()

   GetMouseCoord2wind(PVhwnd, mX, mY)
   ;  ToolTip, % HUDobjHistoBoxu[3] "==" HUDobjHistoBoxu[1] "==" mX "`n" HUDobjHistoBoxu[4] "==" HUDobjHistoBoxu[2] "==" mY , , , 2
   If (showHistogram>1 && imgEditPanelOpened!=1 && drawingShapeNow!=1 && thumbsDisplaying!=1
   && isInRange(mX, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3]) && hasDrawnHistoMap=1
   && isInRange(mY, HUDobjHistoBoxu[4], HUDobjHistoBoxu[6] + HUDobjHistoBoxu[4]))
   {
      ToggleHistogramMode()
      Return
   } Else If (showHistogram>1 && hasDrawnImageMap=1 && thumbsDisplaying!=1 && isInRange(mX, HUDobjHistoBoxu[3], HUDobjHistoBoxu[1] + HUDobjHistoBoxu[3])
   && hasDrawnHistoMap=1 && isInRange(mY, HUDobjHistoBoxu[4], HUDobjHistoBoxu[2] + HUDobjHistoBoxu[4]))
   {
      If (showHistogram=6)
         showHistogram := 1
      If (mainParam="DoubleClick")
         showHistogram := 6
      ToggleImgHistogram(1)
      Return
   } Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && drawingShapeNow!=1 && thumbsDisplaying!=1
   && isInRange(mX, HUDobjNavBoxu[3], HUDobjNavBoxu[1] + HUDobjNavBoxu[3]) && hasDrawnImageMap=1
   && isInRange(mY, HUDobjNavBoxu[4], HUDobjNavBoxu[2] + HUDobjNavBoxu[4]))
   {
      If (mainParam="DoubleClick")
      {
         ToggleImgNavSizeBox()
      } Else
      {
         While, (determineLClickstate()=1)
         {
            GetMouseCoord2wind(PVhwnd, mX, mY)
            ImageNavClickResponder(clampInRange(mX - HUDobjNavBoxu[3], 0, HUDobjNavBoxu[1]), clampInRange(mY - HUDobjNavBoxu[4], 0, HUDobjNavBoxu[2]), HUDobjNavBoxu[1], HUDobjNavBoxu[2])
            Sleep, 5
         }
      }
      Return
   } Else If (showHUDnavIMG=1 && IMGlargerViewPort=1 && thumbsDisplaying!=1 && isInRange(mX, HUDobjNavBoxu[7], HUDobjNavBoxu[5] + HUDobjNavBoxu[7])
   && hasDrawnImageMap=1 && isInRange(mY, HUDobjNavBoxu[8], HUDobjNavBoxu[6] + HUDobjNavBoxu[8]))
   {
      If (mainParam="DoubleClick")
         ToggleImgNavSizeBox()
      Else
         Sleep, 25
      Return
   }

   If (thumbsDisplaying!=1 && mainParam="doubleclick" && StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0)
   {
      Gdip_SetPenWidth(pPen1d, SelDotsSize)
      hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
      hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, 2NDglPG)
      If (hitB=1) || (hitA=1 && imgEditPanelOpened!=1 && imgSelLargerViewPort=0)
      {
         BuildImgLiveEditMenu()
         Return
      } Else If (hitA=1 && imgEditPanelOpened!=1 && imgSelLargerViewPort=1)
      {
         toggleImgSelection()
         Return
      }
   }

   If (mainParam="doubleclick" && thumbsDisplaying=1 && hitTestSelectionPath)
   {
      ; fnOutputDebug("user double-clicked thumb")
      hitA := Gdip_IsVisiblePathPoint(hitTestSelectionPath, mX, mY, glPG)
      If (hitA=1)
         ToggleThumbsMode()
      Return
   } Else If (thumbsDisplaying=1 && maxFilesIndex>0 && mainParam!="doubleclick")
   {
      ; handle clicks on thumbnails and the vertical scrollbar
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      scrollXpos := mainWidth - imgHUDbaseUnit//2
      statusBarYpos := mainHeight - ThumbsStatusBarH
      If (mX>scrollXpos)
      {
         SetTimer, ThumbsScrollbar, -25
         Return
      } Else If (mY>statusBarYpos && noTooltipMSGs=0)
      {
         If (mainParam="rclick")
            invokeFileOptionsMenu()
         Else
            ToggleMultiLineStatus()
         Return
      }

      thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
      rowIndex := 0, columnIndex := -1
      Loop, % maxItemsPage*2
      {
         columnIndex++
         If (columnIndex>=maxItemsW)
         {
            rowIndex++
            columnIndex := 0
         }
         DestPosX := thumbsW*columnIndex + thumbsW
         DestPosY := thumbsH*rowIndex + thumbsH
         If (DestPosX>mX && DestPosY>mY)
         {
            newIndex := startIndex + A_Index - 1
            Break
         }
      }

      maxWidu := maxItemsW*thumbsW - 1
      maxHeitu := maxItemsH*thumbsH  - 1
      If (maxWidu<mX || maxHeitu<mY) || (newIndex && newIndex>maxFilesIndex)
      {
         If (mainParam="rclick")
            SetTimer, InitGuiContextMenu, -10
         Return
      } Else If (!hitTestSelectionPath && mainParam!="rClick" && newIndex=currentFileIndex) && (A_TickCount - lastInvoked>350)
      {
         ToggleThumbsMode()
         Return
      }

      If newIndex
      {
         If (GetKeyState("Ctrl", "P") && mainParam!="rClick")
         {
            disAllowLongTap := 1
            markThisFileNow(newIndex)
         } Else If (GetKeyState("Shift", "P") && mainParam!="rClick")
         {
            disAllowLongTap := 1
            keyu := (newIndex>currentFileIndex) ? "Down" : "Upu"
            prevFileIndex := currentFileIndex
            currentFileIndex := newIndex
            thumbsSelector(keyu, "+Shift", prevFileIndex)
         } Else currentFileIndex := newIndex

         If (mainParam="rClick")
            DelayiedImageDisplay()
         Else
            dummyTimerDelayiedImageDisplay(25)

         longTapDelay := markedSelectFile ? 350 : 750
         If (disAllowLongTap!=1 && TouchScreenMode=1)
            SetTimer, selectFileLongTap, % - longTapDelay
      }

      If (mainParam="rclick")
         SetTimer, InitGuiContextMenu, -10

      lastInvoked := A_TickCount
      Return
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   spaceState := GetKeyState("Space", "P") ? 1 : 0
   displayingImageNow := (thumbsDisplaying!=1 && useGdiBitmap()) ? 1 : 0
   If (mainParam="normal" && displayingImageNow=1 && IMGlargerViewPort=1 && IMGresizingMode=4 && (scrollBarHy>1 || scrollBarVx>1) && thumbsDisplaying!=1)
   {
      ; handle H/V scrollbars for images larger than the viewport
      If (scrollBarHy>1) && ((mY>scrollBarHy && FlipImgV=0)
      || (mY<(mainHeight - scrollBarHy) && FlipImgV=1))
      {
         scrollAxis := 1
         SetTimer, panIMGonScrollBar, -25
         Return
      } Else If (scrollBarVx>1) && ((mX>scrollBarVx && FlipImgH=0)
      || (mX<(mainWidth - scrollBarVx) && FlipImgH=1))
      {
         scrollAxis := 0
         SetTimer, panIMGonScrollBar, -25
         Return
      }
   }

   If (drawingShapeNow=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      ; If (FlipImgH=1 || FlipImgV=1)
         ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      gmX := (FlipImgH=1) ? mainWidth - mX : mX
      gmY := (FlipImgV=1) ? mainHeight - mY : mY
      gmX := gmX + (initialDrawingStartCoords[1] - prevDestPosX)
      gmY := gmY + (initialDrawingStartCoords[2] - prevDestPosY)
      customShapePoints .= gmX "," gmY "|"
      SetTimer, dummyRefreshImgSelectionWindow, 75
      If (mainParam="DoubleClick" || mainParam="rclick")
         stopDrawingShape()
      Return
   }

   If ((editingSelectionNow!=1) || (imgSelOutViewPort=1 && editingSelectionNow=1) || (imgSelLargerViewPort=1 && editingSelectionNow=1))
   && (displayingImageNow=1 && getCaptionStyle(PVhwnd)!=1 && mainParam="normal" && GetKeyState("LButton") && GetKeyState("Shift", "P"))
   {
      ; activate selection on single click + shift
      GetMouseCoord2wind(PVhwnd, mX, mY)
      MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
      MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
      Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
      defineRelativeSelCoords(rImgW, rImgH)
      ToggleEditImgSelection("show-edit")
      dummyTimerDelayiedImageDisplay(50)
      Return
   }

   If (mainParam="normal" && editingSelectionNow=1 && spaceState!=1 && displayingImageNow=1)
   {
      ; handle clicks on the image selection rectangle in the viewport
      mXoT := mX, mYoT := mY, dotsSize := SelDotsSize
      MouseGetPos, mXo, mYo
      nSelDotX  := selDotX,  nSelDotAx := selDotAx
      nSelDotY  := selDotY,  nSelDotAy := selDotAy
      nSelDotBx := selDotBx, nSelDotCx := selDotCx
      nSelDotBy := selDotBy, nSelDotCy := selDotCy
      nSelDotDx := selDotDx, nSelDotDy := selDotDy

      If (FlipImgH=1)
      {
         nSelDotX := mainWidth - selDotX - dotsSize
         nSelDotAx := mainWidth - selDotAx - dotsSize
         nSelDotBx := mainWidth - selDotBx - dotsSize
         nSelDotCx := mainWidth - selDotCx - dotsSize
         nSelDotDx := mainWidth - selDotDx - dotsSize
      }

      If (FlipImgV=1)
      {
         nSelDotY := mainHeight - selDotY - dotsSize
         nSelDotAy := mainHeight - selDotAy - dotsSize
         nSelDotBy := mainHeight - selDotBy - dotsSize
         nSelDotCy := mainHeight - selDotCy - dotsSize
         nSelDotDy := mainHeight - selDotDy - dotsSize
      }

      zL := (zoomLevel>1) ? zoomLevel : 1/zoomLevel
      If (isInRange(mXoT, nselDotX, nselDotX + dotsSize) && isInRange(mYoT, nselDotY, nselDotY + dotsSize))
      {
         dotActive := 1
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotAx, nselDotAx + dotsSize) && isInRange(mYoT, nselDotAy, nselDotAy + dotsSize))
      {
         dotActive := 2
         DotPosX := imgSelX2
         DotPosY := imgSelY2
      } Else If (isInRange(mXoT, nselDotBx, nselDotBx + dotsSize) && isInRange(mYoT, nselDotBy, nselDotBy + dotsSize))
      {
         dotActive := 3
         DotPosX := imgSelX2
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotCx, nselDotCx + dotsSize) && isInRange(mYoT, nselDotCy, nselDotCy + dotsSize))
      {
         dotActive := 4
         DotPosX := imgSelX1
         DotPosY := imgSelY2
      } Else If (isInRange(mXoT, nselDotX, nselDotBx) && isInRange(mYoT, nselDotY, nselDotY + dotsSize))
      {
         dotActive := 5
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotCx, nselDotBx) && isInRange(mYoT, nselDotCy, nselDotCy + dotsSize))
      {
         dotActive := 6
         DotPosX := imgSelX1
         DotPosY := imgSelY2
      } Else If (isInRange(mXoT, nselDotX, nselDotX + dotsSize) && isInRange(mYoT, nselDotY, nselDotCy))
      {
         dotActive := 7
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotBx, nselDotBx + dotsSize) && isInRange(mYoT, nselDotBy, nselDotAy))
      {
         dotActive := 8
         DotPosX := imgSelX2
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotDx, nselDotDx + dotsSize) && isInRange(mYoT, nselDotDy, nselDotDy + dotsSize))
      {
         ; click the center dot of the selection area
         anotherZeit := A_TickCount
         dotActive := 10
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      } Else If (isInRange(mXoT, nselDotX, nselDotBx) && isInRange(mYoT, nselDotBy, nselDotAy))
      {
         ; click anywhere within the selection
         dotActive := 9
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }

      If (dotActive && imgSelOutViewPort=1)
      {
         dotActive := 9
         DotPosX := imgSelX1
         DotPosY := imgSelY1
      }
      ovPselRotation := vPselRotation
      tDotPosX := DotPosX
      tDotPosY := DotPosY

      nImgSelX1 := tImgSelX1 := imgSelX1
      nImgSelY1 := tImgSelY1 := imgSelY1
      nImgSelX2 := tImgSelX2 := imgSelX2
      nImgSelY2 := tImgSelY2 := imgSelY2
      timgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      timgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      tavg := (timgSelW + timgSelH)//2
      timgSelX2 := tImgSelX1 + tavg
      timgSelY2 := tImgSelY1 + tavg
      otimgSelX2 := nImgSelX2
      otimgSelY2 := nImgSelY2
      timgSelRatio := timgSelW/timgSelH

      thisZeit := zX := zY := adjustNowSel := 1
      o_imageLoading := imageLoading
      ctrlState := (GetKeyState("Ctrl", "P") && dotActive=9) ? 1 : 0
      shiftState := GetKeyState("Shift", "P") ? 1 : 0
      altState := GetKeyState("Alt", "P") ? 1 : 0
      If (lockSelectionAspectRatio>0 && desiredSelAspectRatio && adjustGradientOffset!=1 && !altState && isInRange(dotActive, 1, 8) && !ctrlState)
         shiftState := 1

      If dotActive
      {
         drawImgSelectionOnWindow("init", 0, 0, 0, mainWidth, mainHeight)
         If isInRange(dotActive, 1, 8)
            adjustingSelDotNow := dotActive
      }
      newPosZeit := A_TickCount
      oldPosZeit := A_TickCount
      o_alphaMaskOffsetX := alphaMaskOffsetX
      o_alphaMaskOffsetY := alphaMaskOffsetY
      adjustGradientOffset := 0
      If (dotActive=9 && AnyWindowOpen=23 && !GetKeyState("Shift","P"))
      {
         GuiControlGet, FillAreaColorMode, SettingsGUIA:, FillAreaColorMode
         GuiControlGet, FillAreaDoContour, SettingsGUIA:, FillAreaDoContour
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=2 && FillAreaColorMode>1 && FillAreaDoContour!=1)
            adjustGradientOffset := 1
      } Else If (dotActive=9 && (AnyWindowOpen=24 || AnyWindowOpen=31) && !GetKeyState("Shift","P"))
      {
         GuiControlGet, PasteInPlaceAlphaMaskMode, SettingsGUIA:, PasteInPlaceAlphaMaskMode
         GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
         If (CurrentPanelTab=3 && PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5)
            adjustGradientOffset := 1
      }

      While, (determineLClickstate()=1 && o_imageLoading!=1 && dotActive && ctrlState=0)
      {
          MouseGetPos, mX, mY, thisWind
          skipLoop := (isInRange(mX, zX - 5, zX + 5) && isInRange(mY, zY - 5, zY + 5)) ? 1 : 0
          If (A_TickCount - newPosZeit>950) ; || (mX=oX && mY=oY)
          {
             newPosZeit := A_TickCount
             zX := mX, zY := mY
             If (skipLoop=1)
                Continue
          } Else If (skipLoop=1)
             Continue

          zeitSillyPrevent := A_TickCount
          changePosX := (zoomLevel>1) ? Round((mX - mXo)/zL) : Round((mX - mXo)*zL)
          changePosY := (zoomLevel>1) ? Round((mY - mYo)/zL) : Round((mY - mYo)*zL)
          If (dotActive=10)
          {
             ; center dot - selection rotation
             tW := (A_TickCount - oldPosZeit)/2150 + 0.0001
             If (tW>=1)
                tW := 1
             rotAmount := (changePosX/(mainWidth*0.9))*tW
             rotAmount := rotAmount * 360
             nvPselRotation := Round(ovPselRotation + rotAmount, 2)
             If (nvPselRotation<0 || nvPselRotation>360)
                nvPselRotation := 360 - Abs(nvPselRotation)
             vPselRotation := nvPselRotation
             ; ToolTip, % TW " -- " rotAmount " -- " nvPselRotation " -- " ovPselRotation " -- " vPselRotation  , , , 2
             If (shiftState=1)
                vPselRotation := ovPselRotation + 45
             Else If (altState=1)
                vPselRotation := 0
             vPselRotation := clampInRange(vPselRotation, 0, 360)
          } Else If (dotActive=9 && adjustGradientOffset=1)
          {
             ; anywhere within selection click
             coords := 10
             movX := (FlipImgH=1) ? - changePosX/(mainWidth*1.2) : changePosX/(mainWidth*1.2)
             movY := (FlipImgV=1) ? - changePosY/(mainHeight*1.2) : changePosY/(mainHeight*1.2)
             alphaMaskOffsetX := clampInRange(o_alphaMaskOffsetX + movX, -0.9, 0.9)
             alphaMaskOffsetY := clampInRange(o_alphaMaskOffsetY + movY, -0.9, 0.9)
             If (altState=1)
                alphaMaskOffsetX := alphaMaskOffsetY := o_alphaMaskOffsetX := o_alphaMaskOffsetY := 0
          }

          If (shiftState=1 && dotActive=9 && adjustGradientOffset!=1)
          {
             ; drag selection
             maxPos := max(Abs(changePosX), Abs(changePosY))
             If (maxPos=Abs(changePosX))
                changePosY := 0
             Else If (maxPos=Abs(changePosY))
                changePosX := 0
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; changePosX := Round(changePosX*timgSelRatio)
             If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -33000, timgSelH - 2) : clampInRange(changePosY, -timgSelH + 2, 33000)
             } Else If (dotActive=3)
             {
                changePosX := (FlipImgH=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             } Else If (dotActive=4)
             {
                changePosX := (FlipImgH!=1) ? clampInRange(changePosX, -33000, timgSelW - 2) : clampInRange(changePosX, -timgSelW + 2, 33000)
                changePosY := (FlipImgV!=1) ? clampInRange(changePosY, -timgSelH + 2, 33000) : clampInRange(changePosY, -33000, timgSelH - 2)
             }
          }
 
          newSelDotX := (FlipImgH=1) ? tDotPosX - changePosX : tDotPosX + changePosX
          newSelDotY := (FlipImgV=1) ? tDotPosY - changePosY : tDotPosY + changePosY
          If (dotActive=1)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=2)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=3)
          {
             coords := 1
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=4)
          {
             coords := 1
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=5)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=6)
          {
             coords := 3
             nImgSelX1 := newSelDotX
             nImgSelY2 := newSelDotY
          } Else If (dotActive=7)
          {
             coords := 2
             nImgSelX1 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=8)
          {
             coords := 2
             nImgSelX2 := newSelDotX
             nImgSelY1 := newSelDotY
          } Else If (dotActive=9 && adjustGradientOffset!=1)
          {
             coords := 10
             imgSelX1 := (FlipImgH=1) ? nImgSelX1 - changePosX : nImgSelX1 + changePosX
             imgSelY1 := (FlipImgV=1) ? nImgSelY1 - changePosY : nImgSelY1 + changePosY
             imgSelX2 := (FlipImgH=1) ? nImgSelX2 - changePosX : nImgSelX2 + changePosX
             imgSelY2 := (FlipImgV=1) ? nImgSelY2 - changePosY : nImgSelY2 + changePosY
          }

          If (nImgSelX1>nImgSelX2 || nImgSelY1>nImgSelY2) && (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY2
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY1
          } Else If (coords!=10)
          {
             If (coords=1 || coords=2)
                imgSelX1 := nImgSelX1
             If (coords=1 || coords=3)
                imgSelY1 := nImgSelY1
             If (coords=1 || coords=2)
                imgSelX2 := nImgSelX2
             If (coords=1 || coords=3)
                imgSelY2 := nImgSelY2
          }
          If (imgSelX1=imgSelX2)
             imgSelX2 += 2
          If (imgSelY1=imgSelY2)
             imgSelY2 += 2

          imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
          imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          If (adjustGradientOffset!=1 && altState=1 && (dotActive=1 || dotActive=2 || dotActive=9))
          {
             ; rectangular selection mode
             avg := (imgSelW+imgSelH)//2
             If (dotActive=9)
             {
                cAvg := (changePosX+changePosY)//2
                imgSelX2 := timgSelX2 + cAvg
                imgSelY2 := timgSelY2 + cAvg
                imgSelX1 := timgSelX1 - cAvg
                imgSelY1 := timgSelY1 - cAvg
             } Else If (dotActive=2)
             {
                imgSelX2 := imgSelX1 + avg
                imgSelY2 := imgSelY1 + avg
             } Else
             {
                imgSelX1 := imgSelX2 - avg
                imgSelY1 := imgSelY2 - avg

             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          } Else If (adjustGradientOffset!=1 && shiftState=1 && isInRange(dotActive, 1, 8))
          {
             ; keep aspect ratio mode
             cAvg := (changePosX+changePosY)//2
             diffu := (timgSelRatio>1) ? min(timgSelW, timgSelH) : max(timgSelW, timgSelH)
             If (dotActive=2 || dotActive=6 || dotActive=8)
             {
                imgSelX2 := clampInRange(timgSelX1 + Round((diffu + cAvg)*timgSelRatio), timgSelX1 + 5, 33000)
                imgSelY2 := clampInRange(timgSelY1 + (diffu + cAvg), timgSelY1 + 5, 33000)
             } Else If (dotActive=1 || dotActive=5 || dotActive=7)
             {
                cAvg := -cAvg
                imgSelX1 := clampInRange(otimgSelX2 - Round((diffu + cAvg)*timgSelRatio), -33000, otimgSelX2 + 5)
                imgSelY1 := clampInRange(otimgSelY2 - (diffu + cAvg), -33000, otimgSelY2 + 5)
             } Else If (dotActive=3)
             {
                cAvg := -cAvg
                imgSelX2 := timgSelX1 + Round((diffu+cAvg)*timgSelRatio)
                imgSelY1 := otimgSelY2 - diffu - cAvg
             } Else If (dotActive=4)
             {
                ; cAvg := -cAvg
                imgSelY2 := timgSelY1 + diffu + cAvg
                imgSelX1 := otimgSelX2 - Round((diffu+cAvg)*timgSelRatio)
             }

             If (LimitSelectBoundsImg=1)
             {
                imgSelX1 := clampInRange(imgSelX1, 0, prevMaxSelX)
                imgSelY1 := clampInRange(imgSelY1, 0, prevMaxSelY)
                imgSelX2 := clampInRange(imgSelX2, 0, prevMaxSelX)
                imgSelY2 := clampInRange(imgSelY2, 0, prevMaxSelY)
             }
             imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
             imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
          }

          ; ToolTip, % cAvg "=" dotActive "|" changePosX "|" changePosY "|" timgSelW "|" timgSelH , , , 2
          If (A_TickCount - thisZeit>25)
          {
             If (isInRange(dotActive, 1, 4) && noTooltipMSGs=0 && minimizeMemUsage!=1)
             {
                ARGBdec := Gdip_GetPixel(gdiBitmap, newSelDotX, newSelDotY)
                Gdip_FromARGB(ARGBdec, cA, cR, cG, cB)
                pixelColor := cR ", " cG ", " cB ", " cA
                addMsg := "`n `nCorner coordinates:`nX / Y: " newSelDotX ", " newSelDotY "`nColor: " pixelColor
             }

             theRatio := (lockSelectionAspectRatio>0) ? "`nLocked aspect ratio: " Round(desiredSelAspectRatio, 2) : "`nRatio: " Round(imgSelW/imgSelH, 2)
             ; If (imgEditPanelOpened=1)
                theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "
             theMsg := "X / Y: " ImgSelX1 ", " ImgSelY1 "`nW / H: " imgSelW ", " imgSelH theRatio addMsg
             If (adjustGradientOffset=1)
                theMsg := "Gradient center offset:`nX / Y: " Round(alphaMaskOffsetX, 2) ", " Round(alphaMaskOffsetY, 2) "`nGradient angle: " Round(FillAreaGradientAngle) "°"

             ; ToolTip, % theMsg, % mainX + 10, % mainY + 10
             drawImgSelectionOnWindow("live", theMsg, ARGBdec, dotActive, mainWidth, mainHeight)
             thisZeit := A_TickCount
          }
      }
      adjustingSelDotNow := adjustNowSel := 0
      If dotActive
         drawImgSelectionOnWindow("end")

      ToolTip
      If (dotActive && imgEditPanelOpened=1)
         anotherZeit := A_TickCount

      If (dotActive=9 && isInRange(Abs(changePosY), 0, 2) && isInRange(Abs(changePosX), 0, 2))
      {
         If (A_TickCount - anotherZeit<300) && (imgEditPanelOpened!=1)
            thisZeit := dotActive := ctrlState := 0
         anotherZeit := A_TickCount
      }

      If (dotActive || (A_TickCount - thisZeit<150)) && (ctrlState=0)
         Return
   }

   If (mainParam="doubleclick" && thumbsDisplaying!=1 && displayingImageNow=1 && spaceState!=1) && (A_TickCount - lastInvokedSwipe>500) && (A_TickCount - anotherZeit>600)
   {
      ; handle double clicks in the viewport when an image is being displayed
      If (editingSelectionNow=1 && imgEditPanelOpened!=1)
      {
         lastInvoked := A_TickCount
         toggleImgSelection()
         Return
      }

      lastInvoked := A_TickCount
      If (slideShowRunning=1)
         ToggleSlideShowu()
      Sleep, 1
      ToggleViewModeTouch()
   } Else If ((maxFilesIndex>1 || mustOpenStartFolder) && CurrentSLD && mainParam!="DoubleClick") && (A_TickCount - thisZeit>950)
   {
      ; handle single clicks in the viewport when multiple files are loaded
      didSomething := 0
      If (TouchScreenMode=0 || spaceState=1) && (IMGlargerViewPort=1 && thumbsDisplaying!=1)
         SetTimer, panIMGonClick, -25
      Else If (TouchScreenMode=1)
         didSomething := winSwipeAction(thisCtrlClicked)
      Else didSomething := 0

      lastInvoked := A_TickCount
      If didSomething
         lastInvokedSwipe := A_TickCount
   } Else If (!CurrentSLD || maxFilesIndex<1) && (A_TickCount - thisZeit>450)
   {
      ; when no image is loaded, on click, open files dialog
      lastInvoked := A_TickCount
      If StrLen(UserMemBMP)>2
         Return

      SetTimer, drawWelcomeImg, Off
      Sleep, 5
      If (A_TickCount - lastWinDrag>300)
         OpenDialogFiles()
   }
   lastInvoked := A_TickCount
}

JEE_ScreenToWindow(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(RECT, 16)
  DllCall("user32\GetWindowRect", Ptr,hWnd, Ptr,&RECT)
  vWinX := NumGet(&RECT, 0, "Int")
  vWinY := NumGet(&RECT, 4, "Int")
  vPosX2 := vPosX - vWinX
  vPosY2 := vPosY - vWinY
}

JEE_ScreenToClient(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472
  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ScreenToClient", Ptr,hWnd, Ptr,&POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}

ToggleImageSizingMode(dummy:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50)
       Return

    lastInvoked := A_TickCount
    resetSlideshowTimer(0)
    If (imgEditPanelOpened!=1)
    {
       IMGdecalageX := IMGdecalageX := 1
       IMGresizingMode++
       If (IMGresizingMode>5)
          IMGresizingMode := 1

       If (IMGresizingMode=5)
       {
          editingSelectionNow := 0
          updateUIctrl()
       }
    } Else 
    {
       IMGresizingMode := (IMGresizingMode=1) ? 4 : 1
       If (IMGresizingMode=4)
          zoomLevel := 1
    }

    If (dummy="custom")
    {
       IMGresizingMode := 4
       zoomLevel := 1
    }

    friendly := DefineImgSizing()
    showTOOLtip("Rescaling mode:`n" friendly)
    SetTimer, RemoveTooltip, % -msgDisplayTime
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "zoomLevel", "General")
    SetTimer, coreReloadThisPicture, -50
    ; dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

DefineImgSizing() {
   friendly := (IMGresizingMode=1) ? "ADAPT ALL INTO VIEW" : "ADAPT ONLY LARGE IMAGES"
   If (IMGresizingMode=3)
      friendly := "NONE (ORIGINAL SIZE)"
   Else If (IMGresizingMode=4)
      friendly := "CUSTOM ZOOM " Round(zoomLevel * 100) "%"
   If (IMGresizingMode=5)
      friendly := "STRETCHED TO WINDOW"

   Return friendly
}

dummyInfoToggleSlideShowu(actu:=0) {
  Static lastInvoked := 1
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()

  GIFframesPlayied := 0
  r := ToggleSlideShowu(actu)
  If (r="lulz")
     Return

  If (slideShowRunning!=1 || actu="stop")
  {
     userSeenSlideImages := userSeenSessionImagesArray.Count()
     ; userSeenSlideImages := (userSeenSlideImages>maxFilesIndex - 1) ? maxFilesIndex : userSeenSlideImages
     showTOOLtip("Slideshow: STOPPED`nImages seen in this session: " groupDigits(userSeenSlideImages))
     SetTimer, RemoveTooltip, % -msgDisplayTime
     lastInvoked := A_TickCount
  } Else ;  If (A_TickCount - lastInvoked > 450)
  {
     delayu := DefineSlidesRate()
     friendly := DefineSlideShowType()
     etaTime := "Estimated time: " EstimateSlideShowLength()
     showTOOLtip("Started " friendly " slideshow`nSpeed: " delayu "`nTotal files: "  groupDigits(maxFilesIndex) "`n" etaTime)
     SetTimer, RemoveTooltip, % -msgDisplayTime, 900
     If (slideShowDelay < 900)
     {
        Sleep, 550
        RemoveTooltip()
     } Else SetTimer, RemoveTooltip, % -msgDisplayTime, 900
  } ; Else  SetTimer, dummyInfoToggleSlideShowu, Off
  Return
}

InfoToggleSlideShowu() {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 350) && (slideShowRunning!=1) || (maxFilesIndex<3 && StrLen(mustOpenStartFolder)<4)
   {
     lastInvoked := A_TickCount
     Return
   }

   lastInvoked := A_TickCount
   If !(IMGlargerViewPort=1 && IMGresizingMode=4)
      SetTimer, dummyInfoToggleSlideShowu, -80
   Return
}

preventScreenOff() {
  ; if the user is idle ;-)
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 10500) || (slideShowRunning!=1)
     Return

  lastInvoked := A_TickCount
  If (!GetKeyState("Space", "P") && slideShowRunning=1 && WinActive("A")=PVhwnd)
  {
     MouseMove, 2, 0, 2, R
     MouseMove, -2, 0, 2, R
     ; SendEvent, {Up}
  }
}

ToggleSlideShowu(actu:=0) {
  If (maxFilesIndex<3 && slideShowRunning!=1)
  {
     showTOOLtip("WARNING: Insufficient files to start slideshow...")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "lulz"
  }

  If askAboutFileSave(" and the slideshow will begin")
     Return "lulz"
  Else
     terminateIMGediting()

  interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
  interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
  If (slideShowRunning=1 || actu="stop") && (actu!="start")
  {
     slideShowRunning := 0
     ; ResetImgLoadStatus()
     ; SetTimer, theSlideShowCore, Off
     prevSlideShowStop := A_TickCount
     interfaceThread.ahkFunction("slideshowsHandler", 0, "stop", SlideHowMode)
     SetTimer, ResetImgLoadStatus, -150
  } Else If (thumbsDisplaying!=1 || actu="start")
  {
     If (A_TickCount - prevSlideShowStop<500) && (actu!="start")
        Return

     ResetImgLoadStatus()
     interfaceThread.ahkassign("allowNextSlide", 1)
     editingSelectionNow := 0
     updateUIctrl()
     slideShowRunning := 1
     If (hSNDmediaFile && hSNDmediaDuration && hSNDmedia)
        milisec := MCI_Length(hSNDmedia) 

     thisSlideSpeed := (milisec>slideShowDelay) ? milisec : slideShowDelay
     interfaceThread.ahkFunction("slideshowsHandler", thisSlideSpeed, "start", SlideHowMode)
     ; SetTimer, theSlideShowCore, % thisSlideSpeed
  }
  Return
}

theSlideShowCore() {
  If (SlideHowMode=1)
     RandomPicture()
  Else If (SlideHowMode=2)
     PreviousPicture()
  Else If (SlideHowMode=3)
     NextPicture()
  Return
}

GoNextSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoNextSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     RandomPicture()
  Else
     NextPicture()
}

GoPrevSlide() {
  Sleep, 15
  If GetKeyState("LButton")
  {
     SetTimer, GoPrevSlide, -100
     Return
  }

  resetSlideshowTimer(0)
  If (SlideHowMode=1)
     PrevRandyPicture()
  Else
     PreviousPicture()
}

coreSecToHHMMSS(Seco, ByRef Hrs, ByRef Min, ByRef Sec) {
  OldFormat := A_FormatFloat
  SetFormat, Float, 2.00
  Hrs := Seco//3600/1
  Min := Mod(Seco//60, 60)/1
  SetFormat, Float, %OldFormat%
  Sec := Round(Mod(Seco, 60), 2)
}

SecToHHMMSS(Seco) {
  coreSecToHHMMSS(Seco, Hrs, Min, Sec)
  If (hrs>26)
     dayz := Round(hrs/24, 2)
  If (dayz>=1.1)
  {
     If (dayz>32)
        Return "about " Round(dayz/30.5, 2) " months"
     r := dayz " days"
  } Else  r := (Hrs ? Hrs "h " : "") Min "m " Sec "s"

  If (!min && !hrs)
  {
     r := StrReplace(r, "0m ")
     r := Trimmer(r, "0")
  }
  r := StrReplace(r, ".00s", "s")
  If (min || hrs)
     r := RegExReplace(r, "\...s", "s")
  r := StrReplace(r, " 0s")
  r := StrReplace(r, "  ", A_Space)
  r := Trimmer(r)

  Return r
}

DefineSlideShowType() {
   friendly := (SlideHowMode=1) ? "RANDOM" : "BACKWARD"
   If (SlideHowMode=3)
      friendly := "FORWARD"
   Return friendly
}

SwitchSlideModes() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
      Return

   lastInvoked := A_TickCount
   SlideHowMode++
   If (SlideHowMode>3)
      SlideHowMode := 1

   resetSlideshowTimer(0, 1)
   friendly := DefineSlideShowType() "`nCurrently "
   friendly .= (slideShowRunning=1) ? "running" : "stopped"
   showTOOLtip("Slideshow mode: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "SlideHowMode", "General")
}

DefineFXmodes() {
   Static FXmodesLabels := {1:"ORIGINAL", 2:"PERSONALIZED", 3:"AUTO-ADJUSTED", 4:"GRAYSCALE", 5:"RED CHANNEL", 6:"GREEN CHANNEL", 7:"BLUE CHANNEL", 8:"ALPHA CHANNEL", 9:"INVERTED COLORS", 10:"SEPIA"}
        , otherFXLabels := {1:"ADAPTIVE", 2:"BRIGHTNESS", 3:"CONTRAST"}

   If FXmodesLabels.HasKey(imgFxMode)
      friendly := FXmodesLabels[imgFxMode]
   Else
      friendly := "Colors FX: " imgFxMode
   If (imgFxMode=3)
      friendly .= A_Space otherFXLabels[autoAdjustMode]

   If (bwDithering=1 && imgFxMode=4)
      friendly := "BLACK/WHITE DITHERED"

   If (imgFxMode=1 && isInRange(usrColorDepth, 2, 10))
      friendly := "ALTERED COLOR DEPTH"

   If (imgFxMode=1 && RenderOpaqueIMG=1 && currIMGdetails.HasAlpha=1)
      friendly .= "`nAlpha channel: REMOVED"

   Return friendly
}

ToggleImgColorDepth(dir:=0) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbnailsListMode=1)
       Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   If (imgFxMode=4 && bwDithering=1)
   {
      imgFxMode := 1
      Return
   }

   good2go := (imgFxMode=1 || imgFxMode=2 || imgFxMode=3 || imgFxMode=8) ? 1 : 0
   If (good2go!=1)
      imgFxMode := 1

   If (dir=1)
      usrColorDepth--
   Else
      usrColorDepth++

   usrColorDepth := clampInRange(usrColorDepth, 1, 9, 1)
   ForceRefreshNowThumbsList()
   infoColorDepth := (usrColorDepth>1) ? defineColorDepth() : "NONE"
   showTOOLtip("Image color depth simulated: " infoColorDepth, 0, 0, usrColorDepth/9)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "usrColorDepth", "General")
   INIaction(1, "imgFxMode", "General")
   SetTimer, RefreshImageFile, -50

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, usrColorDepth, % usrColorDepth
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineColorDepth() {
   Static bitsOptions := {0:0, 1:0, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:16}

   internalColorDepth := bitsOptions[usrColorDepth]
   r := internalColorDepth " bits [" 2**internalColorDepth " colors]"
   If (r<1)
      r := currIMGdetails.PixelFormat
   Else If (ColorDepthDithering=1)
      r .= " | DITHERED"

   Return r
}

ToggleImgFX(dir:=0) {
   Static lastInvoked := 1, moreFX := {1:"None", 2:"Blur", 3:"Sharpen", 4:"Brightness / Contrast", 5:"Hue / Saturation / Lightness", 6:"Levels adjust [High / Mid / Low]", 7:"Color tint [Hue / Amount]", 8:"Colors balance", 9:"Color curve per channel"}
        , curvesFX := {1:"Brightness (density)", 2:"Contrast", 3:"Highlights", 4:"Shadows", 5:"Midtones", 6:"White saturation", 7:"Black saturation"}
        , curvesChannels := {1:"Red", 2:"Green", 3:"Blue", 4:"All"}

   If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=1)
      imgFxMode--
   Else
      imgFxMode++

   prevColorAdjustZeit := A_TickCount
   If (imgFxMode=3 && thumbsDisplaying=1)
   {
      If (dir=1)
         imgFxMode--
      Else
         imgFxMode++
   }

   imgFxMode := clampInRange(imgFxMode, 1, 10, 1)
   friendly := DefineFXmodes()
   If (imgFxMode=4)
      friendly .= "`nBrightness: " Round(lumosGrayAdjust, 3) "`nContrast: " Round(GammosGrayAdjust, 3)
   Else If (imgFxMode=2)
      friendly .= "`nBrightness: " Round(lumosAdjust, 3) "`nContrast: " Round(GammosAdjust, 3) "`nSaturation: " Round(satAdjust*100) "%"

   If (imgFxMode=2 || imgFxMode=4 || imgFxMode=9)
      friendly .= "`nGamma: " Round(realGammos, 3)

   If (specialColorFXmode>1) && (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9)
   {
      friendly .= "`n" moreFX[specialColorFXmode]
      If (specialColorFXmode=9)
         friendly .= " [" curvesFX[uiColorCurveFXmode] "]: "  Round(lummyAdjust) " - " curvesChannels[uiColorCurveFXchannel]
      Else
         friendly .= ":`n" Round(hueAdjust) " / " Round(zatAdjust) " / " Round(lummyAdjust)
   }

   If (usrColorDepth>1 && imgFxMode=1)
      friendly .= "`nSimulated color depth: " defineColorDepth()

   If (imgFxMode=4 || imgFxMode=3 || imgFxMode=2)
      friendly .= "`n `nPress U to adjust colors display options."
   showTOOLtip("Image colors: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ForceRefreshNowThumbsList()

   If (imgFxMode=3 && thumbsDisplaying!=1)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
   }

   INIaction(1, "imgFxMode", "General")
   If (o_bwDithering=0)
      o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0

   If (o_bwDithering=1 && thumbsDisplaying!=1)
      RefreshImageFile()
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, imgFxMode, % imgFxMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

defineImgAlign() {
   modes := {1:"Top-left corner", 2:"Top-center", 3:"Top-right corner", 4:"Left-center", 5:"Center", 6:"Right-center", 7:"Bottom-left corner", 8:"Bottom-center", 9:"Bottom-right corner"}
   ; thisAlign := (IMGresizingMode=4) ? 5 : imageAligned
   r := modes[imageAligned]
   StringUpper, r, r
   Return r
}

ToggleIMGalign() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(1, 1)
   imageAligned := (imageAligned=5) ? 1 : 5
   ; imageAligned++
   ; If (imageAligned>9)
   ;    imageAligned := 1

   showTOOLtip("Image alignment: " defineImgAlign())
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "imageAligned", "General")
   dummyTimerReloadThisPicture(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

toggleColorAdjustments(noReturn:=0) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

  lastInvoked := A_TickCount
  If (imgFxMode!=1 && thumbsDisplaying!=1)
  {
     prevColorAdjustZeit := A_TickCount
     resetSlideshowTimer(0)
     ForceNoColorMatrix := !ForceNoColorMatrix
     If (noReturn=0)
        AnyWindowOpen := (ForceNoColorMatrix=1) ? 10 : 0
     dummyTimerDelayiedImageDisplay(50)
     If (noReturn=0)
     {
        AnyWindowOpen := 10
        SetTimer, resetClrMatrix, -1500
     }
  }
}

resetClrMatrix() {
   resetSlideshowTimer(0)
   AnyWindowOpen := ForceNoColorMatrix := 0
   dummyTimerDelayiedImageDisplay(50)
}

ResetImageView() {
   Critical, on
   imgPath := getIDimage(currentFileIndex)
   If (!useGdiBitmap() && !CurrentSLD) || !imgPath
   {
      showTOOLtip("WARNING: No image file is currently loaded reset view for...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   ChangeLumos(2)
}

HardResetImageView() {
   Critical, on
   DestroyTempBtnGui("now")
   If (!useGdiBitmap() && !CurrentSLD)
      Return

   ChangeLumos(2, "k")
}

coreResetIMGview(dummy:=0) {
  If (imgFxMode=4 && lumosGrayAdjust=1 && GammosGrayAdjust=0)
     mustResetFxMode := 1

  If (dummy="k")
  {
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0
     imgThreshold := bwDithering := hueAdjust := zatAdjust := lummyAdjust := 0
     specialColorFXmode := 1
  }

  If (imgFxMode=4)
  {
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
  } Else If (imgFxMode=2)
  {
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || dummy="k")
     chnRdecalage := chnGdecalage := chnBdecalage := 0.0

  realGammos := 1
  If (imgFxMode=1 || dummy="k")
  {
     zoomLevel := 1
     FlipImgH := FlipImgV := 0
     If (thumbsDisplaying!=1)
       vpIMGrotation := 0
  }

  If (dummy="k")
  {
     ; bwDithering := 0
     GammosGrayAdjust := 0
     lumosGrayAdjust := 1
     satAdjust := lumosAdjust := 1
     GammosAdjust := 0
     vpIMGrotation := 0
  }

  If (imgFxMode=2 || imgFxMode=3 || imgFxMode>4 || mustResetFxMode=1)
     imgFxMode := 1

  If (thumbsDisplaying=1)
  {
     thumbsZoomLevel := 1
     thumbsH := othumbsH + 1
     thumbsW := othumbsW + 1
     ForceRefreshNowThumbsList()
  }

  If (dummy="k")
     usrColorDepth := internalColorDepth := 1
}

ChangeLumos(dir, dummy:=0) {
   Static prevValues, lastInvoked := 1

   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode!=2 && imgFxMode!=4 && dir!=2)
      imgFxMode := 2

   showHardReset := 0
   If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1 || RenderOpaqueIMG=1)
      showHardReset := 1

   prevColorAdjustZeit := A_TickCount
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (dir=2)
   {
      coreResetIMGview(dummy)
      SetTimer, WriteSettingsColorAdjustments, -95
   } Else If (imgFxMode=4)
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosGrayAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosGrayAdjust += stepu
      Else
         lumosGrayAdjust -= stepu

      lumosGrayAdjust := clampInRange(lumosGrayAdjust, 0.001, 25)
   } Else
   {
      stepu := (A_tickcount - lastInvoked<300) && (lumosAdjust>2) ? 0.08 : 0.04
      If (dir=1)
         lumosAdjust += stepu
      Else
         lumosAdjust -= stepu

      lumosAdjust := clampInRange(lumosAdjust, 0.001, 25)
   }

   value2show := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   If (dir=2)
   {
      If (imgFxMode=4)
         addMsg := DefineFXmodes()
      If (imgFxMode=1 && RenderOpaqueIMG=1 && currIMGdetails.HasAlpha=1)
         addMsg .= "`nAlpha channel: REMOVED"
      If (imgFxMode=1 && usrColorDepth>1)
         addMsg .= "`nImage color depth: ALTERED [ " defineColorDepth() " ]"
      If (vpIMGrotation>0)
         addMsg .= "`nImage rotated: " vpIMGrotation "° degrees."
      If (thisIMGisDownScaled=1)
         addMsg .= "`nImage dimensions DOWNSCALED to screen resolution."

      addMsg .= defineIMGmirroring()
      If (dummy!="k" && showHardReset=1)
      {
         addMore := "`nReset all adjustments to defaults with Ctrl + \"
         CreateGuiButton("Reset all adjustments,,HardResetImageView", 0, msgDisplayTime//1.5 + 100)
      }
      showTOOLtip("Image display: UNALTERED " addMsg addMore)
   } Else showTOOLtip("Image brightness: " value2show, 0, 0, value2show / 25)

   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues && dir!=2)
      Return

   If (dir!=2)
      SetTimer, dummySaveLumGammos, -70

   prevValues := newValues
   If (o_bwDithering=1 || otherFX=1) ; && (thumbsDisplaying!=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

WriteSettingsColorAdjustments() {
    INIaction(1, "userimgQuality", "General")
    INIaction(1, "histogramMode", "General")
    INIaction(1, "usrTextureBGR", "General")
    INIaction(1, "autoAdjustMode", "General")
    INIaction(1, "doSatAdjusts", "General")
    INIaction(1, "usrAdaptiveThreshold", "General")
    INIaction(1, "showHistogram", "General")
    INIaction(1, "IMGresizingMode", "General")
    INIaction(1, "imgThreshold", "General")
    INIaction(1, "bwDithering", "General")
    INIaction(1, "usrColorDepth", "General")
    INIaction(1, "ColorDepthDithering", "General")
    INIaction(1, "imgFxMode", "General")
    INIaction(1, "chnBdecalage", "General")
    INIaction(1, "chnGdecalage", "General")
    INIaction(1, "chnRdecalage", "General")
    INIaction(1, "FlipImgH", "General")
    INIaction(1, "FlipImgV", "General")
    INIaction(1, "GammosAdjust", "General")
    INIaction(1, "GammosGrayAdjust", "General")
    INIaction(1, "hueAdjust", "General")
    INIaction(1, "lumosAdjust", "General")
    INIaction(1, "lumosGrayAdjust", "General")
    INIaction(1, "realGammos", "General")
    INIaction(1, "RenderOpaqueIMG", "General")
    INIaction(1, "satAdjust", "General")
    INIaction(1, "vpIMGrotation", "General")
    INIaction(1, "zatAdjust", "General")
    INIaction(1, "lummyAdjust", "General")
    INIaction(1, "zoomLevel", "General")
    INIaction(1, "specialColorFXmode", "General")
    INIaction(1, "uiColorCurveFXmode", "General")
    INIaction(1, "uiColorCurveFXchannel", "General")
}

defineIMGmirroring() {
    If (FlipImgH=1 || FlipImgV=1)
    {
       infoMirroring := "`nImage mirroring: "
       If (FlipImgV=1 && FlipImgH=0)
          infoMirroring :=  infoMirroring "VERTICAL"
       Else If (FlipImgV=0 && FlipImgH=1)
          infoMirroring := infoMirroring "HORIZONTAL"
       Else If (FlipImgV=1 && FlipImgH=1)
          infoMirroring := infoMirroring "VERTICAL, HORIZONTAL"
    }
    Return infoMirroring
}

ChangeZoom(dir, key:=0, stepFactor:=1) {
   Static prevValues, lastInvoked := 1, lastInvoked2 := 1

   If InStr(key, "wheel")
   {
      MouseGetPos, , , OutputVarWin
      If (OutputVarWin!=PVhwnd)
         Return
   }

   resetSlideshowTimer(0)
   If (thumbsDisplaying=1)
   {
      If (thumbnailsListMode=1)
      {
         changeOSDfontSize(dir)
         Return
      }

      If (dynamicThumbsColumns=1)
      {
         If (dir=1)
            thumbsZoomLevel += 0.1
         Else
            thumbsZoomLevel -= 0.1
      } Else
      {
         If (dir=1)
            thumbsColumns += 1
         Else
            thumbsColumns -= 1
      }

      thumbsZoomLevel := clampInRange(thumbsZoomLevel, 0.35, 3)
      thumbsColumns := clampInRange(thumbsColumns, 2, 100)
      ForceRefreshNowThumbsList()
      recalculateThumbsSizes()
      ; setTexHatchScale(thumbsZoomLevel/2)
      If (thumbnailsListMode=1)
         ForceRefreshNowThumbsList()
      INIaction(1, "thumbsZoomLevel", "General")
      INIaction(1, "thumbsColumns", "General")
      INIaction(1, "dynamicThumbsColumns", "General")
      If (dynamicThumbsColumns=1)
         showTOOLtip("Thumbnails zoom level: " Round(thumbsZoomLevel*100) "%`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", 0, 0, thumbsZoomLevel/3)
      Else
         showTOOLtip("Thumbnails columns: " thumbsColumns "`nDisplay size: " thumbsW " x " thumbsH " px`nThumbnails caching at: " thumbsSizeQuality " px", 0, 0, thumbsColumns/100)
      SetTimer, RemoveTooltip, % -msgDisplayTime
      dummyTimerDelayiedImageDisplay(95)
      Return
   }

   oldZoomLevel := zoomLevel
   If (zoomLevel>5)
      changeFactor := 0.50
   Else If (zoomLevel>1)
      changeFactor := 0.15
   Else If (zoomLevel<0.01)
      changeFactor := 0.005
   Else If (zoomLevel<=0.1)
      changeFactor := 0.01
   Else
      changeFactor := 0.05

   If (dir=1)
      zoomLevel += changeFactor * stepFactor
   Else
      zoomLevel -= changeFactor * stepFactor

   o_IMGresizingMode := IMGresizingMode
   IMGresizingMode := 4
   ; imageAligned := 5
   zoomLevel := clampInRange(zoomLevel, 0.01, 20)
   prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)

   If (zoomLevel>3 && thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
   {
      imgPath := getIDimage(currentFileIndex)
      op := GetImgFileDimension(imgPath, Wi, He)
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      xu := (imgW*zoomLevel)/Wi
      hasThisChangedYo := 1
      zoomLevel := xu
      AutoDownScaleIMGs := 2
   }

   MouseGetPos, , , OutputVarWin
   If (OutputVarWin=PVhwnd && InStr(key, "wheel"))
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      prcW := mX/mainWidth
      prcH := mY/mainHeight

      prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
      prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      decX := Round(((imgW)*prcW) * zoomLevel)
      decY := Round(((imgH)*prcH) * zoomLevel)
      prcW := mX/mainWidth
      prcH := mY/mainHeight
      If (prcW>0.5 || imageAligned=1)
         decX := -decX
      If (prcH>0.5 || imageAligned=1)
         decY := -decY

      IMGdecalageX := IMGdecalageX + decX//35
      IMGdecalageY := IMGdecalageY + decY//35
   }

   ; tooltip, % IMGdecalageX " -- " IMGdecalageY "`n" decX " -- " decY "`n"prcW " -- " prcH
   ; setTexHatchScale(zoomLevel)
   If (A_TickCount - lastInvoked2<150)
   {
      zeitSillyPrevent := A_TickCount
      SetTimer, dummyZoomInfo, -80
   } Else
   {
      dummyZoomInfo()
      lastInvoked2 := A_TickCount
   }

   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")

   newValues := "a" zoomLevel thumbsZoomLevel IMGresizingMode imageAligned getIDimage(currentFileIndex)
   If (prevValues=newValues && hasThisChangedYo!=1)
      Return

   prevValues := newValues
   If (drawModeBzeit>150 && (A_TickCount - lastInvoked < 10) && (LastPrevFastDisplay!=1)) || (hasThisChangedYo=1)
      GdipCleanMain(6)

   lastInvoked := A_TickCount
   If (AutoDownScaleIMGs=2 && hasThisChangedYo=1)
      SetTimer, RefreshImageFileAction, -150
   Else If (o_IMGresizingMode=1 && enableThumbsCaching=1) || (LastPrevFastDisplay=1)
      SetTimer, coreReloadThisPicture, -10
   Else
      dummyTimerDelayiedImageDisplay(10)
}

dummyZoomInfo() {
   If (thisIMGisDownScaled=1)
      friendly := "`nThe image is downscaled.`nPress F5 or increase zoom above 300%`nto load the original file."

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA: Choose, IMGresizingMode, % IMGresizingMode
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }

   showTOOLtip("Zoom level: " Round(zoomLevel*100) "%" friendly, 0, 0, zoomLevel/20)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   ; SetTimer, ResetImgLoadStatus, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

setTexHatchScale(zL, forceIT:=0) {
   Static prevScaleTex
   If !pBrushHatch
      Return

   If (currIMGdetails.HasAlpha!=1 || userimgQuality=0)
      Return

   ScaleTex := (zL>1) ? zL/2 + 0.5 : zL
   If (ScaleTex<0.50)
      ScaleTex := 0.50
   If (prevScaleTex!=ScaleTex || forceIT=1)
   {
      Gdip_ResetTextureTransform(pBrushHatch)
      Gdip_ScaleTextureTransform(pBrushHatch, ScaleTex, ScaleTex)
      prevScaleTex := ScaleTex
   }
}

ChangeGammos(dir) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode!=2 && imgFxMode!=4)
      imgFxMode := 2

   value2Adjust := (imgFxMode=4) ? GammosGrayAdjust : GammosAdjust
   value2AdjustB := (imgFxMode=4) ? lumosGrayAdjust : lumosAdjust
   stepu := (A_tickcount - lastInvoked<300) && (value2Adjust<-2) ? 0.06 : 0.03
   If (dir=1)
   {
      value2Adjust += stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB -= stepu
   } Else
   {
      value2Adjust -= stepu
      If isInRange(value2Adjust, -24, 0.9)
         value2AdjustB += stepu
   }

   value2Adjust := clampInRange(value2Adjust, -25, 1)
   value2AdjustB := clampInRange(value2AdjustB, 0.001, 25)
   If (imgFxMode=4)
   {
      GammosGrayAdjust := value2Adjust
      lumosGrayAdjust := value2AdjustB
   } Else
   {
      GammosAdjust := value2Adjust
      lumosAdjust := value2AdjustB
   }

   prevColorAdjustZeit := A_TickCount
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image contrast: " Round(value2Adjust, 3), 0, 0, Abs(value2Adjust - 1)/26)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
   newValues := "a" GammosGrayAdjust lumosGrayAdjust GammosAdjust lumosAdjust imgFxMode
   If (prevValues=newValues)
      Return

   SetTimer, dummySaveLumGammos, -70
   prevValues := newValues
   If (o_bwDithering=1)
      SetTimer, RefreshImageFile, -50
   Else
      dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

dummySaveLumGammos() {
   INIaction(1, "GammosAdjust", "General")
   INIaction(1, "GammosGrayAdjust", "General")
   INIaction(1, "lumosAdjust", "General")
   INIaction(1, "lumosGrayAdjust", "General")
   INIaction(1, "imgFxMode", "General")
   INIaction(1, "IMGresizingMode", "General")
   If (IMGresizingMode=4)
      INIaction(1, "zoomLevel", "General")
}

ChangeSaturation(dir) {
   Static prevValues

      If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   If (imgFxMode=4)
      satAdjust := 0

   imgFxMode := 2
   prevColorAdjustZeit := A_TickCount
   value2Adjust := satAdjust
   If (dir=1)
      value2Adjust += 0.05
   Else
      value2Adjust -= 0.05

   value2Adjust := clampInRange(value2Adjust, 0, 3)
   satAdjust := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image saturation: " Round(value2Adjust*100) "%", 0, 0, value2Adjust/3)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" satAdjust imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "satAdjust", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeRealGamma(dir) {
   Static prevValues

   If (thumbsDisplaying=1 && thumbnailsListMode=1)
      Return

   resetSlideshowTimer(0)
   prevColorAdjustZeit := A_TickCount
   imgFxMode := 2
   value2Adjust := realGammos
   If (value2Adjust>2)
      stepu := 0.2
   Else If (value2Adjust<0.1)
      stepu := 0.01
   Else
      stepu := 0.05

   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0.01, 8)
   realGammos := value2Adjust
   ; If (thumbsDisplaying!=1)
      ForceRefreshNowThumbsList()
   showTOOLtip("Image gamma: " Round(value2Adjust*100) "%", 0, 0, value2Adjust/8)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   newValues := "a" realGammos imgFxMode
   If (prevValues=newValues)
      Return

   INIaction(1, "realGammos", "General")
   prevValues := newValues
   dummyTimerDelayiedImageDisplay(10)

   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

ChangeVolume(dir) {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   If (thumbsDisplaying=1)
      Return

   resetSlideshowTimer(0, 1)
   value2Adjust := mediaSNDvolume
   If (dir=1)
      value2Adjust += 5
   Else
      value2Adjust -= 5

   value2Adjust := clampInRange(value2Adjust, 1, 100)
   If !hSNDmedia
      infoMedia := "`nNo audio is currently playing..."

   mediaSNDvolume := value2Adjust
   INIaction(1, "mediaSNDvolume", "General")
   SetVolume(mediaSNDvolume)
   showTOOLtip("Audio volume: " value2Adjust "%" infoMedia, 0, 0, value2Adjust/100)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

MenuChangeImgRotationInVP() {
   changeImgRotationInVP(1, 45)
}

changeSelRotation(dir) {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   value2Adjust := vPselRotation
   If (dir=1)
      value2Adjust += 2
   Else
      value2Adjust -= 2

   value2Adjust := clampInRange(value2Adjust, 0, 360 - 2, 1)
   vPselRotation := value2Adjust
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

changeImgRotationInVP(dir, stepu:=15) {
   If (thumbsDisplaying=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   If StrLen(whichBitmap)>3
   {
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
      Gdip_GetRotatedDimensions(imgW, imgH, 45, ResizedW, ResizedH)
      If ((ResizedW*ResizedH>maxGDIbmpSize) || (ResizedW>32500) || (ResizedH>32500)) && (vpIMGrotation=0)
      {
         vpIMGrotation := 0
         SoundBeep, 300, 100
         showTOOLtip("ERROR: The document dimensions exceed the maximum limits...`nThe image cannot be rotated.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   } Else Return

   resetSlideshowTimer(0)
   value2Adjust := vpIMGrotation
   If (dir=1)
      value2Adjust += stepu
   Else
      value2Adjust -= stepu

   value2Adjust := clampInRange(value2Adjust, 0, 360 - stepu, 1)
   vpIMGrotation := value2Adjust
   SetTimer, dummyChangeVProtation, -10
   SetTimer, RefreshImageFile, -750
}

dummyChangeVProtation() {
   showTOOLtip("Image rotation: " vpIMGrotation "° ", 0, 0, vpIMGrotation/360)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "vpIMGrotation", "General")
   GdipCleanMain(4)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, vpIMGrotation, % vpIMGrotation
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

nextDesiredFrame() {
    changeDesiredFrame(1)
}

prevDesiredFrame() {
    changeDesiredFrame(-1)
}

changeDesiredFrame(dir:=1) {
   Static prevValues, lastInvoked := 1
   If (thumbsDisplaying=1 || !totalFramesIndex)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the current image frame will be changed")
      Return

   DestroyGIFuWin()
   resetSlideshowTimer(0)
   value2Adjust := desiredFrameIndex
   If (dir=1)
      value2Adjust++
   Else
      value2Adjust--

   If (dir=-1 && value2Adjust<1)
      value2Adjust := 0

   value2Adjust := clampInRange(value2Adjust, 0, totalFramesIndex, 1)
   desiredFrameIndex := value2Adjust
   If (A_TickCount - lastInvoked > 350) || (dir=-1)
   {
      showCurrentFrameIndex()
      lastInvoked := A_TickCount
   } Else SetTimer, showCurrentFrameIndex, -400

   newValues := value2Adjust currentFileIndex
   If (prevValues!=newValues)
   {
      SetTimer, RefreshImageFile, % (dir=-1) ? -95 : -5
      prevValues := newValues
   }
}

autoChangeDesiredFrame(act:=0, imgPath:=0) {
   Critical, on
   Static prevImgPath, lastInvoked := 1, lastFrameChange := 1
   If (thumbsDisplaying=1 || act="stop" || AnyWindowOpen || animGIFsSupport!=1 || !maxFilesIndex || !CurrentSLD)
   {
      If (animGIFplaying=1)
      {
         SetTimer, autoChangeDesiredFrame, Off
         SetTimer, ResetImgLoadStatus, -10
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         Global lastGIFdestroy := A_TickCount
         lastFrameChange := A_TickCount
         animGIFplaying := 0
         ; lastInvoked := A_TickCount
         interfaceThread.ahkassign("animGIFplaying", 0)
         ; dummyTimerDelayiedImageDisplay(50)
      }
      Return
   }

   If (prevImgPath!=imgPath && StrLen(imgPath)>2)
      lastInvoked := A_TickCount

   If (act="start" && imgPath && prevImgPath!=imgPath)
   {
      SetTimer, ResetImgLoadStatus, -15
      lastFrameChange := A_TickCount
      prevImgPath := imgPath
      allowNextSlide := 0
      animGIFplaying := 1
      interfaceThread.ahkassign("animGIFplaying", 1)
      interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
      Return
   } Else
   {
      Sleep, -1
      animGIFplaying := interfaceThread.ahkgetvar.animGIFplaying
      If !animGIFplaying
      {
         SetTimer, ResetImgLoadStatus, -10
         SetTimer, autoChangeDesiredFrame, Off
         animGIFplaying := 0
         allowNextSlide := 1
         interfaceThread.ahkassign("animGIFplaying", 0)
         interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
         prevAnimGIFwas := prevImgPath
         prevImgPath := ""
         lastFrameChange := A_TickCount
         Global lastGIFdestroy := A_TickCount
         Return
      }
   }

   allowNextSlide := 0
   desiredFrameIndex++
   GIFframesPlayied++
   If (allowGIFsPlayEntirely=1 && GIFframesPlayied>totalFramesIndex-1) || (totalFramesIndex<3) || (allowGIFsPlayEntirely!=1)
      allowNextSlide := 1
   ; ToolTip, % allowGIFsPlayEntirely "--" allowNextSlide , , , 2
   desiredFrameIndex := clampInRange(desiredFrameIndex, 0, totalFramesIndex, 1)
   prevAnimGIFwas := ""
   totalZeit := A_TickCount - startZeitIMGload
   thisFrameDelay := (totalZeit>25 && totalFramesIndex>20) ? GIFspeedDelay//2 : GIFspeedDelay
   If (totalZeit>70 && totalFramesIndex>15) || (totalZeit>25 && totalFramesIndex>180)
      thisFrameDelay := 10
   If (thisFrameDelay<12 && totalZeit<40 && totalFramesIndex<14)
      thisFrameDelay := 11
   If (totalZeit>100 && totalFramesIndex>95)
      thisFrameDelay := 1

   If (slideShowRunning=1 && (A_TickCount - lastInvoked>slideShowDelay + 1) && allowNextSlide=1)
   {
      ; allowNextSlide := 0
      lastInvoked := A_TickCount
      prevImgPath := ""
      interfaceThread.ahkPostFunction("theSlideShowCore", "force")
      ; theSlideShowCore()
      invokeExternalSlideshowHandler()
   } Else If (A_TickCount - lastFrameChange > thisFrameDelay)
   {
      lastFrameChange := A_TickCount
      SetTimer, RefreshImageFile, -1
   }
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
}

showCurrentFrameIndex() {
    showTOOLtip("Image frame index: " desiredFrameIndex " / " totalFramesIndex, 0, 0, desiredFrameIndex/totalFramesIndex)
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

TransformIMGv() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgV := !FlipImgV
   friendly := (FlipImgV=1) ? "ON" : "off"
   showTOOLtip("Vertical mirroring: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgV", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgV, % FlipImgV
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

setMainCanvasTransform(W, H, G:=0, forceH:=0, forceV:=0) {
    If (thumbsDisplaying=1)
       Return

    If !G
       G := glPG

    If (FlipImgH=1 && forceH=0) || (forceH=1)
    {
       Gdip_ScaleWorldTransform(G, -1, 1)
       Gdip_TranslateWorldTransform(G, -W, 0)
    }

    If (FlipImgV=1 && forceV=0) || (forceV=1)
    {
       Gdip_ScaleWorldTransform(G, 1, -1)
       Gdip_TranslateWorldTransform(G, 0, -H)
    }
}

TransformIMGh() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 50)
      Return

   lastInvoked := A_TickCount
   resetSlideshowTimer(0)
   ForceRefreshNowThumbsList()
   FlipImgH := !FlipImgH
   friendly := (FlipImgH=1) ? "ON" : "off"
   showTOOLtip("Horizontal mirroring: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   INIaction(1, "FlipImgH", "General")
   dummyTimerDelayiedImageDisplay(50)
   If (AnyWindowOpen=10 && imgEditPanelOpened=1)
   {
      GuiControl, SettingsGUIA:, FlipImgH, % FlipImgH
      updatePanelColorsInfo()
      updatePanelColorSliderz()
   }
}

doOpenStartFolder() {
   If StrLen(mustOpenStartFolder)>3
   {
      If askAboutFileSave(" and files found in " mustOpenStartFolder "\ will be indexed")
         Return currentFileIndex

      SLDtypeLoaded := 1
      imgPath := getIDimage(currentFileIndex)
      coreOpenFolder("|" mustOpenStartFolder, 0)
      If FileRexists(imgPath)
         startIndex := detectFileID(imgPath)
   } Else startIndex := currentFileIndex
   Return startIndex
}

coreNextPrevImage(direction, startIndex, randomMode) {
   Static countSeen, prevStatus
   If (thumbsDisplaying!=1 && maxFilesIndex>1)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return currentFileIndex
   }

   If StrLen(mustOpenStartFolder)>3
      startIndex := currentFileIndex := doOpenStartFolder()

   thisState := "a" maxFilesIndex CurrentSLD SLDtypeLoaded
   If (thisState!=prevStatus || countSeen>maxFilesIndex)
      countSeen := 0

   prevStatus := thisState
   If (startIndex>=maxFilesIndex && direction=1 && thumbsDisplaying=1 && randomMode!=1)
      Return maxFilesIndex
   Else If (startIndex<2 && direction=-1 && thumbsDisplaying=1 && randomMode!=1)
      Return 1

   startZeit := A_TickCount
   If (startIndex=1 && direction=-1)
      startIndex := maxFilesIndex + 1
   Else If (startIndex=maxFilesIndex && direction=1)
      startIndex := 0

   delayu := (slideShowDelay>3500) ? Round(slideShowDelay*0.25) : Round(slideShowDelay*0.5)
   ; canResetSeen := 0
   Loop, % maxFilesIndex + 1
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        If (thisIndex>maxFilesIndex)
           thisIndex -= maxFilesIndex
        Else If (thisIndex<1)
           thisIndex := startIndex + Abs(thisIndex)

        newIndex := thisIndex
        If (randomMode=1)
        {
           z := RandyIMGids[thisIndex]
           r := getIDimage(z)
        } Else r := getIDimage(thisIndex)
        If !r
           Continue

        If (A_TickCount - startZeit>delayu)
           Break

        r := StrReplace(r, "||")
        If (skipSeenImagesSlider=1 && slideShowRunning=1 && allImagesWereSeen!=1)
        {
           If retrieveSeenImageDBentry(r, thisIndex)
           {
              countSeen++
              Continue
           }
        }

        ignoreFileCheck := (InStr(AprevImgCall, r) || InStr(BprevImgCall, r)) ? 1 : 0
        If (skipDeadFiles=1 && thumbsDisplaying!=1 && ignoreFileCheck!=1)
        {
           If !FileRexists(r)
              Continue
           Else
              Break
        } Else Break
   }

   ; ToolTip, % thisIndex "==" countSeen "==" delayu , , , 2
   If newIndex
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)

   If (countSeen >= maxFilesIndex - 1) || (!newIndex) ; || (allImagesWereSeen=1)
   {
      allImagesWereSeen := 1
      newIndex := (direction=-1) ? startIndex - 1 : startIndex + 1
      newIndex := clampInRange(newIndex, 1, maxFilesIndex, 1)
   }

   If (randomMode=1)
   {
      RandyIMGnow := newIndex
      newIndex := RandyIMGids[RandyIMGnow]
      if (newIndex>maxFilesIndex)
      {
         Random, thisIndex, 1, % maxFilesIndex
         RandyIMGids[RandyIMGnow] := thisIndex
         newIndex := thisIndex
      }
   }
   Return newIndex
}

PreviousPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && thumbsDisplaying!=1 && slideShowRunning!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(-1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Left", "+Left", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

NextPicture(dummy:=0, inLoop:=0, selForbidden:=0) {
   If (StrLen(UserMemBMP)>2 && editingSelectionNow=1 && InStr(dummy, "key-wheel"))
      Return

   If (InStr(dummy, "key-") && slideShowRunning=1 && easySlideStoppage=1)
      ToggleSlideShowu()

   prevFileIndex := currentFileIndex
   If (GetKeyState("Shift", "P") && slideShowRunning!=1 && thumbsDisplaying!=1 && selForbidden!=1)
      shiftPressed := 1

   currentFileIndex := coreNextPrevImage(1, prevFileIndex, 0)
   If (shiftPressed=1)
      thumbsSelector("Right", "+Right", prevFileIndex)

   dummyTimerDelayiedImageDisplay(10)
}

Fnt_GetMultilineStringSizeDT(hFont, p_String, NoWrap, l_Width, ByRef r_Width, ByRef r_Height) {
    Static Dummy64026703
          ,DEFAULT_GUI_FONT:=17
          ,HWND_DESKTOP    :=0
          ,OBJ_FONT        :=6
          ,SIZE

          ;-- DrawText format
          ,DT_NOCLIP:=0x100
                ;-- Draws without clipping.  DrawText is somewhat faster when
                ;   DT_NOCLIP is used.

          ,DT_CALCRECT:=0x400
                ;-- Determines the width and height of the rectangle.  The text
                ;   is not drawn.

          ,DT_NOPREFIX:=0x800
                ;-- Turns off processing of prefix characters.

          ,DT_WORDBREAK:=0x10

    If (NoWrap=1)
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX
    Else
       s_DTFormat:=DT_NOCLIP|DT_CALCRECT|DT_NOPREFIX|DT_WORDBREAK

    r_Width := r_Height := 0
    ;-- If needed, get the handle to the default GUI font
    if (Gdi_GetObjectType(hFont)!="FONT")
       hFont := Gdi_GetStockObject(DEFAULT_GUI_FONT)

    ;-- Select the font into the device context for the desktop
    hDC      := Gdi_GetDC(HWND_DESKTOP)
    old_hFont:= Gdi_SelectObject(hDC, hFont)
    If !l_Width
       l_Width := 0

    ;-- Calculate the size of the string
    VarSetCapacity(RECT,16,0)
    NumPut(l_Width,RECT,8,"Int")                       ;-- right
    ; Gdi_SetTextCharSpacing(hDC, TextInAreaCharSpacing)
    E := DllCall("DrawText"
        ,"Ptr",hDC                                      ;-- hdc [in]
        ,"Str",p_String                                 ;-- lpchText [in, out]
        ,"Int",StrLen(p_String)                         ;-- cchText [in]
        ,"Ptr",&RECT                                    ;-- lprc [in, out]
        ,"UInt",s_DTFormat)                             ;-- uFormat [in]

    ;-- Release the objects needed by the DrawText function
    Gdi_SelectObject(hDC, old_hFont)
        ;-- Necessary to avoid memory leak

    Gdi_ReleaseDC(hDC, HWND_DESKTOP)
    r_Width := NumGet(RECT,8,"Int")
    r_Height := NumGet(RECT,12,"Int")
    Return E
}

drawTextInBox(theString, fntName, theFntSize, maxW, maxH, txtColor, bgrColor, NoWrap, flippable:=0, thisTextAlign:=0, BGRopacity:="0xDD") {
    startZeit := A_TickCount
    ; pBr0 := Gdip_BrushCreateSolid(bgrColor)
    If (FontBolded=1)
       txtStyle .= " Bold"
    If (FontItalica=1 && NoWrap=0)
       txtStyle .= " Italic"
    Else If (NoWrap=1)
       txtStyle .= " NoWrap"

    If !thisTextAlign
       thisTextAlign := (flippable=1 && FlipImgH=1) ? "Right" : "Left"
    Else
       thisTextAlign := Trimmer(thisTextAlign)

    borderSize := (NoWrap=1) ? Floor(theFntSize*1.2) : Floor(theFntSize*1.5)
    borderSize := borderSize//3
    txtOptions := []
    txtOptions.x := borderSize
    txtOptions.y := borderSize
    txtOptions.w := maxW - borderSize*2
    txtOptions.h := maxH - borderSize*2
    txtOptions.Styles := txtStyle
    txtOptions.Align := thisTextAlign
    txtOptions.Color := "0xEE" txtColor
    txtOptions.Size := theFntSize
    mainObju := TextToGraphics(G, "initing", txtOptions, fntName, "begin", units)
    ; ToolTip, % mainObju.hfnt "`n" mainObju.hStrFmt "`n" mainObju.hBrush , , , 2

    dims := TextToGraphics(2NDglPG, theString, nul, fntName, "measure", units, mainObju)
    dimsFw := clampInRange(dims.w + borderSize*2, 5, maxW)
    dimsFh := clampInRange(dims.h + borderSize*2, 5, maxH)

    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, dimsFw, dimsFh, "0xE200B")
    If clipBMPa
       G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 5, 1)

    If (!G || !clipBMPa)
    {
       trGdip_DisposeImage(clipBMPa, 1)
       Return
    }

    fontQuality := (theFntSize>90) ? 2 : 3
    If (theFntSize<20)
       fontQuality := 4

    Gdip_SetTextRenderingHint(G, fontQuality)
    trGdip_GraphicsClear(A_ThisFunc, G, BGRopacity bgrColor)
    ; Gdip_FillRectangle(G, pBr0, -2, -2, dimsFw + 3, dimsFh + 3)
    _E := TextToGraphics(G, theString, txtOptions, fntName, "draw", units, mainObju)
    ; ToolTip, % dims.w "--" dims.h "--" _E , , , 2
    If (flippable=1)
       flipBitmapAccordingToViewPort(clipBMPa, 1)

    Gdip_DeleteGraphics(G)
    ; Gdip_DeleteBrush(pBr0)
    Gdip_DeleteBrush(mainObju.hBrush)
    Gdip_DeleteStringFormat(mainObju.hStrFmt)
    Gdip_DeleteFont(mainObju.hFnt)
    Gdip_DeleteFontFamily(mainObju.hFntFam)
    ; fnOutputDebug("draw text in box: " A_TickCount - startZeit " ms")
    Return clipBMPa
}

TextToGraphics(pGraphics, Text, OptionsObj, Font:="Arial", initMode:=0, Unit:=0, inObj:=0) {

   Static Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
        , Alignments := "Near|Left|Centre|Center|Far|Right"

   If (initMode="begin")
   {
      xpos := OptionsObj.x,  ypos := OptionsObj.y
      Width := OptionsObj.w, Height := OptionsObj.w
      Size := OptionsObj.Size

      Style := 0
      For eachStyle, valStyle in StrSplit(Styles, "|")
      {
         If RegExMatch(OptionsObj.Styles, "\b" valStyle)
            Style |= (valStyle != "StrikeOut") ? (A_Index-1) : 8
      }

      Align := 0
      For eachAlignment, valAlignment in StrSplit(Alignments, "|")
      {
         If RegExMatch(OptionsObj.Align, "\b" valAlignment)
            Align |= A_Index//2.1   ; 0|0|1|1|2|2
      }

      hFontFamily := Gdip_FontFamilyCreate(Font)
      If !hFontFamily
         hFontFamily := Gdip_FontFamilyCreateGeneric(1)

      ; ToolTip, % options "`n" size " == " colour , , , 2
      hFont := Gdip_FontCreate(hFontFamily, Size, Style, Unit)
      FormatStyle := InStr(OptionsObj.Styles, "NoWrap") ? 0x4000 | 0x1000 : 0x4000
      hStringFormat := Gdip_StringFormatCreate(FormatStyle)
      If !hStringFormat
         hStringFormat := Gdip_StringFormatGetGeneric(1)

      pBrush := Gdip_BrushCreateSolid(OptionsObj.Color)
      if !(hFontFamily && hFont && hStringFormat && pBrush)
      {
         E := !pGraphics ? -2 : !hFontFamily ? -3 : !hFont ? -4 : !hStringFormat ? -5 : !pBrush ? -6 : 0
         If pBrush
            Gdip_DeleteBrush(pBrush)
         If hStringFormat
            Gdip_DeleteStringFormat(hStringFormat)
         If hFont
            Gdip_DeleteFont(hFont)
         If hFontFamily
            Gdip_DeleteFontFamily(hFontFamily)
         return E
      }

      Gdip_SetStringFormatAlign(hStringFormat, Align)
      If InStr(OptionsObj.Styles, "autotrim")
         Gdip_SetStringFormatTrimming(hStringFormat, 3)

      obju := []
      obju.hfnt := hFont
      obju.hfntFam := hFontFamily
      obju.hStrFmt := hStringFormat
      obju.hBrush := pBrush
      obju.x := xpos,  obju.y := ypos
      obju.w := width, obju.h := height
      ; ToolTip, % hfont "`n" hStringFormat "`n" pBrush , , , 2
      Return obju
   }

   If (initMode="measure")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ; TOOLTIP, % inObj.x "--" inObj.y "--" inObj.w "--" inObj.h , , , 2
      ReturnRC := Gdip_MeasureString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, RC)
      val := StrSplit(ReturnRC, "|")
      measure := []
      measure.x := Floor(val[1]), measure.y := Floor(val[2])
      measure.w := Ceil(val[3]), measure.h := Ceil(val[4])
      Return measure
   }

   If (initMode="draw")
   {
      CreateRectF(RC, inObj.x, inObj.y, inObj.w, inObj.h)
      ReturnRC := Gdip_MeasureString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, RC)
      ReturnRCtest := StrSplit(ReturnRC, "|")
      testX := Floor(ReturnRCtest[1]) - 2
      If (testX>xpos) ; error correction for different text alignments
      {
         nxpos := Floor(inObj.x - (testX - inObj.x))
         CreateRectF(RC, nxpos, inObj.y, inObj.w, inObj.h)
         ; ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hStringFormat, RC)
         ; MsgBox, % nxpos "--" xpos "--" ypos "`n" width "--" height "`n" ReturnRC
      }

      _E := Gdip_DrawString(pGraphics, Text, inObj.hFnt, inObj.hStrFmt, inObj.hBrush, RC)
      Return _E
   }

   return _E ? _E : ReturnRC
}

HardWrapTextFontBased(TextToWrap, hFont, maxW, maxH, lineHeight) {
   ; Critical, on
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
        , maxCharsInWidth := 2048

   if (StrLen(TextToWrap)<=2)
      return TextToWrap

   TextToWrap := Trimmer(TextToWrap)
   thisIndex := thisH := linez := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   hDC := Gdi_GetDC()
   old_hFont := Gdi_SelectObject(hDC, hFont)
   maxLinez := Round(maxH/lineHeight) - 1
   thisCharSpacing := (TextInAreaCharSpacing>0) ? TextInAreaCharSpacing : 0
   Loop, Parse, TextToWrap
   {
       If (maxLinez<linez && linez>1)
          Break

       thisIndex++
       thisLineu .= A_LoopField
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
       {
          linez++
          thisLineu := ""
          thisIndex := hasMatchedRegEx := 0
          Continue
       }

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
          whereHasMatchedinLine := thisIndex
       }

       ; thisObj := Gdi_TruncateStringToFitWidth(hFont, A_Space thisLineu A_Space, maxW - TextInAreaCharSpacing * (StrLen(thisLineu) + 1))
       E := Gdi_GetTextExtentExPoint(hDC, A_Space thisLineu A_Space, maxW - thisCharSpacing * (StrLen(thisLineu) + 1), fitLength, w, h)
       ; ToolTip, % thisObj.fitLength "==" thisObj.width "==" thisObj.height "==" thisObj.stringLength "`n" thisLineu, , , 2
       stringLength := StrLen(thisLineu) + 1
       If (hasMatchedRegEx=1 && (stringLength>fitLength || stringLength>maxCharsInWidth))
       {
          linez++
          offsetu++
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          hasMatchedRegEx := 0
          If (thisLineu=A_Space)
             thisLineu := ""
          thisLineu := SubStr(thisLineu, whereHasMatchedinLine)
          thisIndex := StrLen(thisLineu)
       } Else If (stringLength>fitLength || stringLength>maxCharsInWidth)
       {
          linez++
          thisLineu := ""
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }
   w := Gdi_SelectObject(hDC, old_hFont)
   g := Gdi_ReleaseDC(hDC, 0)
   ; ToolTip, % w "|" g "." foundPos "==" startPos, , , 2
   return newLinez
}

SimpleHardWrapText(TextToWrap, LengthLim) {
   Static RegExDelimiters := "(\||\*|\!|\]|\[|\\|\/|\.|\=|\:|\;|\?|\@|\-|\_|\)|\(|\{|\}|\s)"
   LengthLim := Round(LengthLim)
   if (LengthLim<2)
      return TextToWrap
   if (StrLen(TextToWrap) <= LengthLim + 1)
      return TextToWrap

   thisIndex := hasMatchedRegEx := offsetu := 0
   whereHasMatched := newLinez := ""
   
   Loop, Parse, TextToWrap
   {
       thisIndex++
       newLinez .= A_LoopField
       If (A_LoopField="`r" || A_LoopField="`n")
          thisIndex := hasMatchedRegEx := 0

       If RegExMatch(A_LoopField, RegExDelimiters)
       {
          hasMatchedRegEx := 1
          whereHasMatched := A_Index
       }

       If (thisIndex=LengthLim && hasMatchedRegEx=1)
       {
          newLinez := ST_Insert("`n", newLinez, whereHasMatched + offsetu)
          offsetu++
          thisIndex := hasMatchedRegEx := 0
       } Else If (thisIndex=LengthLim)
       {
          newLinez .= "`n"
          thisIndex := hasMatchedRegEx := 0
       }
   }

   ; ToolTip, % foundPos "==" startPos, , , 2
   return newLinez
}

Gdi_DrawTextInBox(theString, hFont, maxW, maxH, txtColor, bgrColor, borderSize:=0, NoWrap:=1, scaleuPreview:=1) {
    startZeit := A_TickCount
    ; dimsu := otherGetStringSize(fntName, theFntSize, 0, theString, NoWrap, maxW)
    ; ToolTip, % dimsu.w "--" dimsu.h " == " NoWrap "`n" theString , , , 2
    thisCharSpacing := Round(TextInAreaCharSpacing / scaleuPreview)
    Gdi_MeasureString(hFont, theString, 1, oW, oH)
    ; Fnt_GetMultilineStringSizeDT(hFont, theString, 1, 0, oW, oH)
    reAdjustWtxtspacing := (Abs(thisCharSpacing)//2) * StrLen(theString)
    reAdjustWtxtspacing := clampInRange(reAdjustWtxtspacing, 1, oW - 5)
    If (thisCharSpacing<0)
       oW := oW - reAdjustWtxtspacing
    Else
       oW := oW + thisCharSpacing * StrLen(theString)
    ; ToolTip, % oW "==" oH "==" reAdjustWtxtspacing , , , 2
    Gdip_GetRotatedDimensions(oW, oH, TextInAreaLineAngle/10, rWidth, rHeight)
    scaleu := Abs(TextInAreaLineAngle/900)
    scaleu2 := Abs((TextInAreaLineAngle*scaleu)/900)
    r_Width := rWidth + borderSize*2
    r_Height := rHeight + borderSize*2
    offsetY := (TextInAreaLineAngle<0) ? r_Width//2 - rWidth//2 : r_Height//2 - rHeight//2 + clampValue(Floor(rHeight*(scaleu*1.9)), "-", rHeight)
    offsetX := (TextInAreaLineAngle<0) ? r_Height//2 - rHeight//2 + Floor(rWidth*scaleu2)  : r_Width//2 - rWidth//2
    If (offsetY<(rHeight - oH + borderSize) && TextInAreaLineAngle>0)
       offsetY := Abs(rHeight - oH + borderSize)

    If (offsetX<borderSize)
       offsetX := borderSize

    If (TextInAreaOnlyBorder!=1 || TextInAreaBorderOut=1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDc, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), "0x" rgb2bgr(bgrColor))
       pBitmap := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDc, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hdc)
    }

    If (TextInAreaBorderSize>0 && TextInAreaBorderOut>1)
    {
       hbm := Gdi_CreateDIBSection(r_Width, r_Height)
       hDC := Gdi_CreateCompatibleDC()
       obm := Gdi_SelectObject(hDC, hbm)
       Gdi_SetMapMode(hDC, 1)
       Gdi_SetTextCharSpacing(hDC, thisCharSpacing)
       Gdi_DrawTextOutline(hDC, hFont, theString, offsetX, offsetY, "0x" rgb2bgr(txtColor), Round(TextInAreaBorderSize/scaleuPreview))
       If (TextInAreaBorderOut=3)
          Gdi_DrawTextHelper(hDC, hFont, theString, offsetX, offsetY, "0x000000")
       pBitmap2 := trGdip_CreateBitmapFromHBITMAP(hbm)
       Gdi_SelectObject(hDC, obm)
       Gdi_DeleteObject(hbm)
       Gdi_DeleteDC(hDC)
    }

    ; Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     ; ToolTip, % r_width "=" r_height "`n" hbm "==" hdc "==" obm "`n" imgW "==" imgH, , , 2
    ; fnOutputDebug("draw text in box with GDI: " A_TickCount - startZeit " ms")
    Return [pBitmap, pBitmap2, r_Width, r_Height]
}

coreInsertTextInAreaBox(theString, maxW, maxH, previewMode) {
    Static OBJ_FONT := 6, testString := "This is going to a test"

    Gdip_FromARGB("0xFF" TextInAreaFontColor, A, R, G, B)
    txtColor := Gdip_ToARGB(TextInAreaFontOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBgrColor, A, R, G, B)
    bgrColor := Gdip_ToARGB(TextInAreaBgrOpacity, R, G, B)
    Gdip_FromARGB("0xFF" TextInAreaBorderColor, A, R, G, B)
    borderColor := Gdip_ToARGB(TextInAreaBorderOpacity, R, G, B)

    fntQuality := (previewMode=1) ? 1 : 4
    fntWeight := (TextInAreaFontBold=1) ? 800 : 400
    thisFactor := (zoomLevel<0.45 || TextInAreaFontSize>300) ? 10 : 5
    If (TextInAreaFontSize>650)
       thisFactor := 15

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    thisFactor := ((mainWidth + mainHeight)//150 + thisFactor)//2 + TextInAreaFontSize//200
    If (zoomLevel>0.8 && thisFactor>3)
       thisFactor := 3
    If (TextInAreaFontSize<35)
       thisFactor := 1

    thisLineAngle := (TextInAreaLineAngle<0) ? 3600 + TextInAreaLineAngle : TextInAreaLineAngle
    If !isNumber(thisLineAngle)
       thisLineAngle := 0

    hFontPreview := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize//thisFactor, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    hFont := Gdi_CreateFontByName(TextInAreaFontName, TextInAreaFontSize, fntWeight, TextInAreaFontItalic, TextInAreaFontStrike, TextInAreaFontUline, fntQuality, thisLineAngle)
    If (Gdi_GetObjectType(hFont)!="FONT")
       Return "fail"

    thisBlurAmount := max(TextInAreaBlurAmount, TextInAreaBlurBorderAmount) // 2
    borderSize := (TextInAreaUsrMarginz>0) ? TextInAreaUsrMarginz : TextInAreaBorderSize//2 + thisBlurAmount
    Gdi_MeasureString(hFont, testString, 1, testWa, testHa)
    Gdi_MeasureString(hFontPreview, testString, 1, testWb, testHb)
    If (TextInAreaAutoWrap=1)
       theString := Trimmer(HardWrapTextFontBased(theString, hFont, maxW - borderSize * 2, maxH + 2, clampInRange(testHa + TextInAreaFontLineSpacing, 2, maxH + 10)))
    Else
       theString := Trimmer(theString)

    scaleuPreview := (previewMode=1) ? testWa/testWb : 1
    ; ToolTip, % thisFactor "==" scaleuPreview , , , 2
    ; ToolTip, % testWa "==" testHa "`n" testWb "==" testHb "`n" testWa/testWb , , , 2
    maxW := Round(maxW / scaleuPreview) ; + Round(5*TextInAreaFontSize*scaleuPreview)
    maxH := Round(maxH / scaleuPreview) ; + TextInAreaFontSize*2
    mainBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, "0xE200B")
    If warnUserFatalBitmapError(mainBMP, A_ThisFunc)
       Return "fail"

    thisBlur := Round(TextInAreaBlurAmount / scaleuPreview)
    If (thisBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       pEffect := Gdip_CreateEffect(1, thisBlur, 0, 0)

    thisBorderBlur := Round(TextInAreaBlurBorderAmount / scaleuPreview)
    If (thisBorderBlur>0 && TextInAreaDoBlurs=1 && !isWinXP)
       zEffect := Gdip_CreateEffect(1, thisBorderBlur, 0, 0)

    zBrush := Gdip_BrushCreateSolid(bgrColor)
    thisQuality := (previewMode=1) ? 5 : 7
    G := trGdip_GraphicsFromImage(A_ThisFunc, mainBMP, thisQuality)
    ; If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    ;    trGdip_GraphicsClear(A_ThisFunc, G, "0xFF000000")

    thisY := thisX := 0
    maxedW := maxedH := 0
    minedX := maxW, minedY := maxH
    doConturDraw := (TextInAreaBorderSize>0 && TextInAreaBorderOut>1) ? 1 : 0
    If (previewMode=1)
       borderSize := Round(borderSize/scaleuPreview)

    thisHFont := (previewMode=1) ? hFontPreview : hFont
    rescaleWidthCharSpacing := (TextInAreaCharSpacing<0) ? (100 - Abs(TextInAreaCharSpacing))/90 : 1
    threads := (previewMode=1) ? realSystemCores//2 : 0
    Loop, Parse, theString, `n
    {
       ; If !Trimmer(A_LoopField)
       ;    Continue

       objBMPs := Gdi_DrawTextInBox(A_Space A_LoopField A_Space, thisHFont, maxW, maxH, "FFffFF", "000000", borderSize, 1, scaleuPreview)
       imgW := objBMPs[3], imgH := objBMPs[4]
       pBitmap := (doConturDraw=1 && TextInAreaOnlyBorder=1 && objBMPs[2]) ? objBMPs[2] : objBMPs[1]
       If (doConturDraw=1 && objBMPs[1] && TextInAreaOnlyBorder=1)
          trGdip_DisposeImage(objBMPs[1])

       pBitmapContours := objBMPs[2]
       If (TextInAreaAlign=2)
          thisX := maxW//2 - imgW//2
       If (TextInAreaAlign=3)
          thisX := maxW - imgW

       If (pEffect && (TextInAreaBgrUnified!=1 || TextInAreaPaintBgr!=1))
          Gdip_BitmapApplyEffect(pBitmap, pEffect)

       thisBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(thisBMP)<3
       {
          fattalErr := 1
          trGdip_DisposeImage(pBitmap, 1)
          Break
       }

       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thisBMP)
       If (TextInAreaCutOutMode=1 && TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
       {
          ; trGdip_GraphicsClear(A_ThisFunc, G2)
          Gdip_FillRectangle(G2, zBrush, 0, 0, imgW, imgH)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 1, 1, 1, threads)
          thisOpacity := TextInAreaBgrOpacity/255
       } Else
       {
          thisColor := (TextInAreaOnlyBorder=1) ? borderColor : txtColor
          trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
          QPV_SetAlphaChannel(thisBMP, pBitmap, 0, 1, 1, threads)
          thisOpacity := 1
       }

       If (TextInAreaBgrUnified!=1 && TextInAreaPaintBgr=1)
       {
          If (TextInAreaCutOutMode!=1)
             Gdip_FillRectangle(G, zBrush, thisX, thisY, imgW, imgH)

          If (TextInAreaBgrEntire=1)
          {
             Gdip_SetClipRect(G, 0, thisY, maxW, imgH)
             Gdip_SetClipRect(G, thisX, thisY, imgW, imgH, 4)
             Gdip_FillRectangle(G, zBrush, 0, thisY, maxW, imgH)
             Gdip_ResetClip(G)
          }
       }

       forceW := (imgW>=maxW) ? maxW : imgW
       If (rescaleWidthCharSpacing<1)
       {
          phorceW := Round(forceW*rescaleWidthCharSpacing)
          forceW -= (forceW - phorceW)//2.5
       }

       If (doConturDraw=1 && TextInAreaOnlyBorder!=1 && pBitmapContours)
       {
          If zEffect
             Gdip_BitmapApplyEffect(pBitmapContours, zEffect)
          thizBMP := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
          G5 := trGdip_GraphicsFromImage(A_ThisFunc, thizBMP)
          trGdip_GraphicsClear(A_ThisFunc, G5, borderColor)
          QPV_SetAlphaChannel(thizBMP, pBitmapContours, 0, 1, 1, threads)
          trGdip_DrawImage(A_ThisFunc, G, thizBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
          trGdip_DisposeImage(pBitmapContours, 1)
          trGdip_DisposeImage(thizBMP, 1)
          Gdip_DeleteGraphics(G5)
       }

       maxedW := max(forceW, maxedW)
       maxedH := max(thisY + imgH, maxedH)
       minedX := min(thisX, minedX)
       minedY := min(thisY, minedY)
       drawFail := trGdip_DrawImage(A_ThisFunc, G, thisBMP, thisX, thisY,forceW,imgH,,,,, thisOpacity)
       If (previewMode=1)
          thisY += imgH + Round(TextInAreaFontLineSpacing / scaleuPreview)
       Else
          thisY += imgH + TextInAreaFontLineSpacing
       trGdip_DisposeImage(pBitmap, 1)
       trGdip_DisposeImage(thisBMP, 1)
       Gdip_DeleteGraphics(G2)
       If (drawFail="fail")
       {
          fattalErr := 1
          Break
       }
    }

    If (fattalErr=1)
       warnUserFatalBitmapError("no-gdip", A_ThisFunc)

    Gdi_DeleteObject(hFont)
    Gdi_DeleteObject(hFontPreview)
    minedX := clampInRange(minedX, 0, maxW)
    minedY := clampInRange(minedY, 0, maxH)
    maxedW := clampInRange(maxedW, 1, maxW)
    maxedH := clampInRange(maxedH, 1, maxH)
    ; ToolTip, % maxedW "==" maxedH " = " minedX "==" minedY , , , 2
    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
    {
       newBMP := trGdip_CreateBitmap(A_ThisFunc, maxW, maxH, "0xE200B")
       warnUserFatalBitmapError(newBMP, A_ThisFunc)
    }

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1 && StrLen(newBMP)>2)
    {
       If pEffect
          Gdip_BitmapApplyEffect(mainBMP, pEffect)

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, newBMP)
       If (TextInAreaRoundBoxBgr=1)
       {
          radius := Round(((maxedW + borderSize*2 + maxedH)//2.5)*0.1) + 1
          kPath := Gdip_CreatePath()
          Gdip_AddPathRoundedRectangle(kPath, minedX, minedY, maxedW, maxedH, radius)
          Gdip_SetClipPath(G3, kPath)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          Gdip_DeletePath(kPath)
       } Else
       {
          Gdip_SetClipRect(G3, minedX, minedY, maxedW, maxedH)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
       }
       Gdip_ResetClip(G3)
       trGdip_DrawImage(A_ThisFunc, G3, mainBMP, 0, 0)
       ; QPV_SetAlphaChannel(newBMP, mainBMP, TextInAreaCutOutMode)
       trGdip_DisposeImage(mainBMP, 1)
       mainBMP := newBMP
       Gdip_DeleteGraphics(G3)
    }

    Gdip_DeleteGraphics(G)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DeleteBrush(zBrush)
    obju := [mainBMP, minedX, minedY, maxedW, maxedH, scaleuPreview]
    Return obju
}

drawHistogram(dataArray, maxYlimit, LengthX, Scale, fgrColor, bgrColor, borderSize, infoBoxBMP) {
    Static graphHeight := 300 ; graph height
         , barWidth := 2
    ; ToolTip, % maxYlimit " || " LengthX  , , , 2
    PointsList .= -1 "," graphHeight + 1 "|"
    Loop, % LengthX
    {
        skipThis := 0
        y1 := dataArray[A_Index - 1]/maxYlimit
        If !y1
        {
           y1 := 0
           skipThis := 1
        }

        y1 := graphHeight - Round(graphHeight * y1)
        If (y1<0)
           y1 := 0
        Else If (y1>graphHeight - 1) && (skipThis=0)
           y1 := graphHeight - 1
        thisIndex := A_Index * barWidth - barWidth
        PointsList .= thisIndex - 1 ","  y1 "|" thisIndex ","  y1 "|"
    }

    PointsList .= thisIndex + 1 "," graphHeight + 1
    graphPath := Gdip_CreatePath()
    Gdip_AddPathPolygon(graphPath, PointsList) ; , 0.000001)
    pMatrix := Gdip_CreateMatrix()
    Gdip_ScaleMatrix(pMatrix, Scale/2, Scale/2, 1)
    Gdip_TransformPath(graphPath, pMatrix)
    thisRect := Gdip_GetPathWorldBounds(graphPath)
    imgW := Ceil(thisRect.w), imgH := Ceil(thisRect.h) + 1
    clipBMPa := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
    If StrLen(clipBMPa)<2
    {
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Return
    }

    G := trGdip_GraphicsFromImage(A_ThisFunc, clipBMPa, 7, 4)
    If G
    {
       If infoBoxBMP
          Gdip_GetImageDimensions(infoBoxBMP, imgW2, imgH2)

       clipBMP := trGdip_CreateBitmap(A_ThisFunc, imgW + borderSize * 2, imgH + Round(imgH2) + Round(borderSize*1.5), "0xE200B")
       If StrLen(clipBMP)<2
       {
          Gdip_DeletePath(graphPath)
          Gdip_DeleteMatrix(pMatrix)
          trGdip_DisposeImage(clipBMPa, 1)
          Gdip_DeleteGraphics(G)
          Return
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, clipBMP)
       If G3
       {
          pBr1 := Gdip_BrushCreateSolid(fgrColor)
          Gdip_FillPath(G, pBr1, graphPath)
          Gdip_GetImageDimensions(clipBMP, maxW, maxH)
          lineThickns := borderSize//8
          Gdip_SetPenWidth(pPen1d, lineThickns)
          trGdip_GraphicsClear(A_ThisFunc, G3, bgrColor)
          ; Gdip_FillRectangle(G3, pBr0, -2, -2, maxW + borderSize*2+12, maxH + borderSize*3)
          Gdip_FillRectangle(G3, pBrushE, borderSize, borderSize, imgW, imgH)
          Gdip_DrawRectangle(G3, pPen1d, borderSize - lineThickns, borderSize - lineThickns, imgW + lineThickns*2, imgH + lineThickns*2)
          HUDobjHistoBoxu[5] := imgW + lineThickns*2 + borderSize
          HUDobjHistoBoxu[6] := imgH + lineThickns*2 + borderSize
          trGdip_DrawImage(A_ThisFunc, G3, clipBMPa, borderSize, borderSize)
          trGdip_DrawImage(A_ThisFunc, G3, infoBoxBMP, borderSize//3, imgH + borderSize*1.25)
          Gdip_DeleteGraphics(G3)
       }

       Gdip_DeleteGraphics(G)
       Gdip_DeletePath(graphPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteBrush(pBr1)
    } Else clipBMP := ""
    trGdip_DisposeImage(clipBMPa, 1)
    ; ToolTip, % clipBMPa  "`n" clipBmp , , , 2
    ; tooltip, % maxYlimit ", " LengthX " || "  maxW "," maxH  ;  `n" PointsList
    Return clipBMP
}

PasteInPlaceNow() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : useGdiBitmap()
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       corePasteInPlaceActNow("kill")
       fnOutputDebug("error - PasteInPlaceNow() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startZeit := A_TickCount
    If (UserMemBMP!=whichBitmap)
    {
       whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
       wasClone := whichBitmap
    } Else If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
    {
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    If StrLen(whichBitmap)<3
    {
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    ; pixFmt := Gdip_GetImagePixelFormat(whichBitmap, 2)
       ; E := Gdip_BitmapSetColorDepth(whichBitmap, 32, ColorDepthDithering)

    thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, thisImgQuality, 4)
    If !G2
    {
       SetTimer, ResetImgLoadStatus, -100
       trGdip_DisposeImage(wasClone, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    recordUndoLevelNow("init", 0)
    ; setImageLoading()
    r1 := corePasteInPlaceActNow(G2, whichBitmap)
    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       currIMGdetails.HasAlpha := 1

    Gdip_DeleteGraphics(G2)
    corePasteInPlaceActNow("kill")
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Paste in place operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    SetTimer, RefreshImageFile, -25
}

realtimePasteInPlaceRotater(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState, hasRotated
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return hasRotated
    }

    hasRotated := 0
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return 0

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := JimgW/vpImgW

    Gdip_GetImageDimensions(clipBMP, eImgW, eImgH)
    If (PasteInPlaceOrientation=2)
       ER := Gdip_ImageRotateFlip(clipBMP, 4)
    Else If (PasteInPlaceOrientation=3)
       ER := Gdip_ImageRotateFlip(clipBMP, 6)
    Else If (PasteInPlaceOrientation=4)
       ER := Gdip_ImageRotateFlip(clipBMP, 2)

    Gdip_GetRotatedDimensions(JimgW, JimgH, vPselRotation, testW, testH)
    If (testW*testH>maxGDIbmpSize) || (testW>32500) || (testH>32500)
       notOkayRotate := 1

    If (vPselRotation>0 && notOkayRotate!=1 && !ER)
    {
       setWindowTitle("Rotating image at " vPselRotation "°...")
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, clipBMP, vPselRotation,"", thisImgQuality)
       If StrLen(xBitmap)>3
       {
          hasRotated := 1
          ; If (previewMode=1)
             clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
    }

    If (prevEllipseSelectMode=1 && PasteInPlaceToolMode=1 && vPselRotation>0 && hasRotated=1)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       Gdip_GetRotatedEllipseDimensions(eImgW, eImgH, vPselRotation, pBw, pBh)
       gFx := pBw/rimgW
       gFy := pBh/rimgH
       zwImgW := Round(rImgW * gFx)
       zwImgH := Round(rImgH * gFy)
       dX := (rImgW - zwImgW)//2
       dY := (rImgH - zwImgH)//2
       xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP, dX, dY, zwImgW, zwImgH)
       If StrLen(xBitmap)>3
       {
          clipBMP := trGdip_DisposeImage(clipBMP, 1)
          clipBMP := xBitmap
       }
       ; ToolTip, % gFx " --- " gFy "`n" zwImgW " --- " zwImgH "`n" rImgW " --- " rImgH "`n" dX " --- " dY "`n" clipBMP , , , 2
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return hasRotated
}

realtimePasteInPlaceBlurrator(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    newBitmap := ""

    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" userClipBMPpaste viewportStampBMP previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode prevrotateSelBoundsKeepRatio prevEllipseSelectMode prevVPselRotation getIDimage(currentFileIndex) currentFileIndex PasteInPlaceAdaptMode
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }
 
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    clipBMP := trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return "fail"

    Gdip_GetImageDimensions(userClipBMPpaste, JimgW, JimgH)
    Gdip_GetImageDimensions(viewportStampBMP, vpImgW, vpImgH)
    fScale := vpImgW/JimgW
    If (PasteInPlaceBlurAmount>0)
    {
       setWindowTitle("Applying blur filter on image...")
       thisAmount := (previewMode=1) ? Round(PasteInPlaceBlurAmount * fScale) : PasteInPlaceBlurAmount
       thisAmount := clampInRange(thisAmount, 1, 255)
       pEffect := Gdip_CreateEffect(1, thisAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, clipBMP, thisAmount, pEffect, previewMode)
       Gdip_DisposeEffect(pEffect)
    }

    If (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode=1))
    {
       Gdip_GetImageDimensions(clipBMP, eImgW, eImgH)
       pPath := createImgSelPath(0, 0, eImgW, eImgH, prevEllipseSelectMode)
       If pPath
       {
          Gdip_RotatePathAtCenter(pPath, prevVPselRotation, 1, 1, prevrotateSelBoundsKeepRatio)
          carvePathFromBitmap(clipBMP, pPath, 0, 0, 4)
          Gdip_DeletePath(pPath)
       }
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    Return
}

realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlphaBMP, rImgW, rImgH, thisImgQuality:=0) {
    Static prevBMPu, prevState
    newBitmap := ""
    If (previewMode="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisBMP := userAlphaBMP
    thisChan := (PasteInPlaceAlphaChannelFile=5) ? 1 : 0
    thisState := "a" previewMode PasteInPlaceAlphaFile getIDimage(currentFileIndex) currentFileIndex FillAreaGradientAngle thisChan
    If (thisState=prevState && prevBMPu)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       trGdip_DisposeImage(thisBMP, 1)
       Return newBitmap
    }

    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
    If (PasteInPlaceAlphaChannelFile=5)
    {
       bmpGray := retrieveImgChannel(thisBMP, PasteInPlaceAlphaChannelFile)
       If StrLen(bmpGray)>1
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := bmpGray
       }
    }

    If (FillAreaGradientAngle>0 && thisBMP)
    {
       changeMcursor()
       thisMono := (FillAreaColorReversed!=1) ? "0xFF000000" : "0xFFFFFFFF"
       thisMonoBrush := Gdip_BrushCreateSolid(thisMono)
       xMask := trGdip_RotateBitmapAtCenter(A_ThisFunc, thisBMP, FillAreaGradientAngle, thisMonoBrush, thisImgQuality)
       If StrLen(xMask)>2
       {
          trGdip_DisposeImage(thisBMP, 1)
          thisBMP := xMask
       } Else ER := "fail"
       Gdip_DeleteBrush(thisMonoBrush)
    } Else ER := "fail"

    If ER
    {
       trGdip_DisposeImage(thisBMP, 1)
       Return
    }

    alphaMaskGray := trGdip_ResizeBitmap(A_ThisFunc, thisBMP, rImgW, rImgH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(thisBMP, 1)

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : alphaMaskGray
    prevState := thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? alphaMaskGray : trGdip_CloneBitmap(A_ThisFunc, alphaMaskGray)
    Return newBitmap
}

useGdiBitmap() {
   If StrLen(gdiBitmap)>3
      Return gdiBitmap
   Else If StrLen(UserMemBMP)>3
      Return UserMemBMP
   Else Return
}

retrieveImgChannel(pBitmap, convertGray) {
   If isInRange(convertGray, 1, 4)
   {
      bmpGray := trGdip_RetrieveBitmapChannel(pBitmap, convertGray)
   } Else If (convertGray=5)
   {
      thisValue := (isWinXP=1) ? 0 : -45
      bmpGray := trGdip_BitmapConvertGray(pBitmap, 0, thisValue, 1, 0, "0xE200B")
   }
   Return bmpGray
}

LoadCachableBitmapFromFile(imgPath) {
   Static prevBMPu, prevState
   If (imgPath="kill")
   {
      prevState := 0
      If prevBMPu
         prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
      Return
   }

   thisState := "a" generateThumbName(imgPath, 1) "=-=b"
   If (thisState=prevState && prevBMPu && FileRexists(imgPath))
   {
      newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
      Return newBitmap
   }

   prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
   pBitmap := LoadBitmapFromFileu(imgPath)
   If pBitmap
   {
      zBitmap := cloneGDItoMem(A_ThisFunc, pBitmap)
      If zBitmap
      {
         trGdip_DisposeImage(pBitmap, 1)
         pBitmap := zBitmap
      }
   } Else
   {
      addJournalEntry(A_ThisFunc "() failed: unable to load image file...")
      Return
   }

   prevBMPu := (minimizeMemUsage=1) ? 0 : pBitmap
   prevState := (pBitmap && minimizeMemUsage!=1) ? thisState : 0

   If pBitmap
      newBitmap := (minimizeMemUsage=1) ? pBitmap : trGdip_CloneBitmap(A_ThisFunc, pBitmap)
   Return newBitmap
}

QPV_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask:=0, replaceSourceAlphaChannel:=0, whichChannel:=1, threads:=0) {
  ; thisStartZeit := A_TickCount
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_SetAlphaChannel(pBitmap, pBitmapMask, invertAlphaMask, replaceSourceAlphaChannel, whichChannel)
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmapMask, w2, h2)
  If (w2!=w || h2!=h || !pBitmap || !pBitmapMask)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmapMask, 0, 0, w, h, stride, mScan, mData)
  func2exec := (A_PtrSize=8) ? "SetAlphaChannel" : "_SetAlphaChannel@32"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", invertAlphaMask, "Int", replaceSourceAlphaChannel, "Int", whichChannel, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmapMask, mData)
  ; ToolTip, % "qpv_alpha " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_BlendBitmaps(pBitmap, pBitmap2Blend, blendMode, threads) {
  If (!qpvMainDll || isWinXP)
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BlendBitmaps(pBitmap, pBitmap2Blend, clampInRange(blendMode, 1, 18))
  }

  thisStartZeit := A_TickCount
  Gdip_GetImageDimensions(pBitmap, w, h)
  Gdip_GetImageDimensions(pBitmap2Blend, w2, h2)
  ; ToolTip, % w "=" w2 "||" h "=" h2 , , , 2
  If (w2!=w || h2!=h || !pBitmap || !pBitmap2Blend)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  E2 := Gdip_LockBits(pBitmap2Blend, 0, 0, w, h, stride, mScan, mData)
  func2exec := (A_PtrSize=8) ? "BlendBitmaps" : "_BlendBitmaps@24"
  If (!E1 && !E2)
     r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "UPtr", mScan, "Int", w, "Int", h, "Int", blendMode, "Int", threads)

  If !E1
     Gdip_UnlockBits(pBitmap, iData)
  If !E2
     Gdip_UnlockBits(pBitmap2Blend, mData)
  ; ToolTip, % "r=" r " ; qpv == " A_TickCount - thisStartZeit, , , 2
  return r
}

QPV_InStr(strBase, str2find) {
  return DllCall("qpvmain.dll\isInString", "WStr", strBase, "WStr", str2find)
  ; ToolTip, % r " = r" , , , 2
}

realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, ByRef newBitmap) {
    Static prevBMPu, prevState
    If (previewMode="kill")
    {
       prevState := 0
       realtimePasteInPlaceAlphaMaskRotator("kill", 0, 0, 0)
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (coreDesiredPixFmt="0x21808")
       Return

    thisState := "a" previewMode PasteInPlaceBlurAmount PasteInPlaceToolMode PasteInPlaceOrientation vPselRotation PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB PasteInPlaceAlphaMaskMode PasteInPlaceAlphaFile alphaMaskReplaceMode FillAreaGradientWrapped FillAreaColorReversed FillAreaGradientScale FillAreaGradientAngle FillAreaGradientSigma FillAreaGradientBlend alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceAlphaChannelFile
    If (thisState=prevState && StrLen(prevBMPu)>2)
    {
       newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       Return
    }

    setWindowTitle("Applying alpha mask to image...")
    prevBMPu := trGdip_DisposeImage(prevBMPu, 1)

    If (PasteInPlaceAlphaFile="self" || PasteInPlaceAlphaFile="this")
       PasteInPlaceAlphaFile := currentFileIndex
    Else If (PasteInPlaceAlphaFile="prev")
       PasteInPlaceAlphaFile := currentFileIndex - 1
    Else If (PasteInPlaceAlphaFile="next")
       PasteInPlaceAlphaFile := currentFileIndex + 1
    Else If (PasteInPlaceAlphaFile="last")
       PasteInPlaceAlphaFile := maxFilesIndex
    Else If (PasteInPlaceAlphaFile="first" || PasteInPlaceAlphaFile=0)
       PasteInPlaceAlphaFile := 1
    Else If (PasteInPlaceAlphaFile="obj")
       PasteInPlaceAlphaFile := -1

    thisAlphaFile := IsNumber(PasteInPlaceAlphaFile) ? getIDimage(PasteInPlaceAlphaFile) : PasteInPlaceAlphaFile
    If (isFileLocked(thisAlphaFile) && currentFileIndex!=PasteInPlaceAlphaFile)
       thisAlphaFile := ""

    ; ToolTip, % "l" PasteInPlaceAlphaMaskMode "==" thisAlphaFile "==" clipBMP "==" PasteInPlaceAlphaFile, , , 2
    clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
    If StrLen(clipBMP)<3
       Return

    If (PasteInPlaceAlphaMaskMode=5 && (FileRexists(thisAlphaFile) || PasteInPlaceAlphaFile=-1))
    {
       If (PasteInPlaceAlphaFile=-1)
          userAlpha := (previewMode=1) ? trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP) : trGdip_CloneBitmap(A_ThisFunc, userClipBMPpaste)
       Else
          userAlpha := (useGdiBitmap() && PasteInPlaceAlphaFile=currentFileIndex) ? trGdip_CloneBitmap(A_ThisFunc, useGdiBitmap()) : LoadCachableBitmapFromFile(thisAlphaFile)

       ; ToolTip, % thisAlphaFile "--" PanelPasteInPlace "--" userAlpha , , , 2
       If StrLen(userAlpha)>2
          Gdip_GetImageDimensions(userAlpha, testImgW, testImgH)

       threads := (previewMode=1) ? realSystemCores//2 : 0
       If (StrLen(userAlpha)>2 && testImgW && testImgH)
       {
          Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
          brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
          contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
          thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
          alphaMaskGray := realtimePasteInPlaceAlphaMaskRotator(previewMode, userAlpha, rImgW, rImgH, thisImgQuality)
          If !alphaMaskGray
             Return

          pEffect := Gdip_CreateEffect(5, brLvl, contrLvl)
          pBlurEffect := Gdip_CreateEffect(1, thisAlphaBlur, 0)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          If (thisAlphaBlur>1)
             Gdip_BitmapApplyEffect(alphaMaskGray, pBlurEffect)
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeEffect(pBlurEffect)
          thisChannel := (PasteInPlaceAlphaChannelFile=5) ? 1 : PasteInPlaceAlphaChannelFile
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, thisChannel, threads)
          ResetImgLoadStatus()
          trGdip_DisposeImage(alphaMaskGray, 1)
       }
       SetTimer, ResetImgLoadStatus, -100
    } Else If (PasteInPlaceAlphaMaskMode=6 && ST_Count(customShapePoints, "|")>1)
    {
       tensionLvl := Round(PasteInPlaceAlphaMaskClrB/255, 2)
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       pEffect := Gdip_CreateEffect(1, PasteInPlaceAlphaMaskClrA, 0)
       alphaPath := Gdip_CreatePath()
       fAgScal := (FillAreaGradientScale + 2)/100
       tempArray := StrSplit(initialCustomShapeCoords, "|")
       calcIMGdimensions(tempArray[3], tempArray[4], rImgW, rImgH, rW, rH)
       tRimgW := (tempArray[3]>1) ? Round(rW*fAgScal) : Round(rImgW*fAgScal)
       tRimgH := (tempArray[4]>1) ? Round(rH*fAgScal) : Round(rImgH*fAgScal)
       offX := rImgW - tRimgW + Round((rImgW*alphaMaskOffsetX)*(fAgScal+1))
       offY := rImgH - tRimgH + Round((rImgH*alphaMaskOffsetY)*(fAgScal+1))
       PointsList := convertCustomShape2toReferencedArea(customShapePoints, 1 + offX//2, 1 + offY//2, tRimgW - 2, tRimgH - 2)
       If (PasteInPlaceAlphaMaskClrB<15 && alphaPath)
          Gdip_AddPathPolygon(alphaPath, PointsList)
       Else If alphaPath
          Gdip_AddPathClosedCurve(alphaPath, PointsList, tensionLvl)

       If (FillAreaGradientAngle>0 && alphaPath)
          Gdip_RotatePathAtCenter(alphaPath, FillAreaGradientAngle)

       G4 := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray, 7, 4)
       trGdip_GraphicsClear(A_ThisFunc, G4, "0xFF000000")
       ; BrushA := Gdip_BrushCreateSolid("0xFF000000")
       ; Gdip_FillRectangle(G4, BrushA, -2, -2, rImgW + 2, rImgH + 2)
       If G4
       {
          BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
          Gdip_FillPath(G4, BrushB, alphaPath)
          Gdip_BitmapApplyEffect(alphaMaskGray, pEffect)
          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }
       ResetImgLoadStatus()
       Gdip_DisposeEffect(pEffect)
       Gdip_DeletePath(alphaPath)
       ; Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DeleteGraphics(G4)
       trGdip_DisposeImage(alphaMaskGray, 1)
       SetTimer, ResetImgLoadStatus, -100
       ; trGdip_DisposeImage(clipBmp, 1)
       ; clipBmp := alphaMaskGray
    } Else If isInRange(PasteInPlaceAlphaMaskMode, 2, 4)
    {
       Gdip_GetImageDimensions(clipBMP, rImgW, rImgH)
       alphaMaskGray := trGdip_CreateBitmap(A_ThisFunc, rImgW, rImgH, "0xE200B")
       If warnUserFatalBitmapError(alphaMaskGray, A_ThisFunc)
          Return "fail"

       zpw := PasteInPlaceAlphaMaskClrA
       zpu := PasteInPlaceAlphaMaskClrB
       thisColorA := Gdip_ToARGB("0xFF", zpw, zpw, zpw)
       thisColorB := Gdip_ToARGB("0xFF", zpu, zpu, zpu)
       ; ToolTip, % thisColorA "`n" thisColorB, , , 2
       brImgSelW := rImgW*(FillAreaGradientScale/100)
       brImgSelH := rImgH*(FillAreaGradientScale/100)
       brimgSelPx := 0 - (brImgSelW - rImgW)//2
       brimgSelPy := 0 - (brImgSelH - rImgH)//2
       gradientWrapMode := (FillAreaGradientWrapped=1) ? 3 : 4
       If (PasteInPlaceAlphaMaskMode=2)
       {
          gradBrush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
          If gradBrush
          {
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
             Gdip_RotateLinearGrBrushAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetLinearGrBrushWrapMode(gradBrush, gradientWrapMode)
          }
       } Else If (PasteInPlaceAlphaMaskMode=3 || PasteInPlaceAlphaMaskMode=4)
       {
          grpPath := Gdip_CreatePath()
          If (PasteInPlaceAlphaMaskMode=3 && grpPath)
             Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
          Else If grpPath
             Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

          If grpPath
             gradBrush := Gdip_PathGradientCreateFromPath(grpPath)

          If gradBrush
          {
             Gdip_PathGradientSetCenterPoint(gradBrush, 0 + rImgW//2 + Round(rImgW*alphaMaskOffsetX), 0 + rImgH//2 + Round(rImgH*alphaMaskOffsetY))
             Gdip_SetLinearGrBrushPresetBlend(gradBrush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
             Gdip_RotatePathGradientAtCenter(gradBrush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_PathGradientSetWrapMode(gradBrush, gradientWrapMode)
          }

          Gdip_DeletePath(grpPath)
       }

       thisEllipsMod := (PasteInPlaceToolMode=1) ? prevEllipseSelectMode : EllipseSelectMode
       Ga := trGdip_GraphicsFromImage(A_ThisFunc, alphaMaskGray)
       ; thisColorC := (FillAreaColorReversed=1) ? 
       If Ga
       {
          pPath := createImgSelPath(-Round(rImgW*0.2), -Round(rImgH*0.2), Round(rImgW*1.45), Round(rImgH*1.45), thisEllipsMod)
          trGdip_GraphicsClear(A_ThisFunc, Ga, thisColorB)
          If pPath
             Gdip_FillPath(Ga, gradBrush, pPath)

          QPV_SetAlphaChannel(clipBMP, alphaMaskGray, FillAreaColorReversed, alphaMaskReplaceMode, threads)
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteBrush(gradBrush)
       Gdip_DeleteGraphics(Ga)
       ; trGdip_DisposeImage(clipBMP, 1)
       ; clipBMP := newBitmap
       trGdip_DisposeImage(alphaMaskGray, 1)
       ; clipBMP := alphaMask
    }

    prevBMPu := (previewMode!=1 || minimizeMemUsage=1) ? 0 : clipBMP
    prevState := (previewMode!=1 || minimizeMemUsage=1) ? 0 : thisState
    newBitmap := (previewMode!=1 || minimizeMemUsage=1) ? clipBMP : trGdip_CloneBitmap(A_ThisFunc, clipBMP)
    Return
}

corePasteInPlaceActNow(G2:=0, whichBitmap:=0) {
    Static prevImgCall, prevClipBMP, eImgW, eImgH, hasRotated, thisHasRan
         , lastInvoked := 1

    If (G2="kill" && thisHasRan=1)
    {
       ; fnOutputDebug("remove transform tool caches")
       thisHasRan := 0
       LoadCachableBitmapFromFile("kill")
       realtimePasteInPlaceRotater("kill", 2, lol)
       realtimePasteInPlaceBlurrator("kill", 2, lol)
       realtimePasteInPlaceAlphaMasker("kill", 2, lol)
       getImgSelectedAreaEditMode("kill", 1, 1, 1, 1, 1, 1)
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       viewportIDstampBMP := ""
       Return
    }

    If (PasteInPlaceLivePreview!=1 && !G2) || (G2="kill")
       Return

    If (G2)
    {
       prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
       clipBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       If StrLen(clipBMP)<3
          Return "fail"

       If (PasteInPlaceToolMode!=1)
          flipBitmapAccordingToViewPort(clipBMP, 1)

       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       thisImgQuality := (PasteInPlaceQuality=1) ? 7 : 5
       previewMode := 0
    } Else
    {
       ; If (A_TickCount - lastInvoked < 60)
       ;    Return
       lastInvoked := A_TickCount
       G2 := 2NDglPG
       thisImgQuality := 5
       previewMode := 1
       Gdip_ResetClip(G2)
       Gdip_SetInterpolationMode(G2, thisImgQuality)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
       ; Gdip_GetImageDimensions(gdiBitmap, imgW, imgH)
       ; calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       thisImgCall := getIDimage(currentFileIndex) currentFileIndex viewportStampBMP viewportIDstampBMP PasteInPlaceOrientation vPselRotation PasteInPlaceBlurAmount PasteInPlaceAlphaMaskMode PasteInPlaceAlphaMaskClrA PasteInPlaceAlphaMaskClrB FillAreaColorReversed FillAreaGradientScale FillAreaGradientSigma FillAreaGradientBlend FillAreaGradientWrapped FillAreaGradientAngle PasteInPlaceAlphaFile alphaMaskOffsetX alphaMaskOffsetY PasteInPlaceLight PasteInPlaceHue PasteInPlaceSaturation PasteInPlaceGamma PasteInPlaceApplyColorFX FillAreaBlendMode PasteInPlaceAlphaChannelFile
       If (prevImgCall=thisImgCall && StrLen(prevClipBMP)>2)
       {
          hasCached := 1
          clipBMP := prevClipBMP
       } Else
       {
          prevClipBMP := trGdip_DisposeImage(prevClipBMP, 1)
          clipBMP := trGdip_CloneBitmap(A_ThisFunc, viewportStampBMP)
       }
    }
 
    thisHasRan := 1
    If (hasCached!=1)
    {
       If (PasteInPlaceBlurAmount>0) || (PasteInPlaceToolMode=1 && (prevVPselRotation>0 || prevEllipseSelectMode=1))
       {
          ; fnOutputDebug("hello3")
          realtimePasteInPlaceBlurrator(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       If (PasteInPlaceOrientation>1 || vPselRotation>0)
       {
          ; fnOutputDebug("hello3")
          hasRotated := realtimePasteInPlaceRotater(previewMode, clipBMP, newBitmap)
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       } Else hasRotated := 0

       If (PasteInPlaceAlphaMaskMode>1)
       {
          ; thisStartZeit := A_TickCount
          realtimePasteInPlaceAlphaMasker(previewMode, clipBMP, newBitmap)
          ; ToolTip, % A_TickCount - thisStartZeit, , , 2
          If StrLen(newBitmap)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := newBitmap
          }
       }

       canApplyFX := (PasteInPlaceHue!=0 || PasteInPlaceSaturation!=0) ? 1 : 0
       If (!isWinXP && canApplyFX=1 && PasteInPlaceApplyColorFX=1)
       {
          zEffect := Gdip_CreateEffect(6, PasteInPlaceHue, PasteInPlaceSaturation, 0)
          Gdip_BitmapApplyEffect(clipBMP, zEffect)
          Gdip_DisposeEffect(zEffect)
       }

       canApplyFX := (PasteInPlaceLight!=0 || PasteInPlaceGamma!=0) ? 1 : 0
       If (!isWinXP && canApplyFX=1 && PasteInPlaceApplyColorFX=1)
       {
          zEffect := Gdip_CreateEffect(5, PasteInPlaceLight, PasteInPlaceGamma)
          Gdip_BitmapApplyEffect(clipBMP, zEffect)
          Gdip_DisposeEffect(zEffect)
       }
    }

    Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
    ; fnOutputDebug("hello4")
    calcIMGdimensions(oImgW, oImgH, imgSelW, imgSelH, ResizedW, ResizedH)
    If (previewMode=1)
    {
       Gdip_GetImageDimensions(userClipBMPpaste, qImgW, qImgH)
       If (vPselRotation>0 && hasRotated=1)
       {
          If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
             Gdip_GetRotatedEllipseDimensions(qImgW, qImgH, vPselRotation, qImgW, qImgH)
          Else
             Gdip_GetRotatedDimensions(qImgW, qImgH, vPselRotation, qImgW, qImgH)
       }
    }

    If (PasteInPlaceAdaptMode=3)
    {
       ResizedW := oImgW
       ResizedH := oImgH
       If (previewMode=1)
       {
          If (PasteInPlaceAdaptMode=3)
          {
             ; fnOutputDebug("hello9")
             Gdip_GetImageDimensions(userClipBMPpaste, ResizedW, ResizedH)
             ; fnOutputDebug("hello09")
             If (vPselRotation>0 && hasRotated=1)
             {
                If (EllipseSelectMode=1 && PasteInPlaceToolMode=1)
                   Gdip_GetRotatedEllipseDimensions(ResizedW, ResizedH, vPselRotation, ResizedW, ResizedH)
                Else
                   Gdip_GetRotatedDimensions(ResizedW, ResizedH, vPselRotation, ResizedW, ResizedH)
             }
          }
          ResizedW := ResizedW * zoomLevel
          ResizedH := ResizedH * zoomLevel
       }
    } Else If (PasteInPlaceAdaptMode=2)
    {
       ResizedW := imgSelW
       ResizedH := imgSelH
    }

    If (PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       PasteInPlaceEraseArea(G2, previewMode)

    If (ResizedW*ResizedH>maxGDIbmpSize)
       calcIMGdimensions(ResizedW, ResizedH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), ResizedW, ResizedH)

    If (ResizedW>32500 || ResizedH>32500)
       calcIMGdimensions(ResizedW, ResizedH, 32500, 32500, ResizedW, ResizedH)

    Gdip_ResetClip(G2)
    vPobju := testSelectionLargerThanViewport()
    If (previewMode=1)
       Gdip_SetClipRect(G2, 0, 0, vPobju.mainWidth, vPobju.mainHeight, 0)

    If (PasteInPlaceCropSel=1)
    {
       pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
       Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
       Gdip_SetClipPath(G2, pPath, 1)
    }

    If (PasteInPlaceCentered=2)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
    } Else If (PasteInPlaceCentered=3)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)//2
       imgSelPy := imgSelPy + (imgSelH - ResizedH)//2
    } Else If (PasteInPlaceCentered=4)
    {
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    } Else If (PasteInPlaceCentered=5)
    {
       imgSelPx := imgSelPx + (imgSelW - ResizedW)
       imgSelPy := imgSelPy + (imgSelH - ResizedH)
    }

    If (FillAreaBlendMode>1 && isNumber(FillAreaBlendMode))
    {
       ; fnOutputDebug("hello5")
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If (oImgW*oImgH>ResizedW*ResizedH)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, clipBMP, ResizedW, ResizedH, 0, thisImgQuality, 0, 0)
          If StrLen(tempBMP)>2
          {
             trGdip_DisposeImage(clipBMP, 1)
             clipBMP := tempBMP
          }

          Gdip_GetImageDimensions(clipBMP, oImgW, oImgH)
       }

       If (FillAreaGlassy=2)
          BlurAmount := 15
       Else If (FillAreaGlassy=3)
          BlurAmount := 50
       Else If (FillAreaGlassy=4)
          BlurAmount := 120
       Else If (FillAreaGlassy=5)
          BlurAmount := 180
       Else If (FillAreaGlassy=6)
          BlurAmount := 250
       Else
          BlurAmount := 0

       If (imgSelOutViewPort=1 || vPobju.isLarger=1)
          BlurAmount := 0

       bgrBMP := getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, ResizedW, ResizedH, BlurAmount)
       If StrLen(bgrBMP)>2
       {
          setWindowTitle("Applying blending mode...")
          thisStartZeit := A_TickCount
          factoru := (previewMode=1) ? 2 : 3
          delayu := (previewMode=1) ? -1 : 2
          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMP, clipBMP, FillAreaBlendMode - 1, threads)
          ; Gdip_GetImageDimensions(clipBMP, gimgW, gimgH)
          ; Gdip_BlendBitmaps(bgrBMP, clipBMP, FillAreaBlendMode - 1)
          ; ToolTip, % gImgW "===" gImgH "`n" ResizedW "===" ResizedH , , , 2
       }
    }

    setWindowTitle("Scaling image to selection area...")
    thisBMP := (bgrBMP && FillAreaBlendMode>1) ? bgrBMP : clipBMP
    If (thisBMP && G2)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, thisBMP, imgSelPx, imgSelPy, ResizedW, ResizedH, 0, 0, oImgW, oImgH, PasteInPlaceOpacity/255)

    trGdip_DisposeImage(bgrBMP, 1)
    Gdip_ResetClip(G2)
    If (bgrBMP=thisBMP && PasteInPlaceEraseInitial=1 && PasteInPlaceToolMode=1)
       PasteInPlaceEraseArea(G2, previewMode)

    ; for debugging purposes
    ; Gdip_FillRectangle(G2, pBrushD, 0, 0, pathBounds.w, pathBounds.h)
    ; Gdip_FillRectangle(G2, pBrushE, 0, 0, eImgW, eImgH)
    ; Gdip_GetRotatedDimensions(eImgW, eImgH, PasteInPlaceAngle, fImgW, fImgH)
    ; Gdip_DrawRectangle(G2, pPen1d, 0, 0, fImgW, fImgH)
    ; Gdip_DrawRectangle(G2, pPen1d, 0, 0, oImgW, oImgH)
    ; Gdip_DrawPath(G2, pPen1d, yPath)

    setWindowTitle(pVwinTitle, 1)
    Gdip_DeletePath(pPath)
    If (previewMode=1)
    {
       lastInvoked := A_TickCount
       thisImgQuality := (userimgQuality=1) ? 7 : 5
       Gdip_SetInterpolationMode(G2, thisImgQuality)
       prevImgCall := thisImgCall
       prevClipBMP := clipBMP
       ; trGdip_DisposeImage(clipBmp, 1)
       ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    } Else
    {
       trGdip_DisposeImage(clipBMP, 1)
       ; userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    }
}

getImgSelectedAreaEditMode(previewMode, imgSelPx, imgSelPy, oImgW, oImgH, imgSelW, imgSelH, BlurAmount:=0) {
    Static prevBMPu, prevBlurredBMP, prevState, prevFXid
    If (previewMode="kill")
    {
       prevState := prevFXid := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       Return
    }

    If (previewMode=1)
    {
       thisFXid := decideGDIPimageFX(matrix, imageAttribs, pEffect)
       thisFXid .= (BlurAmount>1) ? "." BlurAmount zoomLevel : "."
       thisFXid .= "Z" FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode

       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       thisState := "a" currentFileIndex getIDimage(currentFileIndex) imgSelPx imgSelPx oImgW oImgH imgSelW imgSelH currentUndoLevel currentSelUndoLevel FlipImgH FlipImgV IMGresizingMode imageAligned zoomLevel prevDestPosX prevDestPosY mainWidth mainHeight useGdiBitmap() prevMaxSelX prevMaxSelY PasteInPlaceAdaptMode
       If (thisFXid=prevFXid && thisState=prevState && StrLen(prevBMPu)>2)
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
          newBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
          Return newBitmap
       }

       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       If (thisFXid!=prevFXid || StrLen(prevBlurredBMP)<3)
       {
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
          prevBlurredBMP := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          If (pEffect && prevBlurredBMP)
          {
             Gdip_BitmapApplyEffect(prevBlurredBMP, pEffect)
             Gdip_DisposeEffect(pEffect)
          }

          If (imageAttribs && prevBlurredBMP)
          {
             G2 := trGdip_GraphicsFromImage(A_ThisFunc, prevBlurredBMP, 3)
             If G2
                r1 := trGdip_DrawImage(A_ThisFunc, G2, prevBlurredBMP,,,,,,,,,,, imageAttribs)
             Gdip_DeleteGraphics(G2)
             Gdip_DisposeImageAttributes(imageAttribs)
          }

          If (BlurAmount>1 && prevBlurredBMP)
          {
             BlurAmount := Round(BlurAmount*zoomLevel)
             BlurAmount := clampInRange(BlurAmount, 1, 255)
             zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, prevBlurredBMP, BlurAmount, zEffect, 1)
             Gdip_DisposeEffect(zEffect)
          }
          prevFXid := thisFXid
       } Else
       {
          Gdip_DisposeEffect(pEffect)
          Gdip_DisposeImageAttributes(imageAttribs)
       }

       thisBMP := prevBlurredBMP
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, thisBMP, imgSelPx, imgSelPy, imgSelW, imgSelH,,,1)
       If (minimizeMemUsage=1 && StrLen(prevBlurredBMP)>2)
          prevBlurredBMP := trGdip_DisposeImage(prevBlurredBMP, 1)
       ; ToolTip, % zBitmap "==" imgSelPx "==" imgSelPy "`n" imgSelW "--" imgSelH , , , 2
       thisImgTempQuality := (userimgQuality=1) ? 3 : 5
       If ((oImgW!=imgSelW || oImgH!=imgSelH) && zBitmap)
       {
          tempBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, oImgW, oImgH, 0, thisImgQuality, 0, 0)
          If tempBMP
          {
             trGdip_DisposeImage(zBitmap, 1)
             zBitmap := tempBMP
          }
       }

       prevState := (minimizeMemUsage=1) ? 0 : thisState
       newBitmap := (minimizeMemUsage=1) ? zBitmap : trGdip_CloneBitmap(A_ThisFunc, zBitmap)
       prevBMPu := (minimizeMemUsage=1) ? 0 : zBitmap
       Return newBitmap
    }

    whichBitmap := StrLen(UserMemBMP)>3 ? UserMemBMP : useGdiBitmap()
    If (imgFxMode>1)
       whichBitmap := useGdiBitmap()

    If !whichBitmap
    {
       SoundBeep , 300, 100
       addJournalEntry(A_ThisFunc "(): ERROR. No bitmap to process.")
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
    MouseCoords2Image(imgSelPx, imgSelPy, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX1, imgY1)
    MouseCoords2Image(imgSelPx + imgSelW, imgSelPy + imgSelH, 0, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgX2, imgY2)

    ; givenCoords := imgSelPx//zoomLevel "|" imgSelPy//zoomLevel "|" Round((imgSelPx + imgSelW)/zoomLevel) "|" Round((imgSelPy + imgSelH)/zoomLevel)
    givenCoords := imgX1 "|" imgY1 "|" imgX2 "|" imgY2 
    calcImgSelection2bmp(1, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0)
    newBitmap := trGdip_CreateBitmap(A_ThisFunc, oImgW, oImgH, "0xE200B")
    If warnUserFatalBitmapError(newBitmap, A_ThisFunc)
       Return

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, 0, 0, 1)
    If (pEffect && zBitmap)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    Gdip_GetImageDimensions(zBitmap, gimgW, gimgH)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap, 3)
    If G2
       r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0, oImgW, oImgH, 0, 0, gimgW, gimgH,,, imageAttribs)

    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DeleteGraphics(G2)
    Gdip_DisposeImageAttributes(imageAttribs)
    If (!G2 || !zBitmap)
    {
       trGdip_DisposeImage(newBitmap, 1)
       Return
    }

    If (BlurAmount>1 && G2)
    {
       BlurAmount := Round(BlurAmount)
       BlurAmount := clampInRange(BlurAmount, 2, 254)
       zEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
       ApplySpecialFixedBlur(A_ThisFunc, newBitmap, BlurAmount, zEffect)
       Gdip_DisposeEffect(zEffect)
    }

    prevState := 0
    Return newBitmap
}

destroyGDIfileCache(remAll:=1, makeBackup:=0) {
    If (remAll=0)
    {
       imgPath := getIDimage(currentFileIndex)
       MD5name := generateThumbName(imgPath, 1)
       If InStr(gdiBitmapIDcall, "1" MD5name imgPath)
       {
          If (makeBackup=1)
          {
             mainCall := SubStr(gdiBitmapIDcall, 2)
             gdiBitmapIDcall := "0" . mainCall
             xBitmap := cloneGDItoMem(A_ThisFunc, gdiBitmap)
             gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
             gdiBitmap := xBitmap
             gdiBitmapIDentire := gdiBitmapIDcall xBitmap
          } Else gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
       }

       If InStr(BprevImgCall, "1" MD5name imgPath)
       {
          BprevImgCall := ""
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       }

       If InStr(AprevImgCall, "1" MD5name imgPath)
       {
          AprevImgCall := ""
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       }

       If (!AprevImgCall && mainCall && makeBackup=1)
       {
          AprevImgCall := gdiBitmapIDcall
          AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       } Else If (!BprevImgCall && mainCall && makeBackup=1)
       {
          BprevImgCall := gdiBitmapIDcall
          BprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
       }

       If InStr(idGDIcacheSRCfileA, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileA := ""
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       }

       If InStr(idGDIcacheSRCfileB, "1" MD5name imgPath)
       {
          idGDIcacheSRCfileB := ""
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       }
    } Else
    {
       If (SubStr(idGDIcacheSRCfileA, 1, 1)=1)
          GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
       If (SubStr(idGDIcacheSRCfileB, 1, 1)=1)
          GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
       If (SubStr(BprevImgCall, 1, 1)=1)
          BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
       If (SubStr(AprevImgCall, 1, 1)=1)
          AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
       If (SubStr(gdiBitmapIDcall, 1, 1)=1)
          gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)

       idGDIcacheSRCfileA := idGDIcacheSRCfileB := ""
       BprevImgCall := AprevImgCall := ""
       GDIcacheSRCfileA := GDIcacheSRCfileB := gdiBitmapIDcall := ""
    }
}

discardViewPortCaches() {
    ; GDIcacheSRCfileA := trGdip_DisposeImage(GDIcacheSRCfileA, 1)
    ; GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
    AprevImgCall := BprevImgCall := ""
    BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
    AprevGdiBitmap := trGdip_DisposeImage(AprevGdiBitmap, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
}

disposeCacheIMGs(dummy:=0) {
    gdiBitmapIDcall := ""
    gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
    If (dummy!="soft")
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)

    prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
    gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
    infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
}

MenuReturnIMGedit() {
   If (StrLen(UserMemBMP)>2 && imgIndexEditing>0)
      currentFileIndex := imgIndexEditing
   MenuDummyToggleThumbsMode()
}

recordSelUndoLevelNow() {
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   ; ToolTip, % currentSelUndoLevel  " = l" , , , 2
   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (undoSelLevelsArray[totalSelUndos, 1]!=selectionCoords)
   {
      currentSelUndoLevel := totalSelUndos + 1
      undoSelLevelsArray[totalSelUndos + 1] := [selectionCoords]
   }
}

decideUndoLevelsAccepted(imgW, imgH) {
   If (A_PtrSize!=4) 
      Return

   pixelz := imgW*imgH
   memUsage := (coreDesiredPixFmt="0x21808") ? pixelz*3 : pixelz*4
   memUsage := memUsage//1000
   preventUndoLevels := (memUsage*5>maxMemUndoLevels) ? 1 : 0
   ; ToolTip, % preventUndoLevels " = mem = " memUsage , , , 2
}

recordUndoLevelNow(actionu, recordedBitmap, dX:=0, dY:=0, forceAlpha:="x") {
   Static prevAct, lastInvoked := 1
   If (preventUndoLevels=1)
      Return

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   thisAct := actionu recordedBitmap whichBitmap minimizeMemUsage currentFileIndex getIDimage(currentFileIndex)
   if (prevAct=thisAct)
   {
      ; SoundBeep, 900, 900
      addJournalEntry(A_ThisFunc "(" actionu "): already recorded undo state")
      Return
   }

   HasAlpha := (forceAlpha!="x") ? forceAlpha : currIMGdetails.HasAlpha
   selectionCoords := imgSelX1 "|" imgSelY1 "|" imgSelX2 "|" imgSelY2 "|" prcSelX1 "|" prcSelY1 "|" prcSelX2 "|" prcSelY2 "|" vPselRotation "|" rotateSelBoundsKeepRatio "|" EllipseSelectMode "|" LimitSelectBoundsImg "|" showSelectionGrid
   If (StrLen(undoLevelsArray[1, 1])<3 && StrLen(whichBitmap)>2 && minimizeMemUsage!=1)
   {
      thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
      If thisBMP
      {
         prevAct := thisAct
         recordSelUndoLevelNow()
         undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         currentUndoLevel := 1
         If (undoLevelsRecorded=0)
            undoLevelsRecorded := 1
      }
   }

   If (actionu="init")
   {
      setImageLoading()
      If (minimizeMemUsage=1)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         thisBMP := trGdip_CloneBitmap(A_ThisFunc "(init)", whichBitmap)
         If thisBMP
         {
            prevAct := thisAct
            currentUndoLevel := 1
            If (undoLevelsRecorded=0)
               undoLevelsRecorded := 1
            undoLevelsArray[1] := [thisBMP, 0, 0, currentSelUndoLevel, HasAlpha]
         }
      }

      lastInvoked := A_TickCount
      Return
   }

   prevAct := 0
   HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
   If (A_PtrSize=8 && undoLevelsRecorded>3)
   {
      systemMemInfo := GlobalMemoryStatusEx()
      mamUsage := GetProcessMemoryUsage(thisPID)
      thisMemoryLoad := Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
      If isWinXP
         thisMemoryLoad := 99

      If (thisMemoryLoad<85 && systemMemInfo.MemoryLoad<85 && hasReachedMaxUndoLevels=0)
         maxUndoLevels := 100
      Else
         maxUndoLevels := hasReachedMaxUndoLevels := undoLevelsRecorded
   }

   ; currentSelUndoLevel := totalSelUndos := Round(undoSelLevelsArray.Count() + 1)
   ; undoSelLevelsArray[totalSelUndos] := [selectionCoords]
   recordSelUndoLevelNow()
   ; ToolTip, % currentSelUndoLevel " = p" , , , 2
   If (minimizeMemUsage=1)
   {
      currentUndoLevel := 2
      undoLevelsRecorded := 2
      trGdip_DisposeImage(undoLevelsArray[2, 1], 1)
      undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(L2)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
   } Else
   {
      If (currentUndoLevel>=maxUndoLevels)
      {
         trGdip_DisposeImage(undoLevelsArray[1, 1], 1)
         undoLevelsArray.RemoveAt(1)
         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lmax)", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
      } Else
      {
         currentUndoLevel++
         undoLevelsRecorded++
         If (undoLevelsRecorded>currentUndoLevel)
            undoLevelsRecorded := currentUndoLevel

         undoLevelsArray[currentUndoLevel] := [trGdip_CloneBitmap(A_ThisFunc "(Lx" currentUndoLevel ")", recordedBitmap), dX, dY, currentSelUndoLevel, HasAlpha]
         Loop, % maxUndoLevels + 1 - currentUndoLevel
         {
             trGdip_DisposeImage(undoLevelsArray[currentUndoLevel + A_Index, 1], 1)
             undoLevelsArray[currentUndoLevel + A_Index, 1] := ""
         }
      }
   }

   currentImgModified := 1
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   ResetImgLoadStatus()
   If (A_TickCount - lastInvoked>950)
      SoundBeep , 900, 100
}

terminateIMGediting() {
   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded>0 && currentFileIndex!=imgIndexEditing && minimizeMemUsage=1)
   {
      UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
      userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
      viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
      viewportIDstampBMP := ""
      Loop, 3
      {
          trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
          undoLevelsArray[A_Index, 1] := ""
      }

      gdipObjectsStats(1, "recordUndoLevelNow")
      currentImgModified := 0
      undoSelLevelsArray := []
      currentSelUndoLevel := 1
      currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
      interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
      interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
      Return
   }

   If (StrLen(UserMemBMP)<3 && undoLevelsRecorded<1) || (currentFileIndex=imgIndexEditing && undoLevelsRecorded>1 && currentImgModified=2)
      Return

   currentImgModified := 0
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
   viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
   viewportIDstampBMP := ""

   Loop, 200
   {
       trGdip_DisposeImage(undoLevelsArray[A_Index, 1], 1)
       undoLevelsArray[A_Index, 1] := ""
   }

   gdipObjectsStats(1, "recordUndoLevelNow")
   fnOutputDebug(A_ThisFunc "(): undo/redo levels purged...")
   currentSelUndoLevel := 1
   undoSelLevelsArray := []
   currentUndoLevel := hasReachedMaxUndoLevels := undoLevelsRecorded := 0
   interfaceThread.ahkassign("UserMemBMP", UserMemBMP)
   interfaceThread.ahkassign("undoLevelsRecorded", undoLevelsRecorded)
   maxUndoLevels := (A_PtrSize=8) ? 100 : 2
}

ImgUndoAction(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel - 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel - howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])

   SetTimer, RefreshImageFile, -325
   showTOOLtip("Undo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelUndoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel - 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel - howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection undo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ImgSelRedoAct(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   totalSelUndos := Round(undoSelLevelsArray.Count())
   If (StrLen(undoSelLevelsArray[currentSelUndoLevel + 1, 1])<3 || imageLoading=1 || thumbsDisplaying=1)
   {
      showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentSelUndoLevel := clampInRange(currentSelUndoLevel + howFar, 1, totalSelUndos)
   restorePreviousSelections(currentSelUndoLevel)

   SetTimer, dummyRefreshImgSelectionWindow, -125
   showTOOLtip("Selection redo [ " currentSelUndoLevel " / " totalSelUndos " ]", 0, 0, currentSelUndoLevel/totalSelUndos)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

restorePreviousSelections(thisLevel) {
   selectionCoords := undoSelLevelsArray[thisLevel, 1]
   ; ToolTip, % thisLevel " = k" , , , 2
   If !selectionCoords
      Return

   selectionPrefsArray := StrSplit(selectionCoords, "|")
   imgSelX1 := selectionPrefsArray[1], imgSelY1 := selectionPrefsArray[2]
   imgSelX2 := selectionPrefsArray[3], imgSelY2 := selectionPrefsArray[4]
   prcSelX1 := selectionPrefsArray[5], prcSelY1 := selectionPrefsArray[6]
   prcSelX2 := selectionPrefsArray[7], prcSelY2 := selectionPrefsArray[8]
   vPselRotation := selectionPrefsArray[9]
   rotateSelBoundsKeepRatio := selectionPrefsArray[10]
   EllipseSelectMode := selectionPrefsArray[11]
   LimitSelectBoundsImg := selectionPrefsArray[12]
   showSelectionGrid := selectionPrefsArray[13]
   currentSelUndoLevel := thisLevel
   currentImgModified := 1
}

ImgRedoAction(dummy:=0) {
   Critical, on
   If (StrLen(UserMemBMP)<3 || thumbsDisplaying=1)
      Return

   If (StrLen(undoLevelsArray[currentUndoLevel + 1, 1])<3) || (imageLoading=1)
   {
      friendly := (preventUndoLevels=1) ? "WARNING: Undo levels are not recorded, to limit memory usage`n" : ""
      showTOOLtip(friendly "Redo [ " currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   currentImgModified := 1
   howFar := (dummy="j") ? 4 : 1
   currentUndoLevel := clampInRange(currentUndoLevel + howFar, 1, undoLevelsRecorded)
   UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
   UserMemBMP := trGdip_CloneBitmap(A_ThisFunc, undoLevelsArray[currentUndoLevel, 1])
   currIMGdetails.HasAlpha := undoLevelsArray[currentUndoLevel, 5]
   restorePreviousSelections(undoLevelsArray[currentUndoLevel, 4])
   SetTimer, RefreshImageFile, -325
   showTOOLtip("Redo [ "  currentUndoLevel " / " undoLevelsRecorded " ]", 0, 0, currentUndoLevel/undoLevelsRecorded)
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

ToggleCorePixFmt() {
   friendly := (A_PtrSize=4 && A_is64BitOS) ? "`n`nPlease use the 64-bits edition of this application to enjoy a better experience for image editing and image viewing." : ""
   friendly .= "`n`nUpon application restart, the 32-bits RGBA mode will no longer be activated."
   coreDesiredPixFmt := (coreDesiredPixFmt="0x21808") ? "0xE200B" : "0x21808"
   If (A_PtrSize=4 && coreDesiredPixFmt="0xE200B")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now activated. " appTitle " will now have an increased memory usage. The maximum amount of usable memory on your system is 2 GB." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=4 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. " appTitle " will use less memory, but various image editing options are disabled." friendly, 0, 0, "exclamation")
   Else If (A_PtrSize=8 && coreDesiredPixFmt="0x21808")
      msgBoxWrapper(appTitle ": WARNING", "32-bits RGBA mode is now deactivated. Please note, various image editing options are disabled in 24-bits RGB mode, including proper alpha channel support.`n`nUpon application restart, the 32-bits RGBA mode will be reactivated. This option is only meant help reduce memory usage for old systems.", 0, 0, "exclamation")

   RefreshImageFileAction()
}

alertReduceColorDepth() {
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to edit is downscaled by " appTitle ". Press F5 to reload the original and then begin again to edit the image, at its original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", 0, 0, "exclamation")

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      r := msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel.", "&OK|&Activate 32-RGBA", 1, "exclamation")
   
   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit is at an unsupported color depth for editing: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost.", 0, 0, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", 0, 0, "exclamation")

   If InStr(r, "activate")
   {
      coreDesiredPixFmt := "0xE200B"
      If !undoLevelsRecorded
         RefreshImageFileAction()
   }

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgBoxWrapper(appTitle ": IMAGE EDITING WARNING", "The image you now begin to edit exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will edit it now at an automatically downscaled resolution:" newRes, 0, 0, "exclamation")
   }
}

alertReduceSaveColorDepth() {
   msgResult := "continue"
   If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1 && StrLen(UserMemBMP)<3)
      msgResult := msgBoxWrapper(appTitle ": WARNING" , "PLEASE NOTE! The image you are about to save is downscaled by " appTitle ". Press F5 to reload the original and then save the modified image, at original dimensions.`n`nTo disabled altogether downscaling, press Ctrl+Q in the main window.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   pixFmt := currIMGdetails.PixelFormat  " | " currIMGdetails.RawFormat
   thisImgBPP := SubStr(pixFmt, 1, InStr(pixFmt, "-") - 1)
   If (currIMGdetails.HasAlpha=1 && thisImgBPP=32 && coreDesiredPixFmt="0x21808")
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you now begin to edit has an alpha channel. However, " appTitle " is set to work in 24-RGB space, without an alpha channel, to reduce memory usage.  Please activate 32-RGBA mode to preserve the alpha channel before editing or saving the image.", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (thisImgBPP!=24 && thisImgBPP!=32)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave is originally at an unsupported color depth: " pixFmt "`n`nThe image will be converted to 24 or 32 bits color depth. Therefore, some color information will probably be lost. ", "&Continue|C&ancel", 1, "exclamation")
   Else If (currIMGdetails.Frames>1)
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave has " currIMGdetails.Frames " frames or pages.`n`nOnly the current frame will be preserved, the other frames will be discarded. ", "&Continue|C&ancel", 1, "exclamation")

   If !InStr(msgResult, "continue")
      Return 1

   If (currIMGdetails.TooLargeGDI=1 && StrLen(UserMemBMP)<3)
   {
      infoRes := "`nOriginal resolution: " currIMGdetails.Width " x " currIMGdetails.Height " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
      ; whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
      newRes := "`nDownscaled resolution: " imgW " x " imgH " px | " Round((imgW*imgH)/1000000,2) " MPx"
      msgResult := msgBoxWrapper(appTitle ": IMAGE SAVE WARNING", "The image you intend to resave exceeds the maximum possible dimensions for image editing." infoRes "`n`nYou will be saving an automatically downscaled resolution:" newRes, "&Continue|C&ancel", 1, "exclamation")
   }
   If !InStr(msgResult, "continue")
      Return 1
}

mergeViewPortEffectsImgEditing(funcu:=0, recordUndoAfter:=1, applyOnArea:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    funcuInfo := funcu ? "`n" funcu "()" : ""
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - mergeViewPortEffectsImgEditing() invoked by " funcu "() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return 1
    }

    If testSelectOutsideImgEntirely(whichBitmap)
    {
       showTOOLtip("WARNING: Invalid image selection area..." funcuInfo)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    If (imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)
    {
       showTOOLtip("ERROR: Image editing is disabled...`nThe document size is too large." funcuInfo)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return 1
    }

    alertReduceColorDepth()
    ; mustOpenStartFolder := ""
    imgIndexEditing := currentFileIndex
    currentImgModified := 1
    setImageLoading()
    showTOOLtip("Processing image, please wait..." funcuInfo)
    If markedSelectFile
       dropFilesSelection()

    discardViewPortCaches()
    ; msgbox % UserMemBMP "---" gdiBitmap
    If StrLen(gdiBitmap)>2
    {
       UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
       UserMemBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, gdiBitmap)
    } 

    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If (pEffect || imageAttribs)
       recordUndoLevelNow("init", 0)

    Gdip_GetImageDimensions(UserMemBMP, imgW, imgH)
    If (editingSelectionNow=1 && applyOnArea=1)
    {
       nImgSelX1 := min(imgSelX1, imgSelX2)
       nImgSelY1 := min(imgSelY1, imgSelY2)
       kimgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
       kimgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
       isEntire := (kimgSelW=imgW && kimgSelH=imgH && nImgSelX1=0 && nImgSelY1=0) ? 1 : 0
       allowOnArea := !isEntire
    }

    If pEffect
    {
       If (StrLen(UserMemBMP)>2 && allowOnArea=1)
          Gdip_BitmapApplyEffect(UserMemBMP, pEffect, nImgSelX1, nImgSelY1, kimgSelW, kimgSelH)
       Else If StrLen(UserMemBMP)>2
          Gdip_BitmapApplyEffect(UserMemBMP, pEffect)
       Gdip_DisposeEffect(pEffect)
    }

    If (imageAttribs && StrLen(UserMemBMP)>2)
    {
       bluba := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
       If StrLen(bluba)>2
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, bluba)

       If G2
       {
          If (allowOnArea=1)
             Gdip_SetClipRect(G2, nImgSelX1, nImgSelY1, kimgSelW, kimgSelH)

          r1 := trGdip_DrawImage(A_ThisFunc, G2, UserMemBMP,,,,,,,,,,, imageAttribs)
          If (allowOnArea=1)
          {
             Gdip_ResetClip(G2)
             Gdip_SetClipRect(G2, nImgSelX1, nImgSelY1, kimgSelW, kimgSelH, 4)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, UserMemBMP)
          }
       }

       Gdip_DeleteGraphics(G2)
       Gdip_DisposeImageAttributes(imageAttribs)
       If (r1!="fail" && G2 && StrLen(bluba)>2)
       {
          trGdip_DisposeImage(UserMemBMP, 1)
          UserMemBMP := bluba
       } Else trGdip_DisposeImage(bluba, 1)
    }

    If ((pEffect || imageAttribs) && StrLen(UserMemBMP)>2 && recordUndoAfter!=0 && r1!="fail")
    {
       recordUndoLevelNow(0, UserMemBMP)
       disposeCacheIMGs("soft")
       ; gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime//2
    usrColorDepth := imgFxMode := 1
    RenderOpaqueIMG := vpIMGrotation := 0 ; FlipImgH := FlipImgV := 0
}

CutSelectedArea() {
   If (thumbsDisplaying=1 || editingSelectionNow!=1)
      Return

   CopyImage2clip()
   EraseAreaFader := 0
   Sleep, 350
   EraseSelectedArea()
   ; EraseSelectedArea(1)
}

ApplyColorAdjustsSelectedArea() {
    Static prevFXmode := "n"

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    o_imgFxMode := imgFxMode
    If (imgFxMode>1)
       prevFXmode := imgFxMode
    Else If (prevFXmode!="n")
       imgFxMode := prevFXmode

    If (imgFxMode=1)
    {
       showTOOLtip("No viewport color adjustments to be applied on image...`n`nPress F to cycle through modes`nor press U to open color adjustments panel.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc, 0, 1)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       imgFxMode := o_imgFxMode
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    capSelectionRelativeCoords()
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
    {
       imgFxMode := o_imgFxMode
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
    If pPath
    {
       Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
       Gdip_SetClipPath(G2, pPath, 4)
    } Else 
    {
       showTOOLtip("Failed to apply the viewport color adjustments to the image selected area...`nUnable to create selection path.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    zBitmap := (preventUndoLevels=1) ? gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, 0, 0)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r0!="fail" && r1!="fail" && G2)
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    SetTimer, RefreshImageFile, -25
    Return r1
}

InsertTextSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - InsertTextSelectedArea() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    startOperation := A_TickCount
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 0)
    If obju[1]
    {
       textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
       trGdip_DisposeImage(obju[1], 1)
    }

    coreDesiredPixFmt := o_coreFmt
    Gdip_GetImageDimensions(textBoxu, nImgW, nImgH)
    Gdip_GetRotatedDimensions(nImgW, nImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, ".")
       If StrLen(xBitmap)>3
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
          Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       }
    }

    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, nimgW, nimgH, 0, 0, nimgW, nimgH)
    livePreviewInsertTextinArea("kill")
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_DeleteGraphics(G2)
    zeitOperation := A_TickCount - startOperation
    If (r1!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }

    etaTime := SecToHHMMSS(Round(zeitOperation/1000, 3))
    addJournalEntry("Text drawn on image in: " etaTime)
    SetTimer, RefreshImageFile, -25
}

livePreviewInsertTextinArea(actionu:=0) {
    Static lastInvoked := 1, prevBMPu, prevState, scaleuPreview := 1
    If (actionu="kill")
    {
       prevState := 0
       If StrLen(prevBMPu)>2
          prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    If (TextInAreaLivePreview!=1 || !AnyWindowOpen)
       Return

    ; setImageLoading()
    G2 := 2NDglPG
    Gdip_ResetClip(G2)
    trGdip_GraphicsClear(A_ThisFunc, G2, "0x00" WindowBGRcolor)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    thisState := "a" UserTextArea TextInAreaAlign TextInAreaValign TextInAreaDoBlurs TextInAreaBlurAmount TextInAreaBlurBorderAmount TextInAreaUsrMarginz TextInAreaBgrColor TextInAreaBgrEntire TextInAreaBgrUnified TextInAreaCutOutMode TextInAreaBgrOpacity TextInAreaBorderSize TextInAreaBorderOut TextInAreaBorderColor TextInAreaBorderOpacity TextInAreaFontBold TextInAreaFontColor TextInAreaFontItalic TextInAreaFontName TextInAreaFontLineSpacing TextInAreaFontOpacity TextInAreaFontSize TextInAreaFontStrike TextInAreaFontUline TextInAreaOnlyBorder TextInAreaPaintBgr TextInAreaRoundBoxBgr imgSelW imgSelH mainWidth mainHeight TextInAreaLineAngle TextInAreaCharSpacing TextInAreaAutoWrap
    o_coreFmt := coreDesiredPixFmt
    coreDesiredPixFmt := "0xE200B"
    If (A_TickCount - lastInvoked < 50) || (thisState=prevState)
    {
       textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       If (thisState!=prevState)
          mustGoTimer := 1
    } Else
    {
       obju := coreInsertTextInAreaBox(UserTextArea, imgSelW, imgSelH, 1)
       If obju[1]
       {
          prevState := thisState
          trGdip_DisposeImage(prevBMPu, 1)
          textBoxu := Gdip_CloneBmpPargbArea(A_ThisFunc, obju[1], obju[2], obju[3], obju[4], obju[5],,, 1)
          trGdip_DisposeImage(obju[1], 1)
          scaleuPreview := obju[6]
          prevBMPu := textBoxu
          textBoxu := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)
       }
    }

    startZeit := A_TickCount
    coreDesiredPixFmt := o_coreFmt
    imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
    imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
    imgSelW := max(X1, X2) - min(X1, X2)
    imgSelH := max(Y1, Y2) - min(Y1, Y2)

    Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
    zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
    zImgH := Round((nImgH*zoomLevel)*scaleuPreview)

    Gdip_GetRotatedDimensions(zImgW, zImgH, vPselRotation, rnImgW, rnImgH)
    If (TextInAreaAlign=3)
       imgSelPx := X2 - rnImgW
    Else If (TextInAreaAlign=2)
       imgSelPx := imgSelPx + imgSelW//2 - rnImgW//2

    If (TextInAreaValign=3)
       imgSelPy := Y2 - rnImgH
    Else If (TextInAreaValign=2)
       imgSelPy := imgSelPy + imgSelH//2 - rnImgH//2

    Gdip_SetInterpolationMode(G2, 5)
    If (vPselRotation>0)
    {
       xBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, textBoxu, vPselRotation, "-", 5)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(textBoxu, 1)
          textBoxu := xBitmap
       }
       Gdip_GetImageDimensions(textBoxu, nimgW, nimgH)
       zImgW := Round((nImgW*zoomLevel)*scaleuPreview)
       zImgH := Round((nImgH*zoomLevel)*scaleuPreview)
    }

    Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, textBoxu, imgSelPx, imgSelPy, zimgW, zimgH, 0, 0, nimgW, nimgH)
    trGdip_DisposeImage(textBoxu, 1)
    Gdip_ResetClip(G2)
    livePreviewsImageEditingDrawSelectionBox()
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    Gdip_SetInterpolationMode(G2, thisImgQuality)
    Gdip_SetSmoothingMode(G2, 4)
    r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    If (A_TickCount - startZeit<65) && (mustGoTimer=1)
       livePreviewsImageEditing()
    Else If (mustGoTimer=1)
       SetTimer, livePreviewInsertTextinArea, -100
    ; Else
       ; SetTimer, ResetImgLoadStatus, -200
    lastInvoked := A_TickCount
}

FillSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - FillSelectedArea() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    startZeit := A_TickCount
    If (FillAreaDoContour=1)
       FillAreaRemBGR := 0

    recordUndoLevelNow("init", 0)
    mustRemBackground := FillAreaRemBGR
    If (UserMemBMP!=whichBitmap && mustRemBackground!=1)
       disposableBMP := whichBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)

    kBitmap := whichBitmap
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (mustRemBackground=1 && FillAreaDoContour!=1)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
    Else
       pBitmap := whichBitmap

    If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
    {
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4)
    pPath := coreFillSelectedArea(G2, whichBitmap, kBitmap)
    If (pPath="fail")
    {
       Gdip_DeleteGraphics(G2)
       trGdip_DisposeImage(disposableBMP, 1)
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    Gdip_ResetClip(G2)
    modus := (FillAreaInverted=1) ? 0 : 4
    If (mustRemBackground=1 && FillAreaDoContour!=1 && pPath)
       Gdip_SetClipPath(G2, pPath, modus)

    If (mustRemBackground=1 && FillAreaDoContour!=1)
    {
       currIMGdetails.HasAlpha := 1
       r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap)
       If (UserMemBMP=whichBitmap)
          UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    }

    Gdip_DeleteGraphics(G2)
    coreFillSelectedArea("kill")
    UserMemBMP := pBitmap
    recordUndoLevelNow(0, UserMemBMP)
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Fill selected area operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
    SetTimer, RefreshImageFile, -25
}

coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH) {
    pPath := Gdip_CreatePath()
    If (FillAreaShape=1) ; rect
    {
       Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (FillAreaShape=2) ; rounded rect
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       Gdip_AddPathRoundedRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, radius)
    } Else If (FillAreaShape=3) ; ellipse
    {
       Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
    } Else If (FillAreaShape=4) ; triangle
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (FillAreaShape=5) ; right triangle
    {
       cX1 := imgSelPx
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH
       cX3 := imgSelPx + imgSelW
       cY3 := imgSelPy + imgSelH
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3)
    } Else If (FillAreaShape=6) ; rhombus
    {
       cX1 := imgSelPx + imgSelW//2
       cY1 := imgSelPy
       cX2 := imgSelPx
       cY2 := imgSelPy + imgSelH//2
       cX3 := imgSelPx + imgSelW//2
       cY3 := imgSelPy + imgSelH
       cX4 := imgSelPx + imgSelW
       cY4 := imgSelPy + imgSelH//2
       Gdip_AddPathPolygon(pPath, cX1 "," cY1 "|" cX2 "," cY2 "|" cX3 "," cY3 "|" cX4 "," cY4)
    } Else If (FillAreaShape=7 && FillAreaCurveTension=1)
    {
       PointsList := convertCustomShape2toReferencedArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       ; ToolTip, % customShapePoints "`nLOL" PointsList , , , 2
       If (FillAreaDoContour!=1 || FillAreaClosedPath=1)
          Gdip_AddPathPolygon(pPath, PointsList)
       Else
          Gdip_AddPathLines(pPath, PointsList)
    } Else If (FillAreaShape=7)
    {
       PointsList := convertCustomShape2toReferencedArea(customShapePoints, imgSelPx + 1, imgSelPy + 1, imgSelW, imgSelH)
       If (FillAreaDoContour!=1 || FillAreaClosedPath=1)
          Gdip_AddPathClosedCurve(pPath, PointsList, tensionCurveCustomShape)
       Else
          Gdip_AddPathCurve(pPath, PointsList, tensionCurveCustomShape)
    }
    Return pPath
}

DrawRoundedRectangle2(pGraphics, pPen, x, y, w, h, r, Angle:=0) {
; extracted from: https://github.com/tariqporter/Gdip2/blob/master/lib/Object.ahk
; and adapted by Marius Șucan

   penWidth := Gdip_GetPenWidth(pPen)
   pw := penWidth / 2
   if (w <= h && (r + pw > w / 2))
   {
      r := (w / 2 > pw) ? w / 2 - pw : 0
   } else if (h < w && r + pw > h / 2)
   {
      r := (h / 2 > pw) ? h / 2 - pw : 0
   } else if (r < pw / 2)
   {
      r := pw / 2
   }

   r2 := r * 2
   path1 := Gdip_CreatePath(0)
   Gdip_AddPathArc(path1, x + pw, y + pw, r2, r2, 180, 90)
   Gdip_AddPathLine(path1, x + pw + r, y + pw, x + w - r - pw, y + pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + pw, r2, r2, 270, 90)
   Gdip_AddPathLine(path1, x + w - pw, y + r + pw, x + w - pw, y + h - r - pw)
   Gdip_AddPathArc(path1, x + w - r2 - pw, y + h - r2 - pw, r2, r2, 0, 90)
   Gdip_AddPathLine(path1, x + w - r - pw, y + h - pw, x + r + pw, y + h - pw)
   Gdip_AddPathArc(path1, x + pw, y + h - r2 - pw, r2, r2, 90, 90)
   Gdip_AddPathLine(path1, x + pw, y + h - r - pw, x + pw, y + r + pw)
   Gdip_ClosePathFigure(path1)
   If (Angle>0)
      Gdip_RotatePathAtCenter(path1, Angle, 1, 1, rotateSelBoundsKeepRatio)
   _E := Gdip_DrawPath(pGraphics, pPen, path1)
   Gdip_DeletePath(path1)
   return _E
}

PersonalizedRotatePath(pPath, angle, x, y, w, h, withinBounds:=0, withinBkeepRatio:=1, EllipseMode:=1) {
  dummyPath := Gdip_CreatePath()
  If (EllipseMode=1)
     Gdip_AddPathEllipse(dummyPath, x, y, w, h)
  Else
     Gdip_AddPathRectangle(dummyPath, x, y, w, h)

  MatrixOrder := 1
  Rect := Gdip_GetPathWorldBounds(dummyPath)
  cX := Rect.x + (Rect.w / 2)
  cY := Rect.y + (Rect.h / 2)
  pMatrix := Gdip_CreateMatrix()
  Gdip_TranslateMatrix(pMatrix, -cX , -cY)
  Gdip_RotateMatrix(pMatrix, Angle, MatrixOrder)
  Gdip_TranslateMatrix(pMatrix, cX, cY, MatrixOrder)
  E := Gdip_TransformPath(dummyPath, pMatrix)
  E := Gdip_TransformPath(pPath, pMatrix)
  Gdip_DeleteMatrix(pMatrix)
  If (withinBounds=1 && !E && Angle!=0)
  {
     nRect := Gdip_GetPathWorldBounds(dummyPath)
     ncX := nRect.x + (nRect.w / 2)
     ncY := nRect.y + (nRect.h / 2)
     pMatrix := Gdip_CreateMatrix()
     Gdip_TranslateMatrix(pMatrix, -ncX , -ncY)
     sX := Rect.w / nRect.w
     sY := Rect.h / nRect.h
     If (withinBkeepRatio=1)
     {
        sX := min(sX, sY)
        sY := min(sX, sY)
     }
     Gdip_ScaleMatrix(pMatrix, sX, sY, MatrixOrder)
     Gdip_TranslateMatrix(pMatrix, ncX, ncY, MatrixOrder)
     If (sX!=0 && sY!=0)
     {
        E := Gdip_TransformPath(pPath, pMatrix)
        E := Gdip_TransformPath(dummyPath, pMatrix)
     }
     Gdip_DeleteMatrix(pMatrix)
  }
  Gdip_DeletePath(dummyPath)
}

coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode:=0) {
    Static prevState, prevBMPu
    If (whichBitmap="kill")
    {
       prevState := 0
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       Return
    }

    thisState := "a" whichBitmap dimgSelPx dimgSelPy dimgSelW dimgSelH thisQuality G2 imgSelPx imgSelPy imgSelW imgSelH mainWidth mainHeight BlurAmount
    If (thisState!=prevState || G2!=2NDglPG || !prevBMPu)
    {
       ; ToolTip, % thisState , , , 2
       prevBMPu := trGdip_DisposeImage(prevBMPu, 1)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH)
       thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, dimgSelW//2+2, dimgSelH//2 + 2, 0, thisQuality, -1)
       If !warnUserFatalBitmapError(thisBMP, A_ThisFunc)
       {
          trGdip_DisposeImage(zBitmap, 1)
          zBitmap := thisBMP

          setWindowTitle("Blurring image, please wait...")
          afterVPresize := (AnyWindowOpen && G2=2NDglPG) ? Round(dimgSelW*zoomLevel) * Round(dimgSelH*zoomLevel) : 1
          preVPresize := dimgSelW//2 * dimgSelH//2
          applyBlurAfter := (afterVPresize<preVPresize && afterVPresize!=1) ? 1 : 0
          If (applyBlurAfter=0 || G2!=2NDglPG)
          {
             BlurAmountA := BlurAmount + 1
             BlurAmountA := clampInRange(BlurAmountA, 2, 255)
             pzEffect := Gdip_CreateEffect(1, BlurAmountA, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, zBitmap, BlurAmountA, pzEffect, previewMode)
          }
       }

       If (AnyWindowOpen && G2=2NDglPG)
       {
          thisBMP := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, Round(dimgSelW*zoomLevel), Round(dimgSelH*zoomLevel), 0, thisQuality, -1)
          If (applyBlurAfter=1)
          {
             BlurAmountB := Round(BlurAmount*zoomLevel)*2
             BlurAmountB := clampInRange(BlurAmountB, 2, 254)
             zEffect := Gdip_CreateEffect(1, BlurAmountB, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, thisBMP, BlurAmountB, zEffect, previewMode)
          }

          trGdip_DisposeImage(zBitmap, 1)
       } Else thisBMP := zBitmap
       prevBMPu := thisBMP
       prevState := thisState
       thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, thisBMP)
    } Else thisPBitmap := trGdip_CloneBitmap(A_ThisFunc, prevBMPu)

    Gdip_SetClipPath(G2, pPath, 0)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If pEffect
       Gdip_BitmapApplyEffect(thisPBitmap, pEffect)

    If (AnyWindowOpen && G2=2NDglPG)
       Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, thisPBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,,,, imageAttribs)
    trGdip_DisposeImage(thisPBitmap, 1)
    Gdip_ResetClip(G2)
    setWindowTitle(pVwinTitle, 1)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DisposeEffect(pzEffect)
}

testSelectionLargerThanViewport() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    obju := []
    obju.mainWidth := mainWidth
    obju.mainHeight := mainHeight
    vPimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    obju.isLarger := (MAINmpx<VPmpx) ? 1 : 0
    Return obju
}

trGdip_DrawImage(funcu, pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1, Unit:=2, ImageAttr:=0) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using pG=" pGraphics ", pBMP=" pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImage(pGraphics, pBitmap, dx, dy, dw, dh, sx, sy, sw, sh, Matrix, Unit, ImageAttr)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to draw the processed image in the internal graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics " and pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsFromImage(funcu, pBitmap, InterpolationMode:="", SmoothingMode:="", PageUnit:="", CompositingQuality:="") {
  If !pBitmap
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() for pBitmap = " pBitmap)
     Return
  }

  r := Gdip_GraphicsFromImage(pBitmap, InterpolationMode, SmoothingMode, PageUnit, CompositingQuality)
  If (!r || gdipLastError)
  {
     baseMsg := "Unable to create virtual graphics object required for processing the image... Error occured in " A_ThisFunc "() invoked by " funcu "() for pBMP=" pBitmap ". "
     generalInternalErrorMsgBox(gdipLastError, baseMsg)
     Return
  } Else Return r
}

trGdip_DrawImageFX(funcu, pGraphics, pBitmap, dX:="", dY:="", sX:="", sY:="", sW:="", sH:="", matrix:="", pEffect:="", ImageAttr:=0, hMatrix:=0, Unit:=2) {
  If (!pGraphics || !pBitmap)
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() using " pGraphics ", " pBitmap)
     Return "fail"
  }

  r := Gdip_DrawImageFX(pGraphics, pBitmap, dX, dY, sX, sY, sW, sH, matrix, pEffect, ImageAttr, hMatrix, Unit)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to modify the image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "(). "
     generalInternalErrorMsgBox(r, baseMsg)
     Return "fail"
  }
}

trGdip_GraphicsClear(funcu, pGraphics, coloru:=0x00ffFFff, silentMode:=0) {
  If !pGraphics
  {
     addJournalEntry("Internal error. " A_ThisFunc "() called by " funcu "() on graphics = " pGraphics ". ")
     Return "fail"
  }

  r := Gdip_GraphicsClear(pGraphics, coloru)
  If (r=1 && A_LastError=8)
     r := 3

  If r
  {
     baseMsg := "Unable to apply operations on image graphics object... Error occured in " A_ThisFunc "() invoked by " funcu "() for pG=" pGraphics ". "
     generalInternalErrorMsgBox(r, baseMsg, silentMode)
     Return "fail"
  }
}

QPV_SaveImageFile(funcu, pBitmap, file2save, jpegQuality) {
   r := Gdip_SaveBitmapToFile(pBitmap, file2save, jpegQuality)
   If (r=-5)
      r := Gdip_ErrorHandler(gdipLastError, 0)
   Else If r
      r .= " / " A_LastError

   If r
   {
      addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with GDI+: " file2save "`nError code: " r)
      zr := SaveFIMfile(file2save, pBitmap)
      If (!zr && wasInitFIMlib=1)
         r := zr
      Else If (wasInitFIMlib=1)
         addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed to save image with FreeImage: " file2save "`nError code: " zr)
   }

   Return r
}

warnUserFatalBitmapError(pBitmap, funcu) {
    If (StrLen(pBitmap)<3 || pBitmap="err" || pBitmap="fail")
    {
       r := (pBitmap="no-gdip") ? 0 : gdipLastError
       baseMsg := "Unable to create internal bitmap to apply operations on image... Error occured in Gdip_CreateBitmap() invoked by " funcu  "(). "
       generalInternalErrorMsgBox(r, baseMsg)
       Return "fail"
    }
}

coreFillSelectedArea(G2:=0, whichBitmap:=0, ywbmp:=0) {
    Static prevPath, noRepeat := 0
    If (G2="kill")
    {
       Gdip_DeletePath(prevPath)
       prevPath := ""
       coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       Return
    }

    decXu := decYu := decWu := decHu := 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    vPimgSelW := (!G2 && FillAreaInverted=1) ? mainWidth : max(selDotX, selDotAx) - min(selDotX, selDotAx) + SelDotsSize//2
    vPimgSelH := (!G2 && FillAreaInverted=1) ? mainHeight : max(selDotY, selDotAy) - min(selDotY, selDotAy) + SelDotsSize//2
    VPmpx := Round((vPimgSelW*vPimgSelH)/1000000, 3)
    MAINmpx := Round((mainWidth*mainHeight)/1000000, 3) + 0.01
    dropSpecialFX := (MAINmpx<VPmpx && !G2) ? 1 : 0
    If (FillAreaBlendMode>1 && FillAreaDoContour!=1 && FillAreaRemBGR!=1)
    {
       If whichBitmap
          Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

       If (vPimgSelW>mainWidth)
          decWu := mainWidth - vPimgSelW
       If (vPimgSelH>mainHeight)
          decHu := mainHeight - vPimgSelH

       ; vPimgSelW := clampInRange(vPimgSelW, 2, mainWidth)
       ; vPimgSelH := clampInRange(vPimgSelH, 2, mainHeight)
       o_whichBitmap := whichBitmap
       If !G2
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, vPimgSelW, vPimgSelH, "0xE200B")
       Else
          whichBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")

       If warnUserFatalBitmapError(whichBitmap, A_ThisFunc)
          Return "fail"

       o_G2 := G2 ? G2 : 2NDglPG
       If !G2
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 5, 3)
       Else
          G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)

       mustDoBlendMode := 1
    } Else
    {
       If !whichBitmap
          whichBitmap := useGdiBitmap()
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    maxLength := (imgSelW + imgSelH)//2
    thisThick := (FillAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : FillAreaContourThickness
    If (!G2 || 2NDglPG=o_G2)
    {
       previewMode := 1
       thisThick := thisThick*zoomLevel
       If (mustDoBlendMode=1)
       {
          imgSelPx := x1 := SelDotsSize//2, x2 := vPimgSelW
          imgSelPy := y1 := SelDotsSize//2, y2 := vPimgSelH
          imgSelW := imgW := vPimgSelW ; + decWu
          imgSelH := imgH := vPimgSelH ; + decHu
          If (imgSelPx>selDotX + SelDotsSize)
             decXu := imgSelPx - selDotX - SelDotsSize

          If (imgSelPy>selDotY + SelDotsSize)
             decYu := imgSelPy - selDotY - SelDotsSize
       } Else
       {
          o_G2 := G2 := 2NDglPG
          imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
          imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
          imgSelW := max(X1, X2) - min(X1, X2)
          imgSelH := max(Y1, Y2) - min(Y1, Y2)
          imgW := mainWidth
          imgH := mainHeight
       }

       Gdip_ResetClip(o_G2)
       trGdip_GraphicsClear(A_ThisFunc, o_G2, "0x00" WindowBGRcolor)
       Gdip_SetClipRect(o_G2, 0, 0, mainWidth, mainHeight)
       If (decXu>1 || decYu>1 || decWu>1 || decHu>1) && (mustDoBlendMode=1)
       {
          diffu := SelDotsSize
          thisW := min(vPimgSelW, mainWidth) + diffu
          thisH := min(vPimgSelH, mainHeight) + diffu
          thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
          thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
          If (FillAreaInverted!=1)
             Gdip_SetClipRect(G2, decXu, decYu, thisW, thisH)
       }
    } Else previewMode := 0

    dR := (FillAreaContourAlign=3) ? thisThick//2 : 0
    If (FillAreaContourAlign=1)
       dR := -thisThick//2

    If (FillAreaDoContour!=1)
    {
       dR := thisThick := 0
    } Else
    {
       imgSelPx -= dR
       imgSelPy -= dR
       imgSelW += dR*2
       imgSelH += dR*2
    }

    If (FillAreaGlassy=2)
       BlurAmount := 15
    Else If (FillAreaGlassy=3)
       BlurAmount := 50
    Else If (FillAreaGlassy=4)
       BlurAmount := 120
    Else If (FillAreaGlassy=5)
       BlurAmount := 180
    Else If (FillAreaGlassy=6)
       BlurAmount := 250
    Else
       BlurAmount := 0

    ; prepare the brush
    Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
    thisColorA := Gdip_ToARGB(FillAreaOpacity, R, G, B)
    Gdip_FromARGB("0xFF" FillArea2ndColor, A, R, G, B)
    thisColorB := Gdip_ToARGB(FillArea2ndOpacity, R, G, B)
    If (FillAreaColorReversed=1 && FillAreaColorMode>1 && FillAreaDoContour!=1)
    {
       tempu := thisColorA
       thisColorA := thisColorB
       thisColorB := tempu
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
    {
       rimgSelW := max(selDotX, selDotAx) - min(selDotX, selDotAx) ; + SelDotsSize//2
       rimgSelH := max(selDotY, selDotAy) - min(selDotY, selDotAy) ; + SelDotsSize//2
       rimgSelX := selDotX + SelDotsSize//2
       rimgSelY := selDotY + SelDotsSize//2
       brImgSelW := Round(rImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(rImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := rimgSelX - (brImgSelW - rimgSelW)//2
       brimgSelPy := rimgSelY - (brImgSelH - rimgSelH)//2
    } Else
    {
       brImgSelW := Round(ImgSelW*(FillAreaGradientScale/100))
       brImgSelH := Round(ImgSelH*(FillAreaGradientScale/100))
       brimgSelPx := imgSelPx - (brImgSelW - imgSelW)//2
       brimgSelPy := imgSelPy - (brImgSelH - imgSelH)//2
    }

    If (FillAreaColorMode=1 || FillAreaDoContour=1)
    {
       Brush := Gdip_BrushCreateSolid(thisColorA)
    } Else If (FillAreaColorMode=2)
    {
       Brush := Gdip_CreateLinearGrBrushFromRect(brimgSelPx + Round(brImgSelW*alphaMaskOffsetX), brimgSelPy + Round(brImgSelH*alphaMaskOffsetY), brimgSelW, brimgSelH, thisColorA, thisColorB, 1, FillAreaGradientWrapped)
       Gdip_RotateLinearGrBrushAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       ; Gdip_SetLinearGrBrushSigmaBlend(Brush, FillAreaGradientSigma/100, 1)
       Gdip_SetLinearGrBrushPresetBlend(Brush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
    } Else If (FillAreaColorMode=3 || FillAreaColorMode=4)
    {
       grpPath := Gdip_CreatePath()
       If (FillAreaColorMode=3)
          Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
       Else
          Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

       Brush := Gdip_PathGradientCreateFromPath(grpPath)
       If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
          Gdip_PathGradientSetCenterPoint(Brush, rimgSelX + rimgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), rimgSelY + rimgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))
       Else
          Gdip_PathGradientSetCenterPoint(Brush, imgSelPx + imgSelW//2 + Round(brImgSelW*alphaMaskOffsetX), imgSelPy + imgSelH//2 + Round(brImgSelH*alphaMaskOffsetY))
       Gdip_SetLinearGrBrushPresetBlend(Brush, 0, FillAreaGradientSigma/100, FillAreaGradientBlend/100, 1, thisColorA, thisColorA, thisColorB, thisColorB)
       Gdip_RotatePathGradientAtCenter(Brush, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
       Gdip_PathGradientSetWrapMode(Brush, FillAreaGradientWrapped - 1)
       Gdip_DeletePath(grpPath)
       If AnyWindowOpen
       {
          Gdip_SetInterpolationMode(G2, 5)
          Gdip_SetSmoothingMode(G2, 1)
       }
    } Else If (FillAreaColorMode=5) ; not implemented yet - to-do
    {
       modelu := 1
       ; Random, modelu, 1, 6
       Random, iterations, 10, 30
       coredrawWelcomeImg(G2, thisColorA, thisColorB, modelu, iterations, 5, 5, imgSelW, imgSelH)
       ; SoundBeep 
    }

    If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
       pPath := coreCreateFillAreaShape(rimgSelX, rimgSelY, rimgSelW, rimgSelH)
    Else
       pPath := coreCreateFillAreaShape(imgSelPx, imgSelPy, imgSelW, imgSelH)

    If (vPselRotation>0 && pPath)
    {
       If (FillAreaShape=4 || FillAreaShape=5)
       {
          If (FillAreaInverted=1 && mustDoBlendMode=1 && previewMode=1)
             PersonalizedRotatePath(pPath, vPselRotation, rimgSelX, rimgSelY, rimgSelW, rimgSelH, 1, rotateSelBoundsKeepRatio, 0)
          Else
             PersonalizedRotatePath(pPath, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       } Else
          Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    }
    
    ; draw the shape
    mustRemBackground := FillAreaRemBGR
    If (FillAreaInverted=1 && FillAreaDoContour!=1)
    {
       Gdip_SetClipPath(G2, pPath, 4)
       If (FillAreaGlassy>1 && FillAreaRemBGR!=1 && BlurAmount>1 || mustDoBlendMode=1)
       {
          If (previewMode=1)
          {
             bgrBMPu := getImgSelectedAreaEditMode(1, 0, 0, mainWidth, mainHeight, mainWidth, mainHeight, BlurAmount)
          } Else
          {
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, ywbmp)
             If (BlurAmount>1)
             {
                zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
                ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
                Gdip_DisposeEffect(zrEffect)
             }
          }

          If StrLen(bgrBMPu)>3
          {
             If (previewMode!=1)
                trGdip_GraphicsClear(A_ThisFunc, G2)

             If (mustDoBlendMode=1)
             {
                threads := (previewMode=1) ? realSystemCores//2 : 0
                Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)
                QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
                thisG2 := (previewMode=1) ? 2NDglPG : o_G2
                trGdip_DrawImage(A_ThisFunc, thisG2, bgrBMPu)
                trGdip_DisposeImage(whichBitmap, 1)
                Gdip_DeleteGraphics(G2)
             } Else trGdip_DrawImage(A_ThisFunc, G2, bgrBMPu)
             trGdip_DisposeImage(bgrBMPu, 1)
          }
       }

       If (mustRemBackground=1 && AnyWindowOpen && (o_G2=2NDglPG || G2=2NDglPG))
          Gdip_FillRectangle(G2, useHatchedBrush(), -2, -2, imgW + 2, imgH + 2)

       If (mustDoBlendMode!=1)
          Gdip_FillRectangle(G2, Brush, -2, -2, imgW + 2, imgH + 2)
    } Else If (FillAreaDoContour=1)
    {
       radius := Round(((imgSelW + imgSelH)//2)*0.1) + 1
       thisPen := Gdip_CreatePen(thisColorA, thisThick)
       If (FillAreaRoundedCaps=1)
          Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

       compoundArray := "0.0|0.33|0.67|1.0"
       Gdip_SetPenDashStyle(thisPen, FillAreaDashStyle - 1)
       If (FillAreaDoubleLine=1)
          Gdip_SetPenCompoundArray(thisPen, compoundArray)

       If (FillAreaShape=2)
          DrawRoundedRectangle2(G2, thisPen, imgSelPx - thisThick//2, imgSelPy - thisThick//2, imgSelW + thisThick, imgSelH + thisThick, radius, vPselRotation)
       Else
          Gdip_DrawPath(G2, thisPen, pPath)

       Gdip_DeletePen(thisPen)
    } Else
    {
       If (mustRemBackground=1 && AnyWindowOpen && G2=2NDglPG)
          Gdip_FillPath(G2, useHatchedBrush(), pPath)
       
       thisQuality := (G2=2NDglPG && AnyWindowOpen) ? 5 : 3
       canBlur := (G2=2NDglPG && AnyWindowOpen && FillAreaLivePreview=1 || G2!=2NDglPG) ? 1 : 0
       opacityLevels := (FillAreaColorMode=1 && FillAreaOpacity<253) || (FillAreaColorMode>1 && (FillAreaOpacity<253 || FillArea2ndOpacity<253)) ? 1 : 0
       ; MsgBox, % "a" canBlur "=" mustRemBackground "=" FillAreaGlassy "=" opacityLevels

       If (canBlur=1 && dropSpecialFX!=1 && FillAreaBlendMode=1 && FillAreaRemBGR!=1 && !testSelectOutsideImgEntirely(whichBitmap) && FillAreaGlassy>1 && opacityLevels=1)
       {
          Gdip_GetImageDimensions(whichBitmap, aimgW, aimgH)
          calcImgSelection2bmp(0, aimgW, aimgH, Round(aimgW*zoomLevel), Round(aimgH*zoomLevel), dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, vPselRotation)
          coreFillGlassFX(whichBitmap, dimgSelPx, dimgSelPy, dimgSelW, dimgSelH, thisQuality, G2, pPath, imgSelPx, imgSelPy, imgSelW, imgSelH, mainWidth, mainHeight, BlurAmount, previewMode)
          If (!AnyWindowOpen && G2!=2NDglPG)
             coreFillGlassFX("kill", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
       }

       If (AnyWindowOpen && G2=2NDglPG)
          Gdip_SetClipRect(G2, 0, 0, mainWidth, mainHeight, 1)

       ; thisStartZeit := A_TickCount
       Gdip_FillPath(G2, Brush, pPath)
       ; ToolTip, % brImgSelW "--" brImgSelH "==" thisW "--" thisH "==" A_TickCount - thisStartZeit , , , 2

       If (FillAreaDoContour=0 && (FillAreaColorMode=4 || FillAreaColorMode=3) && (FillAreaGradientScale>=99 || FillAreaGradientWrapped!=1))
       {
          sBrush := Gdip_BrushCreateSolid(thisColorB)
          grpPath := Gdip_CreatePath()
          If (sBrush && grpPath)
          {
             If (FillAreaColorMode=3)
                Gdip_AddPathEllipse(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)
             Else
                Gdip_AddPathRectangle(grpPath, brimgSelPx, brimgSelPy, brimgSelW, brimgSelH)

             Gdip_RotatePathAtCenter(grpPath, Mod(Round(FillAreaGradientAngle + vPselRotation), 360), 1)
             Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgSelW, imgSelH)
             Gdip_SetClipPath(G2, grpPath, 4)
             Gdip_FillPath(G2, sBrush, pPath)
             Gdip_DeleteBrush(sBrush)
             Gdip_DeletePath(grpPath)
          }
       }

       If (mustDoBlendMode=1)
       {
          If (previewMode=1)
             Gdip_ResetClip(o_G2)

          thisBlurAmount := 0
          If (BlurAmount>1 && FillAreaGlassy>1 && previewMode=1 && FillAreaLivePreview=1 && dropSpecialFX!=1)
             thisBlurAmount := clampInRange(BlurAmount, 1, 255)

          If (previewMode=1)
          {
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)

             diffu := SelDotsSize
             thisW := min(vPimgSelW, mainWidth) + diffu
             thisH := min(vPimgSelH, mainHeight) + diffu
             thisX := max(- diffu//2, selDotX) ; + SelDotsSize//2
             thisY := max(- diffu//2, selDotY) ; + SelDotsSize//2
             kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, decXu, decYu, thisW, thisH,,,1)
             trGdip_DisposeImage(whichBitmap)
             whichBitmap := kBitmap
             bgrBMPu := getImgSelectedAreaEditMode(1, thisX, thisY, thisW, thisH, thisW, thisH, thisBlurAmount)
          } Else
             bgrBMPu := trGdip_CloneBitmap(A_ThisFunc, o_whichBitmap)

          If (BlurAmount>1 && FillAreaGlassy>1 && FillAreaRemBGR!=1 && previewMode!=1)
          {
             BlurAmount := clampInRange(BlurAmount, 2, 254)
             zrEffect := Gdip_CreateEffect(1, BlurAmount, 0, 0)
             ApplySpecialFixedBlur(A_ThisFunc, bgrBMPu, BlurAmount, zrEffect)
             Gdip_DisposeEffect(zrEffect)
          }

          If (previewMode!=1)
          {
             G3 := trGdip_GraphicsFromImage(A_ThisFunc, bgrBMPu)
             modus := (FillAreaInverted=1) ? 0 : 4
             Gdip_SetClipPath(G3, pPath, modus)
             trGdip_GraphicsClear(A_ThisFunc, G3)
             Gdip_DeleteGraphics(G3)
          }

          threads := (previewMode=1) ? realSystemCores//2 : 0
          QPV_BlendBitmaps(bgrBMPu, whichBitmap, FillAreaBlendMode - 1, threads)
          If (previewMode=1)
             r1 := trGdip_DrawImage(A_ThisFunc, 2NDglPG, bgrBMPu, thisX, thisY)
          Else
             r1 := trGdip_DrawImage(A_ThisFunc, o_G2, bgrBMPu)

          trGdip_DisposeImage(bgrBMPu, 1)
          trGdip_DisposeImage(whichBitmap, 1)
          Gdip_DeleteGraphics(G2)
       }
    }

    Gdip_DeleteBrush(Brush)
    If (previewMode=1)
    {
       Gdip_DeletePath(pPath)
       pPath := ""
       thisImgQuality := (userimgQuality=1) ? 7 : 5
       smoothMode := (userimgQuality=1) ? 4 : 1
       Gdip_SetInterpolationMode(G2, thisImgQuality)
       Gdip_SetSmoothingMode(G2, smoothMode)
       Gdip_ResetClip(G2)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    }

    prevPath := pPath
    Return pPath
}

carvePathFromBitmap(pBitmap, pPath, cX, cY, modus) {
    G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
    If G3
    {
       ; Gdip_GetImageDimensions(pBitmap, qImgW, qImgH)
       zPath := Gdip_ClonePath(pPath)
       pMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(pMatrix, -cX , -cY)
       E := Gdip_TransformPath(zPath, pMatrix)
       Gdip_SetClipPath(G3, zPath, modus)
       r1 := trGdip_GraphicsClear(A_ThisFunc, G3)
       Gdip_DeletePath(zPath)
       Gdip_DeleteMatrix(pMatrix)
       Gdip_DeleteGraphics(G3)
    }

    If (!G3 || r1="fail")
       Return "fail"
}

GraySelectedArea() {
   EraseOrInvertOrGraySelectedArea("desaturate", A_ThisFunc)
}

InvertSelectedArea() {
   EraseOrInvertOrGraySelectedArea("invert", A_ThisFunc)
}

EraseSelectedArea() {
   EraseOrInvertOrGraySelectedArea("erase", A_ThisFunc)
}

FlipSelectedAreaH() {
    EraseOrInvertOrGraySelectedArea("flip-h", A_ThisFunc)
}

FlipSelectedAreaV() {
    EraseOrInvertOrGraySelectedArea("flip-v", A_ThisFunc)
}

EraseOrInvertOrGraySelectedArea(actionu, funcu) {
    If (editingSelectionNow!=1 && thumbsDisplaying!=1 && actionu!="erase")
       selectEntireImage("r")

    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(funcu)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(!LimitSelectBoundsImg, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    G2 := trGdip_GraphicsFromImage(funcu, whichBitmap, 7, 4)
    infoFriendly := (actionu="flip" || actionu="flip" ) ? actionu : actionu " the colours in"
    If !G2
    {
       showTOOLtip("Failed to " infoFriendly " the selected area...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    recordUndoLevelNow("init", 0)
    If (!gdiBitmap && preventUndoLevels=1)
    {
       hasCloned := 1
       o_gdiBitmap := Gdip_CloneBmpPargbArea(funcu, UserMemBMP)
    } Else o_gdiBitmap := gdiBitmap

    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
    If pPath
    {
       Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
       Gdip_SetClipPath(G2, pPath)
    } Else 
    {
       showTOOLtip("Failed to " infoFriendly " the selected area...`nUnable to create selection path.")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SetTimer, ResetImgLoadStatus, -250
       Return
    }

    r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
    If !r0
       currIMGdetails.HasAlpha := 1

    If (actionu="erase")
    {
       matrix := (EraseAreaFader=1) ?  EraseAreaOpacity / 256 : 0
    } Else If (actionu="invert")
    {
       matrix := GenerateColorMatrix(6, 1, 0, 1)
    } Else If (actionu="desaturate")
    {
       matrix := GenerateColorMatrix(2)
       If !isWinXP
          pEffect := Gdip_CreateEffect(6, 0, -40, 0)
    } Else If InStr(actionu, "flip")
    {
       matrix := 1
       thisW := imgSelW + imgSelPx*2
       thisH := imgSelH + imgSelPy*2
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)
       If (actionu="flip-h")
       {
          Gdip_ScaleWorldTransform(G2, -1, 1)
          Gdip_TranslateWorldTransform(G2, -thisW, 0)
       } Else If (actionu="flip-v")
       {
          Gdip_ScaleWorldTransform(G2, 1, -1)
          Gdip_TranslateWorldTransform(G2, 0, -thisH)
       }
    }

    zBitmap := (preventUndoLevels=1) ? o_gdiBitmap : undoLevelsArray[currentUndoLevel, 1] 
    If (!pEffect && matrix)
       r1 := trGdip_DrawImage(funcu, G2, zBitmap, 0, 0,,,,,,, matrix)
    Else If pEffect
       r1 := trGdip_DrawImageFX(funcu, G2, zBitmap,,,,,,, matrix, pEffect)

    Gdip_DeletePath(pPath)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeleteGraphics(G2)
    If hasCloned
       trGdip_DisposeImage(o_gdiBitmap, 1)

    If (r0!="fail" && r1!="fail" && G2)
    {
       currIMGdetails.HasAlpha := 0
       isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
       If (actionu="erase") || (InStr(actionu, "flip") && isInside=0)
          currIMGdetails.HasAlpha := 1

       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
}

ResizeIMGviewportSelection() {
    stopNow := (editingSelectionNow=1 && StrLen(gdiBitmap)>4) ? 0 : 1
    If (stopNow=1)
       Return 

    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 ||!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    thisQuality := (userimgQuality=1) ? 7 : 5
    newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgSelW, imgSelH, 0, thisQuality, -1)
    If StrLen(newBitmap)<2
    {
       SetTimer, ResetImgLoadStatus, -150
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
    UserMemBMP := newBitmap

    editingSelectionNow := 0
    vpIMGrotation := 0
    updateUIctrl()
    MouseMoveResponder()
    recordUndoLevelNow(0, newBitmap)
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgResizeVP, -125
}

dummyInfoImgResizeVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image resized to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

getTransformToolSelectedArea(simpleMode) {
    If (simpleMode=0)
    {
       stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
       whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
       If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
          Return
    } Else whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (simpleMode=0)
    {
       capSelectionRelativeCoords()
       imgSelX1 := X1, imgSelY1 := Y1
       imgSelX2 := X2, imgSelY2 := Y2
       dummyRefreshImgSelectionWindow()
       RemoveTooltip()
    }

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
    ; flipBitmapAccordingToViewPort(zBitmap, 1)
    Return zBitmap
}

DrawLinesInSelectedArea() {
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
    If !G2
       Return

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    If (slideShowRunning=1)
       ToggleSlideShowu()

    coreDrawLinesSelectionArea(G2, whichBitmap)
    Gdip_DeleteGraphics(G2)
    UserMemBMP := whichBitmap
    recordUndoLevelNow(0, UserMemBMP)
    SetTimer, RefreshImageFile, -25
}

coreDrawLinesSelectionArea(G2:=0, whichBitmap:=0) {
    If (G2)
    {
       Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       maxLength := (imgSelW + imgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
    } Else
    {
       G2 := 2NDglPG
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
       Gdip_GetImageDimensions(gdiBitmap, qimgW, qimgH)
       calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
       imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
       imgSelW := max(X1, X2) - min(X1, X2)
       imgSelH := max(Y1, Y2) - min(Y1, Y2)
       maxLength := (qimgSelW + qimgSelH)//2
       thisThick := (DrawLineAreaContourThickness>maxLength//1.5) ? maxLength//1.5 : DrawLineAreaContourThickness
       thisThick := thisThick*zoomLevel
    }

    dR := (DrawLineAreaContourAlign=3) ? thisThick//2 : 0
    If (DrawLineAreaContourAlign=1)
       dR := -thisThick//2

    imgSelPx -= dR
    imgSelPy -= dR
    imgSelW += dR*2
    imgSelH += dR*2
    x1 -= dR
    y1 -= dR
    x2 += dR
    y2 += dR

    pPathArcs := Gdip_CreatePath()
    If (DrawLineAreaBorderArcA=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 180, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcB=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 270, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcC=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 90, 90)
    Gdip_StartPathFigure(pPathArcs)
    If (DrawLineAreaBorderArcD=1)
       Gdip_AddPathArc(pPathArcs, x1, y1, imgSelW, imgSelH, 0, 90)

    pPathBrders := Gdip_CreatePath()
    If (DrawLineAreaBorderTop=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderBottom=1)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderLeft=1)
       Gdip_AddPathLine(pPathBrders, x1, y1, x1, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderRight=1)
       Gdip_AddPathLine(pPathBrders, x2, y1, x2, y2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=2 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1 + imgSelW//2, y1, x1 + imgSelW//2, y2)
    
    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=3 || DrawLineAreaBorderCenter=7)
       Gdip_AddPathLine(pPathBrders, x1, y1 + imgSelH//2, x2, y1 + imgSelH//2)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=4 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y2, x2, y1)

    Gdip_StartPathFigure(pPathBrders)
    If (DrawLineAreaBorderCenter=5 || DrawLineAreaBorderCenter=6)
       Gdip_AddPathLine(pPathBrders, x1, y1, x2, y2)

    Gdip_FromARGB("0xFF" DrawLineAreaColor, A, R, G, B)
    thisColor := Gdip_ToARGB(DrawLineAreaOpacity, R, G, B)
    thisPen := Gdip_CreatePen(thisColor, thisThick)
    Gdip_SetPenDashStyle(thisPen, DrawLineAreaDashStyle - 1)
    If (DrawLineAreaCapsStyle=1)
       Gdip_SetPenLineCaps(thisPen, 2, 2, 2)

    compoundArray := "0.0|0.33|0.67|1.0"
    If (DrawLineAreaDoubles=1)
       Gdip_SetPenCompoundArray(thisPen, compoundArray)

    If (DrawLineAreaKeepBounds!=1)
    {
       applyLimits :=  Gdip_GetPathPointsCount(pPathBrders)>2 ? 1 : 0
       Gdip_RotatePathAtCenter(pPathBrders, vPselRotation, 1, applyLimits, rotateSelBoundsKeepRatio)
       Gdip_RotatePathAtCenter(pPathArcs, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
    } Else
    {
       PersonalizedRotatePath(pPathBrders, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
       PersonalizedRotatePath(pPathArcs, vPselRotation, imgSelPx, imgSelPy, imgSelW, imgSelH, 1, rotateSelBoundsKeepRatio, 0)
    }


    Gdip_DrawPath(G2, thisPen, pPathBrders)
    Gdip_DrawPath(G2, thisPen, pPathArcs)
 
    Gdip_DeletePath(pPathBrders)
    Gdip_DeletePath(pPathArcs)
    Gdip_DeletePen(thisPen)
    If (AnyWindowOpen && G2=2NDglPG)
    {
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    }
}

ChangeImageCanvasSize(userW, userH, userAddT, userAddB, userAddL, userAddR, userAddC, vpMode) {
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    If (vpMode=1)
    {
       calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       newW := imgSelW, newH := imgSelH
       If (newW*newH>maxGDIbmpSize)
       {
          calcIMGdimensions(imgSelW, imgSelH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       } Else If (newW>32500 || newH>32500)
       {
          calcIMGdimensions(imgSelW, imgSelH, 32500, 32500, newW, newH)
          SoundBeep, 300, 100
          addJournalEntry("Image canvas too large: " imgSelW " x " imgSelH ". Dimensions capped to: " newW " x " newH ".")
       }

       If (isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
          Return

       imgSelPx := - imgSelPx
       imgSelPy := - imgSelPy
       editingSelectionNow := 0
       updateUIctrl()
       MouseMoveResponder()
    } Else If (adjustCanvasMode=1)
    {
       newW := userAddL + userAddR + userAddC + imgW
       newH := userAddT + userAddB + userAddC + imgH
       imgSelPx := userAddL + (userAddC + 1)//2
       imgSelPy := userAddT + (userAddC + 1)//2
    } Else
    {
       newW := userW
       newH := userH
       imgSelPx := (adjustCanvasCentered=1) ? newW//2 - imgW//2 : 0
       imgSelPy := (adjustCanvasCentered=1) ? newH//2 - imgH//2 : 0
    }

    xBitmap := trGdip_CreateBitmap(A_ThisFunc, newW, newH, 0xE200B)
    If warnUserFatalBitmapError(xBitmap, A_ThisFunc)
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap, 7, 4)
    If !G2
    {
       ResetImgLoadStatus()
       dummyTimerDelayiedImageDisplay(50)
       Return "fail"
    }

    recordUndoLevelNow("init", 0)
    currIMGdetails.HasAlpha := 1
    If (adjustCanvasNoBgr!=1)
    {
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       Gdip_SetClipRect(G2, 0, 0, newW, newH, 0)
       Gdip_SetClipRect(G2, imgSelPx, imgSelPy, imgW, imgH, 4)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       If r0
          addJournalEntry(A_ThisFunc "(): failed to set background color through trGdip_GraphicsClear()...")
       Gdip_ResetClip(G2)
    }
    ; MsgBox, % newW "--" newH "--" imgSelPx "--" imgSelPy
    ; r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy, imgW, imgH, 0, 0, imgW, imgH)
    r1 := trGdip_DrawImage(A_ThisFunc, G2, whichBitmap, imgSelPx, imgSelPy)
    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(whichBitmap, 1)
    If (r1!="fail")
    {
       UserMemBMP := xBitmap
       recordUndoLevelNow(0, UserMemBMP)
    } Else trGdip_DisposeImage(xBitmap, 1)
    SetTimer, RefreshImageFile, -25
}

ApplySpecialFixedBlur(funcu, zBitmap, radius, pEffect, previewMode:=0) {
    If (!pEffect || !zBitmap)
    {
       addJournalEntry("Internal error: " A_ThisFunc "() has failed: " pEffect " | " zBitmap ". Caller: " funcu "()")
       Return
    }

    If (radius>19 || previewMode=1)
    {
       Gdip_BitmapApplyEffect(zBitmap, pEffect)
       Return
    }

    If (radius=19)
       radius += 18
    Else If (radius=18)
       radius += 15
    Else If (radius=17)
       radius += 12
    Else If (radius=16)
       radius += 10
    Else If (radius=15)
       radius += 8
    Else If (radius=14)
       radius += 6
    Else If (radius=13)
       radius += 4
    Else If (radius=12)
       radius += 2
    Else If (radius=11)
       radius += 1

    If (radius<=1)
       radius := 2

    zA := Gdip_CreateEffect(1, radius//2, 0, 0)
    zB := Gdip_CreateEffect(1, radius//2, 0, 0)
    Gdip_ImageRotateFlip(zBitmap, 1)
    Gdip_BitmapApplyEffect(zBitmap, zA)
    Gdip_ImageRotateFlip(zBitmap, 3)
    Gdip_BitmapApplyEffect(zBitmap, zB)
    Gdip_DisposeEffect(zA)
    Gdip_DisposeEffect(zB)
}

BlurSelectedArea() {
    startZeit := A_TickCount
    stopNow := mergeViewPortEffectsImgEditing(A_ThisFunc)
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (stopNow=1 || !whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
    {
       fnOutputDebug("error - BlurSelectedArea() operation abandoned: " whichBitmap "--" stopNow "--" thumbsDisplaying "--" editingSelectionNow)
       SetTimer, ResetImgLoadStatus, -300
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    capSelectionRelativeCoords()
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2

    If (X1<5)
       X1MarginSnap := 1
    If (X2>imgW - 5)
       X2MarginSnap := 1
    If (Y1<5)
       Y1MarginSnap := 1
    If (Y2>imgH - 5)
       Y2MarginSnap := 1

    If (X1MarginSnap=1 && X2MarginSnap=1 && Y1MarginSnap=1 && Y2MarginSnap=1 && blurAreaInverted=1 && EllipseSelectMode!=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "The image seems to be entirely selected, however you selected to invert selection area. Therefore, nothing remains selected. Operation abandoned.", 0, 0, "exclamation")
       SetTimer, ResetImgLoadStatus, -100
       Return
    } Else If (blurAreaAmount<2 && blurAreaPixelizeAmount<2 && blurAreaSoftEdges!=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "You have set both pixelize amount and blur amount to zero. Operation abandoned.", 0, 0, "exclamation")
       SetTimer, ResetImgLoadStatus, -100
       Return
    }

    If (blurAreaSoftEdges=1)
    {
       ; test if soft edges is applicable
       countNoes := 0
       bRa := blurAreaAmount
       gImgselPx := imgSelPx - bRa
       If (gImgSelPx<3)
       {
          countNoes++
          gImgSelPx := 0
       }

       gImgselPy := imgSelPy - bRa
       If (gImgSelPy<3)
       {
          countNoes++
          gImgSelPy := 0
       }

       gImgSelW := imgSelW + bRa * 2
       If (gImgSelW>imgW - gImgselPx - 3)
       {
          countNoes++
          gImgSelW := imgW - gImgselPx
       }

       gImgselH := imgSelH + bRa * 2
       If (gImgSelH>imgH - gImgselPy - 3)
       {
          countNoes++
          gImgSelH := imgH - gImgselPy
       }

       If (EllipseSelectMode=1)
          countNoes := 0
    }

    If (blurAreaSoftEdges!=1 || countNoes=4)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       If !G2
       {
          SetTimer, ResetImgLoadStatus, -100
          Return
       }
    }

    recordUndoLevelNow("init", 0)
    If (UserMemBMP!=whichBitmap)
       gdiBitmap := ""

    If (blurAreaSoftEdges=1 && countNoes<4)
    {
       setWindowTitle("Preparing blur image effect, please wait", 1)
       pEffect := Gdip_CreateEffect(1, blurAreaAmount, 0, 0)
       kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, gimgSelPx, gimgSelPy, gimgSelW, gimgSelH)
       If (blurAreaInverted=1)
       {
          If (blurAreaOpacity<253)
             primoBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)

          If (blurAreaTwice=1)
          {
             setWindowTitle("EXTRA BLUR - INVERTED AREA, please wait", 1)
             xBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgW//2, imgH//2, 1, 3, -1)
             If StrLen(xBitmap)>2
             {
                trGdip_DisposeImage(whichBitmap, 1)
                ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)
                wBitmap := trGdip_ResizeBitmap(A_ThisFunc, xBitmap, imgW, imgH, 1, 3, -1)
                trGdip_DisposeImage(xBitmap, 1)
                If StrLen(wBitmap)>2
                   whichBitmap := wBitmap
             }
          }

          setWindowTitle("BLURRING IMAGE - INVERTED AREA, please wait", 1)
          ApplySpecialFixedBlur(A_ThisFunc, whichBitmap, blurAreaAmount, pEffect)
       }

       G2 := trGdip_GraphicsFromImage(A_ThisFunc, whichBitmap, 7, 4)
       Gdip_GetImageDimensions(kBitmap, kimgW, kimgH)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, kImgW, kImgH, "0xE200B")
       If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(kBitmap, 1)
          Gdip_DisposeEffect(pEffect)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 5, 1)
       If !G3
       {
          trGdip_DisposeImage(kBitmap, 1)
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(pBitmap, 1)
          Gdip_DisposeEffect(pEffect)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       setWindowTitle("CALCULATING SOFT EDGE ALPHA MASK, please wait", 1)
       ; Gdip_FillRectangle(G3, BrushA, -2, -2, gImgselW + 2, gImgselH + 2)
       BrushA := Gdip_BrushCreateSolid("0xFF000000")
       r2 := trGdip_GraphicsClear(A_ThisFunc, G3, "0xFF000000")
       If r2
          r2 := Gdip_FillRectangle(G3, BrushA, 0, 0, kImgW, kImgH)
       thisAmount := (min(gimgSelW, gimgSelH)<bRa*2.5) ? min(gimgSelW, gimgSelH)//2.5 : bRa
       thisAmountX1 := (X1MarginSnap=1) ? 0 : thisAmount
       thisAmountY1 := (Y1MarginSnap=1) ? 0 : thisAmount
       thisAmountX2 := (X2MarginSnap=1) ? gImgSelW + 2 : gImgSelW - thisAmount*2
       thisAmountY2 := (Y2MarginSnap=1) ? gImgSelH + 2 : gImgSelH - thisAmount*2
       BrushB := Gdip_BrushCreateSolid("0xFFFFFFFF")
       pPath := createImgSelPath(thisAmountX1, thisAmountY1, thisAmountX2, thisAmountY2, EllipseSelectMode)
       If pPath
       {
          Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
          r3 := Gdip_FillPath(G3, BrushB, pPath)
       }

       thisAmount := (min(imgSelW, imgSelH)<blurAreaAmount*2.5) ? min(imgSelW, imgSelH)//2.5 : blurAreaAmount
       pEffect2 := Gdip_CreateEffect(1, thisAmount, 0, 0)
       Gdip_BitmapApplyEffect(pBitmap, pEffect2) ; the alpha masked blurred
       If (min(imgSelW, imgSelH)>blurAreaAmount*4.5 && blurAreaTwice=1)
       {
          pEffect3 := Gdip_CreateEffect(1, thisAmount//2+1, 0, 0)
          Gdip_BitmapApplyEffect(pBitmap, pEffect3) ; the alpha masked blurred
          Gdip_DisposeEffect(pEffect3)
       }

       If (blurAreaInverted!=1)
       {
          setWindowTitle("BLURRING IMAGE, please wait", 1)
          thisOpacity := blurAreaOpacity/255
          ApplySpecialFixedBlur(A_ThisFunc, kBitmap, blurAreaAmount, pEffect) ; the actual image blurred
       } Else thisOpacity := 1

       bRa := (EllipseSelectMode=1) ? Round(blurAreaAmount*8.5) : Round(blurAreaAmount*4.25)
       noOptimisations := (vPselRotation>1) || (bRa>gimgSelW - 5) || (bRa>gimgSelH - 5) ? 1 : 0
       ; msgbox, % bra "--" gImgSelW "--" gImgSelH "--" noOptimisations
       setWindowTitle("MERGING SOFT EDGE ALPHA MASK, please wait", 1)
       If (blurAreaInverted!=1)
       {
          kImgW := kImgW//2
          kImgH := kImgH//2
          bRa := (EllipseSelectMode=1) ? Round(blurAreaAmount*8.5) : Round(blurAreaAmount*4.25)
          noOptimisations := (bRa>gimgSelW//2 - 5) || (bRa>gimgSelH//2 - 5) ? 1 : 0
          gBitmap := trGdip_ResizeBitmap(A_ThisFunc, pBitmap, kimgW, kImgH, 0, 3, -1)
          If StrLen(gBitmap)>2
          {
             trGdip_DisposeImage(pBitmap, 1)
             pBitmap := gBitmap 
          }

          dBitmap := trGdip_ResizeBitmap(A_ThisFunc, kBitmap, kimgW, kImgH, 0, 5, -1)
          If StrLen(dBitmap)>2
          {
             trGdip_DisposeImage(kBitmap, 1)
             kBitmap := dBitmap
          }

          If (blurAreaTwice=1)
             ApplySpecialFixedBlur(A_ThisFunc, kBitmap, blurAreaAmount, pEffect)  ; the actual image blurred
       }

       ; Gdip_GetImageDimensions(kBitmap, zz, xx)
       ; Gdip_GetImageDimensions(pBitmap, zaz, xax)
       QPV_SetAlphaChannel(kBitmap, pBitmap)
       ; ToolTip, % zz "--" xx "`n" zaz "--" xax , , , 2
       ; kBitmap := SetBitmapAlphaChannel(kBitmap, pBitmap, bRa, noOptimisations)
       setWindowTitle("FINALISING BLUR, please wait", 1)
       r1 := trGdip_DrawImage(A_ThisFunc, G2, kBitmap, gimgSelPx, gimgSelPy, gimgSelW, gimgSelH, 0, 0, kimgW, kimgH, thisOpacity)
       If (blurAreaOpacity<253)
       {
          thisOpacity := 1.01 - blurAreaOpacity/255
          r0 := trGdip_DrawImage(A_ThisFunc, G2, primoBitmap, 0, 0, imgW, imgH,,,,,thisOpacity)
          ; primoBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap)
       }

       Gdip_DeletePath(pPath)
       Gdip_DeleteGraphics(G2)
       Gdip_DeleteGraphics(G3)
       Gdip_DeleteBrush(BrushA)
       Gdip_DeleteBrush(BrushB)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeEffect(pEffect2)
       trGdip_DisposeImage(primoBitmap, 1)
       trGdip_DisposeImage(pBitmap, 1)
       trGdip_DisposeImage(kBitmap, 1)
       If (r0!="fail" && r1!="fail" && r2!="fail" && !r3)
       {
          UserMemBMP := whichBitmap
          recordUndoLevelNow(0, UserMemBMP)
       }
       SetTimer, RefreshImageFile, -25
       zeitOperation := A_TickCount - startZeit
       addJournalEntry("Blur operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
       Return
    } Else If (blurAreaSoftEdges=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
    If pPath
       Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)

    modus := (blurAreaInverted=1) ? 4 : 0
    If (blurAreaInverted=1 && pPath)
       Gdip_SetClipPath(G2, pPath, 4)
    Else If pPath
       Gdip_SetClipPath(G2, pPath, modus)

    If (blurAreaInverted=1)
    {
       imgSelPx := imgSelPy := 0
       imgSelW := imgW
       imgSelH := imgH
    }

    thisOpacity := blurAreaOpacity/255
    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
    If (blurAreaPixelizeAmount>1 && blurAreaSoftEdges!=1)
    {
       setWindowTitle("PIXELIZING IMAGE, please wait", 1)
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, imgSelW, imgSelH, "0xE200B")
       If warnUserFatalBitmapError(pixiBMP, A_ThisFunc)
       {
          SetTimer, ResetImgLoadStatus, -100
          trGdip_DisposeImage(zBitmap, 1)
          Gdip_DeletePath(pPath)
          Gdip_DeleteGraphics(G2)
          Return "fail"
       }

       thisStartZeit := A_TickCount
       QPV_PixelateBitmap(zBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, min(imgSelW, imgSelH)))
       ; ToolTip, % A_TickCount - thisStartZeit , , , 2
       trGdip_DisposeImage(zBitmap, 1)
       zBitmap := pixiBMP
    }

    thisBlurMode := (blurAreaSoftEdges=1) ? 1 : blurAreaMode
    pEffect := Gdip_CreateEffect(1, blurAreaAmount, 0, 0)
    If (blurAreaTwice=1)
    {
       setWindowTitle("EXTRA-BLURRING IMAGE, please wait", 1)
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, zBitmap, imgSelW//2, imgSelH//2, 1, 3, -1)
       If StrLen(xBitmap)>2
       {
          trGdip_DisposeImage(zBitmap, 1)
          dhMatrix := Gdip_CreateMatrix()
          Gdip_ScaleMatrix(dhMatrix, 2, 2, 1)
          Gdip_TranslateMatrix(dhMatrix, imgSelPx, imgSelPy, 1)
          If (thisBlurMode=3)
          {
             QPV_BoxBlurBitmap(xBitmap, Round(blurAreaAmount/2))
          } Else If (thisBlurMode=2)
          {
             gBitmap := trGdip_BlurBitmap(xBitmap, blurAreaAmount/2.5, 1, 6)
             If !isWinXP
                ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

             Gu := trGdip_GraphicsFromImage(A_ThisFunc, xBitmap)
             If (Gu && gBitmap)
             {
                trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
                Gdip_DeleteGraphics(Gu)
             }
             trGdip_DisposeImage(gBitmap, 1)
          } Else If (thisBlurMode=1)
             ApplySpecialFixedBlur(A_ThisFunc, xBitmap, blurAreaAmount, pEffect)

          zBitmap := xBitmap
       }
    }

    setWindowTitle("BLURRING IMAGE, please wait", 1)
    If (thisBlurMode=3)
    {
       QPV_BoxBlurBitmap(zBitmap, Round(blurAreaAmount/2))
       gEffect := Gdip_CreateEffect(5, Round(blurAreaAmount/2.5), blurAreaAmount//6)
       If gEffect  ; light readjustments
          Gdip_BitmapApplyEffect(zBitmap, gEffect)

       Gdip_DisposeEffect(gEffect)
    } Else If (thisBlurMode=2)
    {
       gBitmap := trGdip_BlurBitmap(zBitmap, blurAreaAmount/2.5, 1, 6)
       If !isWinXP
          ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)
       Gu := trGdip_GraphicsFromImage(A_ThisFunc, zBitmap)
       If (Gu && gBitmap)
       {
          trGdip_DrawImage(A_ThisFunc, Gu, gBitmap)
          Gdip_DeleteGraphics(Gu)
       }
       trGdip_DisposeImage(gBitmap, 1)
    } Else If (thisBlurMode=1)
       ApplySpecialFixedBlur(A_ThisFunc, zBitmap, blurAreaAmount, pEffect)

    If (blurAreaOpacity>252)
       r0 := trGdip_GraphicsClear(A_ThisFunc, G2)

    r1 := trGdip_DrawImage(A_ThisFunc, G2, zBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH,,,,, thisOpacity)
    Gdip_DeleteMatrix(dhMatrix)
    trGdip_DisposeImage(zBitmap, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DeletePath(pPath)
    Gdip_DeleteGraphics(G2)
    If (r1!="fail" && r0!="fail")
    {
       UserMemBMP := whichBitmap
       recordUndoLevelNow(0, UserMemBMP)
    }
    SetTimer, RefreshImageFile, -25
    zeitOperation := A_TickCount - startZeit
    addJournalEntry("Blur operation. Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)))
}

QPV_BoxBlurBitmap(pBitmap, passes) {
  If !qpvMainDll
  {
     addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
     Return Gdip_BoxBlurBitmap(pBitmap, passes)
  }

  If !pBitmap
     Return 0

  Gdip_GetImageDimensions(pBitmap, w, h)
  If (w<1 || h<1)
     Return 0

  E1 := Gdip_LockBits(pBitmap, 0, 0, w, h, stride, iScan, iData)
  If E1
     Return 0

  func2exec := (A_PtrSize=8) ? "BoxBlurBitmap" : "_BoxBlurBitmap@20"
  r := DllCall("qpvmain.dll\" func2exec, "UPtr", iScan, "Int", w, "Int", h, "Int", stride, "Int", passes)
  Gdip_UnlockBits(pBitmap, iData)
  ; DllCall("GlobalFree", "ptr", mCodeFunc)
  return r
}

QPV_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize) {
   If !qpvMainDll
   {
      addJournalEntry(A_ThisFunc "(): QPV dll file is missing or failed to initialize: qpvMain.dll")
      Return Gdip_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize)
   }

   if (!pBitmap || !pBitmapOut)
      return -3

   Gdip_GetImageDimensions(pBitmap, Width, Height)
   If (width<1 || height<1)
      Return 0

   if (Width!=Gdip_GetImageWidth(pBitmapOut) || Height!=Gdip_GetImageHeight(pBitmapOut))
      return -1

   if (BlockSize>Width || BlockSize>Height)
      return -2

   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)

   func2exec := (A_PtrSize=8) ? "PixelateBitmap" : "_PixelateBitmap@24"
   if (!E1 && !E2)
      r := DllCall("qpvmain.dll\" func2exec, "UPtr", Scan01, "UPtr", Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)
   
   If !E1
      Gdip_UnlockBits(pBitmap, BitmapData1)

   If !E2
      Gdip_UnlockBits(pBitmapOut, BitmapData2)
   return r
}

CropImageInViewPortToSelection() {
    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    If (!whichBitmap || thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    If testSelectOutsideImgEntirely(whichBitmap)
    {
       showTOOLtip("WARNING: Invalid image selection area...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    isInside := (imgSelX1>=0 && imgSelY1>=0 && imgSelX2<=imgW && imgSelY2<=imgH) ? 1 : 0
    If (LimitSelectBoundsImg!=1 && isInside!=1)
    {
       ChangeImageCanvasSize(0, 0, 0, 0, 0, 0, 0, 1)
       Return
    }

    If (slideShowRunning=1)
       ToggleSlideShowu()

    calcImgSelection2bmp(0, imgW, imgH, imgW - 1, imgH - 1, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (UserMemBMP=whichBitmap)
       xBitmap := UserMemBMP

    If (EllipseSelectMode!=1 && isInRange(imgSelW, imgW - 2, imgW + 2) && isInRange(imgSelH, imgH - 2, imgH + 2) && !imgSelPx && !imgSelPy)
    {
       MouseMoveResponder()
       SetTimer, RefreshImageFile, -25
       Return
    }

    recordUndoLevelNow("init", 0)
    dummyBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH)
    Gdip_GetImageDimensions(dummyBMP, qImgW, qImgH)
    pPath := createImgSelPath(0, 0, qImgW, qImgH, EllipseSelectMode)
    If pPath
    {
       If (EllipseSelectMode=1 || vpIMGrotation>0)
          currIMGdetails.HasAlpha := 1

       Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
       carvePathFromBitmap(dummyBMP, pPath, 0, 0, 4)
       pB := Gdip_GetPathWorldBounds(pPath)
       pBx := clampInRange(pB.x, 0, qImgW - 1)
       pBy := clampInRange(pB.y, 0, qImgH -1)
       pBw := clampInRange(pB.w, pBx + 1, qImgW)
       pBh := clampInRange(pB.h, pBy + 1, qImgH)
       UserMemBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, dummyBMP, pBx, pBy, pBw, pBh)
       trGdip_DisposeImage(dummyBMP, 1)
       Gdip_DeletePath(pPath)
    } Else
    {
       UserMemBMP := dummyBMP
       addJournalEntry(A_ThisFunc "(): errors occured on image cropping. Failed to create GDI+ path.")
    }

    recordUndoLevelNow(0, UserMemBMP)
    editingSelectionNow := 0
    updateUIctrl()
    trGdip_DisposeImage(xBitmap, 1)
    vpIMGrotation := 0
    MouseMoveResponder()
    SetTimer, RefreshImageFile, -25
    SetTimer, dummyInfoImgCropVP, -125
}

dummyInfoImgCropVP() {
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   mpx := Round((imgW*imgH)/1000000, 2)
   showTOOLtip("Image canvas size set to:`n" groupDigits(imgW) " x " groupDigits(imgH) " px ("  mpx " MPx)" )
   SetTimer, RemoveTooltip, % - msgDisplayTime
}

PasteHDropFiles(allowFilesPaste) {
   Try testClipTypeImgA := DllCall("IsClipboardFormatAvailable", "uint", 8)
   Try testClipTypeImgB := DllCall("IsClipboardFormatAvailable", "uint", 2)
   If (testClipTypeImgA=1 || testClipTypeImgB=1)
      Return

   Try testClipType := DllCall("IsClipboardFormatAvailable", "uint", 15)
   Try imgsListu := Clipboard
   If (testClipType!=1)
   {
      filesFound := 0
      Loop, Parse, imgsListu, `n,`r
      {
           If FileExist(Trimmer(A_LoopField))
              filesFound := 1
      } Until (A_Index>5)

      If (filesFound!=1)
      {
         ResetImgLoadStatus()
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   If (testClipType=1 || filesFound=1) && (allowFilesPaste=0)
   {
      ResetImgLoadStatus()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 1
   }

   countFiles := ST_Count(Trimmer(imgsListu), "`n")
   If (countFiles>0 && StrLen(imgsListu)>4)
   {
      showTOOLtip("Files identified in the clipboard...")
      msgResult := msgBoxWrapper(appTitle ": Paste files", "You have " countFiles " file entries stored in the clipboard by your file explorer or manager.`n`nWould you like to import the image files (if any) into the files list of " appTitle "?", 4, 0, "question", "Select newly inserted index entries")
   }

   If InStr(msgResult.btn, "yes")
   {
      initialIndex := maxFilesIndex
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir, msgResult.check)
      If (initialIndex!=maxFilesIndex)
      {
         currentFileIndex := maxFilesIndex - 1
         GenerateRandyList()
         dummyTimerDelayiedImageDisplay(50)
         ForceRefreshNowThumbsList()
         newFiles := initialIndex - maxFilesIndex
         showTOOLtip("Finished adding " newFiles " image files from the clipboard")
      } Else showTOOLtip("No image files identified in the clipboard...`nFiles list unchanged.")
   } Else RemoveTooltip()

   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return 1
}

corePasteClipboardImg(modus, imgW, imgH, allowFilesPaste) {
    clipBMP := Gdip_CreateBitmapFromClipboard()
    If clipBMP
       createdGDIobjsArray["x" clipBMP] := [clipBMP, "bmp", 1, A_ThisFunc]

    If (isInRange(Abs(clipBMP), 1, 5) || !clipBMP)
    {
       If PasteHDropFiles(allowFilesPaste)
          Return

       Try toPaste := Trimmer(Clipboard)
       If StrLen(toPaste)>2
       {
          textMode := 1
          toPaste := SubStr(toPaste, 1, 9500)
          clipBMP := drawTextInBox(toPaste, OSDFontName, PasteFntSize, imgW, imgH, OSDtextColor, OSDbgrColor, 0, 0, usrTextAlign, "0xFF")
          If (modus=1)
             showTOOLtip("Text clipboard content rendered as image...`nOSD font and colors used")
          SetTimer, RemoveTooltip, % -msgDisplayTime
       } Else
       {
          Tooltip
          showTOOLtip("ERROR: Unable to retrieve image from clipboard...")
          SetTimer, ResetImgLoadStatus, -25
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    ; disposeCacheIMGs()
    If !InStr(Gdip_GetImagePixelFormat(clipBMP, 1), "0xE200")
    {
       krpBmp := Gdip_CloneBmpPargbArea(A_ThisFunc, clipBMP)
       If krpBmp
       {
          trGdip_DisposeImage(clipBMP, 1)
          clipBMP := krpBmp
       }
    }
    ; MsgBox, % Gdip_GetImagePixelFormat(clipBMP, 1)
    Return clipBMP
}

tlbrPasteClipboardIMG() {
   If (editingSelectionNow=1)
      PanelPasteInPlace()
   Else
      PasteClipboardIMG()
}

PasteClipboardIMG() {
    Static clippyCount := 0

    If (AnyWindowOpen>0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    If askAboutFileSave(" and the clipboard image or files entries are going to be pasted")
       Return

    showTOOLtip("Retrieving clipboard, please wait...")
    setImageLoading()
    If PasteHDropFiles(1)
       Return

    changeMcursor()
    calcScreenLimits()
    clipBMP := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 1)
    If !clipBMP
    {
       ResetImgLoadStatus()
       Return
    }

    UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
    clippyCount++
    If (editingSelectionNow=1)
       toggleImgSelection()

    discardViewPortCaches()
    UserMemBMP := clipBMP
    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\Clipboard-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    isUniform := Gdip_TestBitmapUniformity(clipBMP, 7, maxLevelIndex)
    If (isUniform=1 && isInRange(maxLevelIndex, 252, 255))
       currIMGdetails.HasAlpha := 0
    ; ToolTip, % currIMGdetails.HasAlpha " = lol" , , , 2
    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}

thumbsSelector(keyu, aKey, prevFileIndex) {
  Static lastInvoked := 1

  ; ToolTip, % prevFileIndex "--" markedSelectFile "`n" lola
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Upu" || keyu="Home") && prevFileIndex<=1)
  || (InStr(aKey, "+") && (keyu="Right" || keyu="Down" || keyu="End") && prevFileIndex>=maxFilesIndex)
     Return

  selA := resultedFilesList[currentFileIndex, 2]
  selB := resultedFilesList[prevFileIndex, 2]
  If (InStr(aKey, "+") && (keyu="Left" || keyu="Right"))
  {
     testIndex := (keyu="Left") ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (keyu="Left") ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
        markedSelectFile++
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 1
     } Else If (selA=1 && selB=1)
     {
        resultedFilesList[currentFileIndex, 2] := 1
        resultedFilesList[prevFileIndex, 2] := 0
        markedSelectFile -= 2
     }

     markedSelectFile++
  } Else If InStr(aKey, "+") ; && (keyu="Upu" || keyu="Down"))
  {
     direction := (keyu="Down" || keyu="PgDn" || keyu="End") ? 1 : 0
     testIndex := (direction!=1) ? currentFileIndex : currentFileIndex
     selC := resultedFilesList[testIndex, 2]
     testIndex := (direction!=1) ? prevFileIndex + 1 : prevFileIndex - 1
     selD := resultedFilesList[testIndex, 2]
     If (selA!=1 && selB!=1) || (selA=1 && selB!=1)
     || (selA=1 && selB=1 && selC=1 && selD=1)
     {
        selA := selB := 0
        dropFilesSelection(1)
     }

     If (selA!=1 && selB!=1) || (selA!=1 && selB=1) || (selA=1 && selB!=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 1)
     } Else If (selA=1 && selB=1)
     {
        selectFilesRange(currentFileIndex, prevFileIndex, 0)
        resultedFilesList[currentFileIndex, 2] := 1
        markedSelectFile++
     }
  }

  If (markedSelectFile=1 && InStr(aKey, "+"))
  {
     markedSelectFile := 0
     resultedFilesList[currentFileIndex, 2] := 0
  }
}

generateNumberRangeString(pA, pB) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
        stringRange .= "," mA + A_Index - 1 "|"

    Return stringRange
}

selectFilesRange(pA, pB, sel) {
    mB := max(pA, pB)
    mA := min(pA, pB)
    rangeC := mB - mA + 1
    Loop, % rangeC
    {
        oSel := resultedFilesList[mA + A_Index - 1, 2]
        resultedFilesList[mA + A_Index - 1, 2] := sel
        If (sel=1 && oSel!=1)
           markedSelectFile++
        Else If (sel!=1 && oSel=1)
           markedSelectFile--
    }

    Return rangeC
}

ThumbsNavigator(keyu, aKey) {
  resetSlideshowTimer(0)
  If (thumbsDisplaying!=1 && maxFilesIndex>1)
  {
     If askAboutFileSave(" and another image will be loaded")
        Return
  }

  prevFileIndex := currentFileIndex
  thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
  If (keyu="Down")
  {
     currentFileIndex := currentFileIndex + maxItemsW - 1
     NextPicture(0, 0, 1)
  } Else If (keyu="Upu")
  {
     currentFileIndex := currentFileIndex - maxItemsW + 1
     PreviousPicture(0, 0, 1)
  } Else If (keyu="PgUp")
  {
     currentFileIndex := currentFileIndex - maxItemsPage + 1
     PreviousPicture()
  } Else If (keyu="PgDn")
  {
     Loop, % maxItemsH
     {
        currentFileIndex := currentFileIndex + maxItemsW - 1
        NextPicture(0, 0, 1)
        thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
     }
     ; currentFileIndex := currentFileIndex + maxItemsPage - 1
     ; NextPicture()
  } Else If (keyu="Left")
     PreviousPicture()
  Else If (keyu="Right")
     NextPicture()
  Else If (keyu="End")
     LastPicture()
  Else If (keyu="Home")
     FirstPicture()

  thumbsSelector(keyu, aKey, prevFileIndex)
  If (thumbsDisplaying!=1 && InStr(aKey, "+"))
     dummyTimerDelayiedImageDisplay(50)
}

PanIMGonScreen(direction) {
   If (IMGresizingMode!=4)
   {
      IMGdecalageX := IMGdecalageY := 1
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (GetKeyState("Left", "P")!=1 && GetKeyState("Right", "P")!=1)
   && (GetKeyState("Down", "P")!=1 && GetKeyState("Up", "P")!=1)
      Return

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   zL := (zoomLevel<0.7) ? 0.7 : zoomLevel
   If (zoomLevel>2)
      zL := 2
   stepu := GetKeyState("Shift", "P") ? 0.3 : 0.1 * zL
   stepu := (Round(mainHeight*stepu) + Round(mainWidth*stepu))//2 + 1
   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY + stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      IMGdecalageY := IMGdecalageY - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX + stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      IMGdecalageX := IMGdecalageX - stepu

   If (direction="U" && FlipImgV=0) || (direction="D" && FlipImgV=1)
      diffIMGdecY := stepu
   Else If (direction="D" && FlipImgV=0) || (direction="U" && FlipImgV=1)
      diffIMGdecY := - stepu
   Else If (direction="L" && FlipImgH=0) || (direction="R" && FlipImgH=1)
      diffIMGdecX := stepu
   Else If (direction="R" && FlipImgH=0) || (direction="L" && FlipImgH=1)
      diffIMGdecX := - stepu

; ReloadThisPicture()
   If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
      SetTimer, coreReloadThisPicture, -5
   Else
      dummyTimerDelayiedImageDisplay(10)
}

dummyTimerDelayiedImageDisplay(timeru:=0) {
  If (timeru>1)
     SetTimer, extraDummyDelayiedImageDisplay, % -timeru ; , 950
}

extraDummyDelayiedImageDisplay() {
  If (imageLoading=1)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -15
     Return
  }
  DelayiedImageDisplay()
}

filterDelayiedImageDisplay() {
  Static lastInvoked := 1
  If (A_tickcount - lastInvoked < 60)
  {
     SetTimer, extraDummyDelayiedImageDisplay, -50
     Return
  }
  lastInvoked := A_TickCount
  DelayiedImageDisplay()
  lastInvoked := A_TickCount
}

DelayiedImageDisplay() {
   If (CurrentSLD && maxFilesIndex>0) || StrLen(UserMemBMP)>2
   {
      r := IDshowImage(currentFileIndex)
      If !r
         informUserFileMissing()
   }
}

DonateNow() {
   Try Run, https://www.paypal.me/MariusSucan/10
}

openSettingsDir() {
   Try Run, % mainCompiledPath
}

DeleteAllSettings() {
    SoundBeep, 300, 300
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete ALL personalized settings?`n`n" appTitle " will automatically restart if you choose to do so. This action is irreversible.", "&Restore defaults|&Cancel", 2, "exclamation")
    If (msgResult="restore defaults")
    {
       FileSetAttrib, -R, % mainSettingsFile
       FileDelete, % mainSettingsFile
       terminateIMGediting()
       restartAppu()
    }
}

externalinvokedSettingsContextMenu() {
    hwndA := WinActive("ahk_id " hSetWinGui)
    hwndB := WinActive("ahk_id " MsgBox2hwnd)
    hwnd := ((hwndA=hSetWinGui || hwndB=MsgBox2hwnd) && AnyWindowOpen) ? 1 : 0
    If (hwnd!=1)
       Return

    If (AnyWindowOpen && MsgBox2hwnd=hwndB)
       GuiControlGet, OutputVar, WinMsgBox: Focus
    Else If AnyWindowOpen
       GuiControlGet, OutputVar, SettingsGUIA: Focus
    ; ToolTip, % OutputVar , , , 2
    If InStr(OutputVar, "edit")
       Return

    If (AnyWindowOpen=3 && InStr(OutputVar, "listview"))
       invokePanelDynaFoldersContextMenu()
    Else If (AnyWindowOpen=2 && InStr(OutputVar, "listview"))
       invokePanelStaticFoldersContextMenu()
    Else If AnyWindowOpen
       invokePrefsPanelsContextMenu()
}

SettingsGUIAGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1

    If (mouseToolTipWinCreated=1)
    {
       mouseTurnOFFtooltip()
       Return
    }

    If (GuiHwnd!=hSetWinGui)
       Return

    If (AnyWindowOpen=3 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelDynaFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen=2 && InStr(A_GuiControl, "lview") && IsRightClick=1)
    {
       invokePanelStaticFoldersContextMenu()
       Return
    } Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview") && IsRightClick=1) ; || (MsgBox2hwnd && A_IsSuspended)
    {
       If SettingsToolTips()
          Return
    }

    If (CtrlHwnd && IsRightClick=1) || ((A_TickCount - lastInvoked>250) && IsRightClick=0) || (mouseToolTipWinCreated=1)
    {
       lastInvoked := A_TickCount
       Return
    }

    lastInvoked := A_TickCount
    invokePrefsPanelsContextMenu()
    Return
}

invokePrefsPanelsContextMenu() {
    Menu, ContextMenu, UseErrorLevel
    Menu, ContextMenu, Delete
    Sleep, 5
    Menu, ContextMenu, Add, &Large UI fonts, ToggleLargeUIfonts
    Menu, ContextMenu, Add, &Close panel`tESC, CloseWindow
    If (imgEditPanelOpened=1)
       Menu, ContextMenu, Add, C&ollapse panel`tF8, toggleImgEditPanelWindow
    Menu, ContextMenu, Add, 
    If (PrefsLargeFonts=1)
       Menu, ContextMenu, Check, &Large UI fonts

    Menu, ContextMenu, Add, O&pen settings folder, openSettingsDir
    Menu, ContextMenu, Add, Restore ALL defaults, DeleteAllSettings
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &Visit official site, OpenGitHub
    Menu, ContextMenu, Add, &Make a donation, DonateNow
    Menu, ContextMenu, Add
    Menu, ContextMenu, Add, &New instance, OpenNewQPVinstance
    Menu, ContextMenu, Add, &Restart %appTitle%, restartAppu
    showThisMenu("ContextMenu")
}

WinMsgBoxGuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y) {
    Static lastInvoked := 1
    If (mouseToolTipWinCreated=1) ; || (A_TickCount - lastInvoked<90)
    {
       mouseTurnOFFtooltip()
       Return
    }

    isFakeWin := (prevOpenedWindow[5]=1 && AnyWindowOpen>0) ? 1 : 0
    If !MsgBox2hwnd
       Return

    If (isRightClick=1)
    {
       If SettingsToolTips()
          Return
       Else If AnyWindowOpen
          invokePrefsPanelsContextMenu()
    }

    lastInvoked := A_TickCount
    Return
}

WM_RBUTTONUP() {
    ; Tooltip, %A_GuiControl%
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()
    Else If (AnyWindowOpen && !InStr(A_GuiControl, "lview")) || (MsgBox2hwnd && A_IsSuspended)
       SettingsToolTips()
}

SettingsToolTips() {
   ActiveWin := WinExist("A")
   thisHwnd := (ActiveWin=hSetWinGui && hSetWinGui!=PVhwnd) || (ActiveWin=MsgBox2hwnd && A_IsSuspended) ? 1 : 0
   If (thisHwnd!=1)
      Return

   If (mouseToolTipWinCreated=1)
      mouseTurnOFFtooltip()
 
   GuiControlGet, value, , %A_GuiControl%
   GuiControlGet, hwnd, hwnd, %A_GuiControl%
   ControlGetText, info,, ahk_id %hwnd%
   ControlGet, listBoxOptions, List,,, ahk_id %hwnd%
   ControlGet, ctrlActiveState, Enabled,,, ahk_id %hwnd%
   If (info=value)
      info := ""

   If StrLen(info)>0
      info .= "`n"

   value := StrReplace(value, "&")
   ctrlu := StrReplace(A_GuiControl, "&")
   If (ctrlu=value)
      value := ""

   ; btnType := GetButtonType(hwnd)
   If StrLen(value)>0
   {
      thisValueNumber := isNumber(Trimmer(value))
      value .= " = "
   }

   MouseGetPos, , , id, controla, 2
   If !hwnd
      ControlGetText, info, , ahk_id %controla%

   WinGetClass, OutputVar, ahk_id %hwnd%
   If OutputVar
   {
      If InStr(OutputVar, "_trackbar")
      {
         SendMessage, 0x0401,,,, ahk_id %hwnd%   ; TBM_GETRANGEMIN
         minu := ErrorLevel
         SendMessage, 0x0402,,,, ahk_id %hwnd%   ; TBM_GETRANGEMAX
         maxu := ErrorLevel
         OutputVar := "Slider: " minu "; " maxu
      } Else If (InStr(OutputVar, "Button") && thisValueNumber=1 && InStr(value, "="))
         OutputVar := "Checkbox"
      Else If InStr(OutputVar, "_updown")
      {
         SendMessage, 0x0400+102,,,, ahk_id %hwnd%   ; UDM_GETRANGE
         UDM_GETRANGE := ErrorLevel
         minu := UDM_GETRANGE >> 16
         maxu := UDM_GETRANGE & 0xFFFF
         OutputVar := "Up/Down range: " minu "; " maxu
      } Else If InStr(OutputVar, "edit")
         OutputVar := "Edit field"
      Else If InStr(OutputVar, "static")
         OutputVar := "Clickable"
      controlType := "`n[" OutputVar "]"
   }

   msg2show := info value A_GuiControl controlType
   ; If (ctrlActiveState!=1 && StrLen(msg2show)>2 && btnType)
   ;    msg2show .= "`n[CONTROL DISABLED]"
   If StrLen(listBoxOptions)>3
   {
      countListBoxOptions := ST_Count(listBoxOptions, "`n")
      If (countListBoxOptions>10)
         listBoxOptions := "[too many to list]"
      msg2show .= "`n`nLIST OPTIONS: " countListBoxOptions "`n" listBoxOptions
   }

   ; If (!value && btnType)
   ;    msg2show .= "`n`nCONTROL TYPE:`n" btnType
   If InStr(msg2show, "lib\") || InStr(msg2show, "a href=")
      Return

   mouseCreateOSDinfoLine(msg2show, PrefsLargeFonts)
   Return msg2show
}

ST_Count(Haystack, searchFor) {
    StrReplace(Haystack, searchFor,, OutputVarCount)
    Return OutputVarCount
}

SetParentID(Window_ID, theOther) {
  r := DllCall("SetParent", "uint", theOther, "uint", Window_ID) ; success = handle to previous parent, failure =null 
  Return r
}

CreateGuiButton(btnList, killWin:=0, delayu:=950) {
    Critical, On
    Static lastCreated := 1, bgrColor := 112288, txtColor := "ddeeFF", thisOpacity := 200
    If (killWin=1)
    {
       Gui, TempBtnGui: Destroy
       tempBtnVisible := "null"
       interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
       Return
    }

    If (TouchScreenMode!=1 && killWin!="force") ; || MsgBox2hwnd
       Return
 
    Global BtnTemp1, BtnTemp2
    thisFntSize := OSDfntSize
    thisFntSize := Round(thisFntSize*0.45)
    If (thisFntSize<9)
       thisFntSize := 9
    Gui, TempBtnGui: Destroy
    Sleep, 25

    roundedCsize := Round(thisFntSize/1.7) + 15
    Gui, TempBtnGui: -DPIScale -Caption +ToolWindow +E0x8000000 +hwndhGuiBtn +Owner%PVhwnd%
    Gui, TempBtnGui: Margin, % thisFntSize + 10, % thisFntSize
    Gui, TempBtnGui: Color, c%bgrColor%
    Gui, TempBtnGui: Font, s%thisFntSize% Bold Q5, Arial
    btnArray := StrSplit(btnList, "||")
    tempBtnGuiBtnArray := []
    Loop, % btnArray.Count()
    {
        thisBtnArr := StrSplit(btnArray[A_Index], ",,")
        ; ToolTip, % thisBtnArr[1] "==" thisBtnArr[2] , , , 2
        If (A_Index=1)
           Gui, TempBtnGui: Add, Text, c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
        Else If thisBtnArr[1]
           Gui, TempBtnGui: Add, Text, x+%OSDfntSize% c%txtColor% gtempGuiBtnCall%A_Index%, % thisBtnArr[1]
 
        tempBtnGuiBtnArray[A_Index] := thisBtnArr[2]
    }

    WinGetPos, winPosX, winPosY, Wid, Heig, ahk_id %PVhwnd%
    Gui, TempBtnGui: Show, NoActivate AutoSize Hide x%winPosX% y%winPosY%, QPVGuiActionBtn
    WinGetPos,,, gWid, gHeig, ahk_id %hGuiBtn%
    If (gWid>Wid - thisFntSize*2.2)
       gWid := Wid - Round(thisFntSize * 2.25) - 5
    If (gWid<5)
       gWid := 5

    ; compatMode := (A_OSVersion="WIN_XP" || A_OSVersion="WIN_7") ? 1 : 0
    compatMode := 1
    If (compatMode=0)
       winPosX := winPosY := 1

    offsetuY := scrollBarHy ? Heig - scrollBarHy : 0
    Final_x := winPosX + thisFntSize * 2
    Final_y := winPosY + Heig - thisFntSize * 2 - gHeig - offsetuY//2
    If (compatMode=1)
    {
       WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBtn%
       WinSet, AlwaysOnTop, On, ahk_id %hGuiBtn%
    }

    WinSet, Region, 0-0 R%roundedCsize%-%roundedCsize% w%gWid% h%gHeig%, QPVGuiActionBtn
    If (compatMode=0)
       SetParentID(PVhwnd, hGuiBtn)

    GroupAdd, QPVwindows, ahk_id %hGuiBtn%
    Gui, TempBtnGui: Show, NoActivate AutoSize x%Final_x% y%Final_y%, GuiActionBtn
    tempBtnVisible := hGuiBtn
    interfaceThread.ahkassign("tempBtnVisible", tempBtnVisible)
    SetTimer, DestroyTempBtnGui, % - delayu
    lastCreated := A_TickCount
}

tempGuiBtnCall1() {
    coretempGuiBtnCalls(1)
}

tempGuiBtnCall2() {
    coretempGuiBtnCalls(2)
}

tempGuiBtnCall3() {
    coretempGuiBtnCalls(3)
}

tempGuiBtnCall4() {
    coretempGuiBtnCalls(4)
}

tempGuiBtnCall5() {
    coretempGuiBtnCalls(5)
}

coretempGuiBtnCalls(indexu) {
    SetTimer, DestroyTempBtnGui, -950
    If (WinActive("A")!=PVhwnd)
       WinActivate, ahk_id %PVhwnd%
    thisFunc := tempBtnGuiBtnArray[indexu]
    ; ToolTip, % thisfunc "===" indexu , , , 2
    %thisFunc%()
    If (drawingShapeNow!=1)
       SetTimer, DestroyTempBtnGui, -950
}

DestroyTempBtnGui(dummy:=0) {
    Critical, On
    MouseGetPos, , , OutputVarWin
    thisWin := WinActive("A")
    okay := (thisWin=PVhwnd || thisWin=hSetWinGui) ? 1 : 0
    ; ToolTip, % OutputVarWin , , , 2
    If (OutputVarWin!=tempBtnVisible) || (okay!=1) || (dummy="now")
       CreateGuiButton("Die dummy", 1)  ;   ;-)
    Else
       SetTimer, DestroyTempBtnGui, -950
}

openPreviousPanel(mode:="") {
   thisFunc := prevOpenedWindow[2]
   allowReopen := prevOpenedWindow[3]
   If (thisFunc && allowReopen=1) || (thisFunc && mode="forced")
   {
      %thisFunc%()
   } Else
   {
      showTOOLtip("No previously opened panel...")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

mouseTurnOFFtooltip() {
   Gui, mouseToolTipGuia: Destroy
   mouseToolTipWinCreated := 0
}

mouseCreateOSDinfoLine(msg:=0, largus:=0) {
    Critical, On
    Static prevMsg, lastInvoked := 1
    Global TippyMsg

    thisHwnd := (AnyWindowOpen>0 && prevOpenedWindow[5]!=1) ? hSetWinGui : MsgBox2hwnd
    If (StrLen(msg)<3) || (prevMsg=msg && mouseToolTipWinCreated=1) || (A_TickCount - lastInvoked<100) || !thisHwnd
       Return

    lastInvoked := A_TickCount
    Gui, mouseToolTipGuia: Destroy
    thisFntSize := (largus=1) ? Round(LargeUIfontValue*1.55) : LargeUIfontValue
    If (thisFntSize<12)
       thisFntSize := 12
    bgrColor := OSDbgrColor
    txtColor := OSDtextColor
    isBold := (FontBolded=1) ? " Bold" : ""
    Sleep, 25

    Gui, mouseToolTipGuia: -DPIScale -Caption +Owner%thisHwnd% +ToolWindow +hwndhGuiTip
    Gui, mouseToolTipGuia: Margin, % thisFntSize, % thisFntSize
    Gui, mouseToolTipGuia: Color, c%bgrColor%
    Gui, mouseToolTipGuia: Font, s%thisFntSize% %isBold% Q5, %OSDFontName%
    Gui, mouseToolTipGuia: Add, Text, c%txtColor% gmouseTurnOFFtooltip vTippyMsg, %msg%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVOguiTipsWin

    GetPhysicalCursorPos(mX, mY)
    tipX := mX + 15
    tipY := mY + 15
    ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    MaxWidth := Floor(ResWidth*0.85)
    If (MaxWidth<Wid && MaxWidth>10)
    {
       GuiControl, mouseToolTipGuia: Move, TippyMsg, w1 h1
       GuiControl, mouseToolTipGuia:, TippyMsg,
       Gui, mouseToolTipGuia: Add, Text, xp yp c%txtColor% gmouseTurnOFFtooltip w%MaxWidth%, %msg%
       Gui, mouseToolTipGuia: Show, NoActivate AutoSize Hide x1 y1, QPVguiTipsWin
       ResWidth := adjustWin2MonLimits(hGuiTip, tipX, tipY, Final_x, Final_y, Wid, Heig)
    }
    prevMsg := msg
    mouseToolTipWinCreated := 1
    WinSet, AlwaysOnTop, On, ahk_id %hGuiTip%
    WinSet, Transparent, 225, ahk_id %hGuiTip%
    Gui, mouseToolTipGuia: Show, NoActivate AutoSize x%Final_x% y%Final_y%, QPVguiTipsWin
    delayu := StrLen(msg) * 70 + 900
    If (delayu<msgDisplayTime/2)
       delayu := msgDisplayTime//2 + 1
    SetTimer, mouseTurnOFFtooltip, % -delayu
}

adjustWin2MonLimits(winHwnd, winX, winY, ByRef rX, ByRef rY, ByRef Wid, ByRef Heig) {
   GetWinClientSize(Wid, Heig, winHwnd, 1)
   ActiveMon := MWAGetMonitorMouseIsIn(winX, winY)
   If ActiveMon
   {
      SysGet, bCoord, Monitor, %ActiveMon%
      rX := max(bCoordLeft, min(winX, bCoordRight - Wid))
      rY := max(bCoordTop, min(winY, bCoordBottom - Heig*1.2))
      ResWidth := Abs(max(bCoordRight, bCoordLeft) - min(bCoordRight, bCoordLeft))
      ; ResHeight := Abs(max(bCoordTop, bCoordBottom) - min(bCoordTop, bCoordBottom))
   } Else
   {
      rX := winX
      rY := winY
   }

   Return ResWidth
}

createSettingsGUI(IDwin, thisCaller:=0, allowReopen:=1) {
    Static btnHeightBig, btnHeightSmall
    If (isWinXP || A_OSVersion="WIN_7")
    {
       btnHeightBig := 33
       btnHeightSmall := 23
    } Else If (!btnHeightBig && !btnHeightSmall)
    {
       retVal := GetMsgDimensions("TRY AGAIN", "Arial", 10, 900, 900, 1)   ; default btn width / height
       btnHeightSmall := retVal.h
       retVal := ""
       retVal := GetMsgDimensions("TRY AGAIN", "Arial", LargeUIfontValue - 1, 900, 900, 1)   ; default btn width / height
       btnHeightBig := retVal.h
       If (!btnHeightBig && !btnHeightSmall)
       {
          btnHeightBig := 30
          btnHeightSmall := 25
       }
    }

    thisBtnHeight := (PrefsLargeFonts=1) ? btnHeightBig : btnHeightSmall
    If (slideShowRunning=1)
       ToggleSlideShowu()

    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    ; If (editingSelectionNow=1 && imgEditPanelOpened!=1)
    ;    ToggleEditImgSelection()

    panelWinCollapsed := 0
    interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
    interfaceThread.ahkassign("imgEditPanelOpened", imgEditPanelOpened)
    If (imgEditPanelOpened=1)
    {
       initQPVmainDLL()
       recordSelUndoLevelNow()
       INIaction(0, "closeEditPanelOnApply", "General")
       interfaceThread.ahkassign("AnyWindowOpen", IDwin)
       TriggerMenuBarUpdate()
       If AnyWindowOpen
          Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%
       DestroyGIFuWin()
       Gui, SettingsGUIA: Destroy
       Sleep, 5
    } Else CloseWindow()
    Sleep, 15
    Gui, SettingsGUIA: Default
    Gui, SettingsGUIA: -MaximizeBox -MinimizeBox +Owner%PVhwnd% hwndhSetWinGui
    Gui, SettingsGUIA: Margin, 15, 15
    If (PrefsLargeFonts=1)
       Gui, Font, Bold Q4

    AnyWindowOpen := IDwin
    interfaceThread.ahkassign("AnyWindowOpen", IDwin)
    interfaceThread.ahkassign("hSetWinGui", hSetWinGui)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 0]
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    Return thisBtnHeight
}

PanelSeenStats() {
    Global LViewMetaD, LViewMetaM, LViewMetaH, infoLine
    showTOOLtip("Generating statistics, please wait...")
    thisBtnHeight := createSettingsGUI(39, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 199
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 140
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    changeMcursor()
    Gui, Add, Tab3,, Daily|Monthly|Hourly|Options
    Gui, Tab, 1 ; Daily
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD gSeenStatsLVaction, #|Date|Images
    Gui, Tab, 2 ; Monthly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaM gSeenStatsLVaction, #|Date|Images
    Gui, Tab, 3 ; Hourly
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaH, #|Hour|Images
    Gui, Tab, 4 ; Options
    Gui, Add, Button, x+15 y+15 h%thisBtnHeight% gCleanDeadFilesSeenImagesDB, &Purge inexistent files from the list
    Gui, Add, Button, y+5 hp geraseSeenIMGsDB, &Erase the entire list
    Gui, Add, Button, y+5 hp gBtnCopySeenStats, &Copy statistics to clipboard
    Gui, Add, Button, y+5 hp gBtnALLviewedImages2List, &Retrieve list of recorded seen images
    Gui, Add, Text, y+10 w%lstWid%, TIP: To retrieve the images seen on a given day or month, double click on the date in the list.
    Gui, Add, Text, y+10 h%thisBtnHeight% +0x200 w%lstWid% vinfoLine, Please wait...

    Gui, Tab
    Gui, Add, Button, xp y+5 h%thisBtnHeight% w1 h1 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Images seen statistics: " appTitle)
    PopulateSeenStatsInfos()
    SetTimer, RemoveTooltip, -500
    SetTimer, ResetImgLoadStatus, -500, 900
}

SeenStatsLVaction() {
    MouseGetPos, , , OutputVarWin, OutputVarControl, 3
    RowNumber := LV_EX_GetNextItem(OutputVarControl, -1)
    folderu := LV_EX_GetSubItemText(OutputVarControl, RowNumber + 1, 2)
    If (StrLen(folderu)<3 || folderu="date") || (A_GuiEvent!="DoubleClick" && dummy!="menu-mode")
       Return

    BtnALLviewedImages2List(folderu "|filteru|")
}

BtnCopySeenStats() {
   textu .= "`nMONTHLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaM
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nDAILY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   textu .= "`nHOURLY SEEN IMAGES:`n"
   Gui, SettingsGUIA: ListView, LViewMetaH
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>3)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1 || aC=2) ? " | " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>950)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Failed to copy to clipboard...")
         SoundBeep , 300, 100
      } Else showTOOLtip("Images seen statistics copied to the clipboard...")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateSeenStatsInfos() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  entriesCount := 0
  RecordSet := ""
  SQL := "SELECT imgViewDate, COUNT(*) FROM images GROUP BY imgViewDate;"
  If !seenImagesDB.Query(SQL, RecordSet)
     Return 0

  entriesD := []
  entriesM := []
  entriesH := []
  Loop
  {
      ; sleep, 50
      ; ToolTip, % Row[1] "a`nb" Row[2] , , , 2
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      ; If RegExMatch(Row[1], RegExFilesPattern)
      If Row[1]
      {
         dateuD := "z" StrReplace(SubStr(Row[1], 1, 10), "-")
         dateuM := "z" StrReplace(SubStr(Row[1], 1, 7), "-")
         dateuH := "z" StrReplace(SubStr(Row[1], 12, 2), "-")
         entriez%dateuD% += Row[2]
         entriez%dateuM% += Row[2]
         entriez%dateuH% += Row[2]
         entriesCount += Row[2]
         entriesD[dateuD] := [entriez%dateuD%, SubStr(Row[1], 1, 10)]
         entriesM[dateuM] := [entriez%dateuM%, SubStr(Row[1], 1, 7)]
         entriesH[dateuH] := [entriez%dateuH%, SubStr(Row[1], 12, 2)]
      }
      RC := RecordSet.Next(Row)
  } Until (RC<1)
  Gui, SettingsGUIA: ListView, LViewMetaD
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesD
      LV_Add(A_Index, A_Index, Value[2], Value[1])
  Loop, 3
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaM
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesM
      LV_Add(A_Index, A_Index, Value[2], Value[1])
  Loop, 3
      LV_ModifyCol(A_Index, "AutoHdr Center")
  LV_ModifyCol(2, "SortDesc")

  Gui, SettingsGUIA: ListView, LViewMetaH
  LV_ModifyCol(1, "Integer")
  LV_ModifyCol(3, "Integer")
  For Key, Value in entriesH
      LV_Add(A_Index, A_Index, Value[2] ":00", Value[1])
  Loop, 3
      LV_ModifyCol(A_Index, "AutoHdr Center")

  entriesCount := groupDigits(entriesCount)
  GuiControl, SettingsGUIA:, infoLine, Total seen images: %entriesCount%
}

PanelImageInfos() {
    Global LViewMetaD, LViewMetaOthers
    If (thumbsDisplaying=1)
       MenuDummyToggleThumbsMode()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, fileNamu, folderu)
    If !FileRexists(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(5, A_ThisFunc)
    btnWid := 105
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 230
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Tab3,, General|Others
    Gui, Tab, 1 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaD, Property|Data
    Gui, Tab, 2 ; general
    Gui, Add, ListView, x+15 y+15 w%lstWid% r12 Grid vLViewMetaOthers, Property|Data
    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w40 gInfoBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gInfoBtnNextImg, >>
    Gui, Add, Button, x+15 hp w%btnWid% gcopyIMGinfos2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gOpenThisFileFolder, &Open in folder
    Gui, Add, Button, x+5 hp w%btnWid% gOpenFileProperties, &File properties
    Gui, Add, Button, x+5 hp w90 Default gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file details: " appTitle)
    PopulateImgInfos()
}

BtnCloseWindow() {
   CloseWindow("yes")
}

InfoBtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  NextPicture()
  Sleep, 1
  PopulateImgInfos()
}

InfoBtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  PreviousPicture()
  Sleep, 1
  PopulateImgInfos()
}

copyIMGinfos2clip() {
   Gui, SettingsGUIA: ListView, LViewMetaD
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>95)
          Break
   }

   textu := Trimmer(textu) "`NOTHER DETAILS:`n"
   Gui, SettingsGUIA: ListView, LViewMetaOthers
   aR := aC := 0
   Loop
   {
       aC++
       If (aC>2)
       {
          aR++
          aC := 1
       }
       LV_GetText(valu, aR, aC)
       delimu := (aC=1) ? ": " : "`n"
       If valu
          textu .= valu delimu
       Sleep, -1
       ; ToolTip, %valu% -- %aC% -- %aR%
       If (valu="" && A_Index>99)
          Break
   }

   If StrLen(textu)>10
   {
      Try Clipboard := Trimmer(textu)
      Catch wasError
          Sleep, 1

      If wasError
      {
         showTOOLtip("ERROR: Unable to copy to clipboard file details...")
         SoundBeep , 300, 100
      } Else showTOOLtip("File details copied to the clipboard...")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

PopulateImgInfos() {
   resultu := getIDimage(currentFileIndex)
   If !FileExist(resultu)
   {
      informUserFileMissing()
      Return
   }

   Gui, SettingsGUIA: ListView, LViewMetaOthers
   LV_Delete()
   Try PropList := FGP_List(resultu)            ; Gets all of a file's non-blank properties.
   Loop, Parse, % PropList.CSV,`n
   {
       If !A_LoopField
          Continue
       lineArru := StrSplit(A_LoopField, ",")
       LV_Add(A_Index, lineArru[2], lineArru[3])
   }

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")

   Gui, SettingsGUIA: ListView, LViewMetaD
   LV_Delete()
   FileGetSize, FileSizu, % resultu, K
   FileGetTime, FileDateM, % resultu, M
   FileGetTime, FileDateC, % resultu, C
   FormatTime, FileDateM, % FileDateM, dddd, d MMMM yyyy, HH:mm:ss
   FormatTime, FileDateC, % FileDateC, dddd, d MMMM yyyy, HH:mm:ss

   zPlitPath(resultu, 0, fileNamu, folderu)
   zoomu := Round(zoomLevel*100)
   If (thisIMGisDownScaled=1)
      infoDownScale := " [DOWNSCALED] "

   Gdip_GetImageDimensions(useGdiBitmap(), Width, Height)
   If (currIMGdetails.TooLargeGDI=1)
      infoRes := "`nOriginal resolution (W x H)||" groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " (in pixels)"

   generalInfos := "File name||" fileNamu "`nLocation||" folderu "\`nFile size||" groupDigits(fileSizu) " kilobytes`nDate created||" FileDateC "`nDate modified||" FileDateM infoRes "`nResolution (W x H)||" groupDigits(Width) " x " groupDigits(Height) " (in pixels)`nCurrent zoom level||" zoomu " % (" DefineImgSizing() infoDownScale ")"
   Loop, Parse, generalInfos, `n
   {
       lineArru := StrSplit(A_LoopField, "||")
       LV_Add(A_Index, lineArru[1], lineArru[2])
   }

   LV_Add(A_Index, "Colors display mode", DefineFXmodes())
   Gdip_GetHistogram(useGdiBitmap(), 2, ArrChR, ArrChG, ArrChB)
   Loop, 256
   {
       sumTotalR += ArrChR[A_Index] * A_Index
       sumTotalG += ArrChG[A_Index] * A_Index
       sumTotalB += ArrChB[A_Index] * A_Index
   }

   diffRGBtotal := max(sumTotalR, sumTotalG, sumTotalB) - min(sumTotalR, sumTotalG, sumTotalB)
   diffRGBtotal := diffRGBtotal/max(sumTotalR, sumTotalG, sumTotalB)
   If (diffRGBtotal<0.0001 || diffRGBtotal="")
      LV_Add(A_Index, "Grayscale image", 1)
   Else
      LV_Add(A_Index, "Grayscale image", 0)

   LV_Add(A_Index, "Image file format", currIMGdetails.RawFormat)
   LV_Add(A_Index, "Image pixel format", currIMGdetails.PixelFormat)

   CountFrames := currIMGdetails.Frames
   If (CountFrames>1)
      LV_Add(A_Index, "Embedded frames", CountFrames)

   If (currIMGdetails.OpenedWith="GDI+")
   {
      thumbBMP := trGdip_CreateBitmapFromFile(getIDimage(currentFileIndex))
      If StrLen(thumbBMP)>2
         MoreProperties := Gdip_GetAllPropertyItems(thumbBMP)
      For ID, Val In MoreProperties
      {
         If ID Is Integer
         {
            PropName := Gdip_GetPropertyTagName(ID)
            PropType := Gdip_GetPropertyTagType(Val.Type)
            If (val.value && StrLen(PropName)>1 && PropName!="unknown" && PropType!="undefined" && PropType!="byte")
            {
               If (InStr(PropName, "nancetable") || InStr(PropName, "jpeg") || InStr(PropName, "thumbnail")
               || InStr(PropName, "printflag") || InStr(PropName, "strip") || InStr(PropName, "chromatic"))
                  Continue
 
               If (PropName="frame delay") || (PropName="bits per sample")
               {
                  valu := SubStr(Val.Value, 1, InStr(Val.Value, A_Space))
                  LV_Add(A_Index, PropName, valu)
               } Else LV_Add(A_Index, PropName, Val.Value)
            }
         }
      }
      trGdip_DisposeImage(thumbBMP, 1)
   }
   LV_Add(A_Index, "Image loaded with ", currIMGdetails.OpenedWith)

   Loop, 2
       LV_ModifyCol(A_Index, "AutoHdr Left")
}

Trimmer(string, whatTrim:="") {
   If (whatTrim!="")
      string := Trim(string, whatTrim)
   Else
      string := Trim(string, "`r `n `t`f`v`b")
   Return string
}

FileRexists(filePath) {
   filePath := Trimmer(filePath)
   FileGetSize, fileSizu, %filePath%
   fileAttribs := FileExist(filePath)
   ; MsgBox, % fileAttribs "`n" fileSizu "`nA" filePath "A"
   If (!fileAttribs || InStr(fileAttribs, "D") || fileSizu<120 || !FileSizu)
      Return 0
   Else
      Return 1
}

hFindIsFolder(ByRef fileInfos) {
   Static FILE_ATTRIBUTE_DIRECTORY := 0x10
   Return NumGet(&fileInfos,0,"UInt") & FILE_ATTRIBUTE_DIRECTORY
}

hFindGetName(ByRef fileInfos) {
   cFileName := StrGet(&fileInfos + 44, 260, "UTF-16")
   If (cFileName="." || cFileName="..")
      cFileName := ""
   Return cFileName
}


testGetFile(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 1512, 0)

    hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")
    cFileName := hFindGetName(Win32FindData)
    If (hFindIsFolder(Win32FindData) && cFileName)
    {
    ;  MsgBox, folderrr
       testGetFile(filePath "\" cFileName)
    } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
    {
       maxFilesIndex++
       resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
    }

   ; MsgBox, % filePath "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError


 ;   instance.nFileSizeHigh := NumGet(&Win32FindData, 28,  "UInt")
;    instance.nFileSizeLow := NumGet(&Win32FindData, 32,  "UInt")

    While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
          cFileName := hFindGetName(Win32FindData)
          If hFindIsFolder(Win32FindData) && cFileName
          {
             testGetFile(filePath "\" cFileName)
          } Else If (RegExMatch(Trimmer(cFileName), RegExFilesPattern))
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [filePath "\" cFileName]
          }
    ; MsgBox, % filePath "`n" r "`n" hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
    }

   ; maxFilesIndex := resultedFilesList.Length()
    ; SoundBeep 
    Return
}

testGetFile2(filePath) {
  ; SizeInBytes := 568 + 3 * 8 = 592
    VarSetCapacity(Win32FindData, 318+1024, 0)
    if (hFind := DllCall("FindFirstFileW", "WStr", filePath "\*", "Ptr", &Win32FindData, "Ptr")) {
        cFileName := StrGet(&Win32FindData + 44, 260, "UTF-16")
        cAlternateFileName := StrGet(&Win32FindData + 564, 14, "UTF-16")
        
        MsgBox, %  hFind "`n" cFileName "`n" cAlternateFileName "`n" ErrorLevel "`n" A_LastError
        While (r := DllCall("FindNextFileW", "ptr", hFind, "ptr", &Win32FindData)) {
            cFileNamea := StrGet(&Win32FindData + 44, 260, "UTF-16")
            cAlternateFileNamea := StrGet(&Win32FindData + 564, 14, "UTF-16")
            MsgBox, %  r "`n" cFileNameA "`n" cAlternateFileNameA "`n" ErrorLevel "`n" A_LastError
        }
    }
    Return
}

testFileExistence(imgPath) {
  ; https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfilesize
  ; H := DllCall("kernel32\GetFileAttributesW", "Str", imgPath)
  ; H := DllCall("shlwapi.dll\PathFileExistsW", "Str", imgPath)
  ; If (h>0)
  ;    Return 256
  VarSetCapacity(dummy, 1024, 0)
  H := DllCall("kernel32\FindFirstFileW", "Str", imgPath, "Ptr", &dummy, "Ptr")
  Return H
}

informUserFileMissing() {
   Critical, on
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
   winTitle := "[*] " currentFileIndex "/" maxFilesIndex " | " fileNamu " | " folderu
   setWindowTitle(winTitle, 1)
   SoundBeep, 300, 50
   If (autoRemDeadEntry=1)
      remCurrentEntry(0, 1)
   If (thumbsDisplaying=1 && maxFilesIndex>0)
      mainGdipWinThumbsGrid()

   SetTimer, RemoveTooltip, % -msgDisplayTime
}

JEE_StrRegExLiteral(vText) {
  vOutput := ""
  VarSetCapacity(vOutput, StrLen(vText)*2*2)

  Loop, Parse, vText
  {
    If InStr("\.*?+[{()^$", A_LoopField)
      vOutput .= "\" A_LoopField
    Else
      vOutput .= A_LoopField
  }

  Return vOutput
}

FiltersComboAction() {
  If (A_GuiControlEvent="DoubleClick")
     BtnApplyFilesFilter()
}


readRecentFiltersEntries() {
   testFilteru := Trimmer(StrReplace(usrFilesFilteru, "&"))
   entriesList .= StrLen(usrFilesFilteru)>1 ? "--={ no filter }=--`n" : ""
   Loop, 20
   {
       IniRead, newEntry, % mainRecentsFile, RecentFilters, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If ((newEntry="--={ no filter }=--") || InStr(entriesList, newEntry "`n") || !newEntry)
          Continue

       addSel := (newEntry=testFilteru) ? "`n" : ""
       If StrLen(newEntry)>1
          entriesList .= newEntry "`n" addSel
   }
   Return entriesList
}

EraseFilterzHisto() {
  IniDelete, % mainRecentsFile, RecentFilters
  CloseWindow()
  Sleep, 50
  PanelEnableFilesFilter()
}

PanelEnableFilesFilter() {
    Global UsrEditFilter
    If (maxFilesIndex<3 && !usrFilesFilteru)
       Return

    thisBtnHeight := createSettingsGUI(6, A_ThisFunc)
    btnWid := 80
    txtWid := 360
    EditWid := 399
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 200
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    listu := readRecentFiltersEntries()
    If (!InStr(listu, "`n`n") && StrLen(usrFilesFilteru)>1)
       listu := usrFilesFilteru "`n`n" listu

    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid%, Type a string to filter file names and/or paths.
    Gui, Add, ComboBox, y+10 w%EditWid% r7 gFiltersComboAction Simple vUsrEditFilter, % listu
    Gui, Add, Text, y+7 w%txtWid%, Tip: you can begin the string with \> to use RegEx.

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnApplyFilesFilter, &Apply filter
    Gui, Add, Checkbox, x+5 hp Checked%UsrMustInvertFilter% vUsrMustInvertFilter, Invert filter
    Gui, Add, Button, x+35 hp w%btnWid% gEraseFilterzHisto, Erase &history
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Files list filtering: " appTitle)
}

BtnApplyFilesFilter() {
   GuiControlGet, UsrEditFilter
   GuiControlGet, UsrMustInvertFilter
   CloseWindow("yes")
   Sleep, 2
   UsrEditFilter := Trimmer(UsrEditFilter)
   UsrEditFilter := StrReplace(UsrEditFilter, "||", "|")
   UsrEditFilter := Trimmer(UsrEditFilter, "|")
   UsrEditFilter := StrReplace(UsrEditFilter, "&")
   If (!UsrEditFilter && !filesFilter)
      Return

   If askAboutFileSave(" and the files list will be renewed based on the provided filter criteria")
   {
      UsrEditFilter := ""
      Return
   }

   RecentFiltersManager(UsrEditFilter)
   If (UsrMustInvertFilter=1 && StrLen(UsrEditFilter)>0)
      UsrEditFilter := "&" UsrEditFilter

   If InStr(UsrEditFilter, "{ no filter }")
      UsrEditFilter := ""
   coreEnableFiltru(UsrEditFilter)
}

RecentFiltersManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFiltersEntries()
  If (StrLen(entry2add)<3 || InStr(entry2add, "{ no filter }"))
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>20)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentFilters, E%countItemz%
  }
}

msgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, checkBoxuCaption:="", checkState:=0, dropListu:="",edithu:="", edithuDef:="", listEdit:=0, setWidth:=0) {
    Static msgBoxed := 0
    If (msgBoxed=1 && MsgBox2hwnd)
       Return

    msgBoxed := 1
    SetTimer, dummyUnSuspendu, Delete
    doSuspendu(1)
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", iconz)

    panelMode := 0
    fontSize := (PrefsLargeFonts=1) ? LargeUIfontValue : 0
    hwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
    If (InStr(winTitle, "panelu|") && AnyWindowOpen>0 && prevOpenedWindow[5]=1)
    {
       winTitle := StrReplace(winTitle, "panelu|")
       panelMode := 1
       hwnd := PVhwnd
    } Else DestroyTempBtnGui("now")

    zr := MsgBox2(msg, winTitle, buttonz, defaultBTN, iconz, nullFnt, PrefsLargeFonts, fontSize, hwnd, hwnd, checkBoxuCaption, checkState, dropListu, edithu, edithuDef, listEdit, setWidth)
    r := zr.btn

    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    If (buttonz!=-1)
       addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
    Else
       addJournalEntry("HELP BOX CLOSED: " winTitle)

    If (panelMode=1) ; fake window panel
    {
       AnyWindowOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    }

    lastLongOperationAbort := A_TickCount
    If (iconz="error" || iconz="exclamation" || iconz="question") && (runningLongOperation!=1)
       interfaceThread.ahkPostFunction("setTaskbarIconState", "normal")
    SetTimer, dummyUnSuspendu, -200, 900
    msgBoxed := 0
    Return (checkBoxuCaption || dropListu || edithu) ? zr : r
}

simpleMsgBoxWrapper(winTitle, msg, buttonz:=0, defaultBTN:=1, iconz:=0, modality:=0, optionz:=0) {
   ; Buttonz options:
   ; 0 = OK (that is, only an OK button is displayed)
   ; 1 = OK/Cancel
   ; 2 = Abort/Retry/Ignore
   ; 3 - Yes/No/Cancel
   ; 4 = Yes/No
   ; 5 = Retry/Cancel
   ; 6 = Cancel/Try Again/Continue

   ; Iconz options:
   ; 16 = Icon Hand (stop/error)
   ; 32 = Icon Question
   ; 48 = Icon Exclamation
   ; 64 = Icon Asterisk (info)

   ; Modality options:
   ; 4096 = System Modal (always on top)
   ; 8192 = Task Modal
   ; 262144 = Always-on-top (style WS_EX_TOPMOST - like System Modal but omits title bar icon)

   If AnyWindowOpen
   {
      If (defaultBTN=2)
         defaultBTN := 255
      Else If (defaultBTN=3)
         defaultBTN := 512
      Else
         defaultBTN := 0
 
      If (iconz=1 || iconz="hand" || iconz="error" || iconz="stop")
         iconz := 16
      Else If (iconz=2 || iconz="question")
         iconz := 32
      Else If (iconz=3 || iconz="exclamation")
         iconz := 48
      Else If (iconz=4 || iconz="info")
         iconz := 64
      Else
         iconz := 0
 
      theseOptionz := buttonz + iconz + defaultBTN + modality
      If optionz
         theseOptionz := optionz
 
      Gui, SettingsGUIA: +OwnDialogs
      MsgBox, % theseOptionz, % winTitle, % msg
      IfMsgBox, Yes
           r := "Yes"
      IfMsgBox, No
           r := "No"
      IfMsgBox, OK
           r := "OK"
      IfMsgBox, Cancel
           r := "Cancel"
      IfMsgBox, Abort
           r := "Abort"
      IfMsgBox, Ignore
           r := "Ignore"
      IfMsgBox, Retry
           r := "Retry"
      IfMsgBox, Continue
           r := "Continue"
      IfMsgBox, TryAgain
           r := "TryAgain"
   } Else r := interfaceThread.ahkFunction("msgBoxWrapper", winTitle, msg, buttonz, defaultBTN, iconz, modality, optionz)

   ; addJournalEntry("DIALOG BOX: " msg "`n`nUser answered: " r)
   ; lastLongOperationAbort := A_TickCount
   Return r
}

coreEnableFiltru(stringu, doExactFolderMatch:=0) {
  backCurrentSLD := CurrentSLD
  userSearchString := CurrentSLD := ""
  friendly := (StrLen(stringu)>1) ? "Applying filter on the list of files, please wait...`n" stringu : "Deactivating the files list filter, please wait..."
  showTOOLtip(friendly)
  setImageLoading()
  If StrLen(filesFilter)<2
  {
     thereWasFilter := 0
     bckpResultedFilesList := []
     bckpResultedFilesList := resultedFilesList.Clone()
     bckpMaxFilesIndex := maxFilesIndex
  } Else thereWasFilter := 1

  usrFilesFilteru := stringu
  testRegEx := SubStr(stringu, 1, 2)
  If (testRegEx!="\>")
     filesFilter := JEE_StrRegExLiteral(stringu)
  Else
     filesFilter := SubStr(stringu, 3)

  filesFilter := StrReplace(filesFilter, "&")
  FilterFilesIndex(thereWasNoFilter, doExactFolderMatch)
  If (maxFilesIndex<1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "No files matched your filtering criteria:`n" usrFilesFilteru "`n`nThe application will now restore the complete list of files.", 0, 1, "exclamation")
     usrFilesFilteru := filesFilter := ""
     FilterFilesIndex()
  } Else SoundBeep, 950, 100

  CurrentSLD := backCurrentSLD
  SetTimer, ResetImgLoadStatus, -50
  If (maxFilesIndex>0)
     RandomPicture()

  SetTimer, RemoveTooltip, % -msgDisplayTime
}

FilterFilesIndex(thereWasFilter:=0, doExactFolderMatch:=0) {
   startZeit := A_TickCount
   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   filterBehaviour := InStr(usrFilesFilteru, "&") ? 1 : 2
   If (filesFilter="||Prev-Files-Selection||")
   {
       Loop, % maxFilesIndex + 1
       {
            r := resultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            If (resultedFilesList[A_Index, 2]!=1)
               Continue

            newFilesIndex++
            newFilesList[newFilesIndex] := [r]
            If (thereWasFilter=1)
            {
               oldIndex := filteredMap2mainList[A_Index]
               newMappingList[newFilesIndex] := oldIndex
            } Else newMappingList[newFilesIndex] := A_Index
       }
   } Else
   {
       Loop, % bckpMaxFilesIndex + 1
       {
            r := bckpResultedFilesList[A_Index, 1]
            If (InStr(r, "||") || !r)
               Continue

            thisIndex++
            If StrLen(filesFilter)>1
            {
               If filterCoreString(r, filterBehaviour, filesFilter, doExactFolderMatch)
                  Continue
            }

            newFilesIndex++
            newFilesList[newFilesIndex] := [r]
            If StrLen(filesFilter)>1
               newMappingList[newFilesIndex] := A_Index
       }
   }

   filteredMap2mainList := []
   renewCurrentFilesList()
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
   GenerateRandyList()
}

throwMSGwriteError() {
  Static lastInvoked := 1
  If (ErrorLevel=1) && (A_TickCount - lastInvoked>45100)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the settings files: permission denied...", 0, 0, "error")
     lastInvoked := A_TickCount
  }
}

InListMultiEntriesRemover() {
   filesElected := getSelectedFiles(0, 1)
   If (markedSelectFile>1)
      itsMultiFiles := 1

   If (itsMultiFiles!=1)
   {
      remCurrentEntry(0, 0)
      Return
   }

   If (filesElected>500)
   {
      msgResult := msgBoxWrapper(appTitle, "Are you sure you want to remove " filesElected " entries from the slideshow files list?", 4, 0, "question")
      If (msgResult!="yes")
         Return
   }

   startOperation := A_TickCount
   showTOOLtip("Removing " filesElected " index entries, please wait...")
   prevMSGdisplay := A_TickCount
   ForceRefreshNowThumbsList()
   prevMaxy := maxFilesIndex
   countTFilez := 0
   doStartLongOpDance()
   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("BEGIN TRANSACTION;")

   newFilesIndex := 0
   newFilesList := []
   newMappingList := []
   Loop, % maxFilesIndex + 1
   {
      thisFileIndex := A_Index ; - countTFilez
      isSelected := resultedFilesList[thisFileIndex, 2]
      imgPath := resultedFilesList[thisFileIndex, 1]
      If (isSelected!=1 && imgPath)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := [imgPath]
         If StrLen(filesFilter)>1
            newMappingList[newFilesIndex] := filteredMap2mainList[thisFileIndex]
         Continue
      } Else If !imgPath
         Continue

      If (SLDtypeLoaded=3)
      {
         imgPath := StrReplace(imgPath, "||")
         zPlitPath(imgPath, 1, OutFileName, OutDir)
         deleteSQLdbEntry(OutFileName, OutDir)
      }

      If StrLen(filesFilter)>1
         bckpResultedFilesList[filteredMap2mainList[thisFileIndex], 1] := ""

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
      If !startPoint
         startPoint := thisFileIndex
   }
   resultedFilesList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   filteredMap2mainList := []
   If StrLen(filesFilter)>1
      filteredMap2mainList := newMappingList.Clone()
   newMappingList := []

   If (SLDtypeLoaded=3)
      activeSQLdb.Exec("COMMIT TRANSACTION;")

   ResetImgLoadStatus()
   setImageLoading()
   GenerateRandyList()
   zeitOperation := A_TickCount - startOperation
   etaTime := "Elapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
   If (abandonAll=1)
      showTOOLtip("Operation abaorted. " countTFilez " index entries were removed until now...`n" etaTime)
   Else
      showTOOLtip(countTFilez " index entries removed...`n" etaTime)

   markedSelectFile := 0
   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         changeMcursor()
         showTOOLtip("Removing files list index filter, please wait...")
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
         RandomPicture()
      } Else
      {
         msgBoxWrapper(appTitle ": WARNING", "No files left in the index of " appTitle ", please (re)open a file or folder...", 0, 0, "info")
         resetMainWin2Welcome()
      }
   } Else
   {
      startPoint--
      If (startPoint<2)
         startPoint := 1
      currentFileIndex := startPoint
      dummyTimerDelayiedImageDisplay(50)
   }

   SoundBeep,  % (abandonAll=1) ? 300 : 900, 100
   SetTimer, ResetImgLoadStatus, -50
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

remCurrentEntry(dummy, silentus:=0, batchMode:=0, whichIndex:=0) {
   Critical, on
   thisFileIndex := !whichIndex ? currentFileIndex : whichIndex
   file2remZ := resultedFilesList.RemoveAt(thisFileIndex)
   ; file2remA := file2remZ[1]
   If StrLen(filesFilter)>1
   {
      ; oldIndex :=  filteredMap2mainList[thisFileIndex]
      file2remC := filteredMap2mainList.RemoveAt(thisFileIndex)
      ; file2remB := bckpResultedFilesList[oldIndex, 1]
      bckpResultedFilesList[filteredMap2mainList[thisFileIndex], 1] := ""
      ; Sleep, 200
      ; ToolTip, % file2remC " b " oldIndex " a " file2remB "`n" file2remA, , , 2
   }

   If (SLDtypeLoaded=3 || batchMode!=1)
   {
      file2rem := StrReplace(file2remZ[1], "||")
      zPlitPath(file2rem, 1, OutFileName, OutDir)
      If (batchMode=1)
         deleteSQLdbEntry(OutFileName, OutDir)
    }

   If (InStr(CurrentSLD, "\favourite-images-list.SLD") && batchMode!=1)
      renewFavesListBasedOnIndexList()

   maxFilesIndex--
   If (batchMode=1)
      Return

   ForceRefreshNowThumbsList()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (silentus!=1)
   {
      If (thumbsDisplaying!=1)
         Sleep, 200

      showTOOLtip("Index entry removed...`n" OutFileName "`n" OutDir "\")
   }

   If (maxFilesIndex<1)
   {
      FadeMainWindow()
      If StrLen(filesFilter)>1
      {
         showTOOLtip("Removing files list index filter, please wait...")
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
         RandomPicture()
      } Else
      {
         msgBoxWrapper(appTitle, "No files left in the index of " appTitle ", please (re)open a file or folder...", 0, 0, "info")
         resetMainWin2Welcome()
      }
   } Else 
   {
      currentFileIndex--
      NextPicture()
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

addSQLdbEntry(fileNamu, imgPath, fileSizu, fileMdate, fileCdate) {
   SQLstr := "INSERT INTO images (imgfile, imgfolder, fsize, fmodified, fcreated) VALUES ('" fileNamu "', '" imgPath "', '" fileSizu "', '" fileMdate "', '" fileCdate "');"
   If !activeSQLdb.Exec(SQLStr)
   {
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "INSERT INTO images (imgfile, imgfolder, fsize, fmodified, fcreated) VALUES (" fileNamu ", " imgPath ", '" fileSizu "', '" fileMdate "', '" fileCdate "');"
      activeSQLdb.Exec(SQLStr)
   }
}

updateSQLdbEntryImgRes(fileNamu, imgPath, imgW, imgH) {
   SQLstr := "UPDATE images SET imgwith='" imgW "', imgheight='" imgH "' WHERE (imgfile='" fileNamu "' AND imgfolder='" imgPath "');"
   If !activeSQLdb.Exec(SQLStr)
   {
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      SQLstr := "UPDATE images SET imgwith='" imgW "', imgheight='" imgH "' WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      activeSQLdb.Exec(SQLStr)
   }
}

updateSQLdbEntryCaption(imgPath, txtData, whatSet) {
   activeSQLdb.EscapeStr(imgPath)
   activeSQLdb.EscapeStr(txtData)
   SQLstr := "INSERT INTO imagesData (imgfile) VALUES (" imgPath ");"
   activeSQLdb.Exec(SQLStr)
   SQLstr := "UPDATE imagesData SET " whatSet "=" txtData " WHERE imgfile=" imgPath ";"
   If !activeSQLdb.Exec(SQLStr)
      Return -1
}

retrieveSQLdbEntryCaption(imgPath, whatRetrieve) {
  If (SLDtypeLoaded!=3)
     Return

  RecordSet := ""
  activeSQLdb.EscapeStr(imgPath)
  SQL := "SELECT " whatRetrieve " FROM imagesData WHERE imgfile=" imgPath ";"
  If !activeSQLdb.Query(SQL, RecordSet)
     Return

  Loop
  {
      entries .= Row[1]
      RC := RecordSet.Next(Row)
  } Until (RC<1)

  RecordSet.Free()
  entries := Trimmer(entries)
  Return entries
}

updateSQLdbEntry(fileNamu, imgPath, newFileName, newFilePath) {
   SQLstr := "UPDATE images SET imgfile='" newFileName "', imgfolder='" newFilePath "' WHERE (imgfile='" fileNamu "' AND imgfolder='" imgPath "');"
   If !activeSQLdb.Exec(SQLStr)
   {
      activeSQLdb.EscapeStr(fileNamu)
      activeSQLdb.EscapeStr(imgPath)
      activeSQLdb.EscapeStr(newFileName)
      activeSQLdb.EscapeStr(newFilePath)
      SQLstr := "UPDATE images SET imgfile=" newFileName ", imgfolder=" newFilePath " WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
      activeSQLdb.Exec(SQLStr)
   }
}

deleteSQLdbEntry(fileNamu, imgPath) {
  SQLstr := "DELETE FROM images WHERE (imgfile='" fileNamu "' AND imgfolder='" imgPath "');"
  If !activeSQLdb.Exec(SQLStr)
  {
     activeSQLdb.EscapeStr(fileNamu)
     activeSQLdb.EscapeStr(imgPath)
     SQLstr := "DELETE FROM images WHERE (imgfile=" fileNamu " AND imgfolder=" imgPath ");"
     activeSQLdb.Exec(SQLStr)
  }
}

openFileDialogWrapper(p_Type, optionz, startPath, msg, pattern, ByRef n_FilterIndex:="", chooseFilterIndex:=1, defaultEditField:="") {
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen) ? hSetWinGui : PVhwnd
   ; If (p_type="o")
   ;    pattern .= "|All files (*.*)"

   If FolderExist(startPath)
      pathSymbol := "\"

   If !chooseFilterIndex
      chooseFilterIndex := 1

   optionz .= " NoChangeDir HideReadOnly"
   If InStr(p_type, "o")
   {
      entriesList := defaultu "`n" recentOpenedFolders()
      If (p_type="o1")
      {
         thisCombo := "Open selected file only"
         thisCombo .= "`nOpen in a new QPV instance"
         thisCombo .= "`nIndex all images in current folder as well"
         thisCombo .= "`nPerform recursive folder(s) scan to index images"
         thisGroup := "Open mode"
      }

      FileMustExist := InStr(optionz, "FileMustExist") ? 1 : 0
      zr := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, thisCombo, 1, thisGroup, entriesList, 0, pattern, chooseFilterIndex, FileMustExist, defaultEditField)
      r := zr.SelectedDir
      n_FilterIndex := zr.SelectedCombo
   } Else
   {
      If InStr(p_type, "m")
         p_Type := "o"

      r := Dlg_OpenSaveFile(p_Type, thisHwnd, msg, pattern, chooseFilterIndex, startPath pathSymbol, "", optionz)
      n_FilterIndex := NumGet(optionz, (A_PtrSize=8) ? 44:24,"UInt")
   }
   r := Trimmer(r)
   If StrLen(r)<4
      r := ""

   SetWorkingDir, % mainCompiledPath
   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return r
}

WritePrefsIntoSLD() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   startPath := !CurrentSLD ? prevOpenFolderPath : CurrentSLD
   file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save slideshow settings into file...", "Slideshow plain-text (*.sld)")
   If file2save
   {
      If !RegExMatch(file2save, sldsPattern)
         file2save .= ".sld"

      FileReadLine, firstLine, % file2save, 1
      If InStr(firstLine, "[General]")
      {
         Sleep, 10
         writeSlideSettings(file2save)
      } Else 
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgBoxWrapper(appTitle ": ERROR", "The selected file appears not to have the correct file format.`nPlease select a .SLD file already saved by this application.`n`n" OutFileName, 0, 0, "error")
      }
   }
}

recreateDynaFoldersSQLdbList(saveDynaFolders) {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM dynamicfolders;")
   Loop, Parse, saveDynaFolders, `n
   {
       If StrLen(A_LoopField)>1
          addDynamicFolderSQLdb(Trimmer(A_LoopField), 0, "dynamicfolders")
   }

   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

saveSlideSettingsInDB() {
   activeSQLdb.Exec("BEGIN TRANSACTION;")
   activeSQLdb.Exec("DELETE FROM settings;")
   IniSLDBWrite("SLDcacheFilesList", 1)
   IniSLDBWrite("IMGresizingMode", IMGresizingMode)
   IniSLDBWrite("imgFxMode", imgFxMode)
   IniSLDBWrite("SlideHowMode", SlideHowMode)
   IniSLDBWrite("slideShowDelay", slideShowDelay)
   IniSLDBWrite("WindowBgrColor", WindowBgrColor)
   IniSLDBWrite("FlipImgH", FlipImgH)
   IniSLDBWrite("FlipImgV", FlipImgV)
   IniSLDBWrite("usrColorDepth", usrColorDepth)
   IniSLDBWrite("ColorDepthDithering", ColorDepthDithering)
   IniSLDBWrite("lumosAdjust", lumosAdjust)
   IniSLDBWrite("GammosAdjust", GammosAdjust)
   IniSLDBWrite("lumosGrayAdjust", lumosGrayAdjust)
   IniSLDBWrite("GammosGrayAdjust", GammosGrayAdjust)
   IniSLDBWrite("satAdjust", satAdjust)
   IniSLDBWrite("imageAligned", imageAligned)
   IniSLDBWrite("doSatAdjusts", doSatAdjusts)
   IniSLDBWrite("autoAdjustMode", autoAdjustMode)
   IniSLDBWrite("chnRdecalage", chnRdecalage)
   IniSLDBWrite("chnGdecalage", chnGdecalage)
   IniSLDBWrite("chnBdecalage", chnBdecalage)
   IniSLDBWrite("usrAdaptiveThreshold", usrAdaptiveThreshold)
   ; IniSLDBWrite("noTooltipMSGs", noTooltipMSGs)
   IniSLDBWrite("TouchScreenMode", TouchScreenMode)
   IniSLDBWrite("skipDeadFiles", skipDeadFiles)
   IniSLDBWrite("isAlwaysOnTop", isAlwaysOnTop)
   IniSLDBWrite("bwDithering", bwDithering)
   IniSLDBWrite("RenderOpaqueIMG", RenderOpaqueIMG)
   IniSLDBWrite("zatAdjust", zatAdjust)
   IniSLDBWrite("hueAdjust", hueAdjust)
   IniSLDBWrite("realGammos", realGammos)
   IniSLDBWrite("imgThreshold", imgThreshold)
   IniSLDBWrite("isTitleBarHidden", isTitleBarHidden)
   IniSLDBWrite("animGIFsSupport", animGIFsSupport)
   IniSLDBWrite("thumbsAratio", thumbsAratio)
   IniSLDBWrite("thumbsZoomLevel", thumbsZoomLevel)
   IniSLDBWrite("easySlideStoppage", easySlideStoppage)
   IniSLDBWrite("appVersion", appVersion)
   IniSLDBWrite("usrTextureBGR", usrTextureBGR)
   IniSLDBWrite("syncSlideShow2Audios", syncSlideShow2Audios)
   IniSLDBWrite("autoPlaySNDs", autoPlaySNDs)
   IniSLDBWrite("borderAroundImage", borderAroundImage)
   IniSLDBWrite("resetImageViewOnChange", resetImageViewOnChange)
   IniSLDBWrite("showImgAnnotations", showImgAnnotations)
   IniSLDBWrite("allowGIFsPlayEntirely", allowGIFsPlayEntirely)
   IniSLDBWrite("prevFilesSortMode", prevFilesSortMode)
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

IniSLDBwrite(what, value, whichTable:="settings") {
    SQLstr := "INSERT INTO " whichTable " (paramz, valuez) VALUES ('" what "', '" value "');"
    r := activeSQLdb.Exec(SQLStr)
    Return r
}

IniSLDBreadAll(whichTable:="settings") {
  startOperation := A_TickCount
  SQL := "SELECT paramz, valuez FROM " whichTable ";"
  RecordSet := ""

  If !activeSQLdb.Query(SQL, RecordSet)
     Return -1

  Loop
  {
      If StrLen(Row[1])>3
      {
         paramu := Row[1]
         valu := Row[2]
         If (StrLen(valu)>0 && MustLoadSLDprefs=1 || paramu="prevFilesSortMode")
            %paramu% := valu
      }
      RC := RecordSet.Next(Row)
  } Until (RC<1)
  RecordSet.Free()
  RecordSet := ""
}

SQLdbGenerateStaticFolders() {
   If (SLDtypeLoaded=2)
   {
      BTNignoreSelFolder("update-all")
      Return
   }

   If AnyWindowOpen
      CloseWindow("yes")
   Sleep, 5
   activeSQLdb.Exec("DELETE FROM staticfolders;")
   SQL := "SELECT DISTINCT imgfolder FROM images;"
   RecordSet := ""
   FoldersArray := []
   If !activeSQLdb.Query(SQL, RecordSet)
   {
      SoundBeep, 300, 100
      addJournalEntry("Failed to execute SQL command in order to generate the static folders list from the indexed files.")
      Return
   }

   activeSQLdb.Exec("BEGIN TRANSACTION;")
   Loop
   {
       FoldersArray[A_Index] := Row[1] ; Row[1]
       RC := RecordSet.Next(Row)
   } Until (RC < 1)

   RecordSet.Free()
   Loop, % FoldersArray.Count()
   {
       thisFolder := Trimmer(FoldersArray[A_Index])
       If StrLen(thisFolder)>1
          addDynamicFolderSQLdb(thisFolder, 0, "staticfolders")
   }
   activeSQLdb.Exec("COMMIT TRANSACTION;")
}

SaveDBfilesList() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save slideshow", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nTo save as a slideshow the entire list of files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
      }
      file2save := openFileDialogWrapper("S", "PathMustExist", CurrentSLD, "Save files list as SQL slideshow database...", "Slideshow database (*.sldb)")
      If (!RegExMatch(file2save, "i)(.\.sldb)$") && file2save)
         file2save .= ".sldb"
   } Else Return
   If !file2save
      Return

   CloseWindow("yes")
   Sleep, 10
   startOperation := A_TickCount
   If (SLDtypeLoaded=1 || SLDtypeLoaded=2) && file2save
   {
      activeSQLdb.CloseDB()
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            Try FileDelete, %file2save%
            Catch wasErrorB
                  Sleep, 1
         } Else Return

         If wasErrorB
         {
            msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied...", 0, 0, "error")
            Return
         }
      }

      err := SLDinitSQLdb(file2save)
      If err
      {
         msgBoxWrapper(appTitle ": ERROR", "Unable to create SQL database file. Fatal error. Please choose the plain-text format to save the slideshow...`n`nError details: " err, 0, 0, "error")
         Return
      }

      setImageLoading()
      setWindowTitle("Saving SQL slideshow database, please wait", 1)
      showTOOLtip("Saving list of " maxFilesIndex " entries into SQL database...`n" file2save "`nPlease wait...")

      saveDynaFolders := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
      Sort, saveDynaFolders, UD`n
      recreateDynaFoldersSQLdbList(saveDynaFolders)
      saveSlideSettingsInDB()
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      staticFoldersListu := ""
      If (SLDcacheFilesList=1 && SLDtypeLoaded=2 && ForceRegenStaticFolders!=1)
      {
         populatedStaticFolders := 1
         rawstaticFoldersListu := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
         Loop, % countStaticFolders
         {
             staticFoldersListu .= rawstaticFoldersListu[A_Index, 1] "`n"
             addStaticFolderSQLdb(rawstaticFoldersListu[A_Index, 1], rawstaticFoldersListu[A_Index, 2], 0)
         }
      }

      activeSQLdb.Exec("COMMIT TRANSACTION;")
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      allFoldersList := saveDynaFolders "`n" staticFoldersListu

      Sort, allFoldersList, UD`n
      startZeit := A_TickCount
      Loop, Parse, allFoldersList, `n
      {
          If StrLen(A_LoopField)>2
             strDir := Trimmer(A_LoopField)
          Else
             Continue

          ; MsgBox, % strDir
          dig := "R"
          If InStr(strDir, "|")
          {
             strDir := StrReplace(strDir, "|")
             dig := ""
          }

          Loop, Files, %strDir%\*, %dig%
          {
              If RegExMatch(Trimmer(A_LoopFileFullPath), RegExFilesPattern) && (A_LoopFileSize>120)
                 addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)
          }
      }
      activeSQLdb.Exec("COMMIT TRANSACTION;")

      ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000)
      If (populatedStaticFolders!=1)
         SQLdbGenerateStaticFolders()

      CurrentSLD := file2save
      SLDtypeLoaded := 3
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      dummyTimerDelayiedImageDisplay(50)
      RemoveTooltip()
   } Else If (CurrentSLD=file2save && SLDtypeLoaded=3)
   {
      If (ForceRegenStaticFolders=1)
      {
         showTOOLtip("Regenerating static folders index...")
         SQLdbGenerateStaticFolders()
      }
      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      showTOOLtip("Slideshow database saved.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else If (CurrentSLD!=file2save && SLDtypeLoaded=3)
   {
      activeSQLdb.CloseDB()
      Sleep, 5
      FileCopy, % CurrentSLD, % file2save, 1
      Sleep, 5
      activeSQLdb := new SQLiteDB
      If !activeSQLdb.OpenDB(file2save)
      {
         showTOOLtip("ERROR: Failed to save the slideshow database...")
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return -1
      }

      If (ForceRegenStaticFolders=1)
      {
         showTOOLtip("Regenerating static folders index...")
         SQLdbGenerateStaticFolders()
      }
      saveSlideSettingsInDB()
      activeSQLdb.Exec("VACUUM main;")
      CurrentSLD := file2save
      showTOOLtip("Slideshow database saved.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
   etaTime := "Elapsed time to save database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

SaveFilesList() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (!CurrentSLD || maxFilesIndex<2)
   {
      showTOOLtip("WARNING: No files presently indexed...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (maxFilesIndex>1)
   {
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Save slideshow", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nTo save as a slideshow the entire list of files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
      }
      file2save := openFileDialogWrapper("S", "PathMustExist", CurrentSLD, "Save files list as plain-text slideshow...", "Slideshow plain-text (*.sld)")
      If (!RegExMatch(file2save, "i)(.\.sld)$") && file2save)
         file2save .= ".sld"
   } Else Return

   If file2save
   {
      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult="Yes")
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 1
            If (file2save=CurrentSLD)
            {
               newTmpFile := file2save "-bkcp"
               Try FileMove, %file2save%, %newTmpFile%, 1
               Catch wasErrorA
                     Sleep, 1
            } Else
            {
               Try FileDelete, %file2save%
               Catch wasErrorB
                     Sleep, 1
            }

            If (wasErrorA || wasErrorB)
            {
               msgBoxWrapper(appTitle ": ERROR", "Unable to write or access the file. Permission denied...", 0, 0, "error")
               Return
            }
         } Else Return
      }
      Sleep, 2
      CloseWindow("yes")
      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setImageLoading()
      Sleep, 10
      writeSlideSettings(file2save)
      setWindowTitle("Saving files list index, please wait", 1)
      If (SLDcacheFilesList=1)
         showTOOLtip("Saving list of " maxFilesIndex " entries into...`n" file2save "`nPlease wait...")
      Else
         showTOOLtip("Saving folders index in...`n" file2save "`nPlease wait...")

      thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
      saveDynaFolders := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(thisTmpFile) : DynamicFoldersList
      Sort, saveDynaFolders, UD`n
      dynaFolderListu := "`n[DynamicFolderz]`n"
      Loop, Parse, saveDynaFolders, `n
      {
          fileTest := StrReplace(A_LoopField, "|")
          If !FolderExist(fileTest)
             Continue

          countDynas++
          dynaFolderListu .= "DF" countDynas "=" A_LoopField "`n"
          changeMcursor()
      }

      If (SLDcacheFilesList=0)
         ForceRegenStaticFolders := mustGenerateStaticFolders := 0

      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1) && (SLDcacheFilesList=1)
      {
         filesListu .= printLargeStrArray(resultedFilesList, maxFilesIndex + 1, "`n")
         Loop, % maxFilesIndex + 1
         {
              r := getIDimage(A_Index)
              If (InStr(r, "||") || !r)
                 Continue

              changeMcursor()
              zPlitPath(r, 1, irrelevantVar, OutDir)
              foldersList .= OutDir "`n"
         ;     filesListu .= r "`n"
         }
      } Else If (SLDcacheFilesList=1)
         filesListu .= printLargeStrArray(resultedFilesList, maxFilesIndex + 1, "`n")

      changeMcursor()
      Sort, foldersList, U D`n
      foldersListu := "`n[Folders]`n"
      If (mustGenerateStaticFolders=1 || ForceRegenStaticFolders=1)
      {
         ForceRegenStaticFolders := 0
         Loop, Parse, foldersList, `n
         {
             If !A_LoopField
                Continue

             FileGetTime, dirDate, % A_LoopField, M
             foldersListu .= "Fi" A_Index "=" dirDate "*&*" A_LoopField "`n"
             changeMcursor()
         }
      } Else If (SLDcacheFilesList=1)
      {
         thisTmpFile := !newTmpFile ? backCurrentSLD : newTmpFile
         arrayList := LoadStaticFoldersCached(thisTmpFile, countStaticFolders, 1)
         Loop, % countStaticFolders
               foldersListu .= "Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n"
      }

      foldersListu .= "`n[FilesList]`n"
      Sleep, 10
      changeMcursor()

      Try
      {
          FileAppend, % dynaFolderListu, % file2save, UTF-16
          Sleep, 10
          FileAppend, % foldersListu, % file2save, UTF-16
          Sleep, 10
          FileAppend, % filesListu, % file2save, UTF-16
      } Catch wasErrorC
          Sleep, 1
 
      FileDelete, % newTmpFile
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      CurrentSLD := file2save
      SLDtypeLoaded := 2
      DynamicFoldersList := "|hexists|"
      mustGenerateStaticFolders := 0
      etaTime := "Elapsed time to save plain-text files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
      addJournalEntry(etaTime)
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % wasErrorC ? 300 : 900, 100
      If wasErrorC
         msgBoxWrapper(appTitle ": ERROR", "Errors occured when writing the files list to disk. Permission denied or not enough disk space...", 0, 0, "error")
      dummyTimerDelayiedImageDisplay(50)
   }
}

LoadStaticFoldersCached(fileNamu, ByRef countStaticFolders, asArray:=0) {
    countStaticFolders := 0
    arrayList := []
    hash := []
    If (SLDtypeLoaded=3)
    {
       SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
       If !activeSQLdb.Query(SQL, RecordSet)
          Return 0

       newStaticFoldersListCache := []
       Loop
       {
           z := "z" StringToASC(Row[1])
           If (StrLen(Row[1])>3 && hash[z]!=1)
           {
              hash[z] := 1
              countStaticFolders++
              newStaticFoldersListCache[countStaticFolders] := [Row[1], Row[2]]
           }
           RC := RecordSet.Next(Row)
       } Until (RC<1)

       RecordSet.Free()
       Return newStaticFoldersListCache.Clone()
    }

    If StrLen(newStaticFoldersListCache[1, 1])>4
    {
       countStaticFolders := newStaticFoldersListCache.Count()
       Return newStaticFoldersListCache.Clone()
    }

    FileRead, tehFileVar, %fileNamu%
    newStaticFoldersListCache := []
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(Fi[0-9].*\=.{14}\*\&\*[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
       {
          lineArru := StrSplit(line, "*&*")
          folderu := lineArru[2]
          oldDateu := lineArru[1]
          oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
          z := "z" StringToASC(folderu)
          If (StrLen(folderu)>3 && StrLen(oldDateu)>3 && hash[z]!=1)
          {
             hash[z] := 1
             countStaticFolders++
             newStaticFoldersListCache[countStaticFolders] := [folderu, oldDateu]
             changeMcursor()
          }
       }
    }

    changeMcursor("normal")
    Return newStaticFoldersListCache.Clone()
}

determineTerminateOperation() {
  Static lastInvoked := 1
  If (A_TickCount - lastInvoked < 200)
     Return 0

  lastInvoked := A_TickCount
  theEnd := interfaceThread.ahkgetvar.mustAbandonCurrentOperations
  If theEnd
     lastLongOperationAbort := A_TickCount
  Return theEnd
}

doStartLongOpDance() {
     startLongOperation := A_TickCount
     imageLoading := runningLongOperation := 1
     interfaceThread.ahkassign("mustAbandonCurrentOperations", 0)
     interfaceThread.ahkassign("lastCloseInvoked", 0)
     interfaceThread.ahkassign("imageLoading", 1)
     interfaceThread.ahkassign("runningLongOperation", 1)
     interfaceThread.ahkassign("executingCanceableOperation", A_TickCount)
     interfaceThread.ahkPostFunction("setTaskbarIconState", "anim")
}

cleanFilesList(noFilesCheck:=0) {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      startOperation := A_TickCount
      markedSelectFile := 0
      filterBehaviour := InStr(usrFilesFilteru, "&") ? 1 : 2
      If StrLen(filesFilter)>1
      {
         showTOOLtip("Preparing the files list index...")
         setWindowTitle("Preparing the files list index...", 1)
         backfilesFilter := filesFilter
         backusrFilesFilteru := usrFilesFilteru
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
      }

      msgInfos := (noFilesCheck=2) ? "Sorting" : "Cleaning"
      setWindowTitle(msgInfos " files list, please wait", 1)
      showTOOLtip(msgInfos " files list, please wait")
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      If (noFilesCheck=2)
         filesListu := printLargeStrArray(resultedFilesList, maxFilesIndex, "`n")

      countTFilez := deadFiles := 0
      newList := []
      hash := []
      Loop, % maxFilesIndex + 1
      {
          If (noFilesCheck=2)
             Break

          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          executingCanceableOperation := A_TickCount
          changeMcursor()
          If StrLen(backfilesFilter)>1
          {
             z := filterCoreString(r, filterBehaviour, backfilesFilter)
             noFilesCheck := (z=1) ? 2 : WnoFilesCheck
          }

          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }

          If (A_TickCount - prevMSGdisplay>2000)
          {
             percDone := " ( " Round((countTFilez/maxFilesIndex)*100) "% )"
             showTOOLtip("Checking for dead files, please wait...`n" groupDigits(countTFilez) " / " groupDigits(maxFilesIndex) percDone "`nFound " deadFiles " dead files...", 0, 0, countTFilez/maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }

          z := "z" StringToASC(r)
          If (hash[z]!=1)
          {
             hash[z] := 1
             If FileRexists(r)
             {
                countTFilez++
                newList[countTFilez] := [r]
             } Else deadFiles++
          } Else deadFiles++
      }

      If (abandonAll=1)
      {
         newList := ""
         hash := ""
         showTOOLtip("Operation aborted. Files list unchanged.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 300, 100
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (noFilesCheck=2)
         showTOOLtip("Sorting files list by folder path and file name, please wait...")
      Else If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Removing duplicates from the list, please wait...")

      changeMcursor()
      renewCurrentFilesList()
      If (noFilesCheck=2)
      {
         Sort, filesListu, U D`n
         Loop, Parse, filesListu,`n
         {
             If StrLen(A_LoopField)<5
                Continue

             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [A_LoopField]
         }
      } Else
      {
         resultedFilesList := newList.Clone()
         maxFilesIndex := countTFilez
         newList := []
      }

      If InStr(backCurrentSLD, "\favourite-images-list.SLD")
         renewFavesListBasedOnIndexList()

      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
      {
         bckpResultedFilesList := []
         bckpResultedFilesList := resultedFilesList.Clone()
         bckpMaxFilesIndex := maxFilesIndex
         usrFilesFilteru := backusrFilesFilteru
         filesFilter := backfilesFilter
         FilterFilesIndex()
      } Else GenerateRandyList()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      etaTime := "Elapsed time to clean and resort the files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex " (" deadFiles " dead files removed)."
      addJournalEntry(etaTime)
      CurrentSLD := backCurrentSLD
      RandomPicture()
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

removeFilesListSeenImages() {
   Critical, on
   If (slideShowRunning=1)
      ToggleSlideShowu()

   countSeen := 0
   WnoFilesCheck := (noFilesCheck=2) ? 2 : 0
   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and already seen images will be removed from the files list")
         Return

      remFromDb := 0
      If (SLDtypeLoaded=3)
      {
         msgResult := msgBoxWrapper(appTitle ": Remove already seen images", "You currently have an SQL slideshow database opened. Most actions affecting the files list index are immediately stored/saved, rendering them permanent.`n`nWould you like to remove the already seen indexed images permanently from the database ?", 4, 0, "question")
         If (msgResult="yes")
         {
            activeSQLdb.Exec("BEGIN TRANSACTION;")
            remFromDb := 1
         }
      }

      startOperation := A_TickCount
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      setWindowTitle("Removing already seen images, please wait", 1)
      showTOOLtip("Gathering SQL data, please wait...")
      setImageLoading()
      cachedAllSessionsSeen := []
      seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 0)
      cachedAllSessionsSeen := seenEntries.Clone()
      If (totalSeenIMGs<3)
      {
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         CurrentSLD := backCurrentSLD
         If (SLDtypeLoaded=3)
            activeSQLdb.Exec("COMMIT TRANSACTION;")
         dummyTimerDelayiedImageDisplay(50)
         showTOOLtip("Finished removing already seen images...`nNo image was removed from the files list." etaTime)
         SetTimer, RemoveTooltip, % -msgDisplayTime//2
         Return
      }

      markedSelectFile := 0
      filterBehaviour := InStr(usrFilesFilteru, "&") ? 1 : 2
      If StrLen(filesFilter)>1
      {
         showTOOLtip("Preparing the files list index...")
         backfilesFilter := filesFilter
         backusrFilesFilteru := usrFilesFilteru
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
      }

      zeitOperation := A_TickCount - startOperation
      etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
      showTOOLtip("Removing already seen images, please wait" etaTime)
      prevMSGdisplay := A_TickCount
      doStartLongOpDance()
      newArrayu := []
      newFilesIndex := 0

      Loop, % maxFilesIndex + 1
      {
          r := getIDimage(A_Index)
          If (InStr(r, "||") || !r)
             Continue

          countTFilez++
          If (A_TickCount - prevMSGdisplay>3000)
          {
             zeitOperation := A_TickCount - startOperation
             percDone := " ( " Round((countTFilez / maxFilesIndex) * 100) "% )"
             percLeft := (1 - countTFilez / maxFilesIndex) * 100
             zeitLeft := (zeitOperation/countTFilez) * maxFilesIndex - zeitOperation
             etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
             etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
             showTOOLtip("Checking for already seen images... " countTFilez "/" maxFilesIndex "`nFound " countSeen " of " totalSeenIMGs " recorded images." etaTime, 0, 0, countTFilez / maxFilesIndex)
             prevMSGdisplay := A_TickCount
          }
          ; If retrieveSeenImageDBentry(r, A_Index)           ; InStr(seenEntries, r)
          ; If seenEntries[CalcStringHash(r, 0x8003)]
          checkThis := "z" StringToASC(r)
          If (seenEntries[checkThis]=r)
          {
             If (SLDtypeLoaded=3 && remFromDb=1)
             {
                zPlitPath(r, 1, OutFileName, OutDir)
                deleteSQLdbEntry(OutFileName, OutDir)
             }
             countSeen++
             Continue
          } ; Else cachedAllSessionsSeen[checkThis] := 0 ; commented because it gets too slow with many images

          newFilesIndex++
          newArrayu[newFilesIndex] := [r,,0]
          executingCanceableOperation := A_TickCount
          changeMcursor()
          If (determineTerminateOperation()=1)
          {
             abandonAll := 1
             Break
          }
      }

      seenEntries := []
      activeSQLdb.Exec("COMMIT TRANSACTION;")
      If (abandonAll=1)
      {
         If (SLDtypeLoaded=3)
            showTOOLtip("Operation aborted. " countSeen " already removed until now from the database.")
         Else
            showTOOLtip("Operation aborted. Files list left unchanged, no index entries removed.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 300, 100
         newArrayu := ""
         lastLongOperationAbort := A_TickCount
         Return
      }

      If (newFilesIndex<1)
      {
         SoundBeep, 300, 100
         showTOOLtip("WARNING: All images files were seen.`nTherefore, the files list is left unchanged.")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         SetTimer, ResetImgLoadStatus, -50
         Return
      }
      renewCurrentFilesList()
      maxFilesIndex := newFilesIndex
      resultedFilesList := newArrayu.Clone()

      ForceRefreshNowThumbsList()
      newArrayu := ""
      If StrLen(backfilesFilter)>1
      {
         bckpResultedFilesList := []
         bckpResultedFilesList := resultedFilesList.Clone()
         bckpMaxFilesIndex := maxFilesIndex
         usrFilesFilteru := backusrFilesFilteru
         filesFilter := backfilesFilter
         FilterFilesIndex()
      } Else GenerateRandyList()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      zeitOperation := A_TickCount - startOperation
      etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
      CurrentSLD := backCurrentSLD
      RandomPicture()
      showTOOLtip("Finished removing already seen images...`n" countSeen " images were removed from the files list." etaTime)
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
   }
}

dbSortingCached(SortCriterion) {
   If (maxFilesIndex>1)
   {
      If AnyWindowOpen
         CloseWindow("yes")

      If askAboutFileSave(" and the files list will be sorted")
         Return

      setImageLoading()
      showTOOLtip("Gathering information for " maxFilesIndex " files, please wait...")
      prevFilesSortMode := SortCriterion
      IniSLDBWrite("prevFilesSortMode", SortCriterion)
      setWindowTitle("Sorting files list, please wait", 1)
      RecordSet := ""
      SQL := "SELECT imgfolder||'\'||imgfile AS imgPath FROM images ORDER BY " SortCriterion ";"
      If !activeSQLdb.Query(SQL, RecordSet)
      {
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 300, 100
         SetTimer, RemoveTooltip, -500
         Return -1
      }

      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0
      previmgPath := getIDimage(currentFileIndex)
      If StrLen(filesFilter)>1
      {
         backfilesFilter := filesFilter
         backusrFilesFilteru := usrFilesFilteru
         usrFilesFilteru := filesFilter := ""
         ; FilterFilesIndex()
      }

      showTOOLtip("Generating sorted files list index...")
      renewCurrentFilesList()
      startOperation := A_TickCount
      Loop
      {
          If Row[1]
          {
             maxFilesIndex++
             resultedFilesList[maxFilesIndex] := [Row[1]]
          }
          RC := RecordSet.Next(Row)
      } Until (RC<1)
      RecordSet.Free()

      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
          coreEnableFiltru(backusrFilesFilteru)
      Else
          GenerateRandyList()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 25
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      IDshowImage(currentFileIndex)
  }

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}


ActSortName() {
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder, imgfile")
   Else
      cleanFilesList(2)
}

ActSortSize() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fsize")
   Else
      SortFilesList("size")
   etaTime := "Elapsed time to sort files list by file size: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortPath() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfolder")
   Else
      SortFilesList("name-folder")
   etaTime := "Elapsed time to sort files list by folder name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortFileName() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3)
      dbSortingCached("imgfile")
   Else
      SortFilesList("name-file")
   etaTime := "Elapsed time to sort files list by file name: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortModified() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fmodified")
   Else
      SortFilesList("modified")
   etaTime := "Elapsed time to sort files list by file modified date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortCreated() {
   startOperation := A_TickCount
   If (SLDtypeLoaded=3 && useCachedSLDdata=1)
      dbSortingCached("fcreated")
   Else
      SortFilesList("created")
   etaTime := "Elapsed time to sort files list by file created date: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortResolution() {
   startOperation := A_TickCount
   SortFilesList("image-resolution")
   etaTime := "Elapsed time to sort files list by image resolution (MPx): " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortimgW() {
   startOperation := A_TickCount
   SortFilesList("image-width")
   etaTime := "Elapsed time to sort files list by image width: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortimgH() {
   startOperation := A_TickCount
   SortFilesList("image-height")
   etaTime := "Elapsed time to sort files list by image height: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}

ActSortImgWHratio() {
   startOperation := A_TickCount
   SortFilesList("image-wh-ratio")
   etaTime := "Elapsed time to sort files list by image W/H ratio: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
}


ActSortHistogramAvg() {
   msgResult := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its luminance histogram average value.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
   If (msgResult="yes")
      SortFilesList("histogramAvg")
}

ActSortHistogramMedian() {
   msgResult := msgBoxWrapper(appTitle ": Sort list", "Each file will be read to determine its luminance histogram median value.`n`nAre you sure you want to sort the list in this mode? It can take a lot of time...", 4, 0, "question")
   If (msgResult="yes")
      SortFilesList("histogramMedian")
}

ActSortSimilarity() {
   msgResult := msgBoxWrapper(appTitle ": Sort list", "This operation can take *A LOT* of time, because each image will be compared with the currently selected one.`n`nAre you sure you want to sort the list in this way?", 4, 0, "question")
   If (msgResult="yes")
      SortFilesList("similarity")
}

SortFilesList(SortCriterion) {
   Critical, on
   If AnyWindowOpen
      CloseWindow("yes")

   If (maxFilesIndex>1)
   {
      If askAboutFileSave(" and the files list will be sorted")
         Return

      filesToBeSorted := maxFilesIndex
      If StrLen(filesFilter)>1
      {
         msgResult := msgBoxWrapper(appTitle ": Sort operation", "The files list is filtered down to " maxFilesIndex " files from " bckpMaxFilesIndex ".`n`nOnly the files matched by current filter will be sorted, not all the files.`n`nTo sort all files, remove the filter by pressing Ctrl + F.", 1, 0, "info")
         If (msgResult="cancel")
            Return
      }

      filesPerCore := maxFilesIndex//(realSystemCores + 1)
      If (filesPerCore<3 && realSystemCores>1)
      {
         systemCores := maxFilesIndex//3
         filesPerCore := maxFilesIndex//systemCores
      } Else systemCores := realSystemCores + 1

      mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>3) ? 1 : 0
      previmgPath := getIDimage(currentFileIndex)
      setImageLoading()
      showTOOLtip("Gathering information for " maxFilesIndex " files, please wait...")
      If (SortCriterion="similarity" && mustDoMultiCore!=1)
      {
         img2Compare := getIDimage(currentFileIndex)
         oBitmap := LoadBitmapFromFileu(img2Compare)
         If !oBitmap
         {
            SetTimer, ResetImgLoadStatus, -50
            SoundBeep, 300, 100
            msgBoxWrapper(appTitle ": ERROR", "The selected file seems to not exist or it has an incorrect image file format. Please try again with another file...", 0, 0, "error")
            Return -1
         }

         Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
         o_picRatio := Round(oImgW/oImgH, 3)
         zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 125, 125, 1, 3, -1)
         gBitmap := trGdip_BitmapConvertGray(zBitmap)

         o_thisHistoAvg := calcHistoAvgFile(zBitmap, "histogram", 3)
         oBitmap := trGdip_DisposeImage(oBitmap, 1)
         Gdip_GetImageDimensions(zBitmap, rImgW, rImgH)
      }

      setWindowTitle("Sorting files list, please wait", 1)
      backCurrentSLD := CurrentSLD
      CurrentSLD := ""
      markedSelectFile := 0

      If StrLen(filesFilter)>1
      {
         filterBehaviour := InStr(usrFilesFilteru, "&") ? 1 : 2
         showTOOLtip("Preparing the files list, please wait...")
         backfilesFilter := filesFilter
         backusrFilesFilteru := usrFilesFilteru
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
         Sleep, 10
         RemoveTooltip()
      }

      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      If (mustDoMultiCore=1 && (SortCriterion="similarity" || InStr(SortCriterion, "histogram")))
      {
         createThumbsFolder()
         setPriorityThread(-2)
         multifilesListu := WorkLoadMultiCoresSortHisto(resultedFilesList, maxFilesIndex, SortCriterion, filterBehaviour, backfilesFilter, countTFilez, multinotSortedFilesListu)
         setPriorityThread(0)
         wasMultiThreaded := 1
         If (multifilesListu="abandoned")
            abandonAll := 1
         Else If (multifilesListu="error" || !multifilesListu)
            errorOccured := abandonAll := 1
         Else If (multifilesListu="single-core")
            wasMultiThreaded := multifilesListu := multinotSortedFilesListu := ""
      }

      sortPages := sortedFiles := 0
      unSortPages := unSortedFiles := 0
      If (wasMultiThreaded!=1)
      {
         countTFilez := 0
         doStartLongOpDance()
         Loop, % maxFilesIndex + 1
         {
             r := getIDimage(A_Index)
             If (InStr(r, "||") || !r)
                Continue
 
             changeMcursor()
             If StrLen(backfilesFilter)>1
             {
                z := filterCoreString(r, filterBehaviour, backfilesFilter)
                If (z=1)
                {
                   unSortedFiles++
                   notSortedFilesListu%unSortPages% .= r "`n"
                   If (unSortedFiles>12500)
                   {
                      unSortedFiles := 0
                      unSortPages++
                   }
                   Continue
                }
             }
 
             countTFilez++
             If (A_TickCount - prevMSGdisplay>3000)
             {
                zeitOperation := A_TickCount - startOperation
                percDone := " ( " Round((countTFilez / filesToBeSorted) * 100) "% )"
                percLeft := (1 - countTFilez / filesToBeSorted) * 100
                zeitLeft := (zeitOperation/countTFilez) * filesToBeSorted - zeitOperation
                etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
                etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
                If (failedFiles>0)
                   etaTime .= "`nOn " failedFiles " files encountered failure..."
 
                showTOOLtip("Gathering information for " countTFilez "/" filesToBeSorted " files, please wait..." etaTime, 0, 0, countTFilez / filesToBeSorted)
                prevMSGdisplay := A_TickCount
             }
 
             If !InStr(SortCriterion, "name-")
             {
                If !FileRexists(r)
                {
                   failedFiles++
                   Continue
                }
             }
  
             If (SortCriterion="size")
             {
                FileGetSize, SortBy, %r%
             } Else If (SortCriterion="modified")
             {
                FileGetTime, SortBy, %r%, M
             } Else If (SortCriterion="created")
             {
                FileGetTime, SortBy, %r%, C
             } Else If (SortCriterion="name-folder")
             {
                zPlitPath(r, 1, OutFileName, OutDir)
                SortBy := OutDir
             } Else If (SortCriterion="name-file")
             {
                zPlitPath(r, 1, OutFileName, OutDir)
                SortBy := OutFileName
             } Else If InStr(SortCriterion, "image-")
             {
                op := GetImgFileDimension(r, Wi, He)
                If InStr(SortCriterion, "-resolution")
                   SortBy := (op=1) ? Round((Wi*He)/1000000, 3) : 0
                Else If InStr(SortCriterion, "-width")
                   SortBy := (op=1) ? Round(Wi/10, 2) : 0
                Else If InStr(SortCriterion, "-height")
                   SortBy := (op=1) ? Round(He/10, 2) : 0
                Else If InStr(SortCriterion, "-wh-ratio")
                   SortBy := (op=1) ? Round(Wi/He, 3) : 0
             } Else If (SortCriterion="similarity")
             {
                op := GetImgFileDimension(r, Wi, He)
                PicRatio := Round(Wi/He, 3)
                If isInRange(PicRatio, o_picRatio + 0.3, o_picRatio - 0.3)
                {
                   thisHistoAvg := 0
                   oBitmap := LoadBitmapFromFileu(r)
                   If StrLen(oBitmap)>2
                   {
                      xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, rImgW, rImgH, 0, 3, -1)
                      thisHistoAvg := calcHistoAvgFile(xBitmap, "histogram", 3)
                   }
 
                   ; ToolTip, % o_thisHistoAvg "--" thisHistoAvg, , , 2
                   If !isInRange(thisHistoAvg, o_thisHistoAvg + 45, o_thisHistoAvg - 45)
                   {
                      oBitmap := trGdip_DisposeImage(oBitmap, 1)
                      xBitmap := trGdip_DisposeImage(xBitmap, 1)
                   }
                }
 
                If StrLen(oBitmap)>2
                {
                   oBitmap := trGdip_DisposeImage(oBitmap, 1)
                   lBitmap := trGdip_BitmapConvertGray(xBitmap)
                   SortByA := 100 - Gdip_CompareBitmaps(zBitmap, xBitmap, 100)
                   SortByB := 100 - Gdip_CompareBitmaps(gBitmap, lBitmap, 100)
                   SortBy := (SortByA + SortByB)/2
                   trGdip_DisposeImage(xBitmap, 1)
                   trGdip_DisposeImage(lBitmap, 1)
                } Else SortBy := (op=1) ? thisHistoAvg/256 : 0
             } Else If InStr(SortCriterion, "histogram")
             {
                oBitmap := LoadBitmapFromFileu(r)
                If StrLen(oBitmap)>2
                {
                   xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 300, 300, 1, 3, -1)
                   SortBy := calcHistoAvgFile(xBitmap, SortCriterion, 3)
                   xBitmap := trGdip_DisposeImage(xBitmap, 1)
                   oBitmap := trGdip_DisposeImage(oBitmap, 1)
                } Else SortBy := 0
             }

             executingCanceableOperation := A_TickCount
             If (determineTerminateOperation()=1)
             {
                abandonAll := 1
                Break
             }
 
             If StrLen(SortBy)>1
             {
                sortedFiles++
                filesListu%sortPages% .= SortBy "|!\!|" r "`n"
                If (sortedFiles>12500)
                {
                   sortedFiles := 0
                   sortPages++
                }
             } Else failedFiles++
         }
      }

      If (SortCriterion="similarity")
      {
         trGdip_DisposeImage(zBitmap, 1)
         trGdip_DisposeImage(gBitmap, 1)
      }

      If (abandonAll=1)
      {
         If errorOccured
            msgInfos := "`nErrors occured. Multi-threading error."
         showTOOLtip("Operation aborted. Files list unchanged. " msgInfos)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         CurrentSLD := backCurrentSLD
         lastLongOperationAbort := A_TickCount
         SetTimer, ResetImgLoadStatus, -50
         SoundBeep, 900, 100
         RandomPicture()
         Return
      }

      showTOOLtip("Preparing gathered data...`n" unSortPages " / " sortPages)
      prevMSGdisplay := A_TickCount
      changeMcursor()
      Loop, % sortPages + 1
      {
         thisIndex := A_Index - 1
         entireString .= filesListu%thisIndex%
      }

      Loop, % unSortPages + 1
      {
         thisIndex := A_Index - 1
         entireNotSortedString .= notSortedFilesListu%thisIndex%
      }

      If (wasMultiThreaded=1 && multifilesListu)
      {
         entireString := multifilesListu
         entireNotSortedString := multinotSortedFilesListu
      }

      showTOOLtip("Sorting gathered data...")
      If InStr(SortCriterion, "name-")
         Sort, entireString, D`n
      Else
         Sort, entireString, N D`n

      If (A_TickCount - prevMSGdisplay>1500)
         showTOOLtip("Generating sorted files list index...")

      renewCurrentFilesList()
      Loop, Parse, entireString,`n,`r
      {
          If StrLen(A_LoopField)<2
             Continue

          changeMcursor()
          line := StrSplit(A_LoopField, "|!\!|")
          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [line[2]]
      }

      Loop, Parse, entireNotSortedString,`n
      {
          If StrLen(A_LoopField)<2
             Continue

          maxFilesIndex++
          resultedFilesList[maxFilesIndex] := [A_LoopField]
      }

      ForceRefreshNowThumbsList()
      If StrLen(backfilesFilter)>1
      {
         bckpResultedFilesList := []
         bckpResultedFilesList := resultedFilesList.Clone()
         bckpMaxFilesIndex := maxFilesIndex
         usrFilesFilteru := backusrFilesFilteru
         filesFilter := backfilesFilter
         FilterFilesIndex()
      } Else GenerateRandyList()

      entireString := entireNotSortedString := ""
      If InStr(backCurrentSLD, "\favourite-images-list.SLD")
         renewFavesListBasedOnIndexList()

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      Sleep, 5
      SetTimer, RemoveTooltip, -500
      CurrentSLD := backCurrentSLD
      currentFileIndex := detectFileID(prevImgPath)
      If (maxFilesIndex<1)
         resetMainWin2Welcome()
      Else
         IDshowImage(currentFileIndex)
   }
}

getSelectedFilesListString(maxList, ByRef countTFilez, ByRef filesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  filesListu := []
  selectedFilesArray := []
  showTOOLtip("Preparing workload for multi-threaded processing...")

  Loop, % maxFilesIndex
  {
      isSelected := resultedFilesList[A_Index, 2]
      If !isSelected
         Continue

      r := resultedFilesList[A_Index, 1]
      If (InStr(r, "||") || !r)
         Continue

      countTFilez++
      selectedFilesArray[countTFilez] := A_Index "?" r "`n"
  }

  maxList := selectedFilesArray.Count()
  trenchSize := maxList//systemCores
  r := 0
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          realIndex := trenchSize*(thisIndex-1) + A_Index
          line := selectedFilesArray[realIndex]
          If !line
             Continue

          filesListu[thisIndex] .= line
      }
  }

  Loop, % maxList - trenchSize*(systemCores-1)
  {
      realIndex := trenchSize*(systemCores-1) + A_Index
      line := selectedFilesArray[realIndex]
      If !line
         Continue

      filesListu[systemCores] .= line
  }
}

WorkLoadMultiCoresJpegLL(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-jpegll||" jpegDesiredOperation "=" jpegDoCrop "=" relativeImgSelCoords "=" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  setForceRefreshThumbsFilesIndex(1)
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            zeitOperation := A_TickCount - startOperation
            percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
            percLeft := (1 - processedFiles / countTFilez) * 100
            zeitLeft := (zeitOperation/processedFiles) * countTFilez - zeitOperation
            etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
            etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed..."
            If (failedFiles>0)
               etaTime .= "`nFailed to process " failedFiles " files..."
            If (skippedFiles>0)
               etaTime .= "`n" skippedFiles " files were skipped"

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed..."
               showTOOLtip("Abandoning image files processing, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Performing JPEG lossless operations on " processedFiles "/" countTFilez " files, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

   Loop, % systemCores
       FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt

   processedFiles := skippedFiles := failedFiles := 0
   Loop, % systemCores
   {
      RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
      filesStatusArr := StrSplit(filesStatus, "/")
      If (filesStatusArr[1]>0)
         processedFiles += filesStatusArr[1]
      If (filesStatusArr[2]>0)
         failedFiles += filesStatusArr[2]
      If (filesStatusArr[3]>0)
         skippedFiles += filesStatusArr[3]
   }

   zeitOperation := A_TickCount - startOperation
   someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
   If (failedFiles>0)
      someErrors .= "`nFailed to process " failedFiles " files..."
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"
    
  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. JPEG lossless processing aborted... `n`nPlease try again with multi-threading disabled.`n`n" processedFiles " out of " countFilez " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " processedFiles " out of " markedSelectFile " selected files were processed until now..." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(processedFiles " out of " countTFilez " selected JPEG files were processed" someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
     r := "abandoned"

  CurrentSLD := backCurrentSLD
  Return r
}

testProcessExists(pid) {
   If StrLen(pid)<2
      Return 0

   Process, Exist, % pid
   R := (ErrorLevel=pid) ? 1 : 0
   Return R
}

WorkLoadMultiCoresConvertFormat(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-fmtconv"
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := theseFailures := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  theseFailures += filesStatusArr[3]
               If (filesStatusArr[4]>0)
                  skippedFiles += filesStatusArr[4]
            }

            zeitOperation := A_TickCount - startOperation
            percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
            percLeft := (1 - processedFiles / countTFilez) * 100
            zeitLeft := (zeitOperation/processedFiles) * countTFilez - zeitOperation
            etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
            etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone

            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed..."
            If (failedFiles>0)
               etaTime .= "`nFor " failedFiles " files, the format conversion failed..."
            If (theseFailures>0)
               etaTime .= "`nUnable to remove " theseFailures " original files after format conversion..."
            If (skippedFiles>0)
               etaTime .= "`n" skippedFiles " files were skipped..."

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed..."
               showTOOLtip("Abandoning image file formats conversion, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Converting to ." rDesireWriteFMT A_Space processedFiles "/" countTFilez " files, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := theseFailures := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        theseFailures += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  Loop, Parse, theFinalList,`n,`r
  {
       If StrLen(A_LoopField)>2
       {
          lineArr := StrSplit(A_LoopField, "?")
          thisIndex := lineArr[1]
          imgPath := lineArr[2]
          If (imgPath && thisIndex)
             resultedFilesList[thisIndex, 1] := imgPath
       }
  }

  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFor " failedFiles " files, the format conversion failed..."
  If (theseFailures>0)
     someErrors .= "`nUnable to remove " theseFailures " original files after format conversion..."
  If (skippedFiles>0)
     someErrors .= "`n" skippedFiles " files were skipped..."

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image file formats conversion aborted... `n`nPlease try again with multi-threading disabled.`n`n" processedFiles " out of " countFilez " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " processedFiles " out of " markedSelectFile " selected files were converted to ." rDesireWriteFMT " until now..." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(processedFiles " out of " countTFilez " selected files were converted to ." rDesireWriteFMT someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
     r := "abandoned"

  CurrentSLD := backCurrentSLD
  Return r
}

WorkLoadMultiCoresSimpleImgProcessing(maxList) {
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  backCurrentSLD := CurrentSLD
  CurrentSLD := ""
  skippedFiles := theseFailures := failedFiles := 0
  getSelectedFilesListString(maxList, countTFilez, filesListu)
  If StrLen(filesListu[1])<3
  {
     CurrentSLD := backCurrentSLD
     Return "single-core"
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainWindowID, % hGDIwin
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu[A_Index]
      argsToGive := "batch-simpleimgproc||" imgSelX1 "=" imgSelX2 "=" imgSelY1 "=" imgSelY2 "=" prcSelX1 "=" prcSelX2 "=" prcSelY1 "=" prcSelY2 "=" editingSelectionNow "=" simpleOpRotationAngle
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If StrLen(pidThread%A_Index%)<2
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  If (fatalError=1)
  {
     CurrentSLD := backCurrentSLD
     RegWrite, REG_SZ, %QPVregEntry%, Running, 1
     Return "single-core"
  }

  Sleep, 500
  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisThreadStatus := 1
         RegRead, thisThreadStatus, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         isPIDalive := (A_TickCount - thisZeit > 2500) ? testProcessExists(thisPIDcheck) : 1
         If (thisThreadStatus=1 && isPIDalive=1)
            jobsRunning++
         Else If (thisThreadStatus=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++

         totalEnded := jobDone + threadsCrashed
         ; sleep, 450
         ; ToolTip, % jobsRunning "//" jobDone "//" threadsCrashed "//" totalEnded , , , 2
         ; ToolTip, % thisThreadStatus " // " isPIDalive , , , 2
      }

      If (threadsCrashed>systemCores//2)
         fatalError := abandonAll := 1

      If (jobDone>=systemCores) || (totalEnded>=systemCores)
      {
         Break
      } Else
      {
         Sleep, 200
         processedFiles := skippedFiles := failedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>1500)
         {
            Loop, % systemCores
            {
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
               If (filesStatusArr[3]>0)
                  skippedFiles += filesStatusArr[3]
            }

            zeitOperation := A_TickCount - startOperation
            percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
            percLeft := (1 - processedFiles / countTFilez) * 100
            zeitLeft := (zeitOperation/processedFiles) * countTFilez - zeitOperation
            etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
            etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If (threadsCrashed>0)
               etaTime .= "`n" threadsCrashed " threads have crashed..."
            If (failedFiles>0)
               etaTime .= "`nFailed to process " failedFiles " files..."
            If (skippedFiles>0)
               etaTime .= "`n" skippedFiles " files were skipped..."

            If (abandonAll=1)
            {
               etaTime := "`nRunning threads " jobsRunning " / " systemCores
               etaTime .= "`n" threadsCrashed " threads have crashed..."
               showTOOLtip("Abandoning image files processing, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            } Else showTOOLtip("Processing " processedFiles "/" countTFilez " files, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         lastLongOperationAbort := A_TickCount
         ; fatalError := 0
         ; Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  processedFiles := failedFiles := skippedFiles := 0
  Loop, % systemCores
  {
     RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
     filesStatusArr := StrSplit(filesStatus, "/")
     If (filesStatusArr[1]>0)
        processedFiles += filesStatusArr[1]
     If (filesStatusArr[2]>0)
        failedFiles += filesStatusArr[2]
     If (filesStatusArr[3]>0)
        skippedFiles += filesStatusArr[3]
  }

  Loop, % systemCores
  {
        ; RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
  zeitOperation := A_TickCount - startOperation
  someErrors := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
  If (failedFiles>0)
     someErrors .= "`nFailed to process " failedFiles " files..."
  If (skippedFiles>0)
     someErrors .= "`n" skippedFiles " files were skipped..."

  If (fatalError=1)
  {
     ; RemoveTooltip()
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. Image processing aborted... `n`nPlease try again with multi-threading disabled.`n`n" processedFiles " out of " countTFilez " selected files were processed until now..." someErrors, 0, 0, "error")
     r := "error"
  }

  ForceRefreshNowThumbsList()
  dummyTimerDelayiedImageDisplay(100)
  If (abandonAll=1 && fatalError!=1)
     showTOOLtip("Operation aborted. " processedFiles " out of " markedSelectFile " selected files were processed until now..." someErrors)
  Else If (fatalError!=1)
     showTOOLtip(processedFiles " out of " countTFilez " selected files were processed." someErrors)

  If (fatalError!=1)
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100

  SetTimer, ResetImgLoadStatus, -50
  SetTimer, RemoveTooltip, % -msgDisplayTime*1.5
  If (abandonAll=1 && fatalError!=1)
     r := "abandoned"

  CurrentSLD := backCurrentSLD
  Return r
}

WorkLoadMultiCoresSortHisto(whichArray, maxList, SortCriterion, filterBehaviour, backfilesFilter, ByRef countTFilez, ByRef notSortedFilesListu) {
  trenchSize := maxList//systemCores
  countTFilez := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount

  showTOOLtip("Preparing workload for sorting the files list...")
  Loop, % systemCores - 1
  {
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          If StrLen(backfilesFilter)>1
          {
             z := filterCoreString(r, filterBehaviour, backfilesFilter)
             If (z=1)
             {
                notSortedFilesListu .= r "`n"
                Continue
             }
          }

          countTFilez++
          filesListu%thisIndex% .= r "`n"
      }
  }

  Loop, % maxList - trenchSize*(systemCores - 1)
  {
      rA := whichArray[trenchSize*(systemCores - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      If StrLen(backfilesFilter)>1
      {
         z := filterCoreString(r, filterBehaviour, backfilesFilter)
         If (z=1)
         {
            notSortedFilesListu .= r "`n"
            Continue
         }
      }

      countTFilez++
      filesListu%systemCores% .= r "`n"
  }

  If (SortCriterion="similarity")
  {
     img2Compare := getIDimage(currentFileIndex)
     RegWrite, REG_SZ, %QPVregEntry%\multicore, img2Compare, % img2Compare
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 0
  RegWrite, REG_SZ, %QPVregEntry%\multicore, mainThreadHwnd, % PVhwnd
  RegWrite, REG_SZ, %QPVregEntry%, Running, 2
  Loop, % systemCores
  {
      thisList := filesListu%A_Index%
      argsToGive := "batch-sort-histo||" SortCriterion
      pidThread%A_Index% := OpenNewExternalCoreThread(A_Index, argsToGive, thisList)
      If !pidThread%A_Index%
      {
         fatalError := 1
         Break
      }
      Sleep, 1
  }

  RegWrite, REG_SZ, %QPVregEntry%, Running, 1
  If (fatalError=1)
     Return (SortCriterion="similarity") ? "error" : "single-core"

  Sleep, 500
  thisZeit := A_TickCount
  doStartLongOpDance()
  Loop
  {
      Loop, % systemCores
      {
         thisPIDdead := 0
         InitCheckReg := 1
         RegRead, InitCheckReg, %QPVregEntry%\multicore, ThreadRunning%A_Index%
         thisPIDcheck := pidThread%A_Index%
         Process, Exist, % thisPIDcheck
         thisPIDdead := ((!ErrorLevel && thisPIDcheck) && (A_TickCount - thisZeit > 2500)) || !thisPIDcheck ? 1 : 0
         If (InitCheckReg=1 && thisPIDdead!=1)
            jobsRunning++
         Else If (InitCheckReg=2)
            jobDone++
         Else ; If (thisPIDdead=1)
            threadsCrashed++
      }

      If (threadsCrashed>systemCores//2)
      {
         fatalError := abandonAll := 1
         Break
      }

      If (jobDone>systemCores-1)
      {
         Break
      } Else
      {
         Sleep, 300
         processedFiles := 0
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>3000)
         {
            Loop, % systemCores
            {
               InitCheckReg := 1
               RegRead, filesStatus, %QPVregEntry%\multicore, ThreadJob%A_Index%
               filesStatusArr := StrSplit(filesStatus, "/")
               If (filesStatusArr[1]>0)
                  processedFiles += filesStatusArr[1]
               If (filesStatusArr[2]>0)
                  failedFiles += filesStatusArr[2]
            }

            zeitOperation := A_TickCount - startOperation
            percDone := " ( " Round((processedFiles / countTFilez) * 100) "% )"
            percLeft := (1 - processedFiles / countTFilez) * 100
            zeitLeft := (zeitOperation/processedFiles) * countTFilez - zeitOperation
            etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
            etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
            If (failedFiles>0)
               etaTime .= "`nOn " failedFiles " files encountered failure..."
            etaTime .= "`nUsing " jobsRunning " / " systemCores " execution threads"
            If threadsCrashed
               etaTime .= "`n" threadsCrashed " threads have crashed..."
  
            showTOOLtip("Gathering information for "  processedFiles "/" countTFilez " files, please wait..." etaTime, 0, 0, processedFiles / countTFilez)
            prevMSGdisplay := A_TickCount
         }
      }

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         RegWrite, REG_SZ, %QPVregEntry%\multicore, mustAbortAllOperations, 1
         abandonAll := 1
         fatalError := 0
         lastLongOperationAbort := A_TickCount
         Break
      }
      jobDone := threadsCrashed := jobsRunning := 0
  }

  Loop, % systemCores
  {
        RegRead, InitCheckReg, %QPVregEntry%\multicore, ThreadRunning%A_Index%
        RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%A_Index%, 0
        If (abandonAll!=1 && InitCheckReg=2 && fatalError!=1)
           Try FileRead, results, %thumbsCacheFolder%\tempList%A_Index%.txt
        theFinalList .= results
        Sleep, 0
        Try FileDelete, %thumbsCacheFolder%\tempList%A_Index%.txt
  }

  SetTimer, ResetImgLoadStatus, -50
  If (fatalError=1)
  {
     RemoveTooltip()
     SoundBeep, 300, 100
     r := (SortCriterion="similarity") ? "error" : "single-core"
     If (r="error")
        msgBoxWrapper(appTitle ": ERROR", "Most execution threads have crashed. List sorting aborted...", 0, 0, "error")
     Return r
  }

  If (abandonAll=1 && fatalError!=1)
     theFinalList := "abandoned"

  Return theFinalList
}

multiCoresListSorter(coreThread, SortCriterion, filesList) {
  resultsList := ""
  failedFiles := countFilez := operationDone := 0
  ; thisPID := QPVpid
  ; RegWrite, REG_SZ, %QPVregEntry%, pidThread%coreThread%, % thisPID
  ; MsgBox, % SortCriterion " -- " coreThread "`n" filesList
  RegRead, img2Compare, %QPVregEntry%\multicore, img2Compare
  If (SortCriterion="similarity" && StrLen(img2Compare)>3 && InStr(img2Compare, ":\"))
  {
     oBitmap := LoadBitmapFromFileu(img2Compare)
     If oBitmap
     {
        Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
        o_picRatio := Round(oImgW/oImgH, 3)
        zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 125, 125, 1, 3, -1)
        gBitmap := trGdip_BitmapConvertGray(zBitmap)
 
        o_thisHistoAvg := calcHistoAvgFile(zBitmap, "histogram", 3)
        oBitmap := trGdip_DisposeImage(oBitmap, 1)
        Gdip_GetImageDimensions(zBitmap, rImgW, rImgH)
     }
  }

  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
          r := A_LoopField
       Else
          Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If (SortCriterion="similarity")
       {
          op := GetImgFileDimension(r, Wi, He)
          If (op!=1)
             failedFiles++

          PicRatio := Round(Wi/He, 3)
          If isInRange(PicRatio, o_picRatio + 0.3, o_picRatio - 0.3)
          {
             thisHistoAvg := 0
             oBitmap := LoadBitmapFromFileu(r)
             If StrLen(oBitmap)>2
             {
                xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, rImgW, rImgH, 0, 3, -1)
                thisHistoAvg := calcHistoAvgFile(xBitmap, "histogram", 3)
             }

             ; ToolTip, % o_thisHistoAvg "--" thisHistoAvg, , , 2
             If !isInRange(thisHistoAvg, o_thisHistoAvg + 45, o_thisHistoAvg - 45)
             {
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                xBitmap := trGdip_DisposeImage(xBitmap, 1)
             }
          }

          If StrLen(oBitmap)>2
          {
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             lBitmap := trGdip_BitmapConvertGray(xBitmap)
             SortByA := 100 - Gdip_CompareBitmaps(zBitmap, xBitmap, 100)
             SortByB := 100 - Gdip_CompareBitmaps(gBitmap, lBitmap, 100)
             SortBy := (SortByA + SortByB)/2
             trGdip_DisposeImage(xBitmap, 1)
             trGdip_DisposeImage(lBitmap, 1)
          } Else SortBy := (op=1) ? thisHistoAvg/256 : 0
       } Else If InStr(SortCriterion, "histogram")
       {
          oBitmap := LoadBitmapFromFileu(r)
          If oBitmap
          {
             xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 300, 300, 1, 3, -1)
             SortBy := calcHistoAvgFile(xBitmap, SortCriterion, 3)
             xBitmap := trGdip_DisposeImage(xBitmap, 1)
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
          } Else
          {
             SortBy := 0
             failedFiles++
          }
       }
       If StrLen(SortBy)>1
          resultsList .= SortBy " |!\!|" r "`n"

       countFilez++
       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles
   If (SortCriterion="similarity")
   {
      trGdip_DisposeImage(zBitmap, 1)
      trGdip_DisposeImage(gBitmap, 1)
   }

   If (abandonAll!=1)
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, utf-16
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   RegWrite, REG_SZ, %QPVregEntry%\multicore, img2Compare, 0
   operationDone := 1
   ; cleanupThread()
}

multiCoresJpegLL(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  jpegOperation := argumentsArray[1]
  mustCrop := argumentsArray[2]
  relativeImgSelCoords := argumentsArray[3]
  imgSelX1 := argumentsArray[4]
  imgSelX2 := argumentsArray[5]
  imgSelY1 := argumentsArray[6]
  imgSelY2 := argumentsArray[7]
  prcSelX1 := argumentsArray[8]
  prcSelX2 := argumentsArray[9]
  prcSelY1 := argumentsArray[10]
  prcSelY2 := argumentsArray[11]
  failedFiles := skippedFiles := countFilez := operationDone := 0
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       If !RegExMatch(imgPath, "i)(.\.(jpeg|jpg|jpe))$")
       {
          skippedFiles++
          Continue
       }

       r := coreJpegLossLessAction(imgPath, jpegOperation, mustCrop)
       If !r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

multiCoresSimpleImgProcessing(coreThread, arguments, filesList) {
  resultsList := ""
  argumentsArray := StrSplit(arguments, "=")
  ReadSettingsImageProcessing()
  imgSelX1 := argumentsArray[1]
  imgSelX2 := argumentsArray[2]
  imgSelY1 := argumentsArray[3]
  imgSelY2 := argumentsArray[4]
  prcSelX1 := argumentsArray[5]
  prcSelX2 := argumentsArray[6]
  prcSelY1 := argumentsArray[7]
  prcSelY2 := argumentsArray[8]
  editingSelectionNow := argumentsArray[9]
  simpleOpRotationAngle := argumentsArray[10]
  skippedFiles := failedFiles := countFilez := operationDone := 0
  thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

       imgPath := StrReplace(imgPath, "||")
       If !RegExMatch(imgPath, thisRegEX)
       {
          skippedFiles++
          Continue
       }

       zPlitPath(imgPath, 0, OutFileName, OutDir)
       destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
       file2save := destImgPath "\" OutFileName
       If (ResizeUseDestDir=1)
       {
          If (FileExist(file2save) && !FolderExist(file2save))
             file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
       }

       If !file2save
       {
          skippedFiles++
          Continue
       }

       r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       If r
          failedFiles++
       Else
          countFilez++

       RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   }
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" skippedFiles
   Sleep, 1
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

ReadSettingsFormatConvert() {
    IniRead, tstOnConvertKeepOriginals, % mainSettingsFile, General, OnConvertKeepOriginals, @
    IniRead, tstuserActionConflictingFile, % mainSettingsFile, General, userActionConflictingFile, @
    IniRead, tstuserHQraw, % mainSettingsFile, General, userHQraw, @
    IniRead, tstuserJpegQuality, % mainSettingsFile, General, userJpegQuality, @
    IniRead, tstuserDesireWriteFMT, % mainSettingsFile, General, userDesireWriteFMT, @
    IniRead, tstResizeUseDestDir, % mainSettingsFile, General, ResizeUseDestDir, @
    IniRead, tstResizeDestFolder, % mainSettingsFile, General, ResizeDestFolder, @
    IniRead, tstPreserveDateTimeOnSave, % mainSettingsFile, General, PreserveDateTimeOnSave, @

    If (tstuserJpegQuality!="@")
       userJpegQuality := clampInRange(tstuserJpegQuality, 1, 100)
    If (StrLen(tstResizeDestFolder)>3)
       ResizeDestFolder := tstResizeDestFolder
    If (tstuserHQraw=1 || tstuserHQraw=0)
       userHQraw := tstuserHQraw
    If (tstPreserveDateTimeOnSave=1 || tstPreserveDateTimeOnSave=0)
       PreserveDateTimeOnSave := tstPreserveDateTimeOnSave
    If (tstResizeUseDestDir=1 || tstResizeUseDestDir=0)
       ResizeUseDestDir := tstResizeUseDestDir
    If (tstuserDesireWriteFMT!="@")
       userDesireWriteFMT := tstuserDesireWriteFMT
    If (tstOnConvertKeepOriginals=1 || tstOnConvertKeepOriginals=0)
       OnConvertKeepOriginals := tstOnConvertKeepOriginals
    If (isInRange(tstuserActionConflictingFile, 1, 3) && tstuserActionConflictingFile!="@")
       userActionConflictingFile := tstuserActionConflictingFile

    rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
}

ReadSettingsImageProcessing() {
    IniRead, tstResizeApplyEffects, % mainSettingsFile, General, ResizeApplyEffects, @
    IniRead, tstResizeCropAfterRotation, % mainSettingsFile, General, ResizeCropAfterRotation, @
    IniRead, tstResizeDestFolder, % mainSettingsFile, General, ResizeDestFolder, @
    IniRead, tstResizeInPercentage, % mainSettingsFile, General, ResizeInPercentage, @
    IniRead, tstResizeKeepAratio, % mainSettingsFile, General, ResizeKeepAratio, @
    IniRead, tstResizeQualityHigh, % mainSettingsFile, General, ResizeQualityHigh, @
    IniRead, tstResizeRotationUser, % mainSettingsFile, General, ResizeRotationUser, @
    IniRead, tstResizeUseDestDir, % mainSettingsFile, General, ResizeUseDestDir, @
    IniRead, tstResizeWithCrop, % mainSettingsFile, General, ResizeWithCrop, @
    IniRead, tstuserHQraw, % mainSettingsFile, General, userHQraw, @
    IniRead, tstSimpleOperationsFlipV, % mainSettingsFile, General, SimpleOperationsFlipV, @
    IniRead, tstSimpleOperationsFlipH, % mainSettingsFile, General, SimpleOperationsFlipH, @
    IniRead, tstSimpleOperationsDoCrop, % mainSettingsFile, General, SimpleOperationsDoCrop, @
    IniRead, tstSimpleOperationsRotateAngle, % mainSettingsFile, General, SimpleOperationsRotateAngle, @
    IniRead, tstSimpleOperationsScaleXimgFactor, % mainSettingsFile, General, SimpleOperationsScaleXimgFactor, @
    IniRead, tstSimpleOperationsScaleYimgFactor, % mainSettingsFile, General, SimpleOperationsScaleYimgFactor, @
    IniRead, tstResizeMustPerform, % mainSettingsFile, General, ResizeMustPerform, @
    IniRead, tstuserJpegQuality, % mainSettingsFile, General, userJpegQuality, @
    IniRead, tstuserActionConflictingFile, % mainSettingsFile, General, userActionConflictingFile, @

    If (tstuserJpegQuality!="@")
       userJpegQuality := clampInRange(tstuserJpegQuality, 1, 100)
    If (tstuserHQraw=1 || tstuserHQraw=0)
       userHQraw := tstuserHQraw
    If (tstResizeCropAfterRotation=1 || tstResizeCropAfterRotation=0)
       ResizeCropAfterRotation := tstResizeCropAfterRotation
    If (StrLen(tstResizeDestFolder)>3)
       ResizeDestFolder := tstResizeDestFolder
    If (tstResizeUseDestDir=1 || tstResizeUseDestDir=0)
       ResizeUseDestDir := tstResizeUseDestDir
    If (tstResizeMustPerform=1 || tstResizeMustPerform=0)
       ResizeMustPerform := tstResizeMustPerform
    If (tstResizeInPercentage=1 || tstResizeInPercentage=0)
       ResizeInPercentage := tstResizeInPercentage
    If (isInRange(tstResizeRotationUser, 0, 359) && tstResizeRotationUser!="@")
       ResizeRotationUser := tstResizeRotationUser
    If (tstResizeKeepAratio=1 || tstResizeKeepAratio=0)
       ResizeKeepAratio := tstResizeKeepAratio
    If (tstResizeWithCrop=1 || tstResizeWithCrop=0)
       ResizeWithCrop := tstResizeWithCrop
    If (tstResizeQualityHigh=1 || tstResizeQualityHigh=0)
       ResizeQualityHigh := tstResizeQualityHigh
    If (tstResizeApplyEffects=1 || tstResizeApplyEffects=0)
       ResizeApplyEffects := tstResizeApplyEffects
    If (tstSimpleOperationsFlipV=1 || tstSimpleOperationsFlipV=0)
       SimpleOperationsFlipV := tstSimpleOperationsFlipV
    If (tstSimpleOperationsFlipH=1 || tstSimpleOperationsFlipH=0)
       SimpleOperationsFlipH := tstSimpleOperationsFlipH
    If (tstSimpleOperationsDoCrop=1 || tstSimpleOperationsDoCrop=0)
       SimpleOperationsDoCrop := tstSimpleOperationsDoCrop
    If (isInRange(tstSimpleOperationsRotateAngle, 1, 4) && tstSimpleOperationsRotateAngle!="@")
       SimpleOperationsRotateAngle := tstSimpleOperationsRotateAngle
    If (tstSimpleOperationsScaleXimgFactor!="@")
       SimpleOperationsScaleXimgFactor := tstSimpleOperationsScaleXimgFactor
    If (tstSimpleOperationsScaleYimgFactor!="@")
       SimpleOperationsScaleYimgFactor := tstSimpleOperationsScaleYimgFactor
    If (isInRange(tstuserActionConflictingFile, 1, 3) && tstuserActionConflictingFile!="@")
       userActionConflictingFile := tstuserActionConflictingFile

    cleanResizeUserOptionsVars()
}

multiCoresFormatConvert(coreThread, filesList) {
  resultsList := ""
  failedFiles := theseFailures := countFilez := operationDone := 0
  ; FileRead, filesList, %thumbsCacheFolder%\tempList%coreThread%.txt
  ReadSettingsFormatConvert()
  initFIMGmodule()
  Loop, Parse, filesList,`n,`r
  {
       If A_LoopField
       {
          lineArr := StrSplit(A_LoopField, "?")
          imgPath := lineArr[2]
          If !imgPath
             Continue
       } Else Continue

       RegRead, mustAbortAllOperations, %QPVregEntry%\multicore, mustAbortAllOperations
       If (!WinExist("ahk_id" mainThreadHwnd) || mustAbortAllOperations=1)
       {
          abandonAll := 1
          Break
       }

      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(imgPath, "||") || !imgPath)
      {
         skippedFiles++
         Continue
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT

      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         countFilez++

      wasSucces := r ? 0 : 1
      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, %imgPath%
         Sleep, 2
         FileRecycle, %imgPath%
         If ErrorLevel
            theseFailures++

         If (wasSucces=1)
            resultsList .= lineArr[1] "?" file2save "`n"
      }

      RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   }

   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%coreThread%, % countFilez "/" failedFiles "/" theseFailures "/" skippedFiles
   If resultsList
      Try FileAppend, % resultsList, %thumbsCacheFolder%\tempList%coreThread%.txt, utf-16
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 2
   operationDone := 1
   ; cleanupThread()
}

readSlideSettings(readThisFile) {
     IniRead, tstslideShowDelay, %readThisFile%, General, slideShowDelay, @
     IniRead, tstIMGresizingMode, %readThisFile%, General, IMGresizingMode, @
     IniRead, tstSlideHowMode, %readThisFile%, General, SlideHowMode, @
     IniRead, tstimgFxMode, %readThisFile%, General, imgFxMode, @
     IniRead, tstWindowBgrColor, %readThisFile%, General, WindowBgrColor, @
     ; IniRead, tstfilesFilter, %readThisFile%, General, usrFilesFilteru, @
     IniRead, tstFlipImgH, %readThisFile%, General, FlipImgH, @
     IniRead, tstFlipImgV, %readThisFile%, General, FlipImgV, @
     IniRead, tstlumosAdjust, %readThisFile%, General, lumosAdjust, @
     IniRead, tstGammosAdjust, %readThisFile%, General, GammosAdjust, @
     IniRead, tstlumosGrAdjust, %readThisFile%, General, lumosGrayAdjust, @
     IniRead, tstGammosGrAdjust, %readThisFile%, General, GammosGrayAdjust, @
     IniRead, tstsatAdjust, %readThisFile%, General, satAdjust, @
     IniRead, tstimageAligned, %readThisFile%, General, imageAligned, @
     ; IniRead, tstnoTooltipMSGs, %readThisFile%, General, noTooltipMSGs, @
     IniRead, tstTouchScreenMode, %readThisFile%, General, TouchScreenMode, @
     IniRead, tstskipDeadFiles, %readThisFile%, General, skipDeadFiles, @
     IniRead, tstisAlwaysOnTop, %readThisFile%, General, isAlwaysOnTop, @
     IniRead, tstanimGIFsSupport, %readThisFile%, General, animGIFsSupport, @
     IniRead, tstisTitleBarHidden, %readThisFile%, General, isTitleBarHidden, @
     IniRead, tstthumbsAratio, %readThisFile%, General, thumbsAratio, @
     IniRead, tstthumbsZoomLevel, %readThisFile%, General, thumbsZoomLevel, @
     IniRead, tstSLDcacheFilesList, %readThisFile%, General, SLDcacheFilesList, @
     IniRead, tsteasySlideStoppage, %readThisFile%, General, easySlideStoppage, @
     IniRead, tstzatAdjust, %readThisFile%, General, zatAdjust, @
     IniRead, tsthueAdjust, %readThisFile%, General, hueAdjust, @
     IniRead, tstautoAdjustMode, %readThisFile%, General, autoAdjustMode, @
     IniRead, tstdoSatAdjusts, %readThisFile%, General, doSatAdjusts, @
     IniRead, tstrealGammos, %readThisFile%, General, realGammos, @
     IniRead, tstLummyAdjust, %readThisFile%, General, lummyAdjust, @
     IniRead, tstspecialColorFXmode, %readThisFile%, General, specialColorFXmode, @
     IniRead, tstuiColorCurveFXchannel, %readThisFile%, General, uiColorCurveFXchannel, @
     IniRead, tstuiColorCurveFXmode, %readThisFile%, General, uiColorCurveFXmode, @
     IniRead, tstimgThreshold, %readThisFile%, General, imgThreshold, @
     IniRead, tstchnRdecalage, %readThisFile%, General, chnRdecalage, @
     IniRead, tstchnGdecalage, %readThisFile%, General, chnGdecalage, @
     IniRead, tstchnBdecalage, %readThisFile%, General, chnBdecalage, @
     IniRead, tstusrAdaptiveThreshold, %readThisFile%, General, usrAdaptiveThreshold, @
     IniRead, tstbwDithering, %readThisFile%, General, bwDithering, @
     IniRead, tstRenderOpaqueIMG, %readThisFile%, General, RenderOpaqueIMG, @
     IniRead, tstusrTextureBGR, %readThisFile%, General, usrTextureBGR, @
     IniRead, tstusrColorDepth, %readThisFile%, General, usrColorDepth, @
     IniRead, tstColorDepthDithering, %readThisFile%, General, ColorDepthDithering, @
     IniRead, tstautoPlaySNDs, %readThisFile%, General, autoPlaySNDs, @
     IniRead, tstsyncSlideShow2Audios, %readThisFile%, General, syncSlideShow2Audios, @
     IniRead, tstborderAroundImage, %readThisFile%, General, borderAroundImage, @
     IniRead, tstresetImageViewOnChange, %readThisFile%, General, resetImageViewOnChange, @
     IniRead, tstshowImgAnnotations, %readThisFile%, General, showImgAnnotations, @
     IniRead, tstallowGIFsPlayEntirely, %readThisFile%, General, allowGIFsPlayEntirely, @
     IniRead, tstshowHUDnavIMG, %readThisFile%, General, showHUDnavIMG, @

     If (tstshowHUDnavIMG=1 || tstshowHUDnavIMG=0)
        showHUDnavIMG := tstshowHUDnavIMG
     If (tstallowGIFsPlayEntirely=1 || tstallowGIFsPlayEntirely=0)
        allowGIFsPlayEntirely := tstallowGIFsPlayEntirely
     If (tstshowImgAnnotations=1 || tstshowImgAnnotations=0)
        showImgAnnotations := tstshowImgAnnotations
     If (tstresetImageViewOnChange=1 || tstresetImageViewOnChange=0)
        resetImageViewOnChange := tstresetImageViewOnChange
     If (tstsyncSlideShow2Audios=1 || tstsyncSlideShow2Audios=0)
        syncSlideShow2Audios := tstsyncSlideShow2Audios
     If (tstborderAroundImage=1 || tstborderAroundImage=0)
        borderAroundImage := tstborderAroundImage
     If (tstautoPlaySNDs=1 || tstautoPlaySNDs=0)
        autoPlaySNDs := tstautoPlaySNDs
     If (tstusrTextureBGR=1 || tstusrTextureBGR=0)
        usrTextureBGR := tstusrTextureBGR
     If (tstColorDepthDithering=1 || tstColorDepthDithering=0)
        ColorDepthDithering := tstColorDepthDithering
     If isInRange(tstusrColorDepth, 0, 9)
        usrColorDepth := tstusrColorDepth
     If (tstRenderOpaqueIMG=1 || tstRenderOpaqueIMG=0)
        RenderOpaqueIMG := tstRenderOpaqueIMG
     ; If (tstnoTooltipMSGs=1 || tstnoTooltipMSGs=0)
     ;    noTooltipMSGs := tstnoTooltipMSGs
     If (tstSLDcacheFilesList=1 || tstSLDcacheFilesList=0)
        SLDcacheFilesList := tstSLDcacheFilesList
     If (tstbwDithering=1 || tstbwDithering=0)
        bwDithering := tstbwDithering
     If (tstTouchScreenMode=1 || tstTouchScreenMode=0)
        TouchScreenMode := tstTouchScreenMode
     If (tstdoSatAdjusts=1 || tstdoSatAdjusts=0)
        doSatAdjusts := tstdoSatAdjusts
     If (tsteasySlideStoppage=1 || tsteasySlideStoppage=0)
        easySlideStoppage := tsteasySlideStoppage
     If (tstFlipImgH=1 || tstFlipImgH=0)
        FlipImgH := tstFlipImgH
     If (tstFlipImgV=1 || tstFlipImgV=0)
        FlipImgV := tstFlipImgV
     If (tstskipDeadFiles=1 || tstskipDeadFiles=0)
        skipDeadFiles := tstskipDeadFiles
     If (tstanimGIFsSupport=1 || tstanimGIFsSupport=0)
        animGIFsSupport := tstanimGIFsSupport
     If (tstisAlwaysOnTop=1 || tstisAlwaysOnTop=0)
        isAlwaysOnTop := tstisAlwaysOnTop
     If (tstisTitleBarHidden=1 || tstisTitleBarHidden=0)
        isTitleBarHidden := tstisTitleBarHidden
     If (IsNumber(tstSlideHowMode) && isInRange(tstSlideHowMode, 1, 3))
        SlideHowMode := Trimmer(tstSlideHowMode)
     If (IsNumber(tstimageAligned) && (imageAligned=1 || imageAligned=5))
        imageAligned := Trimmer(tstimageAligned)
     If (IsNumber(tstthumbsAratio) && isInRange(tstthumbsAratio, 1, 3))
        thumbsAratio := Trimmer(tstthumbsAratio)
     If (IsNumber(tstspecialColorFXmode) && isInRange(tstspecialColorFXmode, 1, 9))
        specialColorFXmode := Trimmer(tstspecialColorFXmode)
     If (IsNumber(tstuiColorCurveFXmode) && isInRange(tstuiColorCurveFXmode, 1, 7))
        uiColorCurveFXmode := Trimmer(tstuiColorCurveFXmode)
     If (IsNumber(tstuiColorCurveFXchannel) && isInRange(tstuiColorCurveFXchannel, 1, 4))
        uiColorCurveFXchannel := Trimmer(tstuiColorCurveFXchannel)
     If (IsNumber(tstslideShowDelay) && tstslideShowDelay>90)
        slideShowDelay := Trimmer(tstslideShowDelay)
     If (IsNumber(tstIMGresizingMode) && isInRange(tstIMGresizingMode, 1, 5))
        IMGresizingMode := Trimmer(tstIMGresizingMode)
     If (IsNumber(tstimgFxMode) && isInRange(tstimgFxMode, 1, 10))
        imgFxMode := Trimmer(tstimgFxMode)
     If (IsNumber(tstautoAdjustMode) && isInRange(tstautoAdjustMode, 1, 3))
        autoAdjustMode := Trimmer(tstautoAdjustMode)

     If (tstWindowBgrColor!="@" && StrLen(tstWindowBgrColor)=6)
     {
        WindowBgrColor := tstWindowBgrColor
        If (scriptInit=1)
           interfaceThread.ahkFunction("updateWindowColor")
     }
     If (tstfilesFilter!="@" && StrLen(Trimmer(tstfilesFilter))>2)
        usrFilesFilteru := tstfilesFilter

     If isNumber(tstchnRdecalage)
        chnRdecalage := Trimmer(tstchnRdecalage)
     If isNumber(tstchnGdecalage)
        chnGdecalage := Trimmer(tstchnGdecalage)
     If isNumber(tstchnBdecalage)
        chnBdecalage := Trimmer(tstchnBdecalage)
     If isNumber(tstlumosAdjust)
        lumosAdjust := Trimmer(tstlumosAdjust)
     If isNumber(tstGammosAdjust)
        GammosAdjust := Trimmer(tstGammosAdjust)
     If isNumber(tstrealGammos) && (realGammos>0)
        realGammos := Trimmer(tstrealGammos)
     If isNumber(tstimgThreshold)
        imgThreshold := Trimmer(tstimgThreshold)
     If isNumber(tstsatAdjust)
        satAdjust := Trimmer(tstsatAdjust)
     If isNumber(tstzatAdjust)
        zatAdjust := Trimmer(tstzatAdjust)
     If isNumber(tsthueAdjust)
        hueAdjust := Trimmer(tsthueAdjust)
     If isNumber(tstLummyAdjust)
        lummyAdjust := Trimmer(tstLummyAdjust)
     If isNumber(tstusrAdaptiveThreshold)
        usrAdaptiveThreshold := Trimmer(tstusrAdaptiveThreshold)
     If isNumber(tstlumosGrAdjust)
        lumosGrayAdjust := Trimmer(tstlumosGrAdjust)
     If isNumber(tstGammosGrAdjust)
        GammosGrayAdjust := Trimmer(tstGammosGrAdjust)
     If isNumber(tstthumbsZoomLevel)
        thumbsZoomLevel := Trimmer(tstthumbsZoomLevel)

     defineColorDepth()
     recalculateThumbsSizes()
}

writeMainSettings() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 450)
    {
       lastInvoked := A_TickCount
       SetTimer, writeMainSettings, -500
       Return
    }
    
    writeSlideSettings(mainSettingsFile)
    IniWrite, % MustLoadSLDprefs, % mainSettingsFile, General, MustLoadSLDprefs
    IniWrite, % prevFileMovePath, % mainSettingsFile, General, prevFileMovePath
    IniWrite, % PrefsLargeFonts, % mainSettingsFile, General, PrefsLargeFonts
    IniWrite, % prevOpenFolderPath, % mainSettingsFile, General, prevOpenFolderPath
    IniWrite, % autoRemDeadEntry, % mainSettingsFile, General, autoRemDeadEntry
    IniWrite, % askDeleteFiles, % mainSettingsFile, General, askDeleteFiles
    IniWrite, % enableThumbsCaching, % mainSettingsFile, General, enableThumbsCaching
    IniWrite, % ResizeInPercentage, % mainSettingsFile, General, ResizeInPercentage
    IniWrite, % ResizeKeepAratio, % mainSettingsFile, General, ResizeKeepAratio
    IniWrite, % ResizeQualityHigh, % mainSettingsFile, General, ResizeQualityHigh
    IniWrite, % ResizeApplyEffects, % mainSettingsFile, General, ResizeApplyEffects
    IniWrite, % ResizeRotationUser, % mainSettingsFile, General, ResizeRotationUser
    IniWrite, % ResizeCropAfterRotation, % mainSettingsFile, General, ResizeCropAfterRotation
    IniWrite, % prevFileSavePath, % mainSettingsFile, General, prevFileSavePath
    IniWrite, % alwaysOpenwithFIM, % mainSettingsFile, General, alwaysOpenwithFIM
    IniWrite, % userHQraw, % mainSettingsFile, General, userHQraw
    IniWrite, % OSDFontName, % mainSettingsFile, General, OSDFontName
    IniWrite, % FontBolded, % mainSettingsFile, General, FontBolded
    IniWrite, % FontItalica, % mainSettingsFile, General, FontItalica
    IniWrite, % OSDfntSize, % mainSettingsFile, General, OSDfntSize
    IniWrite, % PasteFntSize, % mainSettingsFile, General, PasteFntSize
    IniWrite, % OSDbgrColor, % mainSettingsFile, General, OSDbgrColor
    IniWrite, % OSDtextColor, % mainSettingsFile, General, OSDtextColor
    IniWrite, % DisplayTimeUser, % mainSettingsFile, General, DisplayTimeUser
    IniWrite, % userimgQuality, % mainSettingsFile, General, userimgQuality
    IniWrite, % usrTextAlign, % mainSettingsFile, General, usrTextAlign
    IniWrite, % relativeImgSelCoords, % mainSettingsFile, General, relativeImgSelCoords
    IniWrite, % showInfoBoxHUD, % mainSettingsFile, General, showInfoBoxHUD
    IniWrite, % showHistogram, % mainSettingsFile, General, showHistogram
    IniWrite, % mediaSNDvolume, % mainSettingsFile, General, mediaSNDvolume
    IniWrite, % OnConvertKeepOriginals, % mainSettingsFile, General, OnConvertKeepOriginals
    IniWrite, % userDesireWriteFMT, % mainSettingsFile, General, userDesireWriteFMT
    IniWrite, % ResizeUseDestDir, % mainSettingsFile, General, ResizeUseDestDir
    IniWrite, % ResizeDestFolder, % mainSettingsFile, General, ResizeDestFolder
    IniWrite, % userMultiDelChoice, % mainSettingsFile, General, userMultiDelChoice
    IniWrite, % doSlidesTransitions, % mainSettingsFile, General, doSlidesTransitions
    IniWrite, % multilineStatusBar, % mainSettingsFile, General, multilineStatusBar
    IniWrite, % minimizeMemUsage, % mainSettingsFile, General, minimizeMemUsage
    IniWrite, % showSelectionGrid, % mainSettingsFile, General, showSelectionGrid
    IniWrite, % EllipseSelectMode, % mainSettingsFile, General, EllipseSelectMode
    IniWrite, % thumbnailsListMode, % mainSettingsFile, General, thumbnailsListMode
    IniWrite, % thumbsListViewMode, % mainSettingsFile, General, thumbsListViewMode
    IniWrite, % LimitSelectBoundsImg, % mainSettingsFile, General, LimitSelectBoundsImg
    IniWrite, % allowRecordHistory, % mainSettingsFile, General, allowRecordHistory
    IniWrite, % skipSeenImagesSlider, % mainSettingsFile, General, skipSeenImagesSlider
    IniWrite, % showMainMenuBar, % mainSettingsFile, General, showMainMenuBar
    IniWrite, % rotateSelBoundsKeepRatio, % mainSettingsFile, General, rotateSelBoundsKeepRatio
    IniWrite, % highlightAlreadySeenImages, % mainSettingsFile, General, highlightAlreadySeenImages
    IniWrite, % useCachedSLDdata, % mainSettingsFile, General, useCachedSLDdata
    IniWrite, % userAllowWindowDrag, % mainSettingsFile, General, userAllowWindowDrag
    IniWrite, % dynamicThumbsColumns, % mainSettingsFile, General, dynamicThumbsColumns
    IniWrite, % thumbsColumns, % mainSettingsFile, General, thumbsColumns
    IniWrite, % histogramMode, % mainSettingsFile, General, histogramMode
    IniWrite, % cycleFavesOpenIMG, % mainSettingsFile, General, cycleFavesOpenIMG
    lastInvoked := A_TickCount
}

loadMainSettings() {
    readSlideSettings(mainSettingsFile)
    IniRead, tstMustLoadSLDprefs, % mainSettingsFile, General, MustLoadSLDprefs, @
    IniRead, tstprevFileMovePath, % mainSettingsFile, General, prevFileMovePath, @
    IniRead, tstprevOpenFolderPath, % mainSettingsFile, General, prevOpenFolderPath, @
    IniRead, tstPrefsLargeFonts, % mainSettingsFile, General, PrefsLargeFonts, @
    IniRead, tstaskDeleteFiles, % mainSettingsFile, General, askDeleteFiles, @
    IniRead, tstenableThumbsCaching, % mainSettingsFile, General, enableThumbsCaching, @
    IniRead, tstautoRemDeadEntry, % mainSettingsFile, General, autoRemDeadEntry, @
    IniRead, tstprevFileSavePath, % mainSettingsFile, General, prevFileSavePath, @
    IniRead, tstalwaysOpenwithFIM, % mainSettingsFile, General, alwaysOpenwithFIM, @
    IniRead, tstuserHQraw, % mainSettingsFile, General, userHQraw, @
    IniRead, tstOSDFontName, % mainSettingsFile, General, OSDFontName, @
    IniRead, tstFontBolded, % mainSettingsFile, General, FontBolded, @
    IniRead, tstFontItalica, % mainSettingsFile, General, FontItalica, @
    IniRead, tstOSDfntSize, % mainSettingsFile, General, OSDfntSize, @
    IniRead, tstPasteFntSize, % mainSettingsFile, General, PasteFntSize, @
    IniRead, tstOSDbgrColor, % mainSettingsFile, General, OSDbgrColor, @
    IniRead, tstOSDtextColor, % mainSettingsFile, General, OSDtextColor, @
    IniRead, tstDisplayTimeUser, % mainSettingsFile, General, DisplayTimeUser, @
    IniRead, tstuserimgQuality, % mainSettingsFile, General, userimgQuality, @
    IniRead, tstusrTextAlign, % mainSettingsFile, General, usrTextAlign, @
    ; IniRead, tstrelativeImgSelCoords, % mainSettingsFile, General, relativeImgSelCoords, @
    IniRead, tstshowInfoBoxHUD, % mainSettingsFile, General, showInfoBoxHUD, @
    IniRead, tstshowHistogram, % mainSettingsFile, General, showHistogram, @
    IniRead, tstmediaSNDvolume, % mainSettingsFile, General, mediaSNDvolume, @
    IniRead, tstuserMultiDelChoice, % mainSettingsFile, General, userMultiDelChoice, @
    IniRead, tstdoSlidesTransitions, % mainSettingsFile, General, doSlidesTransitions, @
    IniRead, tstmultilineStatusBar, % mainSettingsFile, General, multilineStatusBar, @
    IniRead, tstAutoDownScaleIMGs, % mainSettingsFile, General, AutoDownScaleIMGs, @
    IniRead, tstallowMultiCoreMode, % mainSettingsFile, General, allowMultiCoreMode, @
    IniRead, tstminimizeMemUsage, % mainSettingsFile, General, minimizeMemUsage, @
    IniRead, tstResizeDestFolder, % mainSettingsFile, General, ResizeDestFolder, @
    IniRead, tstmaxUserThreads, % mainSettingsFile, Hidden, maxUserThreads, @
    IniRead, tstmaxMemThumbsCache, % mainSettingsFile, Hidden, maxMemThumbsCache, @
    IniRead, tstshowSelectionGrid, % mainSettingsFile, General, showSelectionGrid, @
    IniRead, tstEllipseSelectMode, % mainSettingsFile, General, EllipseSelectMode, @
    IniRead, tstthumbnailsListMode, % mainSettingsFile, General, thumbnailsListMode, @
    IniRead, tstthumbsListViewMode, % mainSettingsFile, General, thumbsListViewMode, @
    IniRead, tstLimitSelectBoundsImg, % mainSettingsFile, General, LimitSelectBoundsImg, @
    IniRead, tstallowRecordHistory, % mainSettingsFile, General, allowRecordHistory, @
    IniRead, tstskipSeenImagesSlider, % mainSettingsFile, General, skipSeenImagesSlider, @
    IniRead, tstshowMainMenuBar, % mainSettingsFile, General, showMainMenuBar, @
    IniRead, tstrotateSelBoundsKeepRatio, % mainSettingsFile, General, rotateSelBoundsKeepRatio, @
    IniRead, tsthighlightAlreadySeenImages, % mainSettingsFile, General, highlightAlreadySeenImages, @
    IniRead, tstuseCachedSLDdata, % mainSettingsFile, General, useCachedSLDdata, @
    IniRead, tstuserAllowWindowDrag, % mainSettingsFile, General, userAllowWindowDrag, @
    IniRead, tstdynamicThumbsColumns, % mainSettingsFile, General, dynamicThumbsColumns, @
    IniRead, tstthumbsColumns, % mainSettingsFile, General, thumbsColumns, @
    IniRead, tstuserMultiCoresLimit, % mainSettingsFile, General, userMultiCoresLimit, @
    IniRead, tsthistogramMode, % mainSettingsFile, General, histogramMode, @
    IniRead, tstmainWinSize, % mainSettingsFile, General, mainWinSize, @
    IniRead, tstmainWinPos, % mainSettingsFile, General, mainWinPos, @
    IniRead, tstmainWinMaximized, % mainSettingsFile, General, mainWinMaximized, @
    IniRead, tstzoomLevel, % mainSettingsFile, General, zoomLevel, @
    IniRead, tstcmrRAWtoneMapAlgo, % mainSettingsFile, General, cmrRAWtoneMapAlgo, @
    IniRead, tstcmrRAWtoneMapParamA, % mainSettingsFile, General, cmrRAWtoneMapParamA, @
    IniRead, tstcmrRAWtoneMapParamB, % mainSettingsFile, General, cmrRAWtoneMapParamB, @
    IniRead, tstcycleFavesOpenIMG, % mainSettingsFile, General, cycleFavesOpenIMG, @

    If isInRange(tstcmrRAWtoneMapAlgo, 1, 3)
       cmrRAWtoneMapAlgo := tstcmrRAWtoneMapAlgo

    If (cmrRAWtoneMapAlgo=1)
    {
       If isNumber(tstcmrRAWtoneMapParamA)
          cmrRAWtoneMapParamA := clampInRange(tstcmrRAWtoneMapParamA, 0, 9.9)
       If isNumber(tstcmrRAWtoneMapParamB)
          cmrRAWtoneMapParamB := clampInRange(tstcmrRAWtoneMapParamB, -8, 8)
    } Else If (cmrRAWtoneMapAlgo=2)
    {
       If isNumber(tstcmrRAWtoneMapParamA)
          cmrRAWtoneMapParamA := clampInRange(tstcmrRAWtoneMapParamA, -8, 8)
       If isNumber(tstcmrRAWtoneMapParamB)
          cmrRAWtoneMapParamB := clampInRange(tstcmrRAWtoneMapParamB, 0, 1)
    } Else If (cmrRAWtoneMapAlgo=3)
    {
       If isNumber(tstcmrRAWtoneMapParamA)
          cmrRAWtoneMapParamA := clampInRange(tstcmrRAWtoneMapParamA, 0, 1)
       If isNumber(tstcmrRAWtoneMapParamB)
          cmrRAWtoneMapParamB := clampInRange(tstcmrRAWtoneMapParamB, 0, 1)
    }

    If (tstmainWinMaximized=1 || tstmainWinMaximized=2)
       mainWinMaximized := tstmainWinMaximized
    If InStr(tstmainWinPos, "|")
       mainWinPos := tstmainWinPos
    If InStr(tstmainWinSize, "|")
       mainWinSize := tstmainWinSize
    If (tsthistogramMode=1 || tsthistogramMode=2 || tsthistogramMode=3)
       histogramMode := tsthistogramMode
    If (tstuserimgQuality=1 || tstuserimgQuality=0)
       userimgQuality := tstuserimgQuality
    If (tstcycleFavesOpenIMG=1 || tstcycleFavesOpenIMG=0)
       cycleFavesOpenIMG := tstcycleFavesOpenIMG
    If (tstuserAllowWindowDrag=1 || tstuserAllowWindowDrag=0)
       userAllowWindowDrag := tstuserAllowWindowDrag
    If (tstuseCachedSLDdata=1 || tstuseCachedSLDdata=0)
       useCachedSLDdata := tstuseCachedSLDdata
    If (isInRange(tstzoomLevel, 0.01, 20) && tstzoomLevel!="@" && isNumber(tstzoomLevel))
       zoomLevel := tstzoomLevel

    imgQuality := (userimgQuality=1) ? 7 : 5
    If (tstrotateSelBoundsKeepRatio=1 || tstrotateSelBoundsKeepRatio=0)
       rotateSelBoundsKeepRatio := tstrotateSelBoundsKeepRatio
    If (tsthighlightAlreadySeenImages=1 || tsthighlightAlreadySeenImages=0)
       highlightAlreadySeenImages := tsthighlightAlreadySeenImages
    If (tstshowMainMenuBar=1 || tstshowMainMenuBar=0)
       showMainMenuBar := tstshowMainMenuBar
    If (tstskipSeenImagesSlider=1 || tstskipSeenImagesSlider=0)
       skipSeenImagesSlider := tstskipSeenImagesSlider
    If (tstdynamicThumbsColumns=1 || tstdynamicThumbsColumns=0)
       dynamicThumbsColumns := tstdynamicThumbsColumns
    If IsNumber(Trimmer(tstthumbsColumns))
       thumbsColumns := Trimmer(tstthumbsColumns)
    If (tstthumbnailsListMode=1 || tstthumbnailsListMode=0)
       thumbnailsListMode := tstthumbnailsListMode
    If (tstallowRecordHistory=1 || tstallowRecordHistory=0)
       allowRecordHistory := tstallowRecordHistory
    If (tstthumbsListViewMode=1 || tstthumbsListViewMode=2 || tstthumbsListViewMode=3)
       thumbsListViewMode := tstthumbsListViewMode
    If (tstEllipseSelectMode=1 || tstEllipseSelectMode=0)
       EllipseSelectMode := tstEllipseSelectMode
    If (tstshowSelectionGrid=1 || tstshowSelectionGrid=0)
       showSelectionGrid := tstshowSelectionGrid
    If (tstLimitSelectBoundsImg=1 || tstLimitSelectBoundsImg=0)
       LimitSelectBoundsImg := tstLimitSelectBoundsImg
    If (tstallowMultiCoreMode=1 || tstallowMultiCoreMode=0)
       allowMultiCoreMode := tstallowMultiCoreMode
    If (tstminimizeMemUsage=1 || tstminimizeMemUsage=0)
       minimizeMemUsage := tstminimizeMemUsage
    If (tstAutoDownScaleIMGs=1 || tstAutoDownScaleIMGs=0)
       AutoDownScaleIMGs := tstAutoDownScaleIMGs
    If (tstusrTextAlign="Left" || tstusrTextAlign="Right" || tstusrTextAlign="Center")
       usrTextAlign := tstusrTextAlign
    If (IsNumber(tstDisplayTimeUser) && tstDisplayTimeUser>0)
       DisplayTimeUser := Trimmer(tstDisplayTimeUser)
    If (IsNumber(tstOSDfntSize) && tstOSDfntSize>15)
       OSDfntSize := Trimmer(tstOSDfntSize)
    If (IsNumber(tstPasteFntSize) && tstPasteFntSize>15)
       PasteFntSize := Trimmer(tstPasteFntSize)
    If (IsNumber(tstmediaSNDvolume) && tstmediaSNDvolume>2)
       mediaSNDvolume := Trimmer(tstmediaSNDvolume)
    If (IsNumber(tstuserMultiCoresLimit) && tstuserMultiCoresLimit>1)
       userMultiCoresLimit := Trimmer(tstuserMultiCoresLimit)
    If IsNumber(tstmaxMemThumbsCache) && tstmaxMemThumbsCache>10
       maxMemThumbsCache := Trimmer(tstmaxMemThumbsCache)
    If IsNumber(maxUserThreads) && maxUserThreads>2
       maxUserThreads := Trimmer(maxUserThreads)
    If (tstFontBolded=1 || tstFontBolded=0)
       FontBolded := tstFontBolded
    If (tstFontItalica=1 || tstFontItalica=0)
       FontItalica := tstFontItalica
    If isInRange(tstshowHistogram, 1, 6)
       showHistogram := tstshowHistogram
    If (tstmultilineStatusBar=1 || tstmultilineStatusBar=0)
       multilineStatusBar := tstmultilineStatusBar
    If (tstshowInfoBoxHUD=2 || tstshowInfoBoxHUD=1 || tstshowInfoBoxHUD=0)
       showInfoBoxHUD := tstshowInfoBoxHUD

    If (tstuserMultiDelChoice=1 || tstuserMultiDelChoice=2 || tstuserMultiDelChoice=3)
       userMultiDelChoice := tstuserMultiDelChoice
    If (tstdoSlidesTransitions=1 || tstdoSlidesTransitions=0)
       doSlidesTransitions := tstdoSlidesTransitions
    If (tstalwaysOpenwithFIM=1 || tstalwaysOpenwithFIM=0)
       alwaysOpenwithFIM := tstalwaysOpenwithFIM
    If (tstalwaysOpenwithFIM=1 || tstalwaysOpenwithFIM=0)
       alwaysOpenwithFIM := tstalwaysOpenwithFIM
    If (tstuserHQraw=1 || tstuserHQraw=0)
       userHQraw := tstuserHQraw
    ; If (tstrelativeImgSelCoords=1 || tstrelativeImgSelCoords=0)
    ;    relativeImgSelCoords := tstrelativeImgSelCoords
    If (tstenableThumbsCaching=1 || tstenableThumbsCaching=0)
       enableThumbsCaching := tstenableThumbsCaching
    If (tstaskDeleteFiles=1 || tstaskDeleteFiles=0)
       askDeleteFiles := tstaskDeleteFiles
    If (tstautoRemDeadEntry=1 || tstautoRemDeadEntry=0)
       autoRemDeadEntry := tstautoRemDeadEntry
    If (tstPrefsLargeFonts=1 || tstPrefsLargeFonts=0)
       PrefsLargeFonts := tstPrefsLargeFonts
    If (tstMustLoadSLDprefs=1 || tstMustLoadSLDprefs=0)
       MustLoadSLDprefs := tstMustLoadSLDprefs
    If (StrLen(tstprevFileMovePath)>3)
       prevFileMovePath := tstprevFileMovePath
    If (StrLen(tstOSDFontName)>2)
       OSDFontName := tstOSDFontName
    If (StrLen(tstprevFileSavePath)>3)
       prevFileSavePath := tstprevFileSavePath
    If (StrLen(tstprevOpenFolderPath)>3)
       prevOpenFolderPath := tstprevOpenFolderPath
    If (StrLen(tstResizeDestFolder)>3)
       ResizeDestFolder := tstResizeDestFolder
    If (tstOSDbgrColor!="@" && StrLen(tstOSDbgrColor)=6)
       OSDbgrColor := tstOSDbgrColor
    If (tstOSDtextColor!="@" && StrLen(tstOSDtextColor)=6)
       OSDtextColor := tstOSDtextColor

    If !prevOpenFolderPath
       prevOpenFolderPath := A_WorkingDir

    If !ResizeDestFolder
    {
       If prevOpenFolderPath
          ResizeDestFolder := prevOpenFolderPath
       Else
          ResizeDestFolder := A_WorkingDir
    }

    If (OSDfntSize<9)
       OSDfntSize := 9

    EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
    userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
    realSystemCores := userMultiCoresLimit
    SetVolume(mediaSNDvolume)
    calcHUDsize()
    msgDisplayTime := DisplayTimeUser*1000
}

calcHUDsize() {
   imgHUDbaseUnit := (PrefsLargeFonts=1) ? Round(OSDfntSize*2.5) : Round(OSDfntSize*2)
}

writeSlideSettings(file2save) {
    IniWrite, % SLDcacheFilesList, %file2save%, General, SLDcacheFilesList
    IniWrite, % IMGresizingMode, %file2save%, General, IMGresizingMode
    IniWrite, % imgFxMode, %file2save%, General, imgFxMode
    IniWrite, % SlideHowMode, %file2save%, General, SlideHowMode
    IniWrite, % slideShowDelay, %file2save%, General, slideShowDelay
    IniWrite, % WindowBgrColor, %file2save%, General, WindowBgrColor
    IniWrite, % FlipImgH, %file2save%, General, FlipImgH
    IniWrite, % FlipImgV, %file2save%, General, FlipImgV
    IniWrite, % usrColorDepth, %file2save%, General, usrColorDepth
    IniWrite, % ColorDepthDithering, %file2save%, General, ColorDepthDithering
    IniWrite, % lumosAdjust, %file2save%, General, lumosAdjust
    IniWrite, % GammosAdjust, %file2save%, General, GammosAdjust
    IniWrite, % lumosGrayAdjust, %file2save%, General, lumosGrayAdjust
    IniWrite, % GammosGrayAdjust, %file2save%, General, GammosGrayAdjust
    IniWrite, % satAdjust, %file2save%, General, satAdjust
    IniWrite, % lummyAdjust, %file2save%, General, lummyAdjust
    IniWrite, % uiColorCurveFXmode, %file2save%, General, uiColorCurveFXmode
    IniWrite, % uiColorCurveFXchannel, %file2save%, General, uiColorCurveFXchannel
    IniWrite, % specialColorFXmode, %file2save%, General, specialColorFXmode
    IniWrite, % imageAligned, %file2save%, General, imageAligned
    IniWrite, % doSatAdjusts, % mainSettingsFile, General, doSatAdjusts
    IniWrite, % autoAdjustMode, % mainSettingsFile, General, autoAdjustMode
    IniWrite, % chnRdecalage, % mainSettingsFile, General, chnRdecalage
    IniWrite, % chnGdecalage, % mainSettingsFile, General, chnGdecalage
    IniWrite, % chnBdecalage, % mainSettingsFile, General, chnBdecalage
    IniWrite, % usrAdaptiveThreshold, % mainSettingsFile, General, usrAdaptiveThreshold
    ; IniWrite, % noTooltipMSGs, %file2save%, General, noTooltipMSGs
    IniWrite, % TouchScreenMode, %file2save%, General, TouchScreenMode
    IniWrite, % skipDeadFiles, %file2save%, General, skipDeadFiles
    IniWrite, % isAlwaysOnTop, %file2save%, General, isAlwaysOnTop
    IniWrite, % bwDithering, %file2save%, General, bwDithering
    IniWrite, % RenderOpaqueIMG, %file2save%, General, RenderOpaqueIMG
    IniWrite, % zatAdjust, %file2save%, General, zatAdjust
    IniWrite, % hueAdjust, %file2save%, General, hueAdjust
    IniWrite, % realGammos, %file2save%, General, realGammos
    IniWrite, % imgThreshold, %file2save%, General, imgThreshold
    IniWrite, % isTitleBarHidden, %file2save%, General, isTitleBarHidden
    IniWrite, % animGIFsSupport, %file2save%, General, animGIFsSupport
    IniWrite, % thumbsAratio, %file2save%, General, thumbsAratio
    IniWrite, % thumbsZoomLevel, %file2save%, General, thumbsZoomLevel
    IniWrite, % easySlideStoppage, %file2save%, General, easySlideStoppage
    IniWrite, % appVersion, %file2save%, General, appVersion
    IniWrite, % usrTextureBGR, %file2save%, General, usrTextureBGR
    IniWrite, % syncSlideShow2Audios, %file2save%, General, syncSlideShow2Audios
    IniWrite, % autoPlaySNDs, %file2save%, General, autoPlaySNDs
    IniWrite, % borderAroundImage, %file2save%, General, borderAroundImage
    IniWrite, % resetImageViewOnChange, %file2save%, General, resetImageViewOnChange
    IniWrite, % showImgAnnotations, %file2save%, General, showImgAnnotations
    IniWrite, % allowGIFsPlayEntirely, %file2save%, General, allowGIFsPlayEntirely
    throwMSGwriteError()
}

readRecentEntries(forceNewList:=0, doFiltering:=1) {
   Static lastInvoked := 1, historyList

   If (StrLen(forceNewList)>4)
   {
      historyList := forceNewList
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(historyList)>4 && (A_TickCount - lastInvoked<5500))
   {
      lastInvoked := A_TickCount
      Return historyList
   }

   historyList := ""
   Loop, 10
   {
       IniRead, newEntry, % mainRecentsFile, RecentOpen, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>4 && doFiltering=1)
          historyList .= newEntry "`n"
       Else If (doFiltering!=1)
          historyList .= newEntry "`n"
   }
  
   List_MakeUnique(historyList, "`n", 0, 1)
   lastInvoked := A_TickCount
   Return historyList
}

List_MakeUnique(ByRef oList, Delimiter:="`n", Case_Sensitive:=0, keepAsEmpty:=0) {
; By [VxE], removes duplicate entries from a list. Special thanks to SKAN.
; SOURCE: https://autohotkey.com/board/topic/34715-removing-duplicates-from-the-list-without-sorting-it/page-2
; modified by Marius Șucan

   ; VarSetCapacity( New_List, StrLen( List ) )
   New_List := Delimiter
   entriesCount := 0
   Loop, Parse, oList, % Delimiter
   {
      If (keepAsEmpty!=1 && !A_LoopField)
         Continue

      If (!InStr(New_List, Delimiter . A_LoopField . Delimiter, !!Case_Sensitive))
         New_List .= A_LoopField . Delimiter
      Else If (keepAsEmpty=1)
         New_List .= A_Space . Delimiter

      entriesCount++
   }
   oList := SubStr(New_List, 2, -1)
   Return entriesCount
}

readFavesEntries() {
   Static lastInvoked := 1, prevList, prevCall

   FileGetSize, aaa, % mainFavesFile
   FileGetTime, bbb, % mainFavesFile, M
   FileGetAttrib, ccc, % mainFavesFile
   thisCall := "zzz" aaa . bbb . ccc 
   If (thisCall!=prevCall || !prevList)
      FileRead, historyList, % mainFavesFile
   Else
      historyList := prevList

   lastInvoked := A_TickCount
   prevCall := thisCall
   prevList := historyList
   Return historyList
}

RecentFilesManager(entry2add) {
  If (StrLen(entry2add)<5 || !allowRecordHistory)
     Return

  historyList := readRecentEntries()
  historyList := entry2add "`n" historyList
  List_MakeUnique(historyList, "`n", 0, 0)
  Loop, Parse, historyList, `n
  {
      If (A_Index>11)
         Break

      If (StrLen(A_LoopField)<5 || !FileExist(StrReplace(A_LoopField, "|")))
         Continue

      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentOpen, E%countItemz%
      newHistoryList .= A_LoopField "`n"
  }

  readRecentEntries(newHistoryList)
}

ToggleImgFavourites(thisImg:=0, actu:=0, directCall:=0) {
  Static lastInvoked := 1, prevImg
  imgPath := thisImg ? thisImg : getIDimage(currentFileIndex)
  isPipe := InStr(imgPath, "||")
  imgPath := StrReplace(imgPath, "||")
  If (A_TickCount - lastInvoked<550) && (directCall=1 && prevImg=imgPath)
     Return

  If (!FileRexists(imgPath) && actu!="rem")
  {
     showTOOLtip("ERROR: The file seems to not exist.`nYou cannot add to favourites inexistent files...")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  prevImg := imgPath
  isFaved := isPipe ? 0 : resultedFilesList[currentFileIndex, 5]
  If (!isFaved && actu!="rem")
  {
     If !userAddedFavesCount
     {
        IniAction(0, "userAddedFavesCount", "General")
        If !isNumber(userAddedFavesCount)
           userAddedFavesCount := 0
     }

     If (userAddedFavesCount>maxFavesEntries - 1)
     {
        showTOOLtip("WARNING: You have reached the maximum allowed favourite images: " maxFavesEntries " entries.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     lastInvoked := A_TickCount
     FileAppend, % imgPath "`n", % mainFavesFile, UTF-8
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list...`nThe image was not added to favourites.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     userAddedFavesCount++
     IniAction(1, "userAddedFavesCount", "General")
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image ADDED to favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " userAddedFavesCount, 0, 0, userAddedFavesCount/maxFavesEntries)
     resultedFilesList[currentFileIndex, 5] := 1
     If !thisImg
        resultedFilesList[currentFileIndex, 1] := imgPath

     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     lastInvoked := A_TickCount
  } Else
  {
     ToolTip, Please wait...
     lastInvoked := A_TickCount
     FileRead, historyList, % mainFavesFile
     If ErrorLevel
     {
        Tooltip
        showTOOLtip("Failed to read favourites list...`nUnable to remove image from favourites.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     If !thisImg
     {
        resultedFilesList[currentFileIndex, 5] := 0
        If InStr(CurrentSLD, "\favourite-images-list.SLD")
           resultedFilesList[currentFileIndex, 1] := "||" imgPath
     }

     historyList := StrReplace(historyList, imgPath)
     hash := []
     arrayList := []
     Loop, Parse, historyList,`n,`r
     {
         If (realCount>maxFavesEntries)
            Break

         If !RegExMatch(A_LoopField, RegExFilesPattern)
            Continue

         z := "z" StringToASC(A_LoopField)
         If (hash[z]!=1)
         {
            realCount++
            hash[z] := 1
            arrayList[realCount] := A_LoopField
         }
     }

     FileDelete, % mainFavesFile
     Sleep, 125
      ; List_MakeUnique(historyList, "`n", 0, 0)
     userAddedFavesCount := realCount
     IniAction(1, "userAddedFavesCount", "General")
     For Key, Value in arrayList
         finalListu .= Value "`n"

     lastInvoked := A_TickCount
     FileAppend, % finalListu, % mainFavesFile, UTF-8
     Tooltip
     If ErrorLevel
     {
        showTOOLtip("Failed to update the favourites list file...`nThe image was not succesfully removed from favourites.")
        SoundBeep , 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime//2
        Return
     }

     zPlitPath(imgPath, 0, OutFileName, OutDir)
     showTOOLtip("Image REMOVED from favourites:`n" OutFileName "`n" OutDir "\`nTotal entries: " realCount, 0, 0, realCount/maxFavesEntries)
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     lastInvoked := A_TickCount
  }

  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

retrieveFavesAsList(dummy:=0) {
    If askAboutFileSave(". The current files list will be discarded as well")
       Return
 
    If AnyWindowOpen
       CloseWindow("yes")
 
    showTOOLtip("Loading favourites list...")
    FileRead, historyList, % mainFavesFile
    thisList := []
    hash := []
    mustRenewList := countItemz := thisIndexu := 0
    ;  realCount := List_MakeUnique(historyList, "`n", 0, 0)
    Loop, Parse, historyList, `n,`r
    {
       imgu := Trimmer(A_LoopField)
       If (StrLen(imgu)<4 || !RegExMatch(imgu, RegExFilesPattern))
       {
          If A_LoopField
             mustRenewList := 1
          Continue
       }
       posu := InStr(imgu, ":\", 0, -1)
       If (posu>4)
       {
          oimgu := imgu
          imgu := SubStr(imgu, 1, posu - 2)
          bonus := SubStr(oimgu, posu - 1)
          thisIndexu++
          thisList[thisIndexu] := [bonus]
          thisList[thisIndexu, 5] := 1
       }

       z := "z" StringToASC(imgu)
       If (hash[z]!=1)
       {
          thisIndexu++
          thisList[thisIndexu] := [imgu]
          thisList[thisIndexu, 5] := 1
          hash[z] := 1
       } Else mustRenewList := 1
    }

   If (thisIndexu> maxFavesEntries - 1)
      msgBoxWrapper(appTitle ": WARNING", "Please take note, you have exceeded the limit of favourite image entries: " maxFavesEntries ".", 0, 0, "exclamation")

   userAddedFavesCount := thisIndexu
   IniAction(1, "userAddedFavesCount", "General")
   If (thisIndexu<2)
   {
      SoundBeep , 300, 100
      showTOOLtip("Found insufficient favourite images...")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\favourite-images-list.SLD"
   resultedFilesList := thisList.Clone()
   SetTimer, RemoveTooltip, % -msgDisplayTime
   SLDtypeLoaded := 2
   maxFilesIndex := thisList.Count()
   currentFileIndex := (isNumber(dummy)=1 && dummy>0) ? dummy : clampInRange(maxFilesIndex - 2, 1, maxFilesIndex)
   seenEntries := []
   If (mustRenewList=1)
      renewFavesListBasedOnIndexList()

   If (thumbsDisplaying!=1 && !isNumber(dummy))
      MenuDummyToggleThumbsMode()
   GenerateRandyList()
   dummyTimerDelayiedImageDisplay(50)
   SetTimer, dummyInfoOpenFaves, -125
   ; RandomPicture()
}

dummyInfoOpenFaves() {
   showTOOLtip("Favourites list loaded...`nTotal entries: " groupDigits(maxFilesIndex))
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

renewFavesListBasedOnIndexList() {
   ; If StrLen(filesFilter)>1
   ;    Return
   newListu := ""
   realCount := 0
   Loop, % maxFilesIndex
   {
       ; isFaved := resultedFilesList[currentFileIndex, 5]
       ; If !isFaved
       ;    Continue

       If (realCount>maxFavesEntries)
          Break

       If StrLen(filesFilter)>1
          thisImg := bckpResultedFilesList[filteredMap2mainList[A_Index], 1]
       Else
          thisImg := resultedFilesList[A_Index, 1]

       If (StrLen(thisImg)>3 && !InStr(thisImg, "||"))
       {
          realCount++
          newListu .= thisImg "`n"
       }
   }

   FileDelete, % mainFavesFile
   Sleep, 125
   ; realCount := List_MakeUnique(newListu, "`n", 0, 0)
   userAddedFavesCount := realCount
   IniAction(1, "userAddedFavesCount", "General")
   FileAppend, % newListu "`n", % mainFavesFile, UTF-8
}

eraseAllFavedIMGs() {
  msgResult := msgBoxWrapper(appTitle ": Favourites", "Are you sure you want to remove all the entries from the favourites list?", 4, 0, "question")
  If !InStr(msgResult, "yes")
     Return
  
  FileDelete, % mainFavesFile
  showTOOLtip("All entries from the favourites list were removed.")
  SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

RandomPicture(dummy:=0, inLoop:=0) {
   ; Static inLoop := 0
   If (maxFilesIndex=0 || maxFilesIndex="") && (!CurrentSLD)
      Return

   currentFileIndex := coreNextPrevImage(1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

PrevRandyPicture(dummy:=0, inLoop:=0) {
   resetSlideshowTimer(0)
   currentFileIndex := coreNextPrevImage(-1, RandyIMGnow, 1)
   dummyTimerDelayiedImageDisplay(10)
}

getSelectedFiles(getItem:=0, forceSort:=0) {
   Static firstItem, lastItem

   If (getItem=0 && forceSort=0)
      Return markedSelectFile

   If (getItem=1 && markedSelectFile)
      Return firstItem

   If (getItem="L" && markedSelectFile)
      Return lastItem

   If (forceSort=1 && getItem=0)
   {
      firstItem := lastItem := markedSelectFile := 0
      changeMcursor()
      startZeit := A_TickCount
      Loop, % maxFilesIndex
      {
         If (resultedFilesList[A_Index, 2]=1)
         {
            markedSelectFile++
            lastItem := A_Index
            If !firstItem
               firstItem := A_Index
         }
      }

      If (markedSelectFile=1)
      {
         markedSelectFile := 0
         resultedFilesList[firstItem, 2] := 0
         If (thumbsDisplaying=1)
            mainGdipWinThumbsGrid()
      }
      changeMcursor("normal")
      Return markedSelectFile
   }
}

filterToFilesSelection() {
   coreEnableFiltru("||Prev-Files-Selection||")
}

invertFilesSelection(silentMode:=0) {
   markedSelectFile := 0
   Loop, % maxFilesIndex
   {
       sel := resultedFilesList[A_Index, 2]
       resultedFilesList[A_Index, 2] := !sel
       If (!sel=1)
          markedSelectFile++
   }
   If (thumbsDisplaying=1)
      mainGdipWinThumbsGrid()
   Else
      dummyTimerDelayiedImageDisplay(50)

   showTOOLtip("Files selection inverted...`n" markedSelectFile " files are now selected")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dropFilesSelection(silentMode:=0) {
   If (!markedSelectFile && silentMode=1)
      Return

   markedSelectFile := 0
   startZeit := A_TickCount
   Loop, % maxFilesIndex
       resultedFilesList[A_Index, 2] := 0

   ; ToolTip, % A_TickCount - startZeit, , , 2
   If (silentMode!=1)
   {
      showTOOLtip("Files selection dropped...")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (thumbsDisplaying=1)
         mainGdipWinThumbsGrid()
      Else
         dummyTimerDelayiedImageDisplay(50)
   }
}

MenuMarkThisFileNow() {
   markThisFileNow()
}

markThisFileNow(thisFileIndex:=0) {
  If (currentFileIndex=0  || maxFilesIndex<2 || AnyWindowOpen>0)
     Return

  If !thisFileIndex
     thisFileIndex := currentFileIndex

  oSel := resultedFilesList[thisFileIndex, 2]
  sel := oSel ? 0 : 1
  resultedFilesList[thisFileIndex, 2] := sel
  sel := (oSel && !sel) ? 0 : 1

  If sel
     markedSelectFile++
  Else
     markedSelectFile--

  If (markedSelectFile<0)
     getSelectedFiles(0, 1)
  Else If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
  Else
     dummyTimerDelayiedImageDisplay(25)
}

jumpToFilesSelBorderFirst() {
   jumpToFilesSelBorder(-1)
}

jumpToFilesSelBorderLast() {
   jumpToFilesSelBorder(1)
}

jumpToFilesSelBorder(destination) {
  Static prevImgIndex, prevIndexu

  If (slideShowRunning=1)
     ToggleSlideShowu()

  totalCount := getSelectedFiles(0, 1)
  If !totalCount
  {
     RandyIMGnow := currentFileIndex := (destination=-1) ? RandyIMGids[1] : RandyIMGids[maxFilesIndex]
     dummyTimerDelayiedImageDisplay(50)
     Return
  }

  theFirst := getSelectedFiles(1)
  theLast := getSelectedFiles("L")
  currentFileIndex := (destination=-1) ? theFirst : theLast
  FriendlyName := (destination=-1) ? "First" : "Last"
  dummyTimerDelayiedImageDisplay(50)
  showTOOLtip(FriendlyName " selected element index: " currentFileIndex "`n" markedSelectFile " total images selected")
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

navSelectedFilesNext() {
   navSelectedFiles(1)
}

navSelectedFilesPrev() {
   navSelectedFiles(1)
}

navSelectedFiles(direction) {
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   changeMcursor()

   If !markedSelectFile
   {
      getSelectedFiles(0, 1)
      If !markedSelectFile
      {
         changeMcursor("normal")
         CurrentSLD := backCurrentSLD
         showTOOLtip("No files are currently selected...")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }
   }

   startIndex := currentFileIndex
   newIndex := 0
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? currentFileIndex - A_Index : currentFileIndex + A_Index
        r := getIDimage(thisIndex)
        isSelected := resultedFilesList[thisIndex, 2]
        If (isSelected!=1 || !r || InStr(r, "||"))
           Continue

        If (skipDeadFiles=1)
        {
           If !FileRexists(r)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   CurrentSLD := backCurrentSLD
   changeMcursor("normal")
   If (!newIndex && direction=-1)
   {
      jumpToFilesSelBorderLast()
      Return
   } Else If (!newIndex && direction=1)
   {
      jumpToFilesSelBorderFirst()
      Return
   }

   currentFileIndex := (newIndex) ? newIndex : startIndex
   dummyTimerDelayiedImageDisplay(25)
}

searchNextIndex(direction, inLoop:=0) {
   testRegEx := SubStr(userSearchString, 1, 2)
   If (testRegEx!="\>" && userSearchString)
      thisSearchString := JEE_StrRegExLiteral(userSearchString)
   Else
      thisSearchString := SubStr(userSearchString, 3)

   If !thisSearchString
   {
      userSearchString := ""
      PanelSearchIndex()
      Return
   }

   friendly := (direction=-1) ? "previous" : "next"
   showTOOLtip("Searching " friendly " in index matching:`n" userSearchString)
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   originalIndex := startIndex := currentFileIndex
   If (inLoop=1)
      startIndex := (direction=1) ? 0 : maxFilesIndex

   newIndex := 0
   setImageLoading()
   Loop, % maxFilesIndex
   {
        thisIndex := (direction=-1) ? startIndex - A_Index : startIndex + A_Index
        r := getIDimage(thisIndex)
        ; If !InStr(r, userSearchString)
        If filterCoreString(r, 2, thisSearchString)
           Continue

        If (skipDeadFiles=1 && thumbsDisplaying!=1)
        {
           If !FileExist(r)
           {
              Continue
           } Else
           {
              newIndex := thisIndex
              Break
           }
        } Else
        {
           newIndex := thisIndex
           Break
        }
   }

   ResetImgLoadStatus()
   CurrentSLD := backCurrentSLD
   If (!newIndex && inLoop!=1)
   {
      searchNextIndex(direction, 1)
      Return
   }

   If (!newIndex && inLoop=1)
   {
      showTOOLtip("WARNING: No indexed file matched the search criteria:`n" userSearchString)
      userSearchString := ""
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SoundBeep , 900, 100
      Return
   }

   RemoveTooltip()
   currentFileIndex := newIndex ? newIndex : originalIndex
   dummyTimerDelayiedImageDisplay(25)
}

PanelMultiFileDelete() {
    Static lastInvoked := 1

    thisBtnHeight := createSettingsGUI(16, A_ThisFunc, 0)
    filesElected := getSelectedFiles(0, 1)
    btnWid := 120
    txtWid := 280
    If (PrefsLargeFonts=1)
    {
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    If (A_TickCount - lastInvoked>10500)
       move2recycler := 1 
    lastInvoked := A_TickCount
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please choose what to remove:
    Gui, Add, DropDownList, y+10 wp gTglMultiDelChoice AltSubmit Choose%userMultiDelChoice% vuserMultiDelChoice, Delete selected files|Remove file entries from the list|Do both: remove files and the index entries
    Gui, Add, Checkbox, y+10 gTglOptionMove2recycler Checked%move2recycler% vmove2recycler, Do NOT delete files permanently`nMove to recycle bin deleted files
    Gui, Font, Bold
    Gui, Add, Text, xs y+15, Selected entries: %filesElected%.
    Gui, Font, Normal
    If (userMultiDelChoice=2)
       GuiControl, Disable, move2recycler

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w%btnWid% gBTNactiveFileDel, &Delete active file only
    Gui, Add, Button, x+5 hp w95 gBTNmultiDel Default, &Proceed
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Delete files: " appTitle)
}

BTNactiveFileDel() {
   CloseWindow()
   DeleteActivePicture()
   getSelectedFiles(0, 1)
}

DeleteActivePicture() {
   DeletePicture("single")
}

BTNmultiDel() {
   CloseWindow("yes")
   Sleep, 50
   TglOptionMove2recycler()
   If (userMultiDelChoice=3 || userMultiDelChoice=1)
      r := multiFileDelete()
   Else r := 0

   If (userMultiDelChoice=3 || userMultiDelChoice=2) && (r=0)
   {
      If (userMultiDelChoice=3)
         Sleep, 500
      InListMultiEntriesRemover()
   }
}

TglMultiDelChoice() {
  TglOptionMove2recycler()
}

TglOptionMove2recycler() {
  GuiControlGet, move2recycler
  GuiControlGet, userMultiDelChoice

  INIaction(1, "userMultiDelChoice", "General")
  If (userMultiDelChoice=1 || userMultiDelChoice=3)
     GuiControl, SettingsGUIA: Enable, move2recycler
  Else
     GuiControl, SettingsGUIA: Disable, move2recycler
}

multiFileDelete() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected<2)
      Return

   If (filesElected>90)
   {
      msgInfos := "Are you sure you want to delete " filesElected " files?"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   showTOOLtip("Moving to recycle bin " filesElected " files, please wait...")
   prevMSGdisplay := A_TickCount
   destroyGDIfileCache()
   doStartLongOpDance()
   filesRemoved := abandonAll := failedFiles := 0
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Moving to recycle bin " filesRemoved "/" filesElected " files, please wait...", 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
      }

      countTFilez++
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      file2rem := StrReplace(file2rem, "||")
      Try FileSetAttrib, -R, %file2rem%
      Sleep, 0
      changeMcursor()
      If (move2recycler=1)
         FileRecycle, %file2rem%
      Else
         FileDelete, %file2rem%

      If !ErrorLevel
      {
         filesRemoved++
         resultedFilesList[thisFileIndex] := ["||" file2rem, 1]
         If StrLen(filesFilter)>1
            bckpResultedFilesList[filteredMap2mainList[thisFileIndex]] := ["||" file2rem, 1]
      } Else failedFiles++
   }

   If failedFiles
      someErrors := "`nFailed to delete " failedFiles " files..."


   watchFolderDetails := ""
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   If (abandonAll=1)
   {
      SoundBeep, 300, 100
      showTOOLtip("Operation aborted. " filesRemoved " out of " countTFilez " selected files deleted until now..." someErrors)
   } Else
   {
      SoundBeep, 900, 100
      showTOOLtip(filesRemoved " out of " countTFilez " selected files deleted" someErrors)
   }
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return abandonAll
}

DeletePicture(dummy:=0) {
  getSelectedFiles(0, 1)
  If (markedSelectFile>1 && dummy!="single")
  {
      PanelMultiFileDelete()
      Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(currentFileIndex)
  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir)
  If (askDeleteFiles=1 && dummy!="single") || (editingSelectionNow=1 && thumbsDisplaying!=1)
  {
     msgTimer := A_TickCount
     fakeWinCreator(37, A_ThisFunc, 1)
     msgResult := msgBoxWrapper(appTitle "panelu|: Confirmation", "Please confirm you want to delete this image file.`n`n" OutFileName "`n`n" OutDir "\", "&Remove index entry|&Delete|&Cancel", 3, "trash", "Permanently delete file, do not move to recycle bin", 0, "Always prompt before file delete`f`fNo longer prompt before file delete in this session`fNever prompt before file delete")
     If InStr(msgResult.btn, "Delete")
     {
        good2go := 1
     } Else If InStr(msgResult.btn, "remove index")
     {
        remCurrentEntry(0, 0)
        Return
     }

     If (A_TickCount - msgTimer < 550) && InStr(msgResult.btn, "Delete")
     {
        showTOOLtip("Operation aborted. User answered ""Yes"" too fast.")
        SetTimer, RemoveTooltip, % -msgDisplayTime
        good2go := 0
        Return
     }
  } Else good2go := 1

  If (msgResult.list>1 && good2go=1 && msgResult.check!=1)
  {
     askDeleteFiles := 0
     If (msgResult.list=3)
        INIaction(1, "askDeleteFiles", "General")
  }

  If (good2go!=1) || (imageLoading=1 && animGIFplaying!=1)
  {
     SetTimer, ResetImgLoadStatus, -50
     Return
  }

  Sleep, 2
  If (animGIFplaying=1)
  {
     DestroyGIFuWin()
     showTOOLtip("GIF animation stopped...")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  Sleep, 2
  if (!UserMemBMP && thumbsDisplaying!=1)
     UserMemBMP := cloneGDItoMem(A_ThisFunc, gdiBitmap)

  destroyGDIfileCache(0, 1)
  Try FileSetAttrib, -R, %file2rem%
  Sleep, 1

  If (msgResult.check=1)
     FileDelete, %file2rem%
  Else
     FileRecycle, %file2rem%

  If ErrorLevel
  {
     If (thumbsDisplaying=1 && !FileExist(file2rem))
     {
        remCurrentEntry(0, 0)
     } Else
     {
        showTOOLtip("ERROR: File already deleted or access denied...`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
     }
  } Else
  {
     resultedFilesList[currentFileIndex] := ["||" file2rem]
     If StrLen(filesFilter)>1
        bckpResultedFilesList[filteredMap2mainList[currentFileIndex]] := ["||" file2rem]

     If (msgResult.check=1)
        showTOOLtip("File permanently deleted...`n" OutFileName "`n" OutDir "\")
     Else
        showTOOLtip("File moved to recycle bin...`n" OutFileName "`n" OutDir "\")
  }

  watchFolderDetails := ""
  Sleep, 50
  SetTimer, RemoveTooltip, % -msgDisplayTime
  SetTimer, ResetImgLoadStatus, -50
  If (thumbsDisplaying=1)
     mainGdipWinThumbsGrid()
}

readRecentMultiRenameEntries() {
   entriesList := ""
   Loop, 35
   {
       IniRead, newEntry, % mainRecentsFile, RecentMultiRename, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (StrLen(newEntry)>1 && !InStr(entriesList, newEntry "`n"))
          entriesList .= newEntry "`n"
   }
   Return entriesList
}

PanelMultiRenameFiles() {
    Global UsrEditNewFileName
    If (maxFilesIndex<2)
       Return

    thisBtnHeight := createSettingsGUI(8, A_ThisFunc, 0)
    btnWid := 100
    txtWid := 390
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       txtWid := txtWid + 220
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "PreserveDateTimeOnSave", "General")
    getSelectedFiles(0, 1)
    listu := readRecentMultiRenameEntries()
    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 w%txtWid%, Selected files: %markedSelectFile%. Type a pattern to rename the files.
    Gui, Add, ComboBox, y+10 w%EditWid% gMultiRenameComboAction vUsrEditNewFileName, % listu
    Gui, Add, ListView, xp y+1 wp -multi r12 Grid vLViewOthers +hwndhLVmainu, #`nOriginal file name`nNew file name`nFolder
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Text, y+10, In case of file name collisions, you will be prompted.

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gcoreBatchMultiRenameFiles, &Rename files
    Gui, Add, Button, x+5 hp w%btnWid% gEraseMultiRenameHisto, Erase &history
    Gui, Add, Button, x+5 hp w85 gMultiRenameHelp, H&elp
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Rename multiple files: " appTitle)
}

MultiRenameHelp() {
    GuiControlGet, PreserveDateTimeOnSave
    INIaction(1, "PreserveDateTimeOnSave", "General")
    msgBoxWrapper(appTitle ": HELP", "File extensions remain unchanged regardless of the pattern used.`nFile rename patterns possible:`n`na) Whatever [pfdname] file prefix [this] or suffix is trim{X,Y} no surprise ([counter])`nThe token [this] is replaced with the file name, and [pfdname] is replaced with its parent folder name. Trim{X,Y} is a function usable only once in the pattern. X and Y designate how many letters to trim from the beginning and/or end of the original file name. Use [counter] to count files and [fDateM] to insert the files' dates.`n`nb) Replace string//with this one`nUse // to perform search and replace in file names. Begin with \> to use RegEx. Trim function and the tokens mentioned earlier can be used only after //.`n`nc) abcdefgh01234>>any string`nEvery enumerated character before >> will be replaced with a single character or a string specified after >>. The tokens from a) can be used after >>.`n`nd) any text`nFiles will be counted according to its containing folder. This is to avoid naming conflicts and applies only if [this], >> and // are not used.", -1, 0, 0)
}

MultiRenameComboAction() {
   If (A_GuiControlEvent="DoubleClick")
      coreBatchMultiRenameFiles()
   Else
      PopulateLVmultiRename()
}

decideMultiRename(ByRef OriginalNewFileName) {
  obju := []
  obju.renamingCount := 0
  obju.TrimmingMode := 0
  obju.rechecherRemplaceMode := 0
  obju.charsRemplaceMode := 0
  obju.regExRemplaceMode := 0
  obju.IndexModeCount := 0
  If (Trimmer(OriginalNewFileName)="[counter]")
     OriginalNewFileName := "[this] ([counter])"

  matchFoundPosA := RegExMatch(OriginalNewFileName, "i)trim\{..?.?\, ?..?.?\}", matchedStringu)
  If InStr(OriginalNewFileName, "//")
     strArr := StrSplit(OriginalNewFileName, "//")
  Else If InStr(OriginalNewFileName, "\\")
     strArr := StrSplit(OriginalNewFileName, "\\")
  Else If InStr(OriginalNewFileName, ">>")
     chrStrArr := StrSplit(OriginalNewFileName, ">>")
  Else If (!InStr(OriginalNewFileName, "[this]") && !matchedStringu)
     obju.renamingCount := 1

  If (InStr(OriginalNewFileName, "[counter]") && obju.renamingCount!=1)
     obju.IndexModeCount := 1

  If (IsObject(strArr) && obju.renamingCount!=1)
  {
     testRegEx := SubStr(strArr[1], 1, 2)
     If (testRegEx="\>")
     {
        obju.regExRemplaceMode := 1
        obju.strArrA := SubStr(strArr[1], 3)
        obju.strArrB := strArr[2]
     } Else
     {
        obju.strArrA := filterFileName(strArr[1])
        obju.strArrB := filterFileName(strArr[2])
     }

     If (obju.strArrA="")
        Return "err"
     ; If (obju.strArrB="" && StrLen(obju.strArr[2])>0)
     ;    Return "err"

     obju.rechecherRemplaceMode := 1 
  } Else If (IsObject(chrStrArr) && obju.renamingCount!=1)
  {
     obju.strArrA := filterFileName(chrStrArr[1])
     obju.strArrB := filterFileName(chrStrArr[2])
     If (obju.strArrA="")
        Return "err"

     obju.charsRemplaceMode := 1 
  } Else obju.newName := filterFileName(OriginalNewFileName)

  If (obju.renamingCount!=1)
  {
     obju.origMatchedStringu := matchedStringu
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, A_Space)
     matchedStringu := StrReplace(matchedStringu, .)
     matchedStringu := StrReplace(matchedStringu, "trim{")
     matchedStringu := StrReplace(matchedStringu, "}")
     If InStr(matchedStringu, ",")
     {
        trimuObj := StrSplit(matchedStringu, ",")
        obju.leftTrimu := trimuObj[1]
        obju.righttTrimu := trimuObj[2]
        obju.TrimmingMode := (isNumber(obju.leftTrimu) && isNumber(obju.righttTrimu)) ? 1 : 0
     }
     ; ToolTip, % obju.origMatchedStringu "`n" matchedStringu "`n" trimuObj[1] "==" trimuObj[2] , , , 2
  }

  Return obju
}

ChrReplace(string, chars, replacer) {
   If (chars!="")
      Loop, Parse, chars
           string := StrReplace(string, A_LoopField, replacer)

   Return string
}

decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez, parentFolderName, imgPath, obju) {
   If (obju.regExRemplaceMode=1)
      newFileName := RegExReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.rechecherRemplaceMode=1)
      newFileName := StrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (obju.charsRemplaceMode=1)
      newFileName := ChrReplace(fileNamuNoEXT, obju.strArrA, obju.strArrB)
   Else If (!InStr(OriginalNewFileName, "[this]") && obju.TrimmingMode!=1)
      newFileName := OriginalNewFileName " (" countFilez ")"
   Else ; If (obju.TrimmingMode=1)
      newFileName := OriginalNewFileName

   If (InStr(newFileName, "[pfdname]") && InStr(OriginalNewFileName, "[pfdname]"))
      newFileName := StrReplace(newFileName, "[pfdname]", parentFolderName)

   If (InStr(newFileName, "[counter]") && InStr(OriginalNewFileName, "[counter]") && obju.IndexModeCount=1)
      newFileName := StrReplace(newFileName, "[counter]", countFilez)

   If (InStr(newFileName, "[fDateM]") && InStr(OriginalNewFileName, "[fDateM]"))
   {
      FileGetTime, dateu, % imgPath, M
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateM]", dateu)
   }

   If (InStr(newFileName, "[fDateC]") && InStr(OriginalNewFileName, "[fDateC]"))
   {
      FileGetTime, dateu, % imgPath, C
      FormatTime, dateu, % dateu, yyyy-MM-dd
      newFileName := StrReplace(newFileName, "[fDateC]", dateu)
   }

   If (InStr(newFileName, "[this]") && InStr(OriginalNewFileName, "[this]"))
      newFileName := StrReplace(newFileName, "[this]", fileNamuNoEXT)

   If (obju.TrimmingMode=1 && obju.origMatchedStringu && obju.renamingCount!=1)
   {
      clampedL := clampInRange(obju.leftTrimu + 1, 0, StrLen(fileNamuNoEXT) - 1)
      trimmedFileName := SubStr(fileNamuNoEXT, clampedL)
      clampedR := clampInRange(obju.righttTrimu, 1, StrLen(trimmedFileName) - 1)
      If (obju.righttTrimu>0)
         trimmedFileName := SubStr(trimmedFileName, 1, StrLen(trimmedFileName) - clampedR)
      newFileName := StrReplace(newFileName, obju.origMatchedStringu, trimmedFileName)
      ; ToolTip, % clampedL "==" clampedR "`n" trimmedFileName "`n" newFileName , , , 2
   }
   ; ToolTip, % obju.TrimmingMode "==" obju.origMatchedStringu "==" obju.renamingCount , , , 2

   Return newFileName
}

PopulateLVmultiRename() {
  GuiControlGet, UsrEditNewFileName
  Gui, SettingsGUIA: ListView, LViewOthers
  LV_Delete()

  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
     Return

  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err")
     Return

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName
  
  loopzu := 0
  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"


     Loop, % maxFilesIndex
     {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         thisFileIndex := A_Index
         imgPath := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(imgPath, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, imgPath, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu

         If (file2save=imgPath || newFileName="" || newFileName=A_Space)
            Continue

         loopzu++
         LV_Add(A_Index, thisFileIndex, OutFileName, newFileName "." fileEXTu, OutDir "\")
         ; ToolTip, % A_Index , , , 2
         If (loopzu>=999)
            Break
     }
  }

  ; Loop, 3
  ;    LV_ModifyCol(A_Index, "AutoHdr Left")

}


coreBatchMultiRenameFiles() {
  Critical, on
  GuiControlGet, UsrEditNewFileName
  GuiControlGet, PreserveDateTimeOnSave

  INIaction(1, "PreserveDateTimeOnSave", "General")
  OriginalNewFileName := Trimmer(UsrEditNewFileName)
  If (OriginalNewFileName="[this]" || OriginalNewFileName="trim{" || OriginalNewFileName="\\" || OriginalNewFileName="//")
     Return

  objuTemp := decideMultiRename(OriginalNewFileName)
  If (objuTemp="err")
     Return

  If (objuTemp.newName)
     OriginalNewFileName := objuTemp.newName

  If (StrLen(OriginalNewFileName)>1)
  {
     filesElected := getSelectedFiles(0, 1)
     If (filesElected>100)
     {
        msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to rename the selected files.`n`nYou have selected " filesElected " files to be renamed...", 4, 0, "question")
        If (msgResult!="Yes")
           Return
     }

     CloseWindow("yes")
     showTOOLtip("Renaming " filesElected " files, please wait...`nPattern: " OriginalNewFileName)
     prevMSGdisplay := A_TickCount
     destroyGDIfileCache()
     RecentMultiRenamesManager(OriginalNewFileName)
     doStartLongOpDance()
     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("BEGIN TRANSACTION;")

     filezRenamed := countFilez := 0
     countTFilez := skippedFiles := failedFiles := overwrittenFiles := 0
     nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
     if (objuTemp.IndexModeCount=1)
        OutDirAsc := "a"

     Loop, % maxFilesIndex
     {
         wasError := 0
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue

         changeMcursor()
         thisFileIndex := A_Index
         file2rem := getIDimage(thisFileIndex)
         parentFolderName := zPlitPath(file2rem, 0, OutFileName, OutDir, fileNamuNoEXT, fileEXTu)
         countTFilez++
         If !FileExist(file2rem)
         {
            failedFiles++
            Continue
         }

         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            If (failedFiles>0)
               someErrors := "`n" failedFiles " files failed to rename"
            If (skippedFiles>0)
               someErrors .= "`n" skippedFiles " files were skipped"
            If (overwrittenFiles>0)
               someErrors .= "`n" overwrittenFiles " files were overwritten"

            showTOOLtip("Renaming " filezRenamed " / " filesElected " files, please wait...`nPattern: " OriginalNewFileName someErrors, 0, 0, countTFilez/filesElected)
            prevMSGdisplay := A_TickCount
            someErrors := ""
         }

         If (objuTemp.TrimmingMode!=1 && objuTemp.renamingCount=1)
         {
            OutDirAsc := (objuTemp.IndexModeCount=1) ? "a" : StringToASC(OutDir)
            Try countFilez%OutDirAsc%++
         }

         If (objuTemp.IndexModeCount=1)
            countFilez%OutDirAsc%++

         newFileName := decideFinalMultiRename(fileNamuNoEXT, OriginalNewFileName, countFilez%OutDirAsc%, parentFolderName, file2rem, objuTemp)
         file2save := OutDir "\" newFileName "." fileEXTu
         If (file2save=file2rem || newFileName="" || newFileName=A_Space)
         {
            skippedFiles++
            Continue
         }

         thisFileExists := 0
         If (PreserveDateTimeOnSave=1)
         {
            FileGetTime, originalMtime, %file2save%, M
            FileGetTime, originalCtime, %file2save%, C
         }

         If (FileExist(file2save) && !FolderExist(file2save))
         {
            thisFileExists := 1
            file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
            If !file2save
            {
               skippedFiles++
               Continue
            } Else If (file2save="abort")
            {
               abandonAll := 1
               Break
            }
         }

         If (thisFileExists=1)
         {
            If (performOverwrite=1 && objuTemp.renamingCount!=1)
            {
               overwrittenFiles++
               FileSetAttrib, -R, %file2save%
               Sleep, 1
               FileRecycle, %file2save%
               If ErrorLevel
                  wasError++
               Sleep, 1
            } Else If (performOverwrite!=2)
            {
               skippedFiles++
               Continue
            }
         }

         FileSetAttrib, -R, %file2rem%
         Sleep, 1
         FileMove, %file2rem%, %file2save%
         If ErrorLevel
         {
            failedFiles++
            wasError++
         } Else
         {
            If (originalMtime && PreserveDateTimeOnSave=1)
            {
               Sleep, 0
               FileSetTime, % originalMtime, % file2save, M
               FileSetTime, % originalCtime, % file2save, C
            } 

            filezRenamed++
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(OutFileName, OutDir, newFileName "." fileEXTu, OutDir)

            resultedFilesList[thisFileIndex] := [file2save, 1]
            If StrLen(filesFilter)>1
               bckpResultedFilesList[filteredMap2mainList[thisFileIndex]] := [file2save, 1]
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }
     }

     If (SLDtypeLoaded=3)
        activeSQLdb.Exec("COMMIT TRANSACTION;")

     If (failedFiles>0)
        someErrors := "`n" failedFiles " files failed to rename"
     If (skippedFiles>0)
        someErrors .= "`n" skippedFiles " files were skipped"
     If (overwrittenFiles>0)
        someErrors .= "`n" overwrittenFiles " files were overwritten"

     watchFolderDetails := ""
     If InStr(CurrentSLD, "\favourite-images-list.SLD")
        renewFavesListBasedOnIndexList()

     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(100)
     If (abandonAll=1)
        showTOOLtip("Operation aborted. " filezRenamed " out of " filesElected " selected files were renamed" someErrors)
     Else
        showTOOLtip("Finished renaming " filezRenamed " out of " filesElected " selected files" someErrors)
     SetTimer, ResetImgLoadStatus, -50
     SoundBeep, % (abandonAll=1) ? 300 : 900, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
  }
}

RecentMultiRenamesManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentMultiRenameEntries()
  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu, `n
  {
      If (A_LoopField=entry2add)
         Continue
      Else
         renewList .= A_LoopField "`n"
  }

  mainListu := entry2add "`n" renewList
  Loop, Parse, mainListu, `n
  {
      If (A_Index>35)
         Break

      If StrLen(A_LoopField)<3
         Continue
      countItemz++
      IniWrite, % A_LoopField, % mainRecentsFile, RecentMultiRename, E%countItemz%
  }
}

EraseMultiRenameHisto() {
  IniDelete, % mainRecentsFile, RecentMultiRename
  CloseWindow()
  Sleep, 1
  PanelRenameThisFile()
}

PanelOlderThanEraseThumbsCache() {
   If AnyWindowOpen
      Return

   fakeWinCreator(11, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Clear cached thumbnails: " appTitle, "Erase thumbnails cached older than... (in days)", "&Clean old cache|&Empty entire cache|C&ancel", 3, "trash", "&Always cache generated thumbnails", enableThumbsCaching, 0, "limit3 number -multi", 0)
   remCacheOldDays := Trimmer(msgResult.edit)
   If InStr(msgResult.btn, "old")
   {
      enableThumbsCaching := msgResult.check
      If !remCacheOldDays
         SetTimer, PanelOlderThanEraseThumbsCache, -150 ; allows for this execution line to cease peacefully ^_^ 
      Else
         EraseThumbsCache("daysITis", remCacheOldDays)
   } Else If InStr(msgResult.btn, "entire")
   {
      enableThumbsCaching := msgResult.check
      EraseThumbsCache()
   }
}

moveIndexEntry(newFileIndex, oldIndex) {
   tempA := resultedFilesList[oldIndex, 1]
   tempB := resultedFilesList[newFileIndex, 1]
   ; ToolTip, % tempA "`n" tempB "`n" oldIndex "===" newFileIndex , , , 2
   resultedFilesList[oldIndex, 1] := tempB
   resultedFilesList[newFileIndex, 1] := tempA
   If StrLen(filesFilter)>1
   {
      tempA := bckpResultedFilesList[filteredMap2mainList[oldIndex], 1]
      tempB := bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1]
      bckpResultedFilesList[filteredMap2mainList[oldIndex], 1] := tempB
      bckpResultedFilesList[filteredMap2mainList[newFileIndex], 1] := tempA
   }

   If InStr(CurrentSLD, "\favourite-images-list.SLD")
      renewFavesListBasedOnIndexList()

   ForceRefreshNowThumbsList()
   currentFileIndex := newFileIndex
   dummyTimerDelayiedImageDisplay(125)
}

PanelUpdateThisFileIndex() {
    Global newFileName
    If (currentFileIndex=0)
       Return

   imgPath := getIDimage(currentFileIndex)
   fakeWinCreator(21, A_ThisFunc, 1)
   friendlyIndex := (SLDtypeLoaded!=3 && maxFilesIndex>1) ? currentFileIndex "|" : ""
   If friendlyIndex
      msgInfos := "`nType a new index number before | to move this entry elsewhere in the list."

   msgResult := msgBoxWrapper("panelu|Update files list index entry: " appTitle, "Please type the new file path and name.`nCurrent index: " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) "." msgInfos, "&Update entry|&Erase entry|&Browse file|C&ancel", 1, "modify-entry", 0, 0, 0, "limit9050", friendlyIndex imgPath)
   If InStr(msgResult.btn, "update")
   {
      newFileName := Trimmer(msgResult.edit)
      If (newFileName=imgPath) || (newFileName=currentFileIndex "|" imgPath)
         Return

      If askAboutFileSave(" and the current index entry will be updated")
         Return

      If (posu := InStr(newFileName, "|"))
      {
         newFileIndex := SubStr(newFileName, 1, posu - 1)
         newFileIndex := StrReplace(newFileIndex, ".")
         newFileIndex := StrReplace(newFileIndex, ",")
         If !isNumber(newFileIndex)
            newFileIndex := 0
         Else
            newFileIndex := clampInRange(newFileIndex, 1, maxFilesIndex)
 
         If (newFileIndex=currentFileIndex || SLDtypeLoaded=3 || maxFilesIndex<2)
            newFileIndex := 0
 
         newFileName := SubStr(newFileName, posu + 1)
         newFileName := Trimmer(newFileName)
      }

      If (!newFileName && maxFilesIndex>1)
      {
         remCurrentEntry(0, 0)
         Return
      } Else If (newFileName!=imgPath && newFileName)
         r := UpdateIndexBTNaction(newFileName, currentFileIndex)

      If (!r && newFileName!=imgPath && newFileName)
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      } Else If (newFileIndex!=currentFileIndex && newFileIndex && SLDtypeLoaded!=3)
         moveIndexEntry(newFileIndex, currentFileIndex)

   } Else If (InStr(msgResult.btn, "erase") && maxFilesIndex>1)
   {
      If askAboutFileSave(" and the current index entry will be erased")
         Return

      remCurrentEntry(0, 0)
   } Else If InStr(msgResult.btn, "browse")
      BrowseReplaceIndexEntry()
}


PanelBrowseAudioAnnotation() {
    If (currentFileIndex=0 || SLDtypeLoaded!=3 || AnyWindowOpen)
       Return

   fakeWinCreator(38, A_ThisFunc, 1)
   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
   AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
   editFieldAudioFileu := AudioFileu ? AudioFileu : OutDir "\" OutNameNoExt ". WAV or MP3 or WMA"

   msgResult := msgBoxWrapper("panelu|Associate audio file with image: " appTitle, "Please type or browse the file path of an audio files to associate with the current image.", "&Update entry|&Browse file|&Disassociate|C&ancel", 1, "audio-file", 0, 0, 0, "limit9050", editFieldAudioFileu)
   If InStr(msgResult.btn, "update")
   {
      AudioFileu := Trimmer(msgResult.edit)
      If InStr(AudioFileu, OutDir "\" OutNameNoExt ".") || !FileExist(AudioFileu)
      {
         zPlitPath(AudioFileu, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
         showTOOLtip("ERROR: Incorrect file path or inexistent audio file:`n" OutFileName "`n" OutDir "\")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         SetTimer, PanelBrowseAudioAnnotation, -150
         Return
      }

      updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
   } Else If InStr(msgResult.btn, "disassociate")
   {
      updateSQLdbEntryCaption(imgPath, "", "imgAudio")
   } Else If InStr(msgResult.btn, "browse")
   {
      patternObj := {}
      patternObj["Audio files"] := "*.wav;*.mp3;*.wma"
      startPath := AudioFileu ? AudioFileu : imgPath
      AudioFileu := openFileDialogWrapper("O", "FileMustExist", startPath, "Browse sound file...", patternObj, chosenOption, 2)
      AudioFileu := Trimmer(AudioFileu)
      If StrLen(AudioFileu)>3
      {
         If AnyWindowOpen
            CloseWindow("yes")
         Sleep, 25
         updateSQLdbEntryCaption(imgPath, AudioFileu, "imgAudio")
      }
      SetTimer, PanelBrowseAudioAnnotation, -150
   }
}

BrowseReplaceIndexEntry() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   ; pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn3 ")"
   ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"

   patternObj := {}
   patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
   patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4
   imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Replace index entry...", patternObj, chosenOption, 2)
   imgPath := Trimmer(imgPath)
   If !imgPath
   {
      SetTimer, PanelUpdateThisFileIndex, -150
      Return "cancel"
   }

   If AnyWindowOpen
      CloseWindow("yes")
   Sleep, 25
   If StrLen(imgPath)>3
   {
      zPlitPath(imgPath, 0, OutFileName, SelectedDir)
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      If askAboutFileSave(" and the current index entry will be updated")
         Return

      r := UpdateIndexBTNaction(imgPath, currentFileIndex)
      If !r
      {
         Sleep, 150
         SetTimer, PanelUpdateThisFileIndex, -150
      }
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

SingularRenameFile() {
   PanelRenameThisFile("single")
}

askAboutFileCollision(srcFile, destFile, allowSkip, doLastOption, forceOption, ByRef performOverwrite) {
   Static lastOption, useLastOption := 0

   If (doLastOption=3)
   {
      lastOption := useLastOption := 0
      Return
   }

   zPlitPath(srcFile, 0, sOutFileName, sOutDir)
   zPlitPath(destFile, 0, dOutFileName, dOutDir, dfileNamuNoEXT, dFileExt)
   If (doLastOption=2)
      useLastOption := 1
   Else If (doLastOption=1)
      useLastOption := 0

   skipBtn := (allowSkip=1) ? "&Skip file|" : ""
   checkBtn := (allowSkip=1) ? "&Do not prompt again, apply the same option for all the subsequent conflicts" : ""
   If (useLastOption=1 && lastOption)
   {
      msgResult := lastOption
   } Else If !forceOption
   {
      FileGetSize, destFileSizu, % destFile, K
      FileGetSize, srcFileSizu, % srcFile, K
      FileGetTime, srcFileDateM, % srcFile, M
      FileGetTime, destFileDateM, % destFile, M
      FormatTime, srcFileDateM, % srcFileDateM, dddd, d MMMM yyyy, HH:mm
      FormatTime, destFileDateM, % destFileDateM, dddd, d MMMM yyyy, HH:mm
      msgResult := msgBoxWrapper(appTitle ": File name conflict", "SOURCE FILE:`n" sOutFileName "`n" groupDigits(srcFileSizu) " Kilobytes (" srcFileDateM ")`n" sOutDir "\`n`nFile name conflict. Do you want to overwrite the destination file?`n`nDESTINATION FILE:`n" dOutFileName "`n" groupDigits(destFileSizu) " Kilobytes (" destFileDateM ")`n" dOutDir "\", "&Overwrite|&Auto-rename|" skipBtn "C&ancel", 2, "question", checkBtn, doLastOption)
   }

   If IsObject(msgResult)
      useLastOption := msgResult.check

   If (forceOption=1)
      msgResult := "skip"
   Else If (forceOption=2)
      msgResult := "auto-rename"
   Else If (forceOption=3)
      msgResult := "overwrite"

   performOverwrite := 0
   msgR := IsObject(msgResult) ? msgResult.btn : msgResult
   If InStr(msgR, "rename")
   {
      performOverwrite := 2
      Loop
      {
          r := dOutDir "\" dfileNamuNoEXT " [" A_Index "]." dFileExt
          If !FileExist(r)
             Break
      } Until (A_Index>9500)
   } Else If InStr(msgR, "overwrite")
   {
      performOverwrite := 1
      r := destFile
   } Else If InStr(msgR, "skip")
      r := ""
   Else If InStr(msgR, "cancel")
      r := "abort"
   Else
      lastOption := r := msgR := ""

   lastOption := (r="abort") ? "" : msgR
   Return r
}

PanelRenameThisFile(dummy:=0) {
    Global newFileName
    Static doLastOption := 0
    If (currentFileIndex=0)
       Return

    getSelectedFiles(0, 1)
    If (markedSelectFile>1 && dummy!="single")
    {
       PanelMultiRenameFiles()
       Return
    }

    Sleep, 2
    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OutFileName, OutDir)
    If !FileExist(file2rem)
    {
       showTOOLtip("ERROR: File not found or access denied...`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Sleep, 900
       PanelUpdateThisFileIndex()
       Return
    }

   fakeWinCreator(7, A_ThisFunc, 1)
   undoBtn := FileExist(lastRenameUndo[2]) ? "&Undo previous|" : ""
   msgResult := msgBoxWrapper("panelu|Rename file: " appTitle, "File location:`n" OutDir "\`n`nPlease type the new file name...", "&Rename file|" undoBtn "&Modify index entry|C&ancel", 1, "modify-file", "On file name collision, use previously given answer", doLastOption, 0, "limit9050", OutFileName)
   If InStr(msgResult.btn, "Rename")
   {
      doLastOption := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      file2rem := getIDimage(currentFileIndex)
      zPlitPath(file2rem, 0, OutFileName, OutDir)
      If ((Trimmer(OutFileName)=newFileName) || !newFileName)
         Return

      If askAboutFileSave(" and the current file will be renamed and reloaded")
         Return

      r := RenameBTNaction(Trimmer(msgResult.edit), file2rem, doLastOption + 1)
      If !r 
      {
         Sleep, 100
         PanelRenameThisFile(dummy)
      } Else CreateGuiButton("Undo rename,,undoFileRenameAction", 0, msgDisplayTime//1.5 + 500)
   } Else If InStr(msgResult.btn, "modify")
      PanelUpdateThisFileIndex()
    Else If InStr(msgResult.btn, "undo")
      undoFileRenameAction()
}

PanelSetThumbCols() {
   fakeWinCreator(40, A_ThisFunc, 1)
   dropListu := "Wide (1.81)`fTall (0.48)`fSquare (1.00)`f`f"
   sizu := (PrefsLargeFonts=1) ? 800 : 450
   msgResult := msgBoxWrapper("panelu|Set thumbnails columns: " appTitle, "Please type how many columns you want for the thumbnails list. You can adjust this number with the -/+ keys in the viewport.`n`nFor the provided value to take effect, please deactivate «dynamic columns» option.`n`nBelow, you can also set their aspect ratio.", "&Apply|&Cancel", 1, 0, "Dynamic number of thumbnail columns", dynamicThumbsColumns, dropListu, "limit9050 number", thumbsColumns, 2, sizu)
   If InStr(msgResult.btn, "apply")
   {
      thumbsAratio := msgResult.list
      dynamicThumbsColumns := msgResult.check
      thumbsColumns := Trimmer(msgResult.edit)
      thumbsColumns := clampInRange(thumbsColumns, 2, 100)
      recalculateThumbsSizes()
      ForceRefreshNowThumbsList()
      IniAction(1, "dynamicThumbsColumns", "General")
      IniAction(1, "thumbsColumns", "General")
      dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSetSystemCores() {
   EnvGet, thisSystemCores, NUMBER_OF_PROCESSORS
   fakeWinCreator(41, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Multi-threading options: " appTitle, "Please specify the number of threads to use when generating thumbnails or batch processing files. Maximum allowed threads on this system is " thisSystemCores ".`n`nAfter changing this value, a restart of QPV might be necessary.", "&Apply|&Cancel", 1, 0, "Allow multi-threaded processing", allowMultiCoreMode, 0, "limit2 number", userMultiCoresLimit)
   If InStr(msgResult.btn, "apply")
   {
      allowMultiCoreMode := msgResult.check
      userMultiCoresLimit := Trimmer(msgResult.edit)
      userMultiCoresLimit := clampInRange(userMultiCoresLimit, 2, thisSystemCores)
      INIaction(1, "allowMultiCoreMode", "General")
      INIaction(1, "userMultiCoresLimit", "General")
      realSystemCores := userMultiCoresLimit
      If (thumbsDisplaying=1 && thumbnailsListMode!=1 && multiCoreThumbsInitGood="n")
         initAHKhThumbThreads()
      ; dummyTimerDelayiedImageDisplay(50)
   }
}

PanelSaveSlideShowu() {
    Global usePrevSaveFolder := 0, userDesiredSlideFMT := 1

    If (maxFilesIndex<3)
    {
       showTOOLtip("WARNING: Insufficient image files are currently indexed...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    thisBtnHeight := createSettingsGUI(36, A_ThisFunc, 0)
    btnWid := 100
    txtWid := 360
    EditWid := 360
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "prevFileSavePath", "General")
    userDesiredSlideFMT := (SLDtypeLoaded=3) ? 2 : 1
    If (SLDtypeLoaded=3)
       SLDcacheFilesList := 1

    Gui, Add, Text, x15 y15 Section, Slideshow format:
    Gui, Add, DropDownList, xs y+5 w%EditWid% gUItoggleSLDformat AltSubmit Choose%userDesiredSlideFMT% vuserDesiredSlideFMT, .SLD - Plain-text format|.SLDB - SQLite Database format (file details cached)
    Gui, Add, Checkbox, xs y+10 Checked%SLDcacheFilesList% vSLDcacheFilesList, Cache files list (ensures rapid slideshow loading)`nIf this is left unchecked, only the dynamic folders list will be saved.
    If (SLDtypeLoaded=3)
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList

    Gui, Add, Checkbox, xs y+10 Checked%ForceRegenStaticFolders% vForceRegenStaticFolders, Regenerate static folders list`nThe static folders list enables partial files list later updates
    Gui, Add, Text, xs y+10 w%EditWid%, Regardless of the chosen format, the current %appTitle% settings will be stored.
    If (SLDtypeLoaded=2)
       infoThisSLD := "Currently opened: plain-text slideshow`n" CurrentSLD
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "Currently opened: SQLite slideshow database`nMost actions applied on the files index are automatically saved. Under rare circumstances resaving is required.`n" CurrentSLD
    Else
       infoThisSLD := "No slideshow file currently opened."

    Gui, Add, Text, xs y+20 w%EditWid%, % infoThisSLD
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBTNsaveSlideshowPanel, &Save slideshow
    Gui, Add, Button, x+5 hp wp gPanelDynamicFolderzWindow, &Dynamic folders
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save indexed files list: " appTitle)
}

UItoggleSLDformat() {
    GuiControlGet, userDesiredSlideFMT
    If (userDesiredSlideFMT=1)
    {
       GuiControl, SettingsGUIA: Enable, SLDcacheFilesList
    } Else
    {
       SLDcacheFilesList := 1
       GuiControl, SettingsGUIA: Disable, SLDcacheFilesList
       GuiControl, , SLDcacheFilesList, 1
    }
}

BTNsaveSlideshowPanel() {
    GuiControlGet, SLDcacheFilesList
    GuiControlGet, userDesiredSlideFMT
    GuiControlGet, ForceRegenStaticFolders
    If (userDesiredSlideFMT=1)
       SaveFilesList()
    Else
       SaveDBfilesList()
}

FolderExist(filePath) {
   If StrLen(filePath)<4
      Return

   Return InStr(FileExist(filePath), "D")
}

PanelSaveImg() {
    Global userDestinationFolder, editF5, UserCropOnSave, usePrevSaveFolder := 0

    If (thumbsDisplaying=1)
    {
       PanelSaveSlideShowu()
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    If (!useGdiBitmap() || !imgPath)
    {
       showTOOLtip("WARNING: No image file is currently loaded...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    thisBtnHeight := createSettingsGUI(35, A_ThisFunc, 0)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 80
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "userDesireWriteFMT", "General")
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)

    INIaction(0, "prevFileSavePath", "General")
    INIaction(0, "usePrevSaveFolder", "General")
    INIaction(0, "PreserveDateTimeOnSave", "General")
    INIaction(0, "userJpegQuality", "General")
    userJpegQuality := clampInRange(userJpegQuality, 1, 100)

    ; Gui, Add, Text,, Default destination format:
    ; Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    entriesList := StrReplace(recentOpenedFolders(), "`n", "|")
    delim := InStr(entriesList, prevFileSavePath "|") ? "|" : ""
    entriesList := StrReplace(entriesList, prevFileSavePath delim, prevFileSavePath "||")
    If StrLen(entriesList)<4
    {
       usePrevSaveFolder := 0
       GuiControl, Disable, usePrevSaveFolder
    } Else If !InStr(entriesList, "||")
       entriesList .= "|"

    UserCropOnSave := 0
    Gui, Add, Checkbox, x15 y15 Section Checked%UserCropOnSave% vUserCropOnSave, C&rop image to selected area on save
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+7 Section gTglUsePrevSaveFoderu Checked%usePrevSaveFolder% vusePrevSaveFolder, &Open file dialog in a previous location
    Gui, Add, DropDownList, xp+15 y+7 wp+135 vuserDestinationFolder, % entriesList
    Gui, Add, Text, xs y+15, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Text, xs+15 y+7, This applies only for JPG, JP2, J2K, JXR and WEBP files.
    If (editingSelectionNow!=1 || testSelectOutsideImgEntirely(useGdiBitmap()))
       GuiControl, Disable, UserCropOnSave

    If !usePrevSaveFolder
       GuiControl, Disable, userDestinationFolder

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% Default gBTNsaveImgPanel, &Save image
    Gui, Add, Button, x+5 h%thisBtnHeight% w%btnWid% gBTNsaveBrowseImgPanel, &Browse / Save as
    Gui, Add, Button, x+5 hp w%btnWid% gBtnCopyImageClip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Save image file: " appTitle)
}

TglUsePrevSaveFoderu() {
   GuiControlGet, usePrevSaveFolder
   If !usePrevSaveFolder
      GuiControl, Disable, userDestinationFolder
   Else
      GuiControl, Enable, userDestinationFolder

   INIaction(1, "usePrevSaveFolder", "General")
}

BTNsaveImgPanel() {
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If InStr(imgPath, "\temporary memory object\")
      SaveClipboardImage(userDestinationFolder, UserCropOnSave)
   Else
      SaveClipboardImage("current", UserCropOnSave, 1)

   If (minimizeMemUsage=1)
   {
      HardResetImageView()
      SetTimer, RefreshImageFileAction, -125
   }
}

BTNsaveBrowseImgPanel() {
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, UserCropOnSave
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality
   GuiControlGet, userDestinationFolder
   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "usePrevSaveFolder", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   imgPath := getIDimage(currentFileIndex)
   If (usePrevSaveFolder=1 || InStr(imgPath, "\temporary memory object\"))
      SaveClipboardImage(userDestinationFolder, UserCropOnSave)
   Else
      SaveClipboardImage("current", UserCropOnSave)
}

BtnCopyImageClip() {
   GuiControlGet, usePrevSaveFolder
   GuiControlGet, userJpegQuality
   GuiControlGet, PreserveDateTimeOnSave
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userJpegQuality", "General")
   CloseWindow()
   Sleep, 5
   CopyImage2clip()
}

fakeWinCreator(idWin, thisCaller, allowReopen) {
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    If (mouseToolTipWinCreated=1)
       mouseTurnOFFtooltip()

    AnyWindowOpen := idWin
    interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
    prevOpenedWindow := []
    prevOpenedWindow := [AnyWindowOpen, thisCaller, allowReopen, editingSelectionNow, 1]
    addJournalEntry("Window opened: " thisCaller "() [ " AnyWindowOpen " ]")
    ; hSetWinGui := PVhwnd
}

PanelSearchIndex() {
   Static SearchedStringz
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<3)
   {
      showTOOLtip("WARNING: Insufficient files to search for...")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If AnyWindowOpen
      Return
   
   fakeWinCreator(29, A_ThisFunc, 1)
   SearchedStringz := Trimmer(SearchedStringz) "`f"
   thisSearchString := Trimmer(userSearchString) ? userSearchString : Chr(160)
   msgResult := msgBoxWrapper("panelu|Search indexed files: " appTitle, "Please type the string to search for in the indexed files. You can use | between keywords as the OR operator, or begin the string with \> to use Regular Expressions.", "&Search next [F3]|&Filter list panel|C&ancel", 1, "search", "&Highlight matching files in list view mode", markSearchMatches, SearchedStringz thisSearchString "`f`f", nullEdit,nullEdit, 1)
   If InStr(msgResult.btn, "filter list")
   {
      OpenFilterPanelBTNaction()
   } Else If InStr(msgResult.btn, "search")
   {
      If askAboutFileSave(" and the files index search will be performed")
         Return

      markSearchMatches := msgResult.check
      INIaction(1, "markSearchMatches", "General")
      userSearchString := Trimmer(msgResult.list)
      userSearchString := StrReplace(userSearchString, "||", "|")
      userSearchString := Trimmer(userSearchString, "|")
      If userSearchString
      {
         SearchedStringz .= userSearchString "`f"
         Sort, SearchedStringz, UD`f
         searchNextIndex(1)
      } Else userSearchString := ""
   }
}

OpenFilterPanelBTNaction() {
   userSearchString := ""
   CloseWindow()
   PanelEnableFilesFilter()
}

PanelEditImgCaption(dummy:=0) {
    Global newFileName, UsrStoreCaptionDB := 1
    If (currentFileIndex=0)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If !FileExist(imgPath)
    {
       showTOOLtip("ERROR: File not found or access denied...`n" OutFileName "`n" OutDir)
       SetTimer, RemoveTooltip, % -msgDisplayTime
       SoundBeep, 300, 100
       Return
    }

    INIaction(0, "UsrStoreCaptionDB", "General")
    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")
    Else
       UsrStoreCaptionDB := 0

    If !textFileContent
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       Try FileRead, textFileContent, % textFile
    }

    thisBtnHeight := createSettingsGUI(22, A_ThisFunc)
    btnWid := 100
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 230
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Gui, Add, Text, x15 y15 w%txtWid%, Please type the caption or annotation you want associated with this image file...
    Gui, Add, Edit, y+7 w%EditWid% r15 limit1024 -wantTab vnewFileName, % textFileContent
    Gui, Add, Checkbox, y+7 Checked%UsrStoreCaptionDB% vUsrStoreCaptionDB, Store image caption into the SQL slideshow database
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w90 Default gSaveCaptionBTNaction, &Save
    Gui, Add, Button, x+5 hp wp gDeleteCaptionBTNaction, &Delete
    Gui, Add, Button, x+5 hp wp gBTNhelpCaptions, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    If (SLDtypeLoaded!=3)
       GuiControl, Disable, UsrStoreCaptionDB

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Edit image caption: " appTitle)
}

BTNhelpCaptions() {
    msgBoxWrapper(appTitle ": HELP", "Image file captions [annotations] are stored in .TXT files [as plain text], where the image file is located, under the same file name.`n`nFor example:`nC:\example-folder\image-file.jpg`nC:\example-folder\image-file.txt`n`nIf you are using SQLite slideshow databases, you have the option to store the captions in the database, not as individual files for each image. However, please keep in mind, when the files list is renewed or regenerated, the captions or audio annotations might get lost.", -1, 0, 0)
}

DeleteCaptionBTNaction() {
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    CloseWindow("yes")
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"
    If FileExist(textFile)
       mustShowError := 1

    Try FileDelete, % textFile
    Catch wasError
          Sleep, 2

    If (mustShowError && wasError)
    {
       showTOOLtip("ERROR: Unable to delete text file:`n" OutNameNoExt ".txt`n" OutDir "\")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
    If (SLDtypeLoaded=3)
       updateSQLdbEntryCaption(imgPath, "", "imgCaption")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

SaveCaptionBTNaction() {
    GuiControlGet, newFileName
    GuiControlGet, UsrStoreCaptionDB
    INIaction(1, "UsrStoreCaptionDB", "General")
    newFileName := Trimmer(newFileName)
    If !newFileName
       Return

    CloseWindow("yes")
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3 && UsrStoreCaptionDB=1)
    {
       updateSQLdbEntryCaption(imgPath, newFileName, "imgCaption")
    } Else
    {
       textFile := OutDir "\" OutNameNoExt ".txt"
       FileDelete, % textFile
       Sleep, 2
       Try FileAppend, % newFileName, % textFile, UTF-16
       Catch wasError
             msgBoxWrapper(appTitle ": ERROR", "Failed to write text file... Permission denied.`n" OutNameNoExt ".txt`n" OutDir "\", 0, 0, "error")
    }

    showImgAnnotations := 1
    If (showImgAnnotations!=1)
       INIaction(1, "showImgAnnotations", "General")

    If (thumbsDisplaying!=1)
       SetTimer, dummyRefreshImgSelectionWindow, -50
}

InvokeUpdateIndexPanelBTNaction() {
   CloseWindow()
   Sleep, 1
   PanelUpdateThisFileIndex()
}

filterFileName(string) {
  Static forbiddenCharsREGex := "\<|\>|\:|\""|\/|\\|\||\?|\*"
  Static forbiddenNames := "CON|PRN|AUX|NUL|COM1|COM2|COM3|COM4|COM5|COM6|COM7|COM8|COM9|LPT1|LPT2|LPT3|LPT4|LPT5|LPT6|LPT7|LPT8|LPT9"
  string := Trimmer(string)
  string := StrReplace(string, "/", "\")
  string := RegExReplace(string, "\\{2,}", "\")
  If RegExMatch(string, forbiddenCharsREGex)
     Return

  Loop, Parse, forbiddenNames, |
  {
     If (A_LoopField=string)
        Return
  }

  Return string
}

undoFileRenameAction() {
   RenameBTNaction(lastRenameUndo[1], lastRenameUndo[2], 1)
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")
   lastRenameUndo := []
}

RenameBTNaction(newFileName, file2rem, doLastOption) {
  newFileName := filterFileName(newFileName)
  If (StrLen(newFileName)>3)
  {
     zPlitPath(file2rem, 0, OutFileName, OutDir)
     If (Trimmer(OutFileName)=newFileName)
        Return 1

     If !FileExist(file2rem)
        Return 0

     destroyGDIfileCache()
     FileGetTime, originalMtime, % file2rem, M
     FileGetTime, originalCtime, % file2rem, C
     file2save := OutDir "\" newFileName
     thisFileExists := 0
     If (FileExist(file2save) && !FolderExist(file2save))
     {
        thisFileExists := 1
        file2save := askAboutFileCollision(file2rem, file2save, 0, doLastOption + 1, 0, performOverwrite)
     }

     If (file2save="abort" || !file2save)
     {
        SetTimer, SingularRenameFile, -150
        Return
     }

     If (thisFileExists=1)
     {
        If (performOverwrite=1)
        {
           FileSetAttrib, -R, %file2save%
           Sleep, 2
           FileRecycle, %file2save%
           Sleep, 2
        } Else If (performOverwrite!=2)
        {
           showTOOLtip("Rename operation abandoned.`nA file with the provided name already exists.`nFile name conflict...`n" newFileName)
           SetTimer, RemoveTooltip, % -msgDisplayTime
           Return 0
        }
     }

     FileSetAttrib, -R, %file2rem%
     Sleep, 2
     FileMove, %file2rem%, %file2save%, 1
     If ErrorLevel
     {
        showTOOLtip("ERROR: Access denied... The file could not be renamed.`n" OutFileName "`n" OutDir "\")
        SoundBeep, 300, 100
        SetTimer, RemoveTooltip, % -msgDisplayTime
        Return 0
     } Else
     {
        If originalMtime
        {
           Sleep, 0
           FileSetTime, % originalMtime, % file2save, M
           FileSetTime, % originalCtime, % file2save, C
        }


        lastRenameUndo := []
        lastRenameUndo := [OutFileName, file2save]
        If (SLDtypeLoaded=3)
           updateSQLdbEntry(OutFileName, OutDir, newFileName, OutDir)
        resultedFilesList[currentFileIndex, 1] := file2save
        If StrLen(filesFilter)>1
           bckpResultedFilesList[filteredMap2mainList[currentFileIndex]] := [file2save]

        If InStr(CurrentSLD, "\favourite-images-list.SLD")
           renewFavesListBasedOnIndexList()

        watchFolderDetails := ""
        dummyTimerDelayiedImageDisplay(50)
        showTOOLtip("File renamed succesfully to:`n" newFileName "`n" OutDir "\")
        Return 1
     }
  } Else Return 0
}

UpdateIndexBTNaction(newFileName, whichIndex) {
  ; GuiControlGet, newFileName
  newFileName := Trimmer(newFileName)
  newFileName := StrReplace(newFileName, "/", "\")
  newFileName := RegExReplace(newFileName, "\\{2,}", "\")
  allGood := 1
  If !RegExMatch(newFileName, "i)^(.\:\\.)")
     allGood := 0

  strArr := StrSplit(newFileName, "\")
  Loop, % strArr.Count()
  {
      testThis := filterFileName(strArr[A_Index])
      If (!testThis && A_Index>1)
         allGood := 0
  }

  If !RegExMatch(newFileName, RegExFilesPattern)
     allGood := 0

  If !FileRexists(newFileName)
  {
     If (allGood=1)
        fileNotFound := 1
     allGood := 0
  }

  If (StrLen(newFileName)>2 && allGood=1)
  {
     oldFileName := resultedFilesList[whichIndex, 1]
     resultedFilesList[whichIndex, 1] := newFileName
     resultedFilesList[whichIndex, 4] := 1
     If (SLDtypeLoaded=3)
     {
        zPlitPath(oldFileName, 0, OutFileName, OutDir)
        zPlitPath(newFileName, 0, newOutFileName, newOutDir)
        updateSQLdbEntry(OutFileName, OutDir, newOutFileName, newOutDir)
     }
     If StrLen(filesFilter)>1
        bckpResultedFilesList[filteredMap2mainList[whichIndex]] := [OutDir "\" newFileName]

     If InStr(CurrentSLD, "\favourite-images-list.SLD")
        renewFavesListBasedOnIndexList()

     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(150)
     showTOOLtip("File index entry updated")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return 1
  } Else If (StrLen(newFileName)>2)
  {
     SoundBeep, 300, 100
     If (fileNotFound=1)
        showTOOLtip("ERROR: The file index entry was not updated.`nFile not found or access denied...`n" newFileName)
     Else
        showTOOLtip("ERROR: The file index entry was not updated.`nIncorrect file name provided:`n" newFileName)
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return 0
  }
}

BtnBrowseAlphaMaskFile() {
    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O", "FileMustExist", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3)

    If !imgPath
       Return
 
    PasteInPlaceAlphaFile := imgPath
    GuiControl, SettingsGUIA:, PasteInPlaceAlphaFile, % imgPath
    SetTimer, updateUIpastePanel, -50
}

updateUIpastePanel(actionu:=0) {
    Static lastInvoked := 1

    GuiControlGet, PasteInPlaceAdaptMode
    GuiControlGet, PasteInPlaceAlphaChannelFile
    GuiControlGet, PasteInPlaceCentered
    GuiControlGet, PasteInPlaceOpacity
    GuiControlGet, PasteInPlaceCropSel
    GuiControlGet, PasteInPlaceQuality
    GuiControlGet, PasteInPlaceOrientation
    GuiControlGet, PasteInPlaceApplyColorFX
    GuiControlGet, PasteInPlaceBlurAmount
    GuiControlGet, PasteInPlaceLivePreview
    GuiControlGet, PasteInPlaceHue
    GuiControlGet, PasteInPlaceSaturation
    GuiControlGet, PasteInPlaceLight
    GuiControlGet, PasteInPlaceGamma
    GuiControlGet, PasteInPlaceAlphaMaskClrA
    GuiControlGet, PasteInPlaceAlphaMaskClrB
    GuiControlGet, PasteInPlaceAlphaMaskMode
    GuiControlGet, PasteInPlaceAlphaFile
    GuiControlGet, alphaMaskReplaceMode
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientSigma
    GuiControlGet, FillAreaGradientBlend
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaColorReversed
    GuiControlGet, FillAreaBlendMode
    GuiControlGet, FillAreaGlassy
    If (AnyWindowOpen=31)
       GuiControlGet, PasteInPlaceEraseInitial

    If (coreDesiredPixFmt="0x21808")
    {
       PasteInPlaceAlphaMaskMode := 1
       GuiControl, Disable, PasteInPlaceAlphaMaskMode
       GuiControl, Choose, PasteInPlaceAlphaMaskMode, 1
    }

    thisOpacity := Round((PasteInPlaceOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoPasteOpacity, Image opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoPasteHue, Hue: %PasteInPlaceHue%°
    GuiControl, SettingsGUIA:, infoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    GuiControl, SettingsGUIA:, infoPasteLight, Brightness: %PasteInPlaceLight%`%
    GuiControl, SettingsGUIA:, infoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    GuiControl, SettingsGUIA:, infoPasteBlur, Image blur amount: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientSigma%`%
    GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientBlend%`%
    GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
    If (PasteInPlaceAlphaMaskMode=5)
    {
       thisAlphaBlur := Round((FillAreaGradientScale - 1)/305 * 255)
       GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Blur amount: %thisAlphaBlur%
    } Else GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%

    If (PasteInPlaceAlphaMaskMode>=5 || PasteInPlaceAlphaMaskMode=1)
       GuiControl, SettingsGUIA: Disable, FillAreaGradientWrapped
    Else
       GuiControl, SettingsGUIA: Enable, FillAreaGradientWrapped

    If (FillAreaBlendMode>1)
       GuiControl, SettingsGUIA: Enable, FillAreaGlassy
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaGlassy

    actu2 := (PasteInPlaceApplyColorFX=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu2, PasteInPlaceLight
    GuiControl, % actu2, PasteInPlaceGamma
    GuiControl, % actu2, PasteInPlaceHue
    GuiControl, % actu2, PasteInPlaceSaturation
    GuiControl, % actu2, infoPasteLight
    GuiControl, % actu2, infoPasteGamma
    GuiControl, % actu2, infoPasteHue
    GuiControl, % actu2, infoPasteSat

    actu := (PasteInPlaceAlphaMaskMode>1 && PasteInPlaceAlphaMaskMode!=5 && PasteInPlaceAlphaMaskMode!=6) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, FillAreaGradientSigma
    GuiControl, % actu, FillAreaGradientBlend
    GuiControl, % actu, FillAreaColorReversed

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientScale

    actu := (PasteInPlaceAlphaMaskMode=5) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, PasteInPlaceAlphaFile
    GuiControl, % actu, PasteInPlaceAlphaChannelFile
    GuiControl, % actu, btnFldr
    GuiControl, % actu, infoAlphaFile

    If (PasteInPlaceAlphaMaskMode=6)
    {
       brLvl := PasteInPlaceAlphaMaskClrA
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255, 3)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Blur amount: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Curve tension: %contrLvl%
    } Else If (PasteInPlaceAlphaMaskMode=5)
    {
       brLvl := Round(PasteInPlaceAlphaMaskClrA/255*510-255)
       contrLvl := Round(PasteInPlaceAlphaMaskClrB/255*100)
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Brightness: %brLvl%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Contrast: %contrLvl%
    } Else
    {
       GuiControl, SettingsGUIA:, infoPasteAlphaClrA, Intensity A: %PasteInPlaceAlphaMaskClrA%
       GuiControl, SettingsGUIA:, infoPasteAlphaClrB, Intensity B: %PasteInPlaceAlphaMaskClrB%
    }

    actu := (PasteInPlaceAlphaMaskMode>1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
    GuiControl, % actu, alphaMaskReplaceMode
    GuiControl, % actu, FillAreaColorReversed
    GuiControl, % actu, PasteInPlaceAlphaMaskClrA
    GuiControl, % actu, PasteInPlaceAlphaMaskClrB
    GuiControl, % actu, infoPasteAlphaClrA
    GuiControl, % actu, infoPasteAlphaClrB
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientAngle

    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 55)
    {
       livePreviewsImageEditing(1)
       lastInvoked := A_TickCount
    } Else SetTimer, WriteSettingsPasteInPlacePanel, -350
}

WriteSettingsPasteInPlacePanel() {
    INIaction(1, "FillAreaBlendMode", "General")
    INIaction(1, "FillAreaGradientAngle", "General")
    INIaction(1, "FillAreaGradientSigma", "General")
    INIaction(1, "FillAreaGradientBlend", "General")
    INIaction(1, "FillAreaGradientScale", "General")
    INIaction(1, "FillAreaGradientWrapped", "General")
    INIaction(1, "FillAreaGlassy", "General")
    INIaction(1, "FillAreaColorReversed", "General")
    INIaction(1, "PasteInPlaceAlphaChannelFile", "General")
    INIaction(1, "PasteInPlaceAlphaMaskClrA", "General")
    INIaction(1, "PasteInPlaceAlphaMaskClrB", "General")
    INIaction(1, "PasteInPlaceAlphaMaskMode", "General")
    INIaction(1, "PasteInPlaceAdaptMode", "General")
    INIaction(1, "PasteInPlaceCentered", "General")
    INIaction(1, "PasteInPlaceOpacity", "General")
    INIaction(1, "PasteInPlaceQuality", "General")
    INIaction(1, "PasteInPlaceEraseInitial", "General")
    INIaction(1, "PasteInPlaceLivePreview", "General")
    INIaction(1, "PasteInPlaceOrientation", "General")
    INIaction(1, "PasteInPlaceApplyColorFX", "General")
    INIaction(1, "PasteInPlaceBlurAmount", "General")
    INIaction(1, "PasteInPlaceHue", "General")
    INIaction(1, "PasteInPlaceSaturation", "General")
    INIaction(1, "PasteInPlaceLight", "General")
    INIaction(1, "PasteInPlaceGamma", "General")
    INIaction(1, "PasteInPlaceLivePreview", "General")
    INIaction(1, "alphaMaskReplaceMode", "General")
}

BtnPasteInSelectedArea() {
    updateUIpastePanel("noPreview")
    Sleep, 1
    CloseWindow(0, 0)
    ToggleEditImgSelection("show-edit")
    Sleep, 1
    ; viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    PasteInPlaceNow()
}

importGivenFile() {
   If !prevLoadedImageIndex
      Return

   imgPath := getIDimage(currentFileIndex)
   currentFileIndex := prevLoadedImageIndex
   MenuReturnIMGedit()
   Sleep, 2
   ToggleEditImgSelection("show-edit")
   Sleep, 2
   PanelPasteInPlace(imgPath)
}

ReadSettingsPasteInPlace() {
    If !InStr(customShapePoints, "|")
    {
       INIaction(0, "FillAreaCustomShape", "General")
       INIaction(0, "initialCustomShapeCoords", "General")
       customShapePoints := FillAreaCustomShape
    }
    INIaction(0, "FillAreaBlendMode", "General")
    INIaction(0, "FillAreaGradientAngle", "General")
    INIaction(0, "FillAreaGradientSigma", "General")
    INIaction(0, "FillAreaGradientBlend", "General")
    INIaction(0, "FillAreaGradientScale", "General")
    INIaction(0, "FillAreaGradientWrapped", "General")
    INIaction(0, "FillAreaGlassy", "General")
    INIaction(0, "FillAreaColorReversed", "General")
    INIaction(0, "PasteInPlaceAlphaMaskMode", "General")
    INIaction(0, "PasteInPlaceAlphaChannelFile", "General")
    INIaction(0, "PasteInPlaceAlphaMaskClrA", "General")
    INIaction(0, "PasteInPlaceAlphaMaskClrB", "General")
    INIaction(0, "PasteInPlaceBlurAmount", "General")
    INIaction(0, "PasteInPlaceCentered", "General")
    INIaction(0, "PasteInPlaceCropSel", "General")
    INIaction(0, "PasteInPlaceEraseInitial", "General")
    INIaction(0, "PasteInPlaceApplyColorFX", "General")
    INIaction(0, "PasteInPlaceGamma", "General")
    INIaction(0, "PasteInPlaceHue", "General")
    INIaction(0, "PasteInPlaceLight", "General")
    INIaction(0, "PasteInPlaceLivePreview", "General")
    INIaction(0, "PasteInPlaceAdaptMode", "General")
    INIaction(0, "PasteInPlaceOpacity", "General")
    INIaction(0, "PasteInPlaceOrientation", "General")
    INIaction(0, "PasteInPlaceQuality", "General")
    INIaction(0, "PasteInPlaceSaturation", "General")
    INIaction(0, "PasteInPlaceLivePreview", "General")
    INIaction(0, "alphaMaskReplaceMode", "General")
    If !Trimmer(PasteInPlaceGamma)
       PasteInPlaceGamma := 0
}

PanelTransformSelectedArea() {
   MainPanelTransformArea(0, "transform")
}

PanelPasteInPlace(dummy:="") {
   MainPanelTransformArea(dummy, "paste")
}

MainPanelTransformArea(dummy:="", toolu:="") {
    userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    imgPath := getIDimage(currentFileIndex)
    calcScreenLimits()
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || openingPanelNow=1 || !imgPath)
       Return

    openingPanelNow := 1
    If (slideShowRunning=1)
       ToggleSlideShowu()

    DestroyGIFuWin()
    changeMcursor()
    setImageLoading()
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (toolu="transform")
    {
       showTOOLtip("Retrieving selected area from the image, please wait...")
       userClipBMPpaste := getTransformToolSelectedArea(0)
       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       }
    } Else If (toolu="paste")
    {
       showTOOLtip("Retrieving clipboard image, please wait...")
       If FileRexists(dummy)
       {
          thisPBitmap := LoadBitmapFromFileu(dummy)
          userClipBMPpaste := Gdip_CloneBmpPargbArea(A_ThisFunc, thisPBitmap)
          trGdip_DisposeImage(thisPBitmap, 1)
       } Else
          userClipBMPpaste := corePasteClipboardImg(1, ResolutionWidth*2, Round(ResolutionHeight*4.3), 0)

       If StrLen(userClipBMPpaste)>2
       {
          Gdip_GetImageDimensions(userClipBMPpaste, imgW, imgH)
          If (imgW>mainWidth || imgH>mainHeight)
             viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, userClipBMPpaste, mainWidth, mainHeight, 1, 3, -1)
          Else
             viewportStampBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, userClipBMPpaste)
       }
    }

    If (StrLen(userClipBMPpaste)<3 || StrLen(viewportStampBMP)<3)
    {
       viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
       userClipBMPpaste := trGdip_DisposeImage(userClipBMPpaste, 1)
       SetTimer, resetOpeningPanel, -200
       showTOOLtip("ERROR: Failed to retrieve image...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       Return
    }

    viewportIDstampBMP := A_TickCount
    If (toolu="transform")
    {
       prevVPselRotation := vPselRotation
       prevrotateSelBoundsKeepRatio := rotateSelBoundsKeepRatio
       prevEllipseSelectMode := EllipseSelectMode
       prevImgSelX1 := imgSelX1, prevImgSelX2 := imgSelX2
       prevImgSelY1 := imgSelY1, prevImgSelY2 := imgSelY2
       vPselRotation := 0
       PasteInPlaceToolMode := imgEditPanelOpened := 1
       thisBtnHeight := createSettingsGUI(31, A_ThisFunc)
    } Else If (toolu="paste")
    {
       flipBitmapAccordingToViewPort(viewportStampBMP)
       PasteInPlaceToolMode := 0
       imgEditPanelOpened := 1
       thisBtnHeight := createSettingsGUI(24, A_ThisFunc)
    }

    ResetImgLoadStatus()
    ReadSettingsPasteInPlace()
    If isWinXP
       FillAreaBlendMode := 1

    If (!FileRexists(PasteInPlaceAlphaFile) && PasteInPlaceAlphaMaskMode=5) || (coreDesiredPixFmt="0x21808")
       PasteInPlaceAlphaMaskMode := 1

    btnWid := 90,  txtWid := 310
    EditWid := 60, slideWid := 150
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 55
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 120
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid2 := txtWid//2
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    If (toolu="transform")
       prevModeViewPortSelectionManager(prevDestPosX, prevDestPosY, oImgW, oImgH)

    thisOpacity := Round((PasteInPlaceOpacity / 255) * 100)
    Global infoPasteBlur, infoPasteOpacity, infoPasteHue, infoPasteSat, infoPasteLight, infoPasteGamma
         , infoFillAreaSigma, infoFillAreaBlend, infoFillAreaGradientAngle, infoFillAreaGradientScale
         , infoPasteAlphaClrA, infoPasteAlphaClrB, infoAlphaFile

    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Adjust colors|Alpha mask
    Gui, Tab, 1 ; general
    If (toolu="transform")
    {
       Gui, Add, Text, x+15 y+15 Section w%txtWid%, Canvas: %oImgW% x %oImgH% px.`nTransformed object: %imgW% x %imgH% px.
    } Else If (toolu="paste")
    {
       Gui, Add, Text, x+15 y+15 w%txtWid%, Please choose how to paste the clipboard content.
       Gui, Add, Text, y+7 Section wp, Canvas: %oImgW% x %oImgH% px.`nClipboard object: %imgW% x %imgH% px.
    }

    Gui, Add, DropDownList, xs y+7 wp gupdateUIpastePanel AltSubmit Choose%PasteInPlaceAdaptMode% vPasteInPlaceAdaptMode, Adjust image to selection|Fill selection area entirely (ignore aspect ratio)|Original image size
    Gui, Add, DropDownList, xs y+7 gupdateUIpastePanel w%txtWid2% AltSubmit Choose%PasteInPlaceOrientation% vPasteInPlaceOrientation, No mirroring|Flip horizontal|Flip vertical|Flip horizontal and vertical
    Gui, Add, DropDownList, x+2 gupdateUIpastePanel wp AltSubmit Choose%PasteInPlaceCentered% vPasteInPlaceCentered, Top-left|Top-right|Centered|Bottom-left|Bottom-right
    Gui, Add, Checkbox, xs y+7 hp gupdateUIpastePanel Checked%PasteInPlaceCropSel% vPasteInPlaceCropSel, C&rop to selection area
    If (toolu="transform")
       Gui, Add, Checkbox, y+7 hp gupdateUIpastePanel Checked%PasteInPlaceEraseInitial% vPasteInPlaceEraseInitial, &Erase initially selected area
    Gui, Add, Checkbox, y+7 hp gupdateUIpastePanel Checked%PasteInPlaceQuality% vPasteInPlaceQuality, &High quality image resampling
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteBlur, Image blur amount: %PasteInPlaceBlurAmount% ; (inaccurate live preview)
    Gui, Add, Slider, xs y+1 gupdateUIpastePanel AltSubmit ToolTip w%txtWid% vPasteInPlaceBlurAmount Range0-255, % PasteInPlaceBlurAmount
    If (coreDesiredPixFmt="0x21808")
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+10 w%txtWid%, WARNING: 32-bits RGBA mode is not activated. This tool may yield erroneous results.
       Gui, Font, Normal
    }

    Gui, Tab, 2 ; colors
    Gui, Add, Checkbox, x+15 y+15 Section gupdateUIpastePanel Checked%PasteInPlaceApplyColorFX% vPasteInPlaceApplyColorFX, Apply color adjustments
    Gui, Add, DropDownList, x+10 wp-40 gupdateUIpastePanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, No blending|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference
    Gui, Add, Text, xs y+5 w%txtWid% gBtnResetPanelsSpecificControl vinfoPasteHue, Hue: %PasteInPlaceHue%°
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceHue Range-180-180, % PasteInPlaceHue
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteSat, Saturation: %PasteInPlaceSaturation%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceSaturation Range-100-100, % PasteInPlaceSaturation
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteLight, Brightness: %PasteInPlaceLight%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceLight Range-255-255, % PasteInPlaceLight
    Gui, Add, Text, y+4 wp gBtnResetPanelsSpecificControl vinfoPasteGamma, Contrast: %PasteInPlaceGamma%`%
    Gui, Add, Slider, y+1 wp AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceGamma Range-100-100, % PasteInPlaceGamma
    Gui, Add, Text, y+4 gBtnResetPanelsSpecificControl vinfoPasteOpacity , Image opacity: 100`% - ; %thisOpacity%
    Gui, Add, DropDownList, x+25 wp AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIpastePanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Slider, xs y+1 w%txtWid% AltSubmit NoTicks ToolTip gupdateUIpastePanel vPasteInPlaceOpacity Range3-255, % PasteInPlaceOpacity

    Gui, Tab, 3 ; alpha mask
    friendlyMaskInfo := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No alpha mask"
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid2% AltSubmit Choose%PasteInPlaceAlphaMaskMode% vPasteInPlaceAlphaMaskMode gupdateUIpastePanel, %friendlyMaskInfo%|Linear gradient|Radial gradient|Box gradient|Image file|Custom shape
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIpastePanel, &Invert
    Gui, Add, Checkbox, x+2 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIpastePanel, &Tiled
    Gui, Add, Checkbox, x+2 hp Checked%alphaMaskReplaceMode% valphaMaskReplaceMode gupdateUIpastePanel, &Replace
    Gui, Add, Text, xs y+10 w%slideWid% +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrA, Intensity A: 0
    Gui, Add, Text, x+5 hp wp +0x200 gBtnResetPanelsSpecificControl vinfoPasteAlphaClrB, Intensity B: 0
    Gui, Add, Slider, xs y+1 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrA Range0-255, % PasteInPlaceAlphaMaskClrA
    Gui, Add, Slider, x+5 NoTicks wp gupdateUIpastePanel ToolTip AltSubmit vPasteInPlaceAlphaMaskClrB Range0-255, % PasteInPlaceAlphaMaskClrB

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientSigma%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientBlend%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientSigma Range0-100, % FillAreaGradientSigma
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIpastePanel ToolTip AltSubmit vFillAreaGradientBlend Range0-100, % FillAreaGradientBlend
    Gui, Add, Text, xs y+10 wp vinfoAlphaFile, Image file path or list index number:
    Gui, Add, Combobox, xs y+10 w%txtWid2% vPasteInPlaceAlphaFile, obj|this|prev|next|first|last|%PasteInPlaceAlphaFile%
    Gui, Add, DropDownList, x+5 wp-95 AltSubmit Choose%PasteInPlaceAlphaChannelFile% vPasteInPlaceAlphaChannelFile gupdateUIpastePanel, Red|Green|Blue|Alpha|All gray
    Gui, Add, Button, x+5 hp wp gBtnBrowseAlphaMaskFile vbtnFldr, B&rowse

    Gui, Tab
    friendlyBtn := (toolu="paste") ? "&Paste" : "&Transform"
    friendlyTitle := (toolu="paste") ? "Paste in place: " : "Transform selected area: "
    Gui, Add, Button, xm+0 y+15 Section h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w115 hp Default gapplyIMGeditFunction, % friendlyBtn
    Gui, Add, Button, x+5 hp w75 gBtnPasteResetOptions, &Reset
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xs y+7 gupdateUIpastePanel Checked%PasteInPlaceLivePreview% vPasteInPlaceLivePreview, &Live preview (low quality)
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, friendlyTitle appTitle, winPos)
    SetTimer, updateUIpastePanel, -350
    SetTimer, resetOpeningPanel, -300
}

BtnResetPanelsSpecificControl(CtrlHwnd, b, c) {
   ; GuiControlGet, varu, SettingsGUIA: FocusV
   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      GuiControlGet, modus, SettingsGUIA:, PasteInPlaceAlphaMaskMode

   GuiControlGet, varu, SettingsGUIA: Name, % CtrlHwnd
   ; ToolTip, % varu "`n" a "|" b "|" c , , , 2
   If (varu="infoPasteBlur")
   {
      PasteInPlaceBlurAmount := 0
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   }

   If (varu="infoPasteHue")
   {
      PasteInPlaceHue := 0
      GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   }

   If (varu="infoPasteSat")
   {
      PasteInPlaceSaturation := 0
      GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   }

   If (varu="infoPasteLight")
   {
      PasteInPlaceLight := 0
      GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   }

   If (varu="infoPasteGamma")
   {
      PasteInPlaceGamma := 0
      GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   }

   If (varu="infoPasteOpacity")
   {
      PasteInPlaceOpacity := 255
      GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   }

   If (varu="infoPasteAlphaClrA")
   {
      PasteInPlaceAlphaMaskClrA := (modus=5) ? 128 : 0
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrA, % PasteInPlaceAlphaMaskClrA
   }

   If (varu="infoPasteAlphaClrB")
   {
      PasteInPlaceAlphaMaskClrB := (modus=5) ? 0 : 255
      GuiControl, SettingsGUIA:, PasteInPlaceAlphaMaskClrB, % PasteInPlaceAlphaMaskClrB
   }

   If (varu="infoFillAreaGradientAngle")
   {
      FillAreaGradientAngle := 0
      GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   }

   If (varu="infoFillAreaGradientScale")
   {
      FillAreaGradientScale := (modus=5) ? 1 : 100
      GuiControl, SettingsGUIA:, FillAreaGradientScale, % FillAreaGradientScale
   }

   If (varu="infoFillAreaSigma")
   {
      FillAreaGradientSigma := 0
      GuiControl, SettingsGUIA:, FillAreaGradientSigma, % FillAreaGradientSigma
   }

   If (varu="infoFillAreaBlend")
   {
      FillAreaGradientBlend := 100
      GuiControl, SettingsGUIA:, FillAreaGradientBlend, % FillAreaGradientBlend
   }

   If (varu="infoFillAreaContour")
   {
      FillAreaContourThickness := 10
      GuiControl, SettingsGUIA:, FillAreaContourThickness, % FillAreaContourThickness
   }

   If (AnyWindowOpen=24 || AnyWindowOpen=31)
      SetTimer, updateUIpastePanel, -50
   Else If (AnyWindowOpen=23)
      SetTimer, updateUIfillPanel, -50
}

BtnPasteResetOptions() {
   PasteInPlaceBlurAmount := PasteInPlaceHue := PasteInPlaceSaturation := PasteInPlaceLight := PasteInPlaceCropSel := FillAreaGradientAngle := 0
   PasteInPlaceOrientation := PasteInPlaceAdaptMode := PasteInPlaceAlphaMaskMode := 1
   PasteInPlaceCentered := 3
   PasteInPlaceGamma := 0
   PasteInPlaceOpacity := 255
   If (AnyWindowOpen=24)
      GuiControl, SettingsGUIA:, PasteInPlaceBlurAmount, % PasteInPlaceBlurAmount
   GuiControl, SettingsGUIA:, PasteInPlaceHue, % PasteInPlaceHue
   GuiControl, SettingsGUIA:, PasteInPlaceSaturation, % PasteInPlaceSaturation
   GuiControl, SettingsGUIA:, PasteInPlaceLight, % PasteInPlaceLight
   GuiControl, SettingsGUIA:, PasteInPlaceGamma, % PasteInPlaceGamma
   GuiControl, SettingsGUIA:, PasteInPlaceOpacity, % PasteInPlaceOpacity
   GuiControl, SettingsGUIA:, FillAreaGradientAngle, % FillAreaGradientAngle
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAlphaMaskMode, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceCentered, 3
   GuiControl, SettingsGUIA: Choose, PasteInPlaceOrientation, 1
   GuiControl, SettingsGUIA: Choose, PasteInPlaceAdaptMode, 1
   GuiControl, SettingsGUIA: , PasteInPlaceCropSel, 0
   WriteSettingsPasteInPlacePanel()
   updateUIpastePanel()
}

ReadSettingsFillSelArea() {
    If (drawingShapeNow!=1)
       INIaction(0, "FillAreaCurveTension", "General")

    INIaction(0, "initialCustomShapeCoords", "General")
    INIaction(0, "FillAreaClosedPath", "General")
    INIaction(0, "FillAreaBlendMode", "General")
    INIaction(0, "FillAreaCustomShape", "General")
    INIaction(0, "FillAreaColor", "General")
    INIaction(0, "FillAreaShape", "General")
    INIaction(0, "FillAreaOpacity", "General")
    INIaction(0, "FillAreaInverted", "General")
    INIaction(0, "FillAreaRemBGR", "General")
    INIaction(0, "FillAreaDoContour", "General")
    INIaction(0, "FillAreaDashStyle", "General")
    INIaction(0, "FillAreaRoundedCaps", "General")
    INIaction(0, "FillAreaDoubleLine", "General")
    INIaction(0, "FillAreaContourAlign", "General")
    INIaction(0, "FillAreaContourThickness", "General")
    INIaction(0, "FillAreaColorMode", "General")
    INIaction(0, "FillAreaColorReversed", "General")
    INIaction(0, "FillArea2ndColor", "General")
    INIaction(0, "FillArea2ndOpacity", "General")
    INIaction(0, "FillAreaGradientAngle", "General")
    INIaction(0, "FillAreaGradientSigma", "General")
    INIaction(0, "FillAreaGradientBlend", "General")
    INIaction(0, "FillAreaGradientScale", "General")
    INIaction(0, "FillAreaGradientWrapped", "General")
    INIaction(0, "FillAreaGlassy", "General")
}


LEDguiGuiClose:
LEDguiGuiEscape:
   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
Return

StopColorPicker() {
   Critical, on
   colorPickerModeNow := 0
}

StartPickingColor() {
   g := A_Gui, ctrl := A_GuiControl
   ctrl := StrReplace(ctrl, "picku")
   If (isWinXP=1 || A_OSVersion="WIN_7")
   {
      msgBoxWrapper(appTitle ": ERROR", "The color picker functionality is not yet implemented for Windows XP or Windows 7... Please use the color selector associated.", 0, 0, "error")
      Return
   }

   hideLivePreviewObject()
   Sleep, 2
   pBitmap := Gdip_BitmapFromHWND(PVhwnd, 1)
   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   If StrLen(pBitmap)>2
   {
      createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 1, A_ThisFunc]
   } Else
   {
      showTOOLtip("Failed to capture windo image`n`nPlease try again to pick a color...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   diffH := diffW := 0
   LEDu := imgHUDbaseUnit
   Gui, LEDgui: -DPIScale +AlwaysOnTop -Caption +Owner +ToolWindow +E0x20 +hwndhColorPrev
   Gui, LEDgui: Color, 000000
   WinSet, AlwaysOnTop, On, ahk_id %hColorPrev%
   Gui, LEDgui: Add, Text, x1 y1 w%LEDu% h%LEDu% gStopColorPicker, -
   Gui, LEDgui: Show, NoActivate x1 y1 w%LEDu% h%LEDu%, QPVcolorPicker
   Sleep, 1
   colorPickerModeNow := 1
   toggleImgEditPanelWindow("forced")
   errorOccured := 0
   While, (colorPickerModeNow=1)
   {
      If (errorOccured>700)
         Break

      Sleep, -1
      GetMouseCoord2wind(PVhwnd, mX, mY)
      mX := clampInRange(mX + diffW, 0, imgW)
      mY := clampInRange(mY + diffH, 0, imgH)
      ; ToolTip, % imgW " | " imgH "`n" winW " | " winH "`n" diffW " | " diffH "`n" mX " | " mY , , , 2
      h := Gdip_GetPixelColor(pBitmap, mX, mY, 4)
      If !h
      {
         Sleep, 5
         errorOccured++
         Continue
      }

      ; createColorPrevWin(h)
      Gui, LEDgui: Color, %h%
      GetPhysicalCursorPos(pX, pY)
      pX -= LEDu//2, pY -= LEDu//2
      Gui, LEDgui: Show, NoActivate x%pX% y%pY%
      Sleep, 5
      hwnd := WinActive("A")
      ; ToolTip, % h "`n" z "`n" w , , , 2
      If (A_Index>1950)
      {
         errorOccured := 750
         Break
      }

      If (GetKeyState("RButton") || GetKeyState("MButton") || GetKeyState("Enter") || GetKeyState("Escape")
         || GetKeyState("Space") || GetKeyState("Tab") || GetKeyState("Numpad5") || hwnd=hColorPrev)
         Break
   }

   colorPickerModeNow := 0
   Gui, LEDgui: Destroy
   toggleImgEditPanelWindow("forced")

   trGdip_DisposeImage(pBitmap, 1)
   If (errorOccured>690)
      Return

   ; https://autohotkey.com/board/topic/43945-fast-pixelgetcolor-workaround-for-aero-windows-7-and-vista/
   o := %ctrl%
   SoundBeep, 900, 100
   ; ToolTip, % r "`n" ctrl "`n" o "`n" z , , , 2
   %ctrl% := h

   INIaction(1, ctrl, "General")
   GuiControl, %g%:+Background%h%, %ctrl%
   If (imgEditPanelOpened=1)
      livePreviewsImageEditing(1)
}

stopDrawingShape() {
    If (drawingShapeNow!=1)
       Return

    customShapePoints := convertCustomShape2toRelativeCoords(customShapePoints)
    SetTimer, dummyRefreshImgSelectionWindow, -150
    If (!AnyWindowOpen && customShapePoints)
       PanelFillSelectedArea()

    If (drawingLiveMode=1)
       Gdip_DeletePen(PenuDrawLive)
    Else
       Gdip_DeleteBrush(PenuDrawLive)

    drawingShapeNow := 0
    PenuDrawLive := ""
    DestroyTempBtnGui("force")
    If !customShapePoints
    {
       If !AnyWindowOpen
          editingSelectionNow := 0

       showTOOLtip("Drawing abandoned...")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else dummyTimerDelayiedImageDisplay(100)
    interfaceThread.ahkassign("drawingShapeNow", 0)
    updateUIctrl()
    MouseMoveResponder()
}

startDrawingShape(modus) {
     If (thumbsDisplaying=1 || StrLen(gdiBitmap)<3)
        Return

     If (getCaptionStyle(PVhwnd)=1)
     {
        ToggleTitleBaruNow()
        Return
     }
     If (AnyWindowOpen && imgEditPanelOpened=1)
        CloseWindow("yes")
     Sleep, 5
     If (editingSelectionNow=1)
        recordSelUndoLevelNow()
     drawingShapeNow := 1
     interfaceThread.ahkassign("drawingShapeNow", 1)
     ToggleEditImgSelection("show-edit")
     customShapePoints := ""
     INIaction(0, "FillAreaColor", "General")
     INIaction(0, "FillAreaCurveTension", "General")
     INIaction(0, "closedLineCustomShape", "General")
     ; INIaction(0, "cardinalCurveCustomShape", "General")
     decideCustomShapeStyle()
     thisColorA := (modus="line") ? "0xAA" FillAreaColor : "0x88" FillAreaColor
     If (modus="line")
     {
        PenuDrawLive := Gdip_CreatePen(thisColorA, imgHUDbaseUnit//7)
        drawingLiveMode := 1
     } Else If (modus="shape")
     {
        PenuDrawLive := Gdip_BrushCreateSolid(thisColorA)
        drawingLiveMode := 2
     }

     initialDrawingStartCoords := []
     initialDrawingStartCoords := [prevDestPosX, prevDestPosY]

     LabelCurve := (cardinalCurveCustomShape=1) ? "curved" : "polygonal"
     LabelType := (drawingLiveMode=1) ? "path" : "filled shape"
     If (drawingLiveMode=1)
        LabelOpenLine := (closedLineCustomShape=1) ? "closed " : "open "

     showTOOLtip("Draw freeform " LabelOpenLine LabelCurve A_Space LabelType "...`nPress Right Click to end.")
     showQuickActionButtonsDrawingShape()
     SetTimer, dummyRefreshImgSelectionWindow, 75
     SetTimer, RemoveTooltip, % -msgDisplayTime
}

reduceCustomShapePoints() {
   foundPos := InStr(customShapePoints, "|", 0, -1)
   customShapePoints := SubStr(customShapePoints, 1, foundPos)
   showQuickActionButtonsDrawingShape()
   ; SetTimer, DestroyTempBtnGui, % -msgDisplayTime*10000
}

ToggleCardinalCurveMode() {
   cardinalCurveCustomShape := !cardinalCurveCustomShape
   INIaction(1, "cardinalCurveCustomShape", "General")
   showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, 75
}

toggleOpenClosedLineCustomShape() {
   closedLineCustomShape := !closedLineCustomShape
   INIaction(1, "closedLineCustomShape", "General")
   showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, 75
}

showQuickActionButtonsDrawingShape() {
     LabelCurve := (cardinalCurveCustomShape=1) ? "Polygonal" : "Curve"
     If (drawingLiveMode=1)
     {
        LabelOpenLine := (closedLineCustomShape=1) ? "Open path" : "Closed path"
        btnOpenLine := "||" LabelOpenLine ",,toggleOpenClosedLineCustomShape"
     }

     LabelTension := "||Points tension " FillAreaCurveTension ",,togglePathCurveTension"
     CreateGuiButton("Undo,,reduceCustomShapePoints||Done,,stopDrawingShape||" btnOpenLine LabelTension, "force", msgDisplayTime*10000)
}

decideCustomShapeStyle() {
   If (FillAreaCurveTension=4)
      tensionCurveCustomShape := 0.95
   Else If (FillAreaCurveTension=3)
      tensionCurveCustomShape := 0.5
   Else If (FillAreaCurveTension=2)
      tensionCurveCustomShape := 0.2
   Else
      tensionCurveCustomShape := 0.1

   cardinalCurveCustomShape := (FillAreaCurveTension>1) ? 1 : 0
}

togglePathCurveTension() {
   FillAreaCurveTension := clampInRange(FillAreaCurveTension + 1, 1, 4, 1)
   decideCustomShapeStyle()
   INIaction(1, "FillAreaCurveTension", "General")
   showQuickActionButtonsDrawingShape()
   SetTimer, dummyRefreshImgSelectionWindow, 75
}

BtnTabsInfoUpdate() {
   GuiControlGet, CurrentPanelTab, SettingsGUIA:, CurrentPanelTab
}

PanelFillSelectedArea() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(23, A_ThisFunc)
    ReadSettingsFillSelArea()
    If (drawingShapeNow=1)
    {
       FillAreaShape := 7
       FillAreaDoContour := (drawingLiveMode=1) ? 1 : 0
       FillAreaClosedPath := closedLineCustomShape
       FillAreaCustomShape := customShapePoints
       INIaction(1, "FillAreaClosedPath", "General")
       INIaction(1, "FillAreaCustomShape", "General")
       ; INIaction(1, "FillAreaShape", "General")
       INIaction(1, "FillAreaDoContour", "General")
    } Else customShapePoints := FillAreaCustomShape

    btnWid := 100, btnHeight := 25
    txtWid := 285, slideWid := 150
    EditWid := 60, EllipseSelectMode := 0

    If (PrefsLargeFonts=1)
    {
       btnHeight := 30
       EditWid := EditWid + 50
       btnWid := btnWid + 30
       txtWid := txtWid + 115
       slideWid := slideWid + 55
       Gui, Font, s%LargeUIfontValue%
    }

    minislideWid := slideWid//2
    If (FillAreaDoContour=1)
       FillAreaRemBGR := 0

    If isWinXP
    {
       FillAreaBlendMode := 1
       FillAreaGlassy := 1
    }

    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoFillArea2ndOpacity, infoFillAreaContour, infoFillAreaGradientScale, infoFillAreaGradientAngle
         , infoFillAreaSigma, infoFillAreaBlend, PickuFillAreaColor, PickuFillArea2ndColor

    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Main|Colors and gradients
    Gui, Tab, 1
    Gui, Add, DropDownList, x+10 y+10 Section w%slideWid% AltSubmit Choose%FillAreaShape% vFillAreaShape gupdateUIfillPanel, Rectangle|Rounded rectangle|Ellipse|Triangle|Right triangle|Rhombus|Custom shape
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaGlassy% vFillAreaGlassy gupdateUIfillPanel, No glass effect|Weak|Mild|Moderate|Strong|Extreme
    Gui, Add, Checkbox, xs y+7 wp hp Checked%FillAreaInverted% vFillAreaInverted gupdateUIfillPanel, &Invert selection area
    Gui, Add, DropDownList, x+5 w%slideWid% AltSubmit Choose%FillAreaCurveTension% vFillAreaCurveTension gupdateUIfillPanel, Polygonal|Smooth corners|Curve|Round curve
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaRemBGR% vFillAreaRemBGR gupdateUIfillPanel, &Erase background behind the new object
    Gui, Add, Checkbox, xs y+7 hp Checked%FillAreaDoContour% vFillAreaDoContour gupdateUIfillPanel, &Draw only an outline / a contour
    Gui, Add, DropDownList, xs+15 y+7 w%btnWid% AltSubmit Choose%FillAreaContourAlign% vFillAreaContourAlign gupdateUIfillPanel, Inside|Centered|Outside
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%FillAreaDashStyle% vFillAreaDashStyle gupdateUIfillPanel, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaClosedPath% vFillAreaClosedPath, &Closed path
    Gui, Add, Checkbox, xs+15 y+6 wp hp Checked%FillAreaDoubleLine% vFillAreaDoubleLine gupdateUIfillPanel, &Double line
    Gui, Add, Checkbox, x+2 hp gupdateUIfillPanel Checked%FillAreaRoundedCaps% vFillAreaRoundedCaps, &Rounded caps
    Gui, Add, Text, xs y+10 w%txtWid% gBtnResetPanelsSpecificControl vinfoFillAreaContour, Contour thickness: %FillAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIfillPanel ToolTip AltSubmit w%txtWid% vFillAreaContourThickness Range1-450, % FillAreaContourThickness

    Gui, Tab, 2
    Gui, Add, DropDownList, x+10 y+10 Section w200 AltSubmit Choose%FillAreaColorMode% vFillAreaColorMode gupdateUIfillPanel, Solid color|Linear gradient|Radial gradient|Box gradient ; |Random patterns
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaGradientWrapped% vFillAreaGradientWrapped gupdateUIfillPanel, &Tiling pattern
    Gui, Add, Slider, xs y+10 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillAreaOpacity Range2-255, % FillAreaOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, ListView, x+5 hp w60 %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillAreaOpacity, %thisOpacity%`%
    Gui, Add, Slider, xs y+1 NoTicks w%slideWid% gupdateUIfillPanel ToolTip AltSubmit vFillArea2ndOpacity Range2-255, % FillArea2ndOpacity
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillArea2ndColor, P
    Gui, Add, ListView, x+5 hp w60%CCLVO% Background%FillArea2ndColor% vFillArea2ndColor hwndhLVfill2ndColor,
    Gui, Add, Text, x+5 hp wp +0x200 vinfoFillArea2ndOpacity, Opacity: %this2ndOpacity%00`%

    Gui, Add, Text, xs y+15 w%slideWid% gBtnResetPanelsSpecificControl vinfoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%° 
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientAngle Range0-360, % FillAreaGradientAngle
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientScale Range1-300, % FillAreaGradientScale

    infoBlend := (coreDesiredPixFmt="0x21808") ? "Disabled in 24-RGB mode" : "No blending mode"
    Gui, Add, Text, xs y+10 wp gBtnResetPanelsSpecificControl vinfoFillAreaSigma, Sigma: %FillAreaGradientSigma%`%
    Gui, Add, Text, x+5 wp gBtnResetPanelsSpecificControl vinfoFillAreaBlend, Blend: %FillAreaGradientBlend%`%
    Gui, Add, Slider, xs y+1 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientSigma Range0-100, % FillAreaGradientSigma
    Gui, Add, Slider, x+5 wp NoTicks gupdateUIfillPanel ToolTip AltSubmit vFillAreaGradientBlend Range0-100, % FillAreaGradientBlend
    Gui, Add, Checkbox, xs y+5 Checked%FillAreaColorReversed% vFillAreaColorReversed gupdateUIfillPanel, &Reverse colors
    Gui, Add, DropDownList, x+10 wp gupdateUIfillPanel AltSubmit Choose%FillAreaBlendMode% vFillAreaBlendMode, %infoBlend%|Darken|Multiply|Linear burn|Color burn|Lighten|Screen|Linear dodge [Add]|Hard light|Overlay|Hard mix|Linear light|Color dodge|Vivid light|Division|Exclusion|Difference|Substract|Luminosity|Substract reversed|Inverted difference

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%FillAreaLivePreview% vFillAreaLivePreview gupdateUIfillPanel, &Live preview
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Fill/draw shapes in selected area: " appTitle, winPos)
    SetTimer, updateUIfillPanel, -50
}

ToggleClosePanelApply() {
   GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
   INIaction(1, "closeEditPanelOnApply", "General")
}

ReadSettingsDrawLinesArea() {
    INIaction(0, "DrawLineAreaColor", "General")
    INIaction(0, "DrawLineAreaOpacity", "General")
    INIaction(0, "DrawLineAreaKeepBounds", "General")
    INIaction(0, "DrawLineAreaDashStyle", "General")
    INIaction(0, "DrawLineAreaCapsStyle", "General")
    INIaction(0, "DrawLineAreaContourAlign", "General")
    INIaction(0, "DrawLineAreaContourThickness", "General")
    INIaction(0, "DrawLineAreaBorderTop", "General")
    INIaction(0, "DrawLineAreaBorderBottom", "General")
    INIaction(0, "DrawLineAreaBorderLeft", "General")
    INIaction(0, "DrawLineAreaBorderRight", "General")
    INIaction(0, "DrawLineAreaBorderCenter", "General")
    INIaction(0, "DrawLineAreaBorderArcA", "General")
    INIaction(0, "DrawLineAreaBorderArcB", "General")
    INIaction(0, "DrawLineAreaBorderArcC", "General")
    INIaction(0, "DrawLineAreaBorderArcD", "General")
}

PanelDrawLines() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(30, A_ThisFunc)
    ReadSettingsDrawLinesArea()
    EllipseSelectMode := 0
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid := 165
    BtnHeight := thisBtnHeight - 5
    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    Global infoDrawLineAreaOpacity, infoDrawLineAreaContour, PickuDrawLineAreaColor
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please configure what lines to draw and how.
    Gui, Add, Text, y+10 Section w%txtWid%, Line style. Alignment.
    Gui, Add, DropDownList, xs y+7 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaDashStyle% vDrawLineAreaDashStyle, Continous|Dashes|Dots|Dashes and dots
    Gui, Add, DropDownList, x+10 wp gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaContourAlign% vDrawLineAreaContourAlign, Inside|Centered|Outside

    Gui, Add, Checkbox, xs y+10 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcA% vDrawLineAreaBorderArcA,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderTop% vDrawLineAreaBorderTop,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcB% vDrawLineAreaBorderArcB,○
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaCapsStyle% vDrawLineAreaCapsStyle, Rounded caps
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderLeft% vDrawLineAreaBorderLeft,▏
    Gui, Add, Text, x+1 wp hp Center,.
    ; Gui, Add, Checkbox, x+1 wp hp +0x1000 Checked%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,▏
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderRight% vDrawLineAreaBorderRight,▏
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaDoubles% vDrawLineAreaDoubles, Double line
    Gui, Add, Checkbox, xs y+1 w55 h%btnHeight% +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcC% vDrawLineAreaBorderArcC,○
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderBottom% vDrawLineAreaBorderBottom,─
    Gui, Add, Checkbox, x+1 wp hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaBorderArcD% vDrawLineAreaBorderArcD,○
    Gui, Add, ListView, x+10 w%btnWid% hp %CCLVO% Background%DrawLineAreaColor% vDrawLineAreaColor,
    Gui, Add, Button, x+1 hp w25 gStartPickingColor vPickuDrawLineAreaColor, P

    Gui, Add, DropDownList, xs y+0 w%btnWid% gupdateUIDrawLinesPanel AltSubmit Choose%DrawLineAreaBorderCenter% vDrawLineAreaBorderCenter,No center line|Vertical|Horizontal|Slash|Backslash|Both diagonals|Both H/V lines
    Gui, Add, Checkbox, x+10 w%btnWid% hp +0x1000 gupdateUIDrawLinesPanel Checked%DrawLineAreaKeepBounds% vDrawLineAreaKeepBounds, &Within bounds

    Gui, Add, Text, xs y+10 w%txtWid% vinfoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaOpacity Range3-255, % DrawLineAreaOpacity
    Gui, Add, Text, xs y+10 wp vinfoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    Gui, Add, Slider, xs y+1 gupdateUIDrawLinesPanel AltSubmit ToolTip w%txtWid% vDrawLineAreaContourThickness Range1-450, % DrawLineAreaContourThickness


    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w110 hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Draw lines or arcs in selected area: " appTitle, winPos)
    SetTimer, updateUIDrawLinesPanel, -50
}

PanelEraseSelectedArea() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(25, A_ThisFunc)
    INIaction(0, "EraseAreaFader", "General")
    INIaction(0, "EraseAreaOpacity", "General")
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    Global infoEraseOpacity
    Gui, Add, Text, x15 y15 Section w%txtWid%, Please decide how to erase or fade selected area:
    Gui, Add, Checkbox, xs y+10 hp Checked%EraseAreaFader% vEraseAreaFader gupdateUIerasePanel, &Fade selected area
    Gui, Add, Text, xs+15 y+10 wp hp vinfoEraseOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 AltSubmit gupdateUIerasePanel ToolTip w%txtWid% vEraseAreaOpacity Range5-250, % EraseAreaOpacity

    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    ; Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Erase selected area: " appTitle, winPos)
    SetTimer, updateUIerasePanel, -150
}

liveEraserPreview() {
      trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor)
      Gdip_GetImageDimensions(useGdiBitmap(), qimgW, qimgH)
      calcImgSelection2bmp(1, qimgW, qimgH, qimgW, qimgH, qimgSelPx, qimgSelPy, qimgSelW, qimgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      imgSelPx := x1 := selDotX + SelDotsSize//2, x2 := selDotAx + SelDotsSize//2
      imgSelPy := y1 := selDotY + SelDotsSize//2, y2 := selDotAy + SelDotsSize//2
      imgSelW := max(X1, X2) - min(X1, X2)
      imgSelH := max(Y1, Y2) - min(Y1, Y2)
      pPath := Gdip_CreatePath()
      If (EllipseSelectMode=1)
         Gdip_AddPathEllipse(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
      Else
         Gdip_AddPathRectangle(pPath, imgSelPx, imgSelPy, imgSelW, imgSelH)

      Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
      thisOpacity := (EraseAreaFader=1) ? EraseAreaOpacity : 0
      thisBase := (coreDesiredPixFmt="0x21808") ? "0xFF000000" : "0xFF999999"
      Gdip_FromARGB(thisBase, A, R, G, B)
      thisColorA := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      Gdip_FromARGB("0xFF111111", A, R, G, B)
      thisColorB := Gdip_ToARGB(255 - thisOpacity, R, G, B)
      thisBrush := Gdip_BrushCreateHatch(thisColorA, thisColorB, 50)
      Gdip_FillPath(2NDglPG, thisBrush, pPath)

      Gdip_DeletePath(pPath)
      Gdip_DeleteBrush(thisBrush)
      GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
}

PasteInPlaceEraseArea(G2, mode) {
      If (mode=1)
      {
         imgSelPx := x1 := prevSelDotX + SelDotsSize//2, x2 := prevSelDotAx + SelDotsSize//2
         imgSelPy := y1 := prevSelDotY + SelDotsSize//2, y2 := prevSelDotAy + SelDotsSize//2
         imgSelW := max(X1, X2) - min(X1, X2)
         imgSelH := max(Y1, Y2) - min(Y1, Y2)
      } Else
      {
         Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
         calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 1)
      }

      pPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, prevEllipseSelectMode)
      Gdip_RotatePathAtCenter(pPath, prevVPselRotation, 1, 1, prevrotateSelBoundsKeepRatio)
      If (mode=1)
      {
         If pPath
            Gdip_FillPath(G2, useHatchedBrush(), pPath)
      } Else
      {
         If pPath
            Gdip_SetClipPath(G2, pPath)
         trGdip_GraphicsClear(A_ThisFunc, G2)
         Gdip_ResetClip(G2)
      }
      Gdip_DeletePath(pPath)
}

WriteSettingsBlurPanel() {
    INIaction(1, "blurAreaAmount", "General")
    INIaction(1, "blurAreaMode", "General")
    INIaction(1, "blurAreaPixelizeAmount", "General")
    INIaction(1, "blurAreaInverted", "General")
    INIaction(1, "blurAreaSoftEdges", "General")
    INIaction(1, "blurAreaOpacity", "General")
    INIaction(1, "blurAreaTwice", "General")
}

ReadSettingsBlurPanel() {
    INIaction(0, "blurAreaAmount", "General")
    INIaction(0, "blurAreaMode", "General")
    INIaction(0, "blurAreaPixelizeAmount", "General")
    INIaction(0, "blurAreaInverted", "General")
    INIaction(0, "blurAreaSoftEdges", "General")
    INIaction(0, "blurAreaOpacity", "General")
    INIaction(0, "blurAreaTwice", "General")
}

PanelBlurSelectedArea() {
    If (thumbsDisplaying=1)
       Return

    initQPVmainDLL()
    wasSelect := editingSelectionNow
    thisBtnHeight := createSettingsGUI(26, A_ThisFunc)
    ReadSettingsBlurPanel()
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1)
       selectEntireImage("r")

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    Global infoBlurOpacity, infoBlurAmount, infoPixelize
    If (wasSelect!=1)
    {
       blurAreaSoftEdges := 0
       blurAreaInverted := 0
    }
    tinyPrevAreaCoordX := imgSelX1 + 125
    tinyPrevAreaCoordY := imgSelY1 + 125
    If (isWinXP=1 && blurAreaMode=1)
    {
       blurAreaMode := 2
       blurAreaSoftEdges := 0
    }
    
    If (coreDesiredPixFmt="0x21808")
       blurAreaSoftEdges := 0

    friendly := (isWinXP=1) ? " (unsupported)" : ""
    Gui, -DPIScale
    Gui, Font, 
    Gui, Add, Text, x20 y20 w325 h325 Section +0x1000 +0xE gtoggleBlurPviewSize +hwndhCropCornersPic, Preview area
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, Click in the viewport to change the preview area.
    If (PrefsLargeFonts=1)
       Gui, Font, s%LargeUIfontValue%

    Gui, +DPIScale
    Gui, Add, Checkbox, x+20 ys Section Section Checked%blurAreaSoftEdges% vblurAreaSoftEdges gupdateUIblurPanel, &Soft edges%friendly%
    Gui, Add, Checkbox, x+10 Checked%blurAreaInverted% vblurAreaInverted gupdateUIblurPanel, &Invert selection area
    Gui, Add, Checkbox, xs y+10 hp Checked%blurAreaTwice% vblurAreaTwice gupdateUIblurPanel, &Blur twice in one go [for very large images]
    Gui, Add, Text, xs y+10 wp vinfoBlurAmount, Blur amount: %blurAreaAmount%
    Gui, Add, Slider, xp y+5 gupdateUIblurPanel ToolTip w%txtWid% vblurAreaAmount Range0-255, % blurAreaAmount
    Gui, Add, Text, xs y+10 wp vinfoPixelize, Pixelize amount [before blurring]: %blurAreaPixelizeAmount%
    Gui, Add, Slider, xp y+5 gupdateUIblurPanel ToolTip w%txtWid% vblurAreaPixelizeAmount Range0-1024, %blurAreaPixelizeAmount%
    Gui, Add, Text, xs y+10 wp vinfoBlurOpacity, Opacity: %thisOpacity%`%
    Gui, Add, Slider, xp y+5 gupdateUIblurPanel ToolTip w%txtWid% vblurAreaOpacity Range5-255, % blurAreaOpacity
    If (wasSelect!=1 && EllipseSelectMode!=1)
       GuiControl, Disable, blurAreaInverted

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnBlurSelectedArea, &Blur area
    Gui, Add, DropDownList, x+5 wp AltSubmit Choose%blurAreaMode% gupdateUIblurPanel vblurAreaMode, High quality%friendly%|Alternate blur|Box blur (slow)
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Blur/pixelize selected area: " appTitle, winPos)
    SetTimer, updateUIblurPanel, -100
}

PanelNewImage() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(27, A_ThisFunc)
    INIaction(0, "NewDocUseColor", "General")
    INIaction(0, "PredefinedDocsSizes", "General")
    INIaction(0, "NewImageReverseDimensions", "General")
    INIaction(0, "FillAreaColor", "General")
    INIaction(0, "FillAreaOpacity", "General")
    If (!UserNewWidth || !UserNewHeight || !UserNewDPI)
       PredefinedDocsSizes := 1
    Else If (UserNewWidth && UserNewHeight &&UserNewDPI)
       PredefinedDocsSizes := 13

    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    Global infoFillAreaOpacity, infoResultRes, PickuFillAreaColor
    Gui, Add, Text, x15 y15 Section, Create new RGBA image. Please set image dimensions.
    Gui, Add, DropDownList, y+10 wp gupdateUInewImagePanel AltSubmit Choose%PredefinedDocsSizes% vPredefinedDocsSizes, Viewport size|Screen size|Current image size|640x480|800x600|1024x768|HD 480p|HD 720p|HD 1080p|HD 2160p [4K]|A4 @ 300 dpi|A4 @ 150 dpi|Previously used dimensions
    Gui, Add, Text, xs y+10 w%EditWid%, Width (px)
    Gui, Add, Text, x+1 wp, Height (px)
    Gui, Add, Text, x+1 wp, DPI
    Gui, Add, Edit, xs y+7 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewWidth, % UserNewWidth
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewHeight, % UserNewHeight
    Gui, Add, Edit, x+5 wp gNewImageEditResponder r1 limit6 +number -multi -wantTab -wrap vUserNewDPI, % UserNewDPI
    Gui, Add, Checkbox, xs y+10 Checked%NewImageReverseDimensions% vNewImageReverseDimensions, Rotate canvas 90° degrees
    Gui, Add, Checkbox, xs y+10 gupdateUInewImagePanel Checked%NewDocUseColor% vNewDocUseColor, Fill background with color
    Gui, Add, ListView, xs y+10 h30 w%editWid% %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P
    Gui, Add, Text, x+5 hp +0x200 vinfoFillAreaOpacity, Opacity: %thisOpacity%00`%
    Gui, Add, Slider, xs y+1 hp w%txtWid% gupdateUInewImagePanel ToolTip AltSubmit  vFillAreaOpacity Range3-255, % FillAreaOpacity
    ; Gui, Add, Text, xs y+10, Resulted dimensions:
    ; Gui, Add, Text, xs y+10 w%txtWid% vinfoResultRes, --`n--

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnNewImage, &Create new image
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Button, x+25 hp w%btnWid% gOpenNewQPVinstance, &New instance
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "New image: " appTitle)
    SetTimer, updateUInewImagePanel, -150
}

ReadSettingsPrintPanel() {
    INIaction(0, "TextInAreaAlign", "General")
    INIaction(0, "TextInAreaValign", "General")
    INIaction(0, "TextInAreaFontColor", "General")
    INIaction(0, "TextInAreaFontName", "General")
    INIaction(0, "TextInAreaFontBold", "General")
    INIaction(0, "TextInAreaFontItalic", "General")
    INIaction(0, "TextInAreaFontUline", "General")
    INIaction(0, "PrintTxtSize", "General")
    INIaction(0, "PrintDimensionsXYWH", "General")
    INIaction(0, "PrintColorMode", "General")
    INIaction(0, "PrintAdaptToFit", "General")
    INIaction(0, "PrintUseViewportColors", "General")
}

PanelPrintImage() {
    Global PrintPosEditX, PrintPosEditY, PrintPosEditW, PrintPosEditH, PrintPosTxtX, PrintPosTxtY, PrintPosTxtW, PrintPosTxtH
         , PrintCopies, SelectedPrinteru, PrintDoFlipuH, PrintDoFlipuV, PrinterPageInfos, UserTextArea, editF1, PickuTextInAreaFontColor

    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    viewportStampBMP := trGdip_DisposeImage(viewportStampBMP, 1)
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

    If StrLen(useGdiBitmap())>2
       viewportStampBMP := trGdip_ResizeBitmap(A_ThisFunc, useGdiBitmap(), 450, 450, 1, 3, -1)

    thisBtnHeight := createSettingsGUI(37, A_ThisFunc)
    ReadSettingsPrintPanel()
    printDims := StrSplit(PrintDimensionsXYWH, "|")
    PrintPosX := printDims[1]
    PrintPosY := printDims[2]
    PrintPosW := printDims[3]
    PrintPosH := printDims[4]
    PrintDoFlipuV := FlipImgV
    PrintDoFlipuH := FlipImgH
    PrintOrientation := vpIMGrotation
    
    btnWid := 70
    txtWid := 350
    EditWid := 50
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    printerlist := SGDIPrint_GetDefaultPrinter() "||" SGDIPrint_EnumPrinters("|") 
    Gui, -DPIScale
    Gui, Add, Text, x20 y20 w248 h351 Section +0x1000 +0xE +hwndhCropCornersPic, Print preview
    Gui, Add, Text, xp y+10 wp Center vPrinterPageInfos, -`n-`n-`n-
    Gui, +DPIScale

    Gui, Add, Tab3, x+20 ys Section, General|Text line

    Gui, Tab, 1
    Gui, Add, Text, x+15 y+15 Section, Please choose printer:
    Gui, Add, DropDownList, y+7 wp+90 gupdatePrintPreview vSelectedPrinteru, %printerlist%
    Gui, Add, Button, x+5 hp gBtnSetPrinterDefault, Set as &default
    Gui, Add, Edit, xs y+10 w50 r1 limit3 +number -multi -wantTab -wrap vPrintCopies, 1
    Gui, Add, Text, x+5 hp +0x200, copies to print
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintAdaptToFit% vPrintAdaptToFit, Automatically adapt image to cover page
    Gui, Add, Text, xs y+10 vPrintPosTxtY w%EditWid%, Top
    Gui, Add, Text, x+1 vPrintPosTxtX wp, Left
    Gui, Add, Text, x+1 vPrintPosTxtW wp, Width
    Gui, Add, Text, x+1 vPrintPosTxtH wp, Height
    Gui, Add, Text, x+1 wp, Angle
    Gui, Add, Edit, xs y+7 wp gupdatePrintPreview vPrintPosEditY number -multi limit3, % PrintPosY
    Gui, Add, UpDown, vPrintPosY Range0-98, % PrintPosY
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditX number -multi limit3, % PrintPosX
    Gui, Add, UpDown, vPrintPosX Range0-98, % PrintPosX
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditW number -multi limit3, % PrintPosW
    Gui, Add, UpDown, vPrintPosW Range2-100, % PrintPosW
    Gui, Add, Edit, x+2 wp gupdatePrintPreview vPrintPosEditH number -multi limit3, % PrintPosH
    Gui, Add, UpDown, vPrintPosH Range2-100, % PrintPosH
    Gui, Add, Edit, x+2 wp gupdatePrintPreview number -multi limit3, % PrintOrientation
    Gui, Add, UpDown, vPrintOrientation Range0-360, % PrintOrientation
    Gui, Add, Text, xs y+10 hp +0x200, Flip image:
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuH% vPrintDoFlipuH, vertically
    Gui, Add, Checkbox, x+10 hp gupdatePrintPreview Checked%PrintDoFlipuV% vPrintDoFlipuV, horizontally
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintColorMode% vPrintColorMode, Print using colors
    Gui, Add, Checkbox, xs y+10 gupdatePrintPreview Checked%PrintUseViewportColors% vPrintUseViewportColors, Apply viewport color adjustments

    Gui, Tab, 2
    EditWid2 := (PrefsLargeFonts!=1) ? 290 : 450
    Gui, Add, Text, x+15 y+15 Section, Text to insert on the page:
    Gui, Add, Edit, xs y+5 w%EditWid2% r2 gupdatePrintPreview vUserTextArea limit2048, % UserTextArea
    Gui, Add, Text, xs y+15 wp, Font name:
    Gui, Add, DropDownList, xs y+5 wp Sort gupdatePrintPreview Choose1 vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Text, xs y+15, Text size and color:
    Gui, Add, Edit, xs+0 y+5 w%editWid% gupdatePrintPreview r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % PrintTxtSize
    Gui, Add, UpDown, vPrintTxtSize gupdatePrintPreview Range25-999, % PrintTxtSize
    Gui, Add, ListView, x+2 w%editWid% hp gupdatePrintPreview %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P
    Gui, Add, Text, xs y+15, Text alignment and style:
    Gui, Add, DropDownList, xs y+5 w%editWid% gupdatePrintPreview Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdatePrintPreview Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdatePrintPreview Checked%TextInAreaFontUline% vTextInAreaFontUline, U

    Gui, Tab
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% Default w%btnWid% gBtnStartPrintingNow, &Print now
    ; Gui, Add, Button, x+5 hp gupdatePrintPreview, &Preview
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, &Cancel

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Print image: " appTitle)
    ; SetTimer, updatePrintPreview, -500
}

BtnSetPrinterDefault() {
   GuiControlGet, SelectedPrinteru
   If !SGDIPrint_SetDefaultPrinter(SelectedPrinteru)
      msgBoxWrapper(appTitle ": ERROR", "Failed to set " SelectedPrinteru " as default.", 0, 0, "error")
}

printSettingsObj() {
   Gui, SettingsGUIA: Default
   GuiControlGet, PrintAdaptToFit
   GuiControlGet, PrintPosX
   GuiControlGet, PrintPosY
   GuiControlGet, PrintPosW
   GuiControlGet, PrintPosH
   GuiControlGet, PrintColorMode
   GuiControlGet, PrintCopies
   GuiControlGet, SelectedPrinteru
   GuiControlGet, PrintOrientation
   GuiControlGet, PrintDoFlipuH
   GuiControlGet, PrintDoFlipuV
   GuiControlGet, PrintUseViewportColors
   GuiControlGet, TextInAreaAlign
   GuiControlGet, TextInAreaValign
   GuiControlGet, TextInAreaFontName
   GuiControlGet, TextInAreaFontBold
   GuiControlGet, TextInAreaFontItalic
   GuiControlGet, TextInAreaFontUline
   GuiControlGet, PrintTxtSize
   GuiControlGet, UserTextArea

   PrintOptions := []
   PrintOptions.pPrinterName := SelectedPrinteru
   PrintOptions.adaptFit := PrintAdaptToFit
   PrintOptions.userImgX := PrintPosX
   PrintOptions.userImgY := PrintPosY
   PrintOptions.userImgW := PrintPosW
   PrintOptions.userImgH := PrintPosH
   PrintOptions.colorsMode := PrintColorMode
   PrintOptions.imgOrient := PrintOrientation
   PrintOptions.copiez := PrintCopies
   PrintOptions.flipuV := PrintDoFlipuH
   PrintOptions.flipuH := PrintDoFlipuV
   PrintOptions.applyFX := PrintUseViewportColors
   PrintOptions.text := Trimmer(UserTextArea)
   PrintDimensionsXYWH := PrintPosX "|" PrintPosY "|" PrintPosW "|" PrintPosH
   SetTimer, WriteSettingsPrintPanel, -200

   If (PrintAdaptToFit=1)
   {
      GuiControl, SettingsGUIA: Disable, PrintPosX
      GuiControl, SettingsGUIA: Disable, PrintPosY
      GuiControl, SettingsGUIA: Disable, PrintPosW
      GuiControl, SettingsGUIA: Disable, PrintPosH
      GuiControl, SettingsGUIA: Disable, PrintPosEditX
      GuiControl, SettingsGUIA: Disable, PrintPosEditY
      GuiControl, SettingsGUIA: Disable, PrintPosEditW
      GuiControl, SettingsGUIA: Disable, PrintPosEditH
      GuiControl, SettingsGUIA: Disable, PrintPosTxtX
      GuiControl, SettingsGUIA: Disable, PrintPosTxtY
      GuiControl, SettingsGUIA: Disable, PrintPosTxtW
      GuiControl, SettingsGUIA: Disable, PrintPosTxtH
   } Else
   {
      GuiControl, SettingsGUIA: Enable, PrintPosX
      GuiControl, SettingsGUIA: Enable, PrintPosY
      GuiControl, SettingsGUIA: Enable, PrintPosW
      GuiControl, SettingsGUIA: Enable, PrintPosH
      GuiControl, SettingsGUIA: Enable, PrintPosEditX
      GuiControl, SettingsGUIA: Enable, PrintPosEditY
      GuiControl, SettingsGUIA: Enable, PrintPosEditW
      GuiControl, SettingsGUIA: Enable, PrintPosEditH
      GuiControl, SettingsGUIA: Enable, PrintPosTxtX
      GuiControl, SettingsGUIA: Enable, PrintPosTxtY
      GuiControl, SettingsGUIA: Enable, PrintPosTxtW
      GuiControl, SettingsGUIA: Enable, PrintPosTxtH
   }
   Return PrintOptions
}

WriteSettingsPrintPanel() {
    INIaction(1, "TextInAreaAlign", "General")
    INIaction(1, "TextInAreaValign", "General")
    INIaction(1, "TextInAreaFontColor", "General")
    INIaction(1, "TextInAreaFontName", "General")
    INIaction(1, "TextInAreaFontBold", "General")
    INIaction(1, "TextInAreaFontItalic", "General")
    INIaction(1, "TextInAreaFontUline", "General")
    INIaction(1, "PrintTxtSize", "General")
    INIaction(1, "PrintDimensionsXYWH", "General")
    INIaction(1, "PrintColorMode", "General")
    INIaction(1, "PrintAdaptToFit", "General")
    INIaction(1, "PrintUseViewportColors", "General")
}

updatePrintPreview() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<350)
   {
      SetTimer, updatePrintPreview, -500
      Return
   }

   PrintOptions := printSettingsObj()
   printImageNow(viewportStampBMP, PrintOptions, 1)
   lastInvoked := A_TickCount
}

BtnStartPrintingNow() {
   PrintOptions := printSettingsObj()
   CloseWindow("yes")
   Sleep, 2
   showTOOLtip("Please wait, preparing to print image...")
   Sleep, 2
   printImageNow(useGdiBitmap(), PrintOptions, 0)
   Sleep, 2
   RemoveTooltip()
}

PanelIMGselProperties() {
    If (thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(34, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    btnWid2 := EditWid//2 - 2
    Global NewPosX1, NewPosY1, NewPosX2, NewPosY2, NewVProt
         , BtnPosX1m, BtnPosX1p, BtnPosY1m, BtnPosY1p, BtnPosX2m, BtnPosX2p, BtnPosY2m, BtnPosY2p
         , BtnPosXm, BtnPosXp, BtnPosYm, BtnPosYp, BtnPosZm, BtnPosZp

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    Gui, Add, Text, x15 y15 Section, Current image size: %imgW% x %imgH% px.
    Gui, Add, Checkbox, y+7 gupdateUIselectionPropertiesPanel Checked%PanelDefineSelectionCoords% vPanelDefineSelectionCoords, Define image selection coordinates in...
    Gui, Add, DropDownList, x+2 w150 AltSubmit gupdateUIchangeSelectionType vSelectionCoordsType, Pixels||Percentages
    Gui, Add, Text, xs y+10 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Text, x+3 wp, Rotation
    Gui, Add, Edit, xs y+7 wp r1 limit9 -multi -wantTab -wrap gupdateUIselectionPropertiesPanel vNewPosX1, % imgSelX1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselectionPropertiesPanel vNewPosY1, % imgSelY1
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselectionPropertiesPanel vNewPosX2, % imgSelX2
    Gui, Add, Edit, x+3 wp r1 limit9 -multi -wantTab -wrap gupdateUIselectionPropertiesPanel vNewPosY2, % imgSelY2
    Gui, Add, ComboBox, x+3 wp limit9 -multi -wrap gupdateUIselectionPropertiesPanel vNewVProt, 0|45|90|105|135|150|180|200|225|250|270|300|315|%vPselRotation%||
    Gui, Add, Text, xs y+10, Adjust current selection coordinates:
    Gui, Add, Text, xs y+5 w%EditWid%, X1
    Gui, Add, Text, x+3 wp, Y1
    Gui, Add, Text, x+3 wp, X2
    Gui, Add, Text, x+3 wp, Y2
    Gui, Add, Button, xs y+7 w%btnWid2% gOffsetSelProperPanel vBtnPosX1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY1p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosX2p, +
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2m, -
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosY2p, +
    Gui, Add, Button, xs y+7 wp+8 gOffsetSelProperPanel vBtnPosXm, Up
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosXp, Down
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYm, Left
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosYp, Right
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZm, Contract
    Gui, Add, Button, x+3 wp gOffsetSelProperPanel vBtnPosZp, Enlarge
    Gui, Add, Checkbox, xs y+15 gupdateUIselectionPropertiesPanel Checked%LimitSelectBoundsImg% vLimitSelectBoundsImg, &Limit selection to image boundaries
    Gui, Add, Checkbox, xs y+10 gupdateUIselectionPropertiesPanel Checked%rotateSelBoundsKeepRatio% vrotateSelBoundsKeepRatio, &Keep aspect ratio on rotation
    ToggleEditImgSelection("show-edit")
    dummyTimerDelayiedImageDisplay(50)
    Gui, Add, Button, xs y+20 w100 h%thisBtnHeight% gBTNselectEntireImg, &Select all
    Gui, Add, Button, x+10 w125 hp gBTNselectNoneImg, &Select none
    Gui, Add, Button, x+10 w90 hp gBtnCloseWindow Default, &Close
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Selection properties: " appTitle, winPos)
    SetTimer, updateUIselectionPropertiesPanel, -350
}

BTNselectNoneImg() {
   CloseWindow()
   editingSelectionNow := 0
   updateUIctrl()
   MouseMoveResponder()
   dummyTimerDelayiedImageDisplay(50)
}

dummyOffsetSelProperPanel() {
    If (determineLClickstate()=1)
    {
       SetTimer, dummyOffsetSelProperPanel, -25
       OffsetSelProperPanel("usePrev")
    }
}

OffsetSelProperPanel(dummy:=0) {
   Static prevVaru, lastInvoked := 1
   stepu := (A_TickCount - lastInvoked<350) ? 4 : 2
   If (dummy!="usePrev")
      GuiControlGet, varu, SettingsGUIA: FocusV
   Else
      varu := prevVaru

   If (varu="BtnPosYm")
   {
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosXm")
   {
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   } Else If (varu="BtnPosXp")
   {
      arrowKeysAdjustSelectionArea(2, 1, stepu)
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   } Else If (varu="BtnPosYp")
   {
      arrowKeysAdjustSelectionArea(1, 1, stepu)
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   } Else If (varu="BtnPosZm")
      changeSelectZoom(-1)
   Else If (varu="BtnPosZp")
      changeSelectZoom(1)
   Else If (varu="BtnPosX1m")
      arrowKeysAdjustSelectionArea(-1, 1, stepu)
   Else If (varu="BtnPosX1p")
      arrowKeysAdjustSelectionArea(1, 1, stepu)
   Else If (varu="BtnPosY1m")
      arrowKeysAdjustSelectionArea(-2, 1, stepu)
   Else If (varu="BtnPosY1p")
      arrowKeysAdjustSelectionArea(2, 1, stepu)
   Else If (varu="BtnPosX2m")
      arrowKeysAdjustSelectionArea(-1, 2, stepu)
   Else If (varu="BtnPosX2p")
      arrowKeysAdjustSelectionArea(1, 2, stepu)
   Else If (varu="BtnPosY2m")
      arrowKeysAdjustSelectionArea(-2, 2, stepu)
   Else If (varu="BtnPosY2p")
      arrowKeysAdjustSelectionArea(2, 2, stepu)
   lastInvoked := A_TickCount
   prevVaru := varu
   SetTimer, dummyOffsetSelProperPanel, -250
}

updateUIchangeSelectionType() {
   GuiControlGet, SelectionCoordsType
   GuiControlGet, PanelDefineSelectionCoords
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   GuiControl, SettingsGUIA:, NewPosX1, 0
   GuiControl, SettingsGUIA:, NewPosY1, 0
   If (SelectionCoordsType=1)
   {
      GuiControl, SettingsGUIA:, NewPosX2, % imgW//2
      GuiControl, SettingsGUIA:, NewPosY2, % imgH//2
   } Else
   {
      GuiControl, SettingsGUIA:, NewPosX2, 50
      GuiControl, SettingsGUIA:, NewPosY2, 50
   }
   updateUIselectionPropertiesPanel()
}

BTNselectEntireImg() {
   CloseWindow()
   selectEntireImage()
}

updateUIselectionPropertiesPanel() {
   GuiControlGet, NewPosX1, SettingsGUIA:, NewPosX1
   GuiControlGet, NewPosY1, SettingsGUIA:, NewPosY1
   GuiControlGet, NewPosX2, SettingsGUIA:, NewPosX2
   GuiControlGet, NewPosY2, SettingsGUIA:, NewPosY2
   GuiControlGet, NewVProt, SettingsGUIA:, NewVProt
   GuiControlGet, PanelDefineSelectionCoords, SettingsGUIA:, PanelDefineSelectionCoords
   GuiControlGet, SelectionCoordsType, SettingsGUIA:, SelectionCoordsType
   GuiControlGet, LimitSelectBoundsImg, SettingsGUIA:, LimitSelectBoundsImg
   GuiControlGet, rotateSelBoundsKeepRatio, SettingsGUIA:, rotateSelBoundsKeepRatio
   ToggleEditImgSelection("show-edit")
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   actuA := (PanelDefineSelectionCoords=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
   actuB := (PanelDefineSelectionCoords=1) ? "SettingsGUIA: Enable" : "SettingsGUIA: Disable"
   If (PanelDefineSelectionCoords=1)
      lockSelectionAspectRatio := 0

   GuiControl, % actuA, BtnPosX1m
   GuiControl, % actuA, BtnPosX1p
   GuiControl, % actuA, BtnPosY1m
   GuiControl, % actuA, BtnPosY1p
   GuiControl, % actuA, BtnPosX2m
   GuiControl, % actuA, BtnPosX2p
   GuiControl, % actuA, BtnPosY2m
   GuiControl, % actuA, BtnPosY2p
   GuiControl, % actuA, BtnPosXm
   GuiControl, % actuA, BtnPosXp
   GuiControl, % actuA, BtnPosYm
   GuiControl, % actuA, BtnPosYp
   GuiControl, % actuA, BtnPosZm
   GuiControl, % actuA, BtnPosZp
   GuiControl, % actuB, NewPosX1
   GuiControl, % actuB, NewPosY1
   GuiControl, % actuB, NewPosX2
   GuiControl, % actuB, NewPosY2
   GuiControl, % actuB, SelectionCoordsType
   If (PanelDefineSelectionCoords=1)
   {
      If (SelectionCoordsType=1)
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := imgW//2
         If !IsNumber(NewPosY2)
            NewPosY2 := imgH//2
         imgSelX1 := Round(NewPosX1), imgSelY1 := Round(NewPosY1)
         imgSelX2 := Round(NewPosX2), imgSelY2 := Round(NewPosY2)
      } Else
      {
         If !IsNumber(NewPosX1)
            NewPosX1 := 0
         If !IsNumber(NewPosY1)
            NewPosY1 := 0
         If !IsNumber(NewPosX2)
            NewPosX2 := 50
         If !IsNumber(NewPosY2)
            NewPosY2 := 50
         wNewPosX1 := min(NewPosX1, NewPosX2)
         wNewPosX2 := max(NewPosX1, NewPosX2)

         wNewPosY1 := min(NewPosY1, NewPosY2)
         wNewPosY2 := max(NewPosY1, NewPosY2)
         imgSelX1 := Round(imgW*(Abs(wNewPosX1)/100), 3), imgSelY1 := Round(imgH*(Abs(wNewPosY1)/100), 3)
         imgSelX2 := Round(imgW*(Abs(wNewPosX2)/100), 3), imgSelY2 := Round(imgH*(Abs(wNewPosY2)/100), 3)
      }
   }

   If !IsNumber(NewVProt)
      NewVProt := 0

   vPselRotation := clampInRange(Round(NewVProt), 0, 360, 1)
   dummyTimerDelayiedImageDisplay(50)
   Return
}

updateUInewImagePanel() {
    GuiControlGet, PredefinedDocsSizes
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, Opacity: %thisOpacity%`%
    If (NewDocUseColor!=1)
    {
       GuiControl, SettingsGUIA: Disable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, PickuFillAreaColor
    } Else
    {
       GuiControl, SettingsGUIA: Enable, infoFillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, PickuFillAreaColor
    }

    If (PredefinedDocsSizes=1)
    {
       GetWinClientSize(UserNewWidth, UserNewHeight, PVhwnd, 0)
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=2)
    {
       calcScreenLimits()
       UserNewWidth := ResolutionWidth
       UserNewHeight := ResolutionHeight
       UserNewDPI := A_ScreenDPI
    } Else If (PredefinedDocsSizes=3)
    {
       If useGdiBitmap()
       {
          Gdip_BitmapGetDPIResolution(useGdiBitmap(), dpix, dpiy)
          Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
          UserNewDPI := (dpix + dpiy)//2
       } Else
       {
          GetWinClientSize(imgW, imgH, PVhwnd, 0)
          UserNewDPI := A_ScreenDPI
       }
       UserNewWidth := imgW
       UserNewHeight := imgH
    } Else If (PredefinedDocsSizes=4)
    {
       UserNewWidth := 640
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=5)
    {
       UserNewWidth := 800
       UserNewHeight := 600
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=6)
    {
       UserNewWidth := 1024
       UserNewHeight := 768
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=7)
    {
       UserNewWidth := 858
       UserNewHeight := 480
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=8)
    {
       UserNewWidth := 1280
       UserNewHeight := 720
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=9)
    {
       UserNewWidth := 1920
       UserNewHeight := 1080
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=10)
    {
       UserNewWidth := 3860
       UserNewHeight := 2160
       UserNewDPI := 72
    } Else If (PredefinedDocsSizes=11)
    {
       UserNewWidth := 2480
       UserNewHeight := 3508
       UserNewDPI := 300
    } Else If (PredefinedDocsSizes=12)
    {
       UserNewWidth := 1240
       UserNewHeight := 1754
       UserNewDPI := 150
    }

    If (PredefinedDocsSizes<13)
    {
       GuiControl, SettingsGUIA:, UserNewWidth, % UserNewWidth
       GuiControl, SettingsGUIA:, UserNewHeight, % UserNewHeight
       GuiControl, SettingsGUIA:, UserNewDPI, % UserNewDPI
    }
}

NewImageEditResponder() {
   GuiControlGet, UserNewWidth
   GuiControlGet, UserNewHeight
   GuiControlGet, UserNewDPI
   GuiControlGet, whichFocused, FocusV

   If (whichFocused="UserNewWidth" || whichFocused="UserNewHeight" || whichFocused="UserNewDPI")
   {
      PredefinedDocsSizes := 13
      GuiControl, SettingsGUIA: Choose, PredefinedDocsSizes, 13
   }
}

BtnNewImage() {
    Static clippyCount
    GuiControlGet, UserNewWidth
    GuiControlGet, UserNewHeight
    GuiControlGet, UserNewDPI
    GuiControlGet, NewDocUseColor
    GuiControlGet, FillAreaOpacity
    GuiControlGet, NewImageReverseDimensions

    If (UserNewWidth<5 || UserNewHeight<5 || UserNewDPI<5)
    {
       SoundBeep, 300, 100
       showTOOLtip("WARNING: Incorrect dimensions provided for the new image...")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If (UserNewWidth*UserNewHeight>maxGDIbmpSize) || (UserNewWidth>32500) || (UserNewHeight>32500)
    {
       SoundBeep, 300, 100
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits...")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "NewDocUseColor", "General")
    INIaction(1, "PredefinedDocsSizes", "General")
    INIaction(1, "NewImageReverseDimensions", "General")
    INIaction(1, "FillAreaColor", "General")
    INIaction(1, "FillAreaOpacity", "General")

    DestroyGIFuWin()
    CloseWindow()
    PredefinedDocsSizes := 13
    showTOOLtip("Creating the new image, please wait...")
    setImageLoading()
    calcScreenLimits()

    mustOpenStartFolder := ""
    terminateIMGediting()
    discardViewPortCaches()
    clippyCount++
    If (NewImageReverseDimensions=1)
    {
       tUserNewWidth := UserNewHeight
       tUserNewHeight := UserNewWidth
    } Else
    {
       tUserNewWidth := UserNewWidth
       tUserNewHeight := UserNewHeight
    }

    UserMemBMP := trGdip_CreateBitmap(A_ThisFunc, tUserNewWidth, tUserNewHeight, "0xE200B")
    If warnUserFatalBitmapError(UserMemBMP, A_ThisFunc)
    {
       showTOOLtip("Failed to create new image...")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       ResetImgLoadStatus()
       clippyCount--
       Return
    }

    Gdip_BitmapSetResolution(UserMemBMP, UserNewDPI, UserNewDPI)
    If (NewDocUseColor=1)
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, UserMemBMP)
       Gdip_FromARGB("0xFF" FillAreaColor, A, R, G, B)
       thisColor := Gdip_ToARGB(FillAreaOpacity, R, G, B)
       trGdip_GraphicsClear(A_ThisFunc, G2, thisColor)
       Gdip_DeleteGraphics(G2)
    }

    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\New-" clippyCount ".img"
    }

    currIMGdetails.HasAlpha := 1
    If (NewDocUseColor=1 && FillAreaOpacity>253)
       currIMGdetails.HasAlpha := 0

    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}

BtnDrawLinesSelectedArea() {
  updateUIDrawLinesPanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

  If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
  && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
  {
     SoundBeep , 300, 100
     showTOOLtip("WARNING: No lines to draw selected...")
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (closeEditPanelOnApply=1)
     CloseWindow("yes")
  Sleep, 1
  ToggleEditImgSelection("show-edit")
  pPath := DrawLinesInSelectedArea()
  Gdip_DeletePath(pPath)
  SetTimer, RemoveTooltip, -250
}

updateUIDrawLinesPanel(actionu=0) {
    GuiControlGet, DrawLineAreaOpacity
    GuiControlGet, DrawLineAreaKeepBounds
    GuiControlGet, DrawLineAreaDashStyle
    GuiControlGet, DrawLineAreaCapsStyle
    GuiControlGet, DrawLineAreaContourAlign
    GuiControlGet, DrawLineAreaDoubles
    GuiControlGet, DrawLineAreaBorderTop
    GuiControlGet, DrawLineAreaBorderBottom
    GuiControlGet, DrawLineAreaBorderLeft
    GuiControlGet, DrawLineAreaBorderRight
    GuiControlGet, DrawLineAreaBorderCenter
    GuiControlGet, DrawLineAreaBorderArcA
    GuiControlGet, DrawLineAreaBorderArcB
    GuiControlGet, DrawLineAreaBorderArcC
    GuiControlGet, DrawLineAreaBorderArcD
    GuiControlGet, DrawLineAreaContourThickness

    thisOpacity := Round((DrawLineAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoDrawLineAreaOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoDrawLineAreaContour, Contour thickness: %DrawLineAreaContourThickness% pixels
    ToggleEditImgSelection("show-edit")
    If (DrawLineAreaBorderTop=0 && DrawLineAreaBorderBottom=0 && DrawLineAreaBorderLeft=0 && DrawLineAreaBorderRight=0
    && DrawLineAreaBorderCenter=1 && DrawLineAreaBorderArcA=0 && DrawLineAreaBorderArcB=0 && DrawLineAreaBorderArcC=0 && DrawLineAreaBorderArcD=0)
       dummyRefreshImgSelectionWindow()
    Else If (actionu!="noPreview")
       livePreviewsImageEditing(1)
    Else
       SetTimer, WriteSettingsDrawLinesPanel, -250
}

WriteSettingsDrawLinesPanel() {
    INIaction(1, "DrawLineAreaColor", "General")
    INIaction(1, "DrawLineAreaOpacity", "General")
    INIaction(1, "DrawLineAreaKeepBounds", "General")
    INIaction(1, "DrawLineAreaDashStyle", "General")
    INIaction(1, "DrawLineAreaCapsStyle", "General")
    INIaction(1, "DrawLineAreaContourAlign", "General")
    INIaction(1, "DrawLineAreaContourThickness", "General")
    INIaction(1, "DrawLineAreaBorderTop", "General")
    INIaction(1, "DrawLineAreaBorderBottom", "General")
    INIaction(1, "DrawLineAreaBorderLeft", "General")
    INIaction(1, "DrawLineAreaBorderRight", "General")
    INIaction(1, "DrawLineAreaBorderCenter", "General")
    INIaction(1, "DrawLineAreaBorderArcA", "General")
    INIaction(1, "DrawLineAreaBorderArcB", "General")
    INIaction(1, "DrawLineAreaBorderArcC", "General")
    INIaction(1, "DrawLineAreaBorderArcD", "General")
}

updateUIblurPanel() {
    GuiControlGet, blurAreaAmount
    GuiControlGet, blurAreaPixelizeAmount
    GuiControlGet, blurAreaInverted
    GuiControlGet, blurAreaSoftEdges
    GuiControlGet, blurAreaOpacity
    GuiControlGet, blurAreaTwice
    GuiControlGet, blurAreaMode
    If (coreDesiredPixFmt="0x21808")
    {
       blurAreaSoftEdges := 0
       GuiControl, SettingsGUIA: Disable, blurAreaSoftEdges
       GuiControl, SettingsGUIA:, blurAreaSoftEdges, 0
    }

    If (blurAreaSoftEdges=1)
    {
       GuiControl, SettingsGUIA: Disable, blurAreaMode
       GuiControl, SettingsGUIA: Disable, infoPixelize
       GuiControl, SettingsGUIA: Disable, blurAreaPixelizeAmount
    } Else
    {
       GuiControl, SettingsGUIA: Enable, blurAreaMode
       GuiControl, SettingsGUIA: Enable, infoPixelize
       GuiControl, SettingsGUIA: Enable, blurAreaPixelizeAmount
    }

    thisOpacity := Round((blurAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoBlurOpacity, Opacity: %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoBlurAmount, Blur amount: %blurAreaAmount%
    GuiControl, SettingsGUIA:, infoPixelize, Pixelize amount [before blurring]: %blurAreaPixelizeAmount%
    SetTimer, updateUIblurPreview, -50
}

toggleBlurPviewSize() {
   doubleBlurPreviewArea := !doubleBlurPreviewArea
   updateUIblurPanel()
}

updateUIblurPreview() {
    Static uiboxSize := 325
    imgBoxSize := (doubleBlurPreviewArea=1) ? 650 : 325
    WriteSettingsBlurPanel()
    whichBmp := useGdiBitmap()
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
    If !cornersBMP
       Return
   
    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    thisPrevieCoordX := clampInRange(tinyPrevAreaCoordX - imgBoxSize//2, 0, imgW - imgBoxSize)
    thisPrevieCoordY := clampInRange(tinyPrevAreaCoordY - imgBoxSize//2, 0, imgH - imgBoxSize)
    thisBlurMode := (blurAreaSoftEdges=1) ? 1 : blurAreaMode
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    thisOpacity := blurAreaOpacity/255
    thisBlurAmount := (doubleBlurPreviewArea=1) ? blurAreaAmount//2 : blurAreaAmount
    If (thisBlurMode=1)
       bEffect := Gdip_CreateEffect(1, thisBlurAmount, 0, 0)
    Else If (thisBlurMode=2)
       bEffect := Gdip_CreateEffect(1, Round(thisBlurAmount*0.85), 0, 0)

    r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, uiboxSize, uiboxSize, thisPrevieCoordX, thisPrevieCoordY, imgBoxSize, imgBoxSize)
    If pEffect
       Gdip_BitmapApplyEffect(cornersBMP, pEffect)

    zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)
    r1 := trGdip_DrawImage(A_ThisFunc, G, zBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize, uiboxSize, 1, 2, imageAttribs)
    yBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, cornersBMP)

    If (blurAreaPixelizeAmount>1 && blurAreaSoftEdges!=1)
    {
       pixiBMP := trGdip_CreateBitmap(A_ThisFunc, uiboxSize, uiboxSize, "0xE200B")
       QPV_PixelateBitmap(yBitmap, pixiBMP, clampInRange(blurAreaPixelizeAmount, 2, uiboxSize))
       prevBMPu := yBitmap
       yBitmap:= pixiBMP
    }

    If (blurAreaTwice=1)
    {
       xBitmap := trGdip_ResizeBitmap(A_ThisFunc, yBitmap, uiboxSize//2, uiboxSize//2, 1, 3, -1)
       If xBitmap
       {
          prevBMPa := yBitmap
          yBitmap := xBitmap
       }

       If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
          ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
       Else If (thisBlurMode=3)
          QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))
       sF := 2
    } Else sF := 1


    If (bEffect && (thisBlurMode=1 || thisBlurMode=2))
       ApplySpecialFixedBlur(A_ThisFunc, yBitmap, thisBlurAmount, bEffect)
    Else If (thisBlurMode=3)
       QPV_BoxBlurBitmap(yBitmap, Round(thisBlurAmount/2))

    r1 := trGdip_DrawImage(A_ThisFunc, G, yBitmap, 0, 0, uiboxSize, uiboxSize, 0, 0, uiboxSize // sF, uiboxSize // sF, thisOpacity)
    If (r1!="fail")
       hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP)

    SetImage(hCropCornersPic, hBitmap)
    Gdi_DeleteObject(hBitmap)
    Gdip_DeleteGraphics(G)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(yBitmap, 1)
    trGdip_DisposeImage(prevBMPu, 1)
    trGdip_DisposeImage(prevBMPa, 1)
    trGdip_DisposeImage(zBitmap, 1)
    trGdip_DisposeImage(cornersBMP, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(bEffect)
}

updateUIerasePanel(actionu:=0) {
    GuiControlGet, EraseAreaFader
    GuiControlGet, EraseAreaOpacity

    INIaction(1, "EraseAreaOpacity", "General")
    INIaction(1, "EraseAreaFader", "General")
    thisOpacity := Round((EraseAreaOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoEraseOpacity, Opacity: %thisOpacity%`%
    If (EraseAreaFader=1)
    {
       GuiControl, SettingsGUIA: Enable, infoEraseOpacity
       GuiControl, SettingsGUIA: Enable, EraseAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Disable, infoEraseOpacity
       GuiControl, SettingsGUIA: Disable, EraseAreaOpacity
    }

    If (actionu!="noPreview")
       livePreviewsImageEditing(1)
}

BtnEraseSelectedArea() {
  updateUIerasePanel("noPreview")
  GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
  If (closeEditPanelOnApply=1)
     CloseWindow("yes")
  ToggleEditImgSelection("show-edit")
  EraseSelectedArea()
}

BtnBlurSelectedArea() {
  updateUIblurPanel()
  CloseWindow("yes")
  ToggleEditImgSelection("show-edit")
  BlurSelectedArea()
}

updateUIfillPanel(actionu:=0) {
    Static lastInvoked := 1
    GuiControlGet, FillAreaClosedPath
    GuiControlGet, FillAreaBlendMode
    GuiControlGet, FillAreaCurveTension
    GuiControlGet, FillAreaOpacity
    GuiControlGet, FillAreaShape
    GuiControlGet, FillAreaInverted
    GuiControlGet, FillAreaRemBGR
    GuiControlGet, FillAreaDoContour
    GuiControlGet, FillAreaDashStyle
    GuiControlGet, FillAreaRoundedCaps
    GuiControlGet, FillAreaDoubleLine
    GuiControlGet, FillAreaContourAlign
    GuiControlGet, FillAreaContourThickness
    GuiControlGet, FillAreaColorMode
    GuiControlGet, FillAreaColorReversed
    GuiControlGet, FillArea2ndOpacity
    GuiControlGet, FillAreaGradientAngle
    GuiControlGet, FillAreaGradientSigma
    GuiControlGet, FillAreaGradientBlend
    GuiControlGet, FillAreaGradientScale
    GuiControlGet, FillAreaGradientWrapped
    GuiControlGet, FillAreaGlassy
    GuiControlGet, FillAreaLivePreview

    decideCustomShapeStyle()
    If (coreDesiredPixFmt="0x21808")
       FillAreaBlendMode := 1

    thisOpacity := Round((FillAreaOpacity / 255) * 100)
    this2ndOpacity := Round((FillArea2ndOpacity / 255) * 100)
    GuiControl, SettingsGUIA:, infoFillAreaOpacity, %thisOpacity%`%
    GuiControl, SettingsGUIA:, infoFillArea2ndOpacity, %this2ndOpacity%`%
    GuiControl, SettingsGUIA:, infoFillAreaContour, Contour thickness: %FillAreaContourThickness% pixels
    GuiControl, SettingsGUIA:, infoFillAreaSigma, Pos. A: %FillAreaGradientSigma%`%
    GuiControl, SettingsGUIA:, infoFillAreaBlend, Pos. B: %FillAreaGradientBlend%`%
    GuiControl, SettingsGUIA:, infoFillAreaGradientAngle, Angle: %FillAreaGradientAngle%°
    GuiControl, SettingsGUIA:, infoFillAreaGradientScale, Scale: %FillAreaGradientScale%`%
    If (FillAreaDoContour=1)
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode

    If (FillAreaRemBGR=1 || FillAreaDoContour=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaGlassy
       GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode
    } Else
    {
       If (FillAreaDoContour!=1)
       {
          GuiControl, SettingsGUIA: Enable, FillAreaGlassy
          GuiControl, SettingsGUIA: Enable, FillAreaBlendMode
       }

       If (FillAreaGlassy>1)
          GuiControl, SettingsGUIA: Enable, FillAreaLivePreview
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaLivePreview
    }

    actu := (FillAreaColorMode=1 || FillAreaDoContour=1) ? "SettingsGUIA: Disable" : "SettingsGUIA: Enable"
    GuiControl, % actu, FillArea2ndColor
    GuiControl, % actu, infoFillArea2ndOpacity
    GuiControl, % actu, infoFillAreaSigma
    GuiControl, % actu, infoFillAreaBlend
    GuiControl, % actu, infoFillAreaGradientAngle
    GuiControl, % actu, infoFillAreaGradientScale
    GuiControl, % actu, FillAreaGradientAngle
    GuiControl, % actu, FillAreaGradientSigma
    GuiControl, % actu, FillAreaGradientBlend
    GuiControl, % actu, FillAreaGradientScale
    GuiControl, % actu, FillAreaGradientWrapped
    GuiControl, % actu, FillAreaColorReversed
    GuiControl, % actu, FillArea2ndOpacity

    If (FillAreaShape=7)
       GuiControl, SettingsGUIA: Enable, FillAreaCurveTension
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaCurveTension

    If (FillAreaDoContour=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaRemBGR
       GuiControl, SettingsGUIA: Disable, FillAreaColorMode
       GuiControl, SettingsGUIA: Disable, FillAreaInverted
       If (FillAreaShape>=7)
          GuiControl, SettingsGUIA: Enable, FillAreaClosedPath
       Else
          GuiControl, SettingsGUIA: Disable, FillAreaClosedPath
       GuiControl, SettingsGUIA: Enable, FillAreaContourThickness
       GuiControl, SettingsGUIA: Enable, FillAreaRoundedCaps
       GuiControl, SettingsGUIA: Enable, FillAreaDoubleLine
       GuiControl, SettingsGUIA: Enable, infoFillAreaContour
       GuiControl, SettingsGUIA: Enable, FillAreaContourAlign
       GuiControl, SettingsGUIA: Enable, FillAreaDashStyle
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaRemBGR
       GuiControl, SettingsGUIA: Enable, FillAreaInverted
       GuiControl, SettingsGUIA: Enable, FillAreaColorMode
       GuiControl, SettingsGUIA: Disable, FillAreaClosedPath
       GuiControl, SettingsGUIA: Disable, FillAreaDashStyle
       GuiControl, SettingsGUIA: Disable, FillAreaContourAlign
       GuiControl, SettingsGUIA: Disable, FillAreaContourThickness
       GuiControl, SettingsGUIA: Disable, FillAreaRoundedCaps
       GuiControl, SettingsGUIA: Disable, FillAreaDoubleLine
       GuiControl, SettingsGUIA: Disable, infoFillAreaContour
    }

    If (FillAreaDoContour=1 && FillAreaDashStyle>1)
       GuiControl, SettingsGUIA: Enable, FillAreaRoundedCaps
    Else
       GuiControl, SettingsGUIA: Disable, FillAreaRoundedCaps

    If (coreDesiredPixFmt="0x21808")
       GuiControl, SettingsGUIA: Disable, FillAreaBlendMode

    ; ToggleEditImgSelection("show-edit")
    If (actionu!="noPreview") && (A_TickCount - lastInvoked > 45)
    {
       livePreviewsImageEditing(1)
       lastInvoked := A_TickCount
    } Else SetTimer, WriteSettingsFillAreaPanel, -350
}

WriteSettingsFillAreaPanel() {
    If InStr(FillAreaCustomShape, "|")
       INIaction(1, "FillAreaCustomShape", "General")

    INIaction(1, "FillAreaColor", "General")
    INIaction(1, "FillAreaBlendMode", "General")
    INIaction(1, "FillAreaCurveTension", "General")
    INIaction(1, "FillAreaClosedPath", "General")
    INIaction(1, "FillAreaOpacity", "General")
    INIaction(1, "FillAreaShape", "General")
    INIaction(1, "FillAreaInverted", "General")
    INIaction(1, "FillAreaRemBGR", "General")
    INIaction(1, "FillAreaDoContour", "General")
    INIaction(1, "FillAreaDashStyle", "General")
    INIaction(1, "FillAreaRoundedCaps", "General")
    INIaction(1, "FillAreaDoubleLine", "General")
    INIaction(1, "FillAreaContourAlign", "General")
    INIaction(1, "FillAreaContourThickness", "General")
    INIaction(1, "FillAreaColorMode", "General")
    INIaction(1, "FillAreaColorReversed", "General")
    INIaction(1, "FillArea2ndColor", "General")
    INIaction(1, "FillArea2ndOpacity", "General")
    INIaction(1, "FillAreaGradientAngle", "General")
    INIaction(1, "FillAreaGradientSigma", "General")
    INIaction(1, "FillAreaGradientBlend", "General")
    INIaction(1, "FillAreaGradientScale", "General")
    INIaction(1, "FillAreaGradientWrapped", "General")
    INIaction(1, "FillAreaGlassy", "General")
    INIaction(1, "FillAreaLivePreview", "General")
}

BtnFillSelectedArea() {
    updateUIfillPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply

    Sleep, 1
    If (closeEditPanelOnApply=1)
       CloseWindow("yes", 0)
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    FillSelectedArea()
    SetTimer, RemoveTooltip, -250
}


BtnInsertTextSelectedArea() {
    updateUIInsertTextPanel("noPreview")
    GuiControlGet, closeEditPanelOnApply, SettingsGUIA:, closeEditPanelOnApply
    Sleep, 1
    If (closeEditPanelOnApply=1)
       CloseWindow("yes")
    ; Sleep, 1
    ToggleEditImgSelection("show-edit")
    InsertTextSelectedArea()
    SetTimer, RemoveTooltip, -250
}

BtnViewedImages2List() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (userSeenSlideImages<3)
      Return

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   CloseWindow("yes")
   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-current-session.SLD"
   For Key, Value in userSeenSessionImagesArray
       resultedFilesList[A_Index] := [Value]
   SLDtypeLoaded := 2
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   RandomPicture()
}

BtnALLviewedImages2List(dummy:=0) {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   CloseWindow("yes")
   startOperation := A_TickCount
   backCurrentSLD := CurrentSLD
   CurrentSLD := ""
   showTOOLtip("Gathering seen images list, please wait")
   setImageLoading()
   friendly := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : "ALL"
   dummy := InStr(dummy, "|filteru|") ? StrReplace(dummy, "|filteru|") : ""
   seenEntries := retrieveEntireSeenImagesDB(totalSeenIMGs, 1, dummy)
   If (totalSeenIMGs<3)
   {
      SetTimer, ResetImgLoadStatus, -50
      CurrentSLD := backCurrentSLD
      If (SLDtypeLoaded=3)
         activeSQLdb.Exec("COMMIT TRANSACTION;")
      showTOOLtip("Found no already seen images in the database...")
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   If (SLDtypeLoaded=3)
      activeSQLdb.CloseDB()

   AnyWindowOpen := 100
   resetMainWin2Welcome()
   AnyWindowOpen := 0
   CurrentSLD := mainCompiledPath "\viewed-images-history-" friendly ".SLD"
   Loop, % seenEntries.Count()
       resultedFilesList[A_Index] := [seenEntries[A_Index],,1]
   SLDtypeLoaded := 2
   seenEntries := []
   maxFilesIndex := resultedFilesList.Count()
   GenerateRandyList()
   etaTime := "Elapsed time to retrieve seen images list from the database:`n" SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
   addJournalEntry(etaTime)
   RandomPicture()
}

PanelJournalWindow(tabu:=1) {
    If (AnyWindowOpen=1)
       CloseWindow()

    thisBtnHeight := createSettingsGUI(33, A_ThisFunc)
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 40
       Gui, Font, s%LargeUIfontValue%
    }

    txtWid := Round(editWid*6.25)
    totalIndex := QPVjournal.Count()
    For Key, Value in QPVjournal
    {
        currentEntry := totalIndex - A_Index
        line := Trimmer(Value)
        If line
           textList .= "(" currentEntry ") " Trimmer(line) "`n`n"
    }

    userSeenSlideImages := userSeenSessionImagesArray.Count()
    If (skipSeenImagesSlider=1)
    {
       choosu := (tabu=2) ? "||" : ""
       Gui, Add, Tab3,, Journal|Seen images database options%choosu%
       Gui, Tab, 1
       Gui, Add, Button, x+15 y+15 w1 h1 gBtnCloseWindow Default, Clo&se
    } Else
       Gui, Add, Button, x15 y15 w1 h1 gBtnCloseWindow Default, Clo&se

    Gui, Add, Edit, x+1 y+1 Section ReadOnly w%txtWid% r15, % "WinTitle: " pVwinTitle "`n`n" textList
       ; Gui, Add, Button, xs y+2 h%thisBtnHeight% gPanelSeenIMGsOptions, &Seen images database options

    If (skipSeenImagesSlider=1)
    {
       Gui, Tab, 2
       Gui, Add, Button, x+15 y+15 Section h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.

       Gui, Add, Button, xs y+15 h%thisBtnHeight% gBtnALLviewedImages2List, &Retrieve list of all recorded seen images
       Gui, Add, Button, y+5 hp wp gCleanDeadFilesSeenImagesDB, &Purge inexistent files from the list
       Gui, Add, Button, y+5 hp wp geraseSeenIMGsDB, &Erase the entire list
       Gui, Add, Button, y+5 hp wp gPanelSeenStats, &Seen images statistics
       Gui, Add, Text, y+5 wp, TIP: To retrieve the images seen on a given day or month, open the statistics panel.
    } Else
    {
       Gui, Add, Button, xp y+2 h%thisBtnHeight% gBtnViewedImages2List, &View list
       Gui, Add, Text, x+5 yp hp +0x200, Images viewed in this session: %userSeenSlideImages%.
    }

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Application journal: " appTitle)
    SetTimer, ResetImgLoadStatus, -100
}

PanelSeenIMGsOptions() {
    PanelJournalWindow(2)
    Return
}

ReadSettingsTextInArea() {
    INIaction(0, "TextInAreaAlign", "General")
    INIaction(0, "TextInAreaLineAngle", "General")
    INIaction(0, "TextInAreaCharSpacing", "General")
    INIaction(0, "TextInAreaValign", "General")
    INIaction(0, "TextInAreaBlurAmount", "General")
    INIaction(0, "TextInAreaBlurBorderAmount", "General")
    INIaction(0, "TextInAreaUsrMarginz", "General")
    INIaction(0, "TextInAreaBgrColor", "General")
    INIaction(0, "TextInAreaBgrEntire", "General")
    INIaction(0, "TextInAreaBgrUnified", "General")
    INIaction(0, "TextInAreaCutOutMode", "General")
    INIaction(0, "TextInAreaBgrOpacity", "General")
    INIaction(0, "TextInAreaBorderSize", "General")
    INIaction(0, "TextInAreaBorderOut", "General")
    INIaction(0, "TextInAreaBorderColor", "General")
    INIaction(0, "TextInAreaBorderOpacity", "General")
    INIaction(0, "TextInAreaFontBold", "General")
    INIaction(0, "TextInAreaFontColor", "General")
    INIaction(0, "TextInAreaFontItalic", "General")
    INIaction(0, "TextInAreaFontName", "General")
    INIaction(0, "TextInAreaFontLineSpacing", "General")
    INIaction(0, "TextInAreaFontOpacity", "General")
    INIaction(0, "TextInAreaFontSize", "General")
    INIaction(0, "TextInAreaFontStrike", "General")
    INIaction(0, "TextInAreaFontUline", "General")
    INIaction(0, "TextInAreaOnlyBorder", "General")
    INIaction(0, "TextInAreaPaintBgr", "General")
    INIaction(0, "TextInAreaRoundBoxBgr", "General")
    INIaction(0, "TextInAreaLivePreview", "General")
    INIaction(0, "TextInAreaAutoWrap", "General")
}

PanelInsertTextArea() {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(32, A_ThisFunc)
    ReadSettingsTextInArea()
    btnWid := 100
    txtWid := 350
    columnBpos := 190
    slideWid := 150
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos := columnBpos + 85
       slideWid := slideWid + 55
       EditWid := EditWid + 40
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    ddWid := Round(editWid*3.25)
    txtWid := Round(editWid*6.25)
    EllipseSelectMode := 0

    Global editF1, editF2, editF3, editF4, editF5, editF6,  editF7, editF8, editF9, editF10, editF11
         , editF12, PickuTextInAreaFontColor, PickuTextInAreaBgrColor, PickuTextInAreaBorderColor

    Gui, Add, Tab3,, Text|Styling|Colors
    Gui, Tab, 1
    Gui, Add, Edit, x+15 y+15 Section w%txtWid% r10 gupdateUIInsertTextPanel vUserTextArea, % UserTextArea
    Gui, Add, Text, , Font name:
    Gui, Add, DropDownList, x+5 w%ddWid% Sort Choose1 gupdateUIInsertTextPanel vTextInAreaFontName, % TextInAreaFontName
    Gui, Add, Checkbox, x+5 gupdateUIInsertTextPanel Checked%TextInAreaAutoWrap% vTextInAreaAutoWrap, Auto line wrapping

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15 Section, Line angle / letter spacing
    Gui, Add, Text, xs yp+30, Font size / leading / margins
    Gui, Add, Text, xs yp+30, Text alignment and style 
    Gui, Add, Text, xs yp+30, Border style / thickness
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaDoBlurs% vTextInAreaDoBlurs, Blur amount for text / outline
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaPaintBgr% vTextInAreaPaintBgr, Draw background

    Gui, Add, Edit, xs+%columnBpos% ys+0 Section w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF11, % TextInAreaLineAngle
    Gui, Add, UpDown, vTextInAreaLineAngle Range-900-900, % TextInAreaLineAngle
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit4 -multi -wantCtrlA -wantTab -wrap veditF12, % TextInAreaCharSpacing
    Gui, Add, UpDown, vTextInAreaCharSpacing Range-100-255, % TextInAreaCharSpacing

    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF1 , % TextInAreaFontSize
    Gui, Add, UpDown, vTextInAreaFontSize Range5-950, % TextInAreaFontSize
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit4 -multi -wantCtrlA -wantTab -wrap veditF9, % TextInAreaFontLineSpacing
    Gui, Add, UpDown, vTextInAreaFontLineSpacing Range-950-950, % TextInAreaFontLineSpacing
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF10, % TextInAreaUsrMarginz
    Gui, Add, UpDown, vTextInAreaUsrMarginz Range0-500, % TextInAreaUsrMarginz

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Choose%TextInAreaAlign% AltSubmit vTextInAreaAlign, Left|Center|Right
    Gui, Add, DropDownList, x+2 wp gupdateUIInsertTextPanel Choose%TextInAreaValign% AltSubmit vTextInAreaValign, Top|Center|Bottom
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontBold% vTextInAreaFontBold, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontItalic% vTextInAreaFontItalic, I
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontUline% vTextInAreaFontUline, U
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIInsertTextPanel Checked%TextInAreaFontStrike% vTextInAreaFontStrike, S

    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIInsertTextPanel Altsubmit Choose%TextInAreaBorderOut% vTextInAreaBorderOut, None|Center|Outset
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIInsertTextPanel limit3 -multi number -wantCtrlA -wantTab -wrap veditF2, % TextInAreaBorderSize
    Gui, Add, UpDown, vTextInAreaBorderSize Range1-650, % TextInAreaBorderSize
    Gui, Add, Checkbox, x+2 hp gupdateUIInsertTextPanel Checked%TextInAreaOnlyBorder% vTextInAreaOnlyBorder, Only outline

    Gui, Add, Edit, xs yp+30 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF6, % TextInAreaBlurAmount
    Gui, Add, UpDown, vTextInAreaBlurAmount Range1-255, % TextInAreaBlurAmount
    Gui, Add, Edit, x+2 w%editWid% gupdateUIInsertTextPanel r1 limit3 -multi number -wantCtrlA -wantTab -wrap veditF8, % TextInAreaBlurBorderAmount
    Gui, Add, UpDown, vTextInAreaBlurBorderAmount Range1-255, % TextInAreaBlurBorderAmount

    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaBgrUnified% vTextInAreaBgrUnified, Unified
    Gui, Add, Checkbox, x+3 yp hp gupdateUIInsertTextPanel Checked%TextInAreaRoundBoxBgr% vTextInAreaRoundBoxBgr, Rounded
    Gui, Add, Checkbox, xs yp+30 gupdateUIInsertTextPanel Checked%TextInAreaCutOutMode% vTextInAreaCutOutMode, Cut-out mode
    Gui, Add, Checkbox, x+3 gupdateUIInsertTextPanel Checked%TextInAreaBgrEntire% vTextInAreaBgrEntire, Fill entire line(s)

    Gui, Tab, 3
    Gui, Add, Text, x+15 y+15 Section, Text opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaFontOpacity Range1-255, % TextInAreaFontOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaFontColor% vTextInAreaFontColor hwndhLV3,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaFontColor, P

    Gui, Add, Text, xs y+20, Border opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBorderOpacity Range1-255, % TextInAreaBorderOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBorderColor% vTextInAreaBorderColor hwndhLV45,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBorderColor, P

    Gui, Add, Text, xs y+20, Background opacity / color
    Gui, Add, Slider, xs+20 y+10 NoTicks w%slideWid% gupdateUIInsertTextPanel ToolTip AltSubmit vTextInAreaBgrOpacity Range1-255, % TextInAreaBgrOpacity
    Gui, Add, ListView, x+2 w%editWid% hp gupdateUIInsertTextPanel %CCLVO% Background%TextInAreaBgrColor% vTextInAreaBgrColor hwndhLV2,
    Gui, Add, Button, x+2 hp w27 gStartPickingColor vPickuTextInAreaBgrColor, P

    Gui, Tab
    Gui, Add, Button, xm+0 y+15 h%thisBtnHeight% w35 gtoggleImgEditPanelWindow, ▲
    Gui, Add, Button, x+5 w%btnWid% hp Default gapplyIMGeditFunction, &Apply
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, &Cancel
    Gui, Add, Checkbox, x+5 hp Checked%TextInAreaLivePreview% vTextInAreaLivePreview gupdateUIInsertTextPanel, Live preview (low quality)
    Gui, Add, Checkbox, xm+0 y+5 Checked%closeEditPanelOnApply% vcloseEditPanelOnApply gToggleClosePanelApply, Close window after «Apply»

    PopulateFontsList("TextInAreaFontName", "SettingsGUIA")
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Insert text into selected area: " appTitle, winPos)
    SetTimer, updateUIInsertTextPanel, -250
}

PopulateFontsList(thisCtrl, guiu) {
    If !FontList._NewEnum()[k, v]
    {
       Fnt_GetListOfFonts()
       FontList := trimArray(FontList)
    }

    Loop, % FontList.Count()
    {
        fontNameInstalled := FontList[A_Index]
        If (fontNameInstalled ~= "i)(@|biz ud|ud digi kyo|oem|extb|symbol|marlett|wst_|glyph|reference specialty|system|terminal|mt extra|small fonts|cambria math|this font is not|fixedsys|emoji|hksc| mdl|wingdings|webdings)") || (fontNameInstalled=OSDFontName)
           Continue
        GuiControl, %guiu%:, %thisCtrl%, %fontNameInstalled%
    }
}

updateUIInsertTextPanel(actionu:=0) {
    GuiControlGet, TextInAreaAlign
    GuiControlGet, TextInAreaAutoWrap
    GuiControlGet, TextInAreaValign
    GuiControlGet, TextInAreaBlurAmount
    GuiControlGet, TextInAreaBlurBorderAmount
    GuiControlGet, TextInAreaDoBlurs
    GuiControlGet, TextInAreaUsrMarginz
    GuiControlGet, TextInAreaBgrOpacity
    GuiControlGet, TextInAreaBgrEntire
    GuiControlGet, TextInAreaBgrUnified
    GuiControlGet, TextInAreaFontLineSpacing
    GuiControlGet, TextInAreaCharSpacing
    GuiControlGet, TextInAreaCutOutMode
    GuiControlGet, TextInAreaBorderSize
    GuiControlGet, TextInAreaBorderOut
    GuiControlGet, TextInAreaBorderOpacity
    GuiControlGet, TextInAreaFontBold
    GuiControlGet, TextInAreaFontItalic
    GuiControlGet, TextInAreaFontName
    GuiControlGet, TextInAreaFontOpacity
    GuiControlGet, TextInAreaFontSize
    GuiControlGet, TextInAreaFontUline
    GuiControlGet, TextInAreaFontStrike
    GuiControlGet, TextInAreaOnlyBorder
    GuiControlGet, TextInAreaPaintBgr
    GuiControlGet, TextInAreaLineAngle
    GuiControlGet, TextInAreaRoundBoxBgr
    GuiControlGet, TextInAreaLivePreview
    GuiControlGet, UserTextArea

    If !isNumber(TextInAreaFontLineSpacing)
       TextInAreaFontLineSpacing := 0

    If (TextInAreaBorderSize>=TextInAreaFontSize*2)
       TextInAreaBorderSize := TextInAreaFontSize*2

    GuiControl, SettingsGUIA:, infoTextBlur, Blur amount: %TextInAreaBlurAmount%
    If (TextInAreaPaintBgr=1)
    {
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrOpacity
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrColor
       GuiControl, SettingsGUIA: Enable, PickuTextInAreaBgrColor
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrUnified
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Enable, TextInAreaCutOutMode
    } Else
    {
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrUnified
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Disable, TextInAreaCutOutMode
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrOpacity
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrColor
       GuiControl, SettingsGUIA: Disable, PickuTextInAreaBgrColor
    }

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified!=1)
    {
       GuiControl, SettingsGUIA: Enable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Enable, TextInAreaCutOutMode
    } Else
    {
       GuiControl, SettingsGUIA: Disable, TextInAreaBgrEntire
       GuiControl, SettingsGUIA: Disable, TextInAreaCutOutMode
    }

    If (TextInAreaBorderOut>1)
    {
       GuiControl, SettingsGUIA: Enable, editF7
       GuiControl, SettingsGUIA: Enable, editF2
       GuiControl, SettingsGUIA: Enable, TextInAreaBorderSize
       GuiControl, SettingsGUIA: Enable, TextInAreaBorderColor
       GuiControl, SettingsGUIA: Enable, TextInAreaBorderOpacity
       GuiControl, SettingsGUIA: Enable, TextInAreaBlurBorderAmount
       GuiControl, SettingsGUIA: Enable, PickuTextInAreaBorderColor
       GuiControl, SettingsGUIA: Enable, TextInAreaOnlyBorder
    } Else
    {
       GuiControl, SettingsGUIA: Disable, editF7
       GuiControl, SettingsGUIA: Disable, editF2
       GuiControl, SettingsGUIA: Disable, TextInAreaBorderSize
       GuiControl, SettingsGUIA: Disable, TextInAreaBorderColor
       GuiControl, SettingsGUIA: Disable, TextInAreaBorderOpacity
       GuiControl, SettingsGUIA: Disable, TextInAreaBlurBorderAmount
       GuiControl, SettingsGUIA: Disable, PickuTextInAreaBorderColor
       GuiControl, SettingsGUIA: Disable, TextInAreaOnlyBorder
    }

    If (TextInAreaPaintBgr=1 && TextInAreaBgrUnified=1)
       GuiControl, SettingsGUIA: Enable, TextInAreaRoundBoxBgr
    Else
       GuiControl, SettingsGUIA: Disable, TextInAreaRoundBoxBgr

    SetTimer, WriteSettingsTextAreaPanel, -300
    If (actionu!="noPreview" && TextInAreaLivePreview=1)
       livePreviewsImageEditing(1)
}

WriteSettingsTextAreaPanel() {
    INIaction(1, "TextInAreaAlign", "General")
    INIaction(1, "TextInAreaAutoWrap", "General")
    INIaction(1, "TextInAreaLineAngle", "General")
    INIaction(1, "TextInAreaCharSpacing", "General")
    INIaction(1, "TextInAreaValign", "General")
    INIaction(1, "TextInAreaBlurAmount", "General")
    INIaction(1, "TextInAreaBlurBorderAmount", "General")
    INIaction(1, "TextInAreaUsrMarginz", "General")
    INIaction(1, "TextInAreaBgrColor", "General")
    INIaction(1, "TextInAreaBgrEntire", "General")
    INIaction(1, "TextInAreaBgrUnified", "General")
    INIaction(1, "TextInAreaCutOutMode", "General")
    INIaction(1, "TextInAreaBgrOpacity", "General")
    INIaction(1, "TextInAreaBorderSize", "General")
    INIaction(1, "TextInAreaBorderOut", "General")
    INIaction(1, "TextInAreaBorderColor", "General")
    INIaction(1, "TextInAreaBorderOpacity", "General")
    INIaction(1, "TextInAreaFontBold", "General")
    INIaction(1, "TextInAreaFontColor", "General")
    INIaction(1, "TextInAreaFontItalic", "General")
    INIaction(1, "TextInAreaFontName", "General")
    INIaction(1, "TextInAreaFontOpacity", "General")
    INIaction(1, "TextInAreaFontSize", "General")
    INIaction(1, "TextInAreaFontStrike", "General")
    INIaction(1, "TextInAreaFontUline", "General")
    INIaction(1, "TextInAreaFontLineSpacing", "General")
    INIaction(1, "TextInAreaOnlyBorder", "General")
    INIaction(1, "TextInAreaPaintBgr", "General")
    INIaction(1, "TextInAreaRoundBoxBgr", "General")
    INIaction(1, "TextInAreaLivePreview", "General")
}

openPrefsPanelWindow() {
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(14, A_ThisFunc)
    btnWid := 100
    txtWid := 350
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    Global editF4, editF5, editF6, PickuWindowBGRcolor, PickuOSDbgrColor, PickuOSDtextColor

    Gui, Add, Text, x15 y15 w%txtWid%, The text style options apply to the On-Screen Display in the viewport. The same text style is used to render as images texts pasted from the clipboard.
    Gui, Add, Text, y+15 Section, Font name
    Gui, Add, Text, xs yp+30, Font size (OSD / clipboard)
    Gui, Add, Text, xs yp+30, Text color and style
    Gui, Add, Text, xs yp+30, Alignment (captions / paste)
    Gui, Add, Text, xs yp+30, OSD background color
    Gui, Add, Text, xs yp+30, Display time (in sec.)
    Gui, Add, Text, xs yp+30, Window background color

    Gui, Add, DropDownList, xs+%columnBpos2% ys+0 Section w190 gupdateUIsettings Sort Choose1 vOSDFontName, %OSDFontName%
    Gui, Add, Edit, xs+0 yp+30 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF5, %OSDfntSize%
    Gui, Add, UpDown, vOSDfntSize Range10-350, %OSDfntSize%
    Gui, Add, Edit, x+2 w%editWid% r1 gupdateUIsettings limit3 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF4, %PasteFntSize%
    Gui, Add, UpDown, vPasteFntSize Range12-350, %PasteFntSize%

    Gui, Add, ListView, xs yp+30 w%editWid% h28 %CCLVO% Background%OSDtextColor% vOSDtextColor hwndhLV1,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDtextColor, P
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontBolded% vFontBolded, B
    Gui, Add, Checkbox, x+2 yp hp w27 +0x1000 gupdateUIsettings Checked%FontItalica% vFontItalica, I
    Gui, Add, DropDownList, xs yp+30 w%editWid% gupdateUIsettings vusrTextAlign, %usrTextAlign%||Left|Right|Center
    Gui, Add, ListView,  xs+0 yp+30 gupdateUIsettings w%editWid% hp %CCLVO% Background%OSDbgrColor% vOSDbgrColor hwndhLV2,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuOSDbgrColor, P
    Gui, Add, Edit, xs+0 yp+30 gupdateUIsettings w%editWid% hp r1 limit2 -multi number -wantCtrlA -wantReturn -wantTab -wrap veditF6, %DisplayTimeUser%
    Gui, Add, UpDown, vDisplayTimeUser Range1-99, %DisplayTimeUser%
    Gui, Add, ListView, xs+0 yp+30 w%editWid% hp %CCLVO% Background%WindowBGRcolor% vWindowBGRcolor hwndhLV3,
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuWindowBGRcolor, P
    Gui, Add, Checkbox, x15 y+10 gupdateUIsettings Checked%borderAroundImage% vborderAroundImage, Highlight image borders in the viewport

    PopulateFontsList("OSDFontName", "SettingsGUIA")
    Gui, Add, Button, xm+0 y+20 h%thisBtnHeight% w%btnWid% gOpenUImenu, &More options
    Gui, Add, Button, x+5 hp w90 gPrefsCloseBTN Default, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Interface settings: " appTitle)
}

PanelAdjustToneMapping() {
    If AnyWindowOpen
       Return

    IniAction(0, "cmrRAWtoneMapAlgo", "General")
    IniAction(0, "cmrRAWtoneMapParamA", "General")
    IniAction(0, "cmrRAWtoneMapParamB", "General")
    thisBtnHeight := createSettingsGUI(42, A_ThisFunc)
    btnWid := 100
    txtWid := 500
    columnBpos2 := 205
    EditWid := 60
    If (PrefsLargeFonts=1)
    {
       columnBpos2 := columnBpos2 + 50
       EditWid := EditWid + 50
       btnWid := btnWid + 70
       txtWid := txtWid + 20
       Gui, Font, s%LargeUIfontValue%
    }

   If (cmrRAWtoneMapAlgo=1)
   {
      prcA := cmrRAWtoneMapParamA/9.9
      paramA := Round(200*prcA)
      prcB := (cmrRAWtoneMapParamB + 8)/16
      paramB := Round(200*prcB)
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      prcA := (cmrRAWtoneMapParamA + 8)/16
      paramA := Round(200*prcA)
      paramB := 200*cmrRAWtoneMapParamB
   } Else If (cmrRAWtoneMapAlgo=3)
   {
      paramA := 200*cmrRAWtoneMapParamA
      paramB := 200*cmrRAWtoneMapParamB
   }

    showTOOLtip("Initializing tone-mapping panel, please wait...")
    Global SliderA, SliderB, infoSliderA, infoSliderB
    Gui, -DPIScale
    Gui, Add, Text, x15 y15 w460 h320 +0x1000 +0xE +hwndhLVmainu, Image before 
    Gui, Add, Text, x480 y15 w460 h320 +0x1000 +0xE +hwndhCropCornersPic, Image after
    ; Gui, Add, Text, xp-480 y+1 w2 h2 +0x1000 +0xE, -
    Gui, +DPIScale
    Gui, Add, Text, x15 y+10 Section w%txtWid%, High-dynamic range images (HDRIs) must be converted to 32 bits to be displayed on screen. You can choose the algorithm to use for this and also configure it.
    Gui, Add, DropDownList, xs y+10 w%txtWid% AltSubmit gupdateUItoneMappingPanel Choose%cmrRAWtoneMapAlgo% vcmrRAWtoneMapAlgo, Adaptive logarithmic mapping (F. Drago, 2003)|HDR reduction inspired by photoreceptors physiology (E. Reinhard, 2005)|Gradient domain HDR compression (R. Fattal, 2002)
    Gui, Add, Text, xs y+10 wp vinfoSliderA, ParamA
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderA Range1-200, % ParamA
    Gui, Add, Text, xs y+10 wp vinfoSliderB, ParamB
    Gui, Add, Slider, xs y+5 wp gupdateUItoneMappingPanel AltSubmit ToolTip NoTicks vsliderB Range1-200, % ParamB
    friendly := (PrefsLargeFonts=1) ? "`n" : ""
    Gui, Add, Checkbox, xs y+10 gupdateUItoneMappingPanel Checked%userHQraw% vuserHQraw, Load camera RAW images at high quality`nEnable this to have tone-mapping apply%friendly%on RAW images as well

    initializeFimPreviewIMG(getIDimage(currentFileIndex))
    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid% gBTNtoneMapRefresh Default, &Update viewport
    Gui, Add, Button, x+5 hp w90 gBTNresetToneMap, &Reset
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, Clo&se
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "HDR tone-mapping options: " appTitle)
    RemoveTooltip()
    SetTimer, updateUItoneMappingPanel, -350
}

initializeFimPreviewIMG(imgPath) {
  Static uiBoxW := 460, uiBoxH := 320
  initFIMGmodule()
  If !wasInitFIMlib
     Return 0

  tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, "0xE200B")
  If !tempBMP
     Return 0

  Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
  If !Gu
  {
     trGdip_DisposeImage(tempBMP, 1)
     Return 0
  }

  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
  thisX := uiBoxW//2 - thisW//2
  thisY := uiBoxH//2 - thisH//2
  Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
  r1 := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), thisX, thisY, thisW, thisH)
  hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
  SetImage(hLVmainu, hBitmap)
  Gdi_DeleteObject(hBitmap)
  trGdip_DisposeImage(tempBMP, 1)
  Gdip_DeleteGraphics(Gu)

  If globalhFIFimg
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
  }

  loadArgs := 0
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := 0
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
  If hFIFimgA
  {
     FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
     calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
     hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, 0)
  }

  If !hFIFimgB
  {
     FreeImage_UnLoad(globalhFIFimg)
     globalhFIFimg := ""
     Return 0
  }

  globalhFIFimg := hFIFimgB ? hFIFimgB : 0
  If !globalhFIFimg
     Return 0
  Else
     Return 1
}

updateUIfimToneMappedIMG() {
   Static uiBoxW := 460, uiBoxH := 320
   hFIFimgE := FreeImage_ToneMapping(globalhFIFimg, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
   imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgE), "-"))
   If (imgBPPc!=32)
      hFIFimgD := FreeImage_ConvertTo(hFIFimgE, "32Bits")

   hFIFimgZ := hFIFimgD ? hFIFimgD : hFIFimgE
   pBitmap := ConvertFIMtoPBITMAP(hFIFimgZ)

   tempBMP := trGdip_CreateBitmap(A_ThisFunc, uiBoxW, uiBoxH, "0xE200B")
   If !tempBMP
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, tempBMP, 3)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      trGdip_DisposeImage(tempBMP, 1)
      Return
   }

   Gdip_GetImageDimensions(pBitmap, imgW, imgH)
   calcIMGdimensions(imgW, imgH, uiBoxW, uiBoxH, thisW, thisH)
   thisX := uiBoxW//2 - thisW//2
   thisY := uiBoxH//2 - thisH//2
   Gdip_FillRectangle(Gu, pBrushHatchLow, -2, -2, uiBoxW + 3, uiBoxH + 3)
   r1 := trGdip_DrawImage(A_ThisFunc, Gu, pBitmap, thisX, thisY, thisW, thisH)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, tempBMP)
   SetImage(hCropCornersPic, hBitmap)
   Gdi_DeleteObject(hBitmap)
   trGdip_DisposeImage(tempBMP, 1)
   Gdip_DeleteGraphics(Gu)
   trGdip_DisposeImage(pBitmap, 1)

   FreeImage_UnLoad(hFIFimgE)
   If hFIFimgD
      FreeImage_UnLoad(hFIFimgD)
}

BTNtoneMapRefresh() {
   updateUItoneMappingPanel()
   discardViewPortCaches()
   disposeCacheIMGs()
   RefreshImageFileAction()
}

BTNresetToneMap() {
   GuiControl, SettingsGUIA: Choose, cmrRAWtoneMapAlgo, 1
   GuiControl, SettingsGUIA:, SliderA, 38
   GuiControl, SettingsGUIA:, SliderB, 100
   Sleep, 1
   updateUItoneMappingPanel()
}

updateUItoneMappingPanel() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<100)
   {
      SetTimer, updateUItoneMappingPanel, -350
      Return
   }

   Gui, SettingsGUIA: Default
   GuiControlGet, cmrRAWtoneMapAlgo
   GuiControlGet, SliderA
   GuiControlGet, SliderB
   GuiControlGet, userHQraw
   prcA := SliderA/200
   prcB := SliderB/200
   If (cmrRAWtoneMapAlgo=1)
   {
      cmrRAWtoneMapParamA := 9.9*prcA
      GuiControl, SettingsGUIA:, infoSliderA, Gamma: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := 16*prcB - 8
      GuiControl, SettingsGUIA:, infoSliderB, Exposure: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=2)
   {
      cmrRAWtoneMapParamA := 16*prcA - 8
      GuiControl, SettingsGUIA:, infoSliderA, Intensity: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Contrast: %cmrRAWtoneMapParamB%
   } Else If (cmrRAWtoneMapAlgo=3)
   {
      cmrRAWtoneMapParamA := prcA
      GuiControl, SettingsGUIA:, infoSliderA, Saturation: %cmrRAWtoneMapParamA%
      cmrRAWtoneMapParamB := prcB
      GuiControl, SettingsGUIA:, infoSliderB, Attenuation: %cmrRAWtoneMapParamB%
   }
   updateUIfimToneMappedIMG()
   IniAction(1, "cmrRAWtoneMapAlgo", "General")
   IniAction(1, "cmrRAWtoneMapParamA", "General")
   IniAction(1, "cmrRAWtoneMapParamB", "General")
   lastInvoked := A_TickCount
}

updateUIsettings() {
     If (AnyWindowOpen!=14)
        Return

     GuiControlGet, DisplayTimeUser
     GuiControlGet, OSDFontName
     GuiControlGet, OSDfntSize
     GuiControlGet, PasteFntSize
     GuiControlGet, FontBolded
     GuiControlGet, FontItalica
     GuiControlGet, usrTextAlign
     GuiControlGet, borderAroundImage

     calcHUDsize()
     msgDisplayTime := DisplayTimeUser*1000
     SetTimer, WriteSettingsUI, -90
}

WriteSettingsUI() {
  INIaction(1, "DisplayTimeUser", "General")
  INIaction(1, "OSDFontName", "General")
  INIaction(1, "WindowBgrColor", "General")
  INIaction(1, "OSDbgrColor", "General")
  INIaction(1, "OSDtextColor", "General")
  INIaction(1, "OSDfntSize", "General")
  INIaction(1, "PasteFntSize", "General")
  INIaction(1, "FontBolded", "General")
  INIaction(1, "FontItalica", "General")
  INIaction(1, "usrTextAlign", "General")
  INIaction(1, "borderAroundImage", "General")
}

PrefsCloseBTN() {
     updateUIsettings()
     interfaceThread.ahkFunction("updateWindowColor")
     CloseWindow()
}

SetUIcolors(hC, event, c, err=0) {
; Function by Drugwash
; Critical MUST be disabled below! If that's not done, script will enter a deadlock !
  Static
  If (event="RightClick")
  {
     mouseTurnOFFtooltip()
     StartPickingColor()
     SetTimer, mouseTurnOFFtooltip, -50
     Return
  } Else If (event!="Normal")
     Return

  oc := A_IsCritical
  Critical, Off

  ; ToolTip, % event , , , 2
  g := A_Gui, ctrl := A_GuiControl
  r := %ctrl% := hexRGB(Dlg_Color(%ctrl%, hC))
  Critical, %oc%
  GuiControl, %g%:+Background%r%, %ctrl%
  INIaction(1, ctrl, "General")
  If (AnyWindowOpen=14)
  {
     interfaceThread.ahkFunction("updateWindowColor")
     updateUIsettings()
     refreshWinBGRbrush()
     dummyTimerDelayiedImageDisplay(50)
  } Else If (imgEditPanelOpened=1)
     livePreviewsImageEditing(1)
}

hexRGB(c) {
; unknown source
  r := ((c&255)<<16)+(c&65280)+((c&0xFF0000)>>16)
  c := "000000"
  DllCall("msvcrt\sprintf", "AStr", c, "AStr", "%06X", "UInt", r, "CDecl")
  Return c
}

Hex2Str(val, len, x:=false, caps:=true) {
; Function by Drugwash
    VarSetCapacity(out, (len+1)*2, 32), c := caps ? "X" : "x"
    DllCall("msvcrt\sprintf", "AStr", out, "AStr", "%0" len "ll" c, "UInt64", val, "CDecl")
    Result := x ? "0x" out : out
    Return Result
}

getCustomColorsFromImage(whichBitmap) {
  Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
  calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
  c := []
  c[1] := Gdip_GetPixelColor(whichBitmap, X1, Y1, 3)
  c[2] := Gdip_GetPixelColor(whichBitmap, X2, Y2, 3)
  c[3] := Gdip_GetPixelColor(whichBitmap, X1, Y2, 3)
  c[4] := Gdip_GetPixelColor(whichBitmap, X2, Y1, 3)
  c[5] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1 + imgSelH//2, 3)
  c[6] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2, Y1, 3)
  c[7] := Gdip_GetPixelColor(whichBitmap, X1, Y1 + imgSelH//2, 3)
  c[8] := Gdip_GetPixelColor(whichBitmap, X2, Y2 - imgSelH//2, 3)
  c[9] := Gdip_GetPixelColor(whichBitmap, X2 - imgSelW//2, Y2, 3)
  c[10] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//4, Y1 + imgSelH//4, 3)
  c[11] := Gdip_GetPixelColor(whichBitmap, X1 + imgSelW//2 + imgSelW//4, Y1 + imgSelH//2 + imgSelH//4, 3)
  c[12] := Gdip_GetPixelColor(whichBitmap, 1, 1, 3)
  c[13] := Gdip_GetPixelColor(whichBitmap, 1, imgH - 1, 3)
  c[14] := Gdip_GetPixelColor(whichBitmap, imgW - 1, imgH - 1, 3)
  c[15] := Gdip_GetPixelColor(whichBitmap, imgW - 1, 1, 3)
  c[16] := Gdip_GetPixelColor(whichBitmap, imgW//2, imgH//2, 3)
  Return c
}

Dlg_Color(Color,hwnd) {
; Function by maestrith 
; from: [AHK 1.1] Font and Color Dialogs 
; https://autohotkey.com/board/topic/94083-ahk-11-font-and-color-dialogs/
; Modified by Marius Șucan and Drugwash


  VarSetCapacity(CUSTOM,64,0)
  size := VarSetCapacity(CHOOSECOLOR,9*A_PtrSize,0)

  cclrs := getCustomColorsFromImage(useGdiBitmap())
  Loop, 16
  {
     ; BGR HEX
 ;    thisColor := "0x" SubStr(cclrs[A_Index], -1) SubStr(cclrs[A_Index], 7, 2) SubStr(cclrs[A_Index], 5, 2)
     NumPut(cclrs[A_Index], &CUSTOM, (A_Index-1)*4, "UInt")
  }

  oldColor := Color
  Color := "0x" hexRGB(InStr(Color, "0x") ? Color : Color ? "0x" Color : 0x0)
  NumPut(size,CHOOSECOLOR,0,"UInt")
  NumPut(hwnd,CHOOSECOLOR,A_PtrSize,"Ptr")
  NumPut(Color,CHOOSECOLOR,3*A_PtrSize,"UInt")
  NumPut(0x3,CHOOSECOLOR,5*A_PtrSize,"UInt")
  NumPut(&CUSTOM,CHOOSECOLOR,4*A_PtrSize,"Ptr")
  If !ret := DllCall("comdlg32\ChooseColorW","Ptr",&CHOOSECOLOR,"UInt")
     Exit

  SetFormat, Integer, H
  Color := NumGet(CHOOSECOLOR,3*A_PtrSize,"UInt")
  SetFormat, Integer, D
  Return Color
}

OpenUImenu() {
   deleteMenus()
   createMenuInterfaceOptions()
   showThisMenu("PvUIprefs")
}

PanelDefineEntireSlideshowLength() {
    Global userHourDur, userMinDur, userSecDur, infoLine, userDefinedSpeedSlideshow
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (maxFilesIndex<3 || thumbsDisplaying=1)
       Return

    thisBtnHeight := createSettingsGUI(19, A_ThisFunc)
    btnWid := 130
    txtWid := 350
    EditWid := 35
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 2
       btnWid := btnWid + 75
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    infoSliSpeed := DefineSlidesRate()
    etaTime := EstimateSlideShowLength()

    Gui, Add, Text, x15 y15 Section w%txtWid%, Define the total time of the slideshow`nfor %maxFilesIndex% images.
    Gui, Add, Text, y+15 w80, Hours
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserHourDur, % Round(Hrs)
    Gui, Add, Text, xs y+5 wp, Minutes
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserMinDur, % Round(Min)
    Gui, Add, Text, xs y+5 wp, Seconds
    Gui, Add, Edit, x+5 wp gUpdateSlideshowPanel r1 limit2 Number -multi -wantTab -wrap vuserSecDur, % Round(Sec)
    Gui, Add, Text, xs y+5 wp, Speed
    Gui, Add, DropDownList, x+5 wp gChooseSlideSpeed AltSubmit vuserDefinedSpeedSlideshow, ---||30 FPS|15 FPS|7 FPS|2 FPS|1 sec.|2 sec.|4 sec.|8 sec.|16 sec.
    Gui, Add, Button, x+5 hp w75 gTimeLapseInfoBox, Infos
    Gui, Add, Button, x+5 hp w95 gSetTimeLapseMode, Timelapse

    Gui, Add, Text, xs y+15 w%txtWid% vinfoLine, One image every: %infoSliSpeed%`nEstimated slideshow duration: %etaTime%
    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gStartSlideINtotalTimeBTNaction, &Start slideshow
    Gui, Add, Button, x+5 hp w90 gResetSlideSpeed, De&fault
    Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Define total slideshow time: " appTitle)
}

TimeLapseInfoBox() {
    msgBoxWrapper(appTitle ": HELP", "The slideshow durations displayed in the panel include the time estimated to load each image. Based on previously loaded images, it takes about " drawModeCzeit " miliseconds to load an image.`n `nFor optimal timelapses [or very fast slideshows] set zoom at 100`%, disable image rotation and color adjustments and «skip already seen images».", -1, 0, 0)
    ; coreResetSlideSpeed(33, 1)
    ; GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
}

SetTimeLapseMode() {
    msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to set slideshow mode to timelapse? This will set zoom level to 100% and disable any image effect or adjustment.`n`nThe slideshow speed will be set at ~30 FPS [33 images/sec.].", 4, 0, "question")
    If (msgResult="Yes")
    {
       skipSeenImagesSlider := 0
       imgFxMode := usrColorDepth := zoomLevel := 1
       IMGresizingMode := 4
       vpIMGrotation := FlipImgH := FlipImgV := 0
       coreResetSlideSpeed(33, 1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 2
       dummyTimerDelayiedImageDisplay(50)
    }
}

ResetSlideSpeed() {
    coreResetSlideSpeed(4000, 1)
    GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 8
}

ChooseSlideSpeed() {
    GuiControlGet, userDefinedSpeedSlideshow
    If (userDefinedSpeedSlideshow=2)
       coreResetSlideSpeed(33, 1)
    Else If (userDefinedSpeedSlideshow=3)
       coreResetSlideSpeed(67, 1)
    Else If (userDefinedSpeedSlideshow=4)
       coreResetSlideSpeed(143, 1)
    Else If (userDefinedSpeedSlideshow=5)
       coreResetSlideSpeed(500, 1)
    Else If (userDefinedSpeedSlideshow=6)
       coreResetSlideSpeed(1000, 1)
    Else If (userDefinedSpeedSlideshow=7)
       coreResetSlideSpeed(2000, 1)
    Else If (userDefinedSpeedSlideshow=8)
       coreResetSlideSpeed(4000, 1)
    Else If (userDefinedSpeedSlideshow=9)
       coreResetSlideSpeed(8000, 1)
    Else If (userDefinedSpeedSlideshow=10)
       coreResetSlideSpeed(16000, 1)
}

coreResetSlideSpeed(varu, noDDLjump:=0) {
    slideShowDelay := varu
    coreSecToHHMMSS((slideShowDelay/1000)*maxFilesIndex, Hrs, Min, Sec)
    GuiControl, SettingsGUIA:, userHourDur, % Round(Hrs)
    GuiControl, SettingsGUIA:, userMinDur, % Round(Min)
    GuiControl, SettingsGUIA:, userSecDur, % Round(Sec)
    If (noDDLjump!=1)
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    DefineSlidesTotalTimeBTNaction(0)
}

DefineSlidesRate() {
   slidesDuration := slideShowDelay
   ; slidesDuration := (slideShowDelay<drawModeCzeit) ? Round((drawModeCzeit*0.7+slideShowDelay)//2) : slideShowDelay
  ; If (slidesDuration<1995 && slidesDuration!=1000)
  ;    miliSec := slidesDuration " milisec."
   ; Else
      duration := SecToHHMMSS(Round(slidesDuration/1000, 3))
   Return miliSec ? miliSec : duration
}

StartSlideINtotalTimeBTNaction() {
   DefineSlidesTotalTimeBTNaction(0)
   CloseWindow()
   dummyInfoToggleSlideShowu()
}

UpdateSlideshowPanel() {
    Static lastInvoked := 1
    DefineSlidesTotalTimeBTNaction()
    GuiControlGet, WhatsFocused, SettingsGUIA: FocusV
    If (WhatsFocused="userHourDur" || WhatsFocused="userMinDur" || WhatsFocused="userSecDur")
       GuiControl, SettingsGUIA: Choose, userDefinedSpeedSlideshow, 1
    lastInvoked := A_TickCount
}

DefineSlidesTotalTimeBTNaction(doDDLjump:=1) {
    GuiControlGet, userHourDur
    GuiControlGet, userMinDur
    GuiControlGet, userSecDur
    slideShowDelay := 0    
    slideShowDelay += userSecDur*1000
    slideShowDelay += (userMinDur*60)*1000
    slideShowDelay += ((userHourDur*60)*60)*1000
    slideShowDelay := Round(slideShowDelay/maxFilesIndex)
    If (slideShowDelay<16)
       slideShowDelay := 16

    etaTime := EstimateSlideShowLength()
    infoSliSpeed := DefineSlidesRate()
    GuiControl, SettingsGUIA:, InfoLine, One image every: %approxMarker%%infoSliSpeed%`nEstimated slideshow duration: %approxMarker%%etaTime%
}

EstimateSlideShowLength(noPrecision:=0) {
    slidesDuration := (slideShowDelay<drawModeCzeit) ? (drawModeCzeit + slideShowDelay)/2 : drawModeCzeit*0.9 + slideShowDelay
    ; slidesDuration := (slideShowDelay<drawModeCzeit) ? drawModeCzeit : slideShowDelay
    approxMarker := (slideShowDelay<drawModeCzeit) ? "~" : ""
    infoFilesSel := (maxFilesIndex>0) ? maxFilesIndex : 1
    slidesDuration := Round(slidesDuration/1000, 3) * infoFilesSel
    ; MsgBox, % etaTime "--" slidesDuration "--" slideShowDelay "--" drawModeCzeit "--" maxFilesIndex
    etaTime := approxMarker SecToHHMMSS(slidesDuration)
    If (noPrecision=1)
       etaTime := RegExReplace(etaTime, "\...s", "s")
    Return etaTime
}

PanelJump2index() {
   If StrLen(mustOpenStartFolder)>3
      currentFileIndex := doOpenStartFolder()

   If (maxFilesIndex<3)
   {
      showTOOLtip("WARNING: Insufficient files indexed...")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   imgPath := getIDimage(currentFileIndex)
   isAnim := (RegExMatch(imgPath, "i)(.\.(gif))$") && totalFramesIndex>1) ? "`fSkip to given frame index" : ""
   fakeWinCreator(13, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Skip to given index: " appTitle, "Please type a number to skip at in the files list and choose the action. Total entries: " groupDigits(maxFilesIndex) ".", "&Skip to...|C&ancel", 1, "fast-forward", 0, 0, "Skip to given file index`f`fSelect from current file index to given index" isAnim, "limit9050 +number", currentFileIndex, 2)
   If InStr(msgResult.btn, "skip")
   {
      usrJumpIndex := Trimmer(msgResult.edit)
      If !usrJumpIndex
         Return

      newJumpIndex := clampInRange(usrJumpIndex, 1, maxFilesIndex)
      If (newJumpIndex=currentFileIndex && newJumpIndex>0 && msgResult.list!=3)
         Return

      If askAboutFileSave(" and another image will be loaded")
         Return

      If (IsNumber(newJumpIndex) && newJumpIndex>=1)
      {
         If (msgResult.list=3)
         {
            desiredFrameIndex := clampInRange(usrJumpIndex, 1, totalFramesIndex)
            RefreshImageFile()
            Return
         } Else If (msgResult.list=2)
         {
            dropFilesSelection(1)
            selectFilesRange(currentFileIndex, newJumpIndex, 1)
         }

         currentFileIndex := newJumpIndex
         dummyTimerDelayiedImageDisplay(50)
      }
   }
}

SaveClipboardImage(dummy:=0, allowCropping:=0, noDialog:=0) {
   Static lastInvoked := 1

   If !useGdiBitmap()
   {
      showTOOLtip("No image file is currently loaded...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime//2
      Return
   }

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   initFIMGmodule()
   INIaction(0, "userDesireWriteFMT", "General")
   INIaction(0, "prevFileSavePath", "General")
   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   imgPath := getIDimage(currentFileIndex)
   imgPath := StrReplace(imgPath, "||")
   zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
   defaultu := (dummy="current") ? OutDir "\" OutNameNoExt : prevFileSavePath "\" OutNameNoExt
   If !defaultu
      defaultu := prevFileSavePath "\" OutNameNoExt
   If FolderExist(dummy)
      defaultu := dummy "\" OutNameNoExt

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." oEXT)
           defFMTindex := A_Index
   }

   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (imgW*imgH>maxGDIbmpSize)
   {
      SoundBeep, 300, 100
      showTOOLtip("ERROR: The image size is too large. Image file saving disabled.")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If alertReduceSaveColorDepth()
      Return

   If (noDialog=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "PathMustExist", defaultu, "Save image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)

   If file2save
   {
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If (FileExist(file2save) && imgPath!=file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      If FileExist(imgPath)
      {
         FileGetTime, originalMtime, % imgPath, M
         FileGetTime, originalCtime, % imgPath, C
         Sleep, 1
         FileSetAttrib, -R, % file2save
      }

      ForceRefreshNowThumbsList()
      If (AnyWindowOpen=35)
         CloseWindow("yes")

      showTOOLtip("Saving image, please wait...`n" OutFileName)
      newBitmap := CopyImage2clip(1, allowCropping)
      newBitmap := StrReplace(newBitmap, "fail")
      prevFileSavePath := OutDir
      INIaction(1, "prevFileSavePath", "General")
      lastInvoked := A_TickCount
      If StrLen(newBitmap)>2
      {
         destroyGDIfileCache(1, 1)
         changeMcursor()
         r := QPV_SaveImageFile(A_ThisFunc, newBitmap, file2save, userJpegQuality)
         trGdip_DisposeImage(newBitmap, 1)
      } Else r := "err-no-main-bmp"

      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         resultedFilesList[currentFileIndex, 4] := 1
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
      }

      If r
      {
         msgBoxWrapper(appTitle ": ERROR", appTitle " was unable to save the image file due to an undetermined cause...`n`n" OutFileName "`n" OutDir "\`nError code: " r, 0, 0, "error")
         showTOOLtip("Failed to save image file...`n" OutFileName "`n" OutDir "\")
      } Else
      {
         showTOOLtip("Image file succesfully saved...`n" OutFileName "`n" OutDir "\")
         testMem := getIDimage(currentFileIndex)
         If (currentFileIndex=0) || (InStr(testMem, "\temporary memory object\") && maxFilesIndex<2)
         {
            currentFileIndex := maxFilesIndex := 1
            resultedFilesList[1, 1] := file2save
            DynamicFoldersList := OutDir "`n"
            prevOpenFolderPath := OutDir
            CurrentSLD := "|" OutDir
            SLDtypeLoaded := 1
         } Else If (imgPath!=file2save)
            resultedFilesList.InsertAt(currentFileIndex, [file2save])

         imgIndexEditing := currentFileIndex
         currentImgModified := 2
      }

      SoundBeep, % r ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      SetTimer, ResetImgLoadStatus, -50
   }
}

BtnCpyMvChooseFilesDest() {
   If (currentFileIndex=0)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectedDir := openFoldersDialogWrapper("S2", prevFileMovePath)
   SelectedDir := Trimmer(SelectedDir)
   If FolderExist(SelectedDir)
   {
      CloseWindow("yes")
      Sleep, 15
      prevFileMovePath := SelectedDir
      RecentCopyMoveManager(SelectedDir)
      Sleep, 15
      CopyMovePanelWindow()
   } Else
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   }
}

zPlitPath(inputu, fastMode, ByRef fileNamu, ByRef folderu, ByRef fileNamuNoEXT:=0, ByRef fileEXT:=0) {
    If (fastMode=0)
    {
       inputu := Trimmer(StrReplace(inputu, "|"))
       FileGetAttrib, OutputVar, %inputu%
    } Else StringRight, OutputVar, inputu, 1

    If InStr(OutputVar, "D") || (OutputVar="\")
    {
       folderu := inputu
       fileEXT := fileNamuNoEXT := fileNamu := ""
    } Else
    {
       lineArr := StrSplit(inputu, "\")
       maxuIndex := lineArr.Count()
       fileNamu := lineArr[maxuIndex]
       fileParentFolder := lineArr[maxuIndex - 1]
       folderu := SubStr(inputu, 1, StrLen(inputu) - StrLen(fileNamu) - 1)
       fileEXTpos := RegExMatch(fileNamu, "\.[^.\\/:*?<>|\r\n]+$")
       If fileEXTpos
          fileEXT := SubStr(fileNamu, fileEXTpos+1)
       fileNamuNoEXT := fileEXTpos ? RegExReplace(fileNamu, "\.[^.\\/:*?<>|\r\n]+$") : fileNamu
    }
    Return fileParentFolder
}

StringToASC(string) {
   Static lastInvoked, lastAsc
   If !String
      Return

   If (string=lastInvoked)
      Return lastAsc

   Loop, Parse, string 
      AscString .= Ord(A_LoopField)
 
   lastInvoked := string
   lastAsc := AscString
   Return AscString
}

readRecentFileDesties(modus:=0) {
   listu := ""
   If (modus!=1)
   {
      If FolderExist(prevFileMovePath)
         listu .= prevFileMovePath "`n"
      If FolderExist(prevFileSavePath)
         listu .= prevFileSavePath "`n"
      If FolderExist(prevOpenFolderPath)
         listu .= prevOpenFolderPath "`n"
   }

   Loop, 15
   {
       IniRead, newEntry, % mainRecentsFile, RecentFDestinations, E%A_Index%, @
       newEntry := Trimmer(newEntry)
       If (FolderExist(newEntry) && !InStr(listu, newEntry "`n"))
          listu .= newEntry "`n"
   }
   Return listu
}

PanelMoveCopyFiles() {
   UsrCopyMoveOperation := 2
   CopyMovePanelWindow()
}

InvokeCopyFiles() {
   UsrCopyMoveOperation := 3
   If (maxFilesIndex>0)
      CopyMovePanelWindow()
}

CopyMovePanelWindow() {
    Global UsrEditFileDestination, BtnCpyMv, lastInvoked := 1
    ; Static prevmainDynaFoldersListu, prevCurrentSLD

    openingPanelNow := 1
    thisBtnHeight := createSettingsGUI(9, A_ThisFunc)
    btnWid := 125
    btnWid2 := 60
    txtWid := 360
    EditWid := 395
    If (PrefsLargeFonts=1)
    {
       EditWid := EditWid + 220
       btnWid := btnWid + 70
       btnWid2 += 60
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }

    ToolTip, Please wait...,,, 2
    listu := readRecentFileDesties()
    listu .= "--={ other destinations }=--`n"
    setImageLoading()
    historyList := readRecentEntries()
    Loop, Parse, historyList, `n
    {
       If (A_Index>10)
          Break 

       If StrLen(A_LoopField<4)
          Continue 

       changeMcursor()
       OutDir := StrReplace(A_LoopField, "|")
       If InStr(listu, OutDir "`n") || !FolderExist(OutDir)
          Continue

       listu .= OutDir "`n"
    } 

    thisDynaList := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
    ; DynamicFoldersList := mainDynaFoldersListu
    prevCurrentSLD := CurrentSLD
    lastInvoked := A_TickCount

    Loop, Parse, thisDynaList, `n
    {
        If (A_Index>15)
           Break

        If StrLen(A_LoopField)<4
           Continue

        changeMcursor()
        folderu := StrReplace(A_LoopField, "|")
        If InStr(listu, folderu "`n") || !FolderExist(folderu)
           Continue

        listu .= folderu "`n"
    }

    List_MakeUnique(listu, "`n", 0, 0)
    Loop, Parse, listu, `n
    {
        If !A_LoopField
           Continue

        changeMcursor()
        indexu := InStr(A_LoopField, "{ other dest") ? "" : A_Index - 1 "; "
        finalListu .= indexu A_LoopField "`n"
        If (A_Index=1)
           finalListu .= "`n"
    }

    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       finalListu .= "[group-by-month-year]`n[group-by-years]`n[group-by-file-types]"
       copyMoveDoLastOption := 0
       infoSelection := "Selected files: " markedSelectFile ". "
    }

    Gui, +Delimiter`n
    Gui, Add, Text, x15 y15 Section, %infoSelection%Please select or type destination folder...
    Gui, Add, ComboBox, xs y+10 w%EditWid% gCopyMoveComboAction r12 Simple vUsrEditFileDestination, % finalListu
    Gui, Add, Checkbox, y+10 Checked%copyMoveDoLastOption% vcopyMoveDoLastOption, When file name(s) collide, use previously given answer
    If (markedSelectFile>1)
       GuiControl, Disable, copyMoveDoLastOption

    ToolTip,,,,2
    SetTimer, ResetImgLoadStatus, -50
    btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
    Gui, Add, DropDownList, xs y+20 w%btnWid% gchangeCopyMoveAction AltSubmit Choose%UsrCopyMoveOperation% vUsrCopyMoveOperation, Action to perform...`nMove file(s)`nCopy file(s)
    Gui, Add, Button, x+5 hp w%btnWid% gBtnCpyMvChooseFilesDest, &Choose a new folder
    Gui, Add, Button, x+5 hp w90 gBtnHelpCopyMovePanel, Hel&p

    Gui, Add, Button, xs y+20 h%thisBtnHeight% w%btnWid2% Default gBtnCopyMoveAction vBtnCpyMv, &Proceed
    Gui, Add, Button, x+5 hp wp+30 gEraseCopyMoveHisto, Erase &history
    Gui, Add, Button, x+5 hp wp+60 gBtnMarkFilesExplorer, &Mark file(s) (Explorer)
    Gui, Add, Button, x+5 hp w70 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, btnName " file(s) to...: " appTitle)
    SetTimer, resetOpeningPanel, -300
}

BtnHelpCopyMovePanel() {
  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  msgBoxWrapper(appTitle ": HELP", "Recognized patterns:`n`na) " btnName " files to parent folder: .\`n`nb) " btnName " files to a new or existing sub-folder: \given-folder`n`nc) " btnName " files into a new or exiting folder within the parent folder: .\given-folder.`n`nThe destination folder for all files will be calculated relative to the currently active file index entry: " currentFileIndex ".`n" OutDir "`n`nUse [group-by-month-year], [group-by-years] or [group-by-file-types] as folder name to automatically group files in newly created folders named based on files' modification date or file types.`n`nIf you click on «Mark files (Explorer)» button, the selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", -1, 0, 0)
}

changeCopyMoveAction() {
  GuiControlGet, UsrCopyMoveOperation
  btnName := (UsrCopyMoveOperation=2) ? "Move" : "Copy"
  ; GuiControl, SettingsGUIA:, BtnCpyMv, &%btnName% file(s)
  Gui, SettingsGUIA: Show,, %btnName% file(s) to...: %appTitle%
  If (UsrCopyMoveOperation=1)
     GuiControl, SettingsGUIA: Disable, BtnCpyMv
  Else
     GuiControl, SettingsGUIA: Enable, BtnCpyMv
}

CopyMoveComboAction() {
  Static lastInvoked := 1
  GuiControlGet, UsrEditFileDestination
  If (A_GuiControlEvent="DoubleClick")
  {
     BtnCopyMoveAction()
  } Else If (A_GuiControlEvent="Normal") && (A_TickCount - lastInvoked > 50) && StrLen(UsrEditFileDestination)<5
    && !InStr(UsrEditFileDestination, ":\") && InStr(UsrEditFileDestination, ";")
  {
     SendInput, {Up}
     lastInvoked := A_TickCount
  }
}

EraseCopyMoveHisto() {
  IniDelete, % mainRecentsFile, RecentFDestinations
  CloseWindow()
  CopyMovePanelWindow()
}

BtnMarkFilesExplorer() {
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "Please choose an action to perform: copy or move.`n`nThe selected file(s) will be marked as «COPY» or «CUT» and you can paste them in any file manager, or in another session of " appTitle ".", 0, 0, "exclamation")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  CloseWindow("yes")
  If (UsrCopyMoveOperation=3)
     MenuExplorerCopyFiles()
  Else
     MenuExplorerCutFiles()
}

BtnCopyMoveAction() {
  GuiControlGet, UsrEditFileDestination, SettingsGUIA:, UsrEditFileDestination
  GuiControlGet, UsrCopyMoveOperation, SettingsGUIA:, UsrCopyMoveOperation
  GuiControlGet, copyMoveDoLastOption, SettingsGUIA:, copyMoveDoLastOption
  If (UsrCopyMoveOperation=1)
  {
     showTOOLtip("WARNING: Please choose an action to perform: copy or move...")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  imgPath := getIDimage(currentFileIndex)
  zPlitPath(imgPath, 0, OutFileName, OutDir)
  folderu := Trimmer(UsrEditFileDestination)
  folderu := StrReplace(folderu, "/", "\")
  folderu := RegExReplace(folderu, "\\{2,}", "\")
  groupingMode := 0
  If (folderu="[group-by-month-year]" || folderu="[group-by-years]" || folderu="[group-by-file-types]")   ; group files
  {
     groupingMode := 1
     folderu := OutDir "\" folderu
  } Else If (folderu=".\")   ; move files one level up
  {
     folderu := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
  } Else If RegExMatch(folderu, "^(\\.)") ; move files to a given sub-folder
  {
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  } Else If RegExMatch(folderu, "^(\.\\.)") ; move files to a given sibling folder
  {
     OutDir := SubStr(OutDir, 1, InStr(OutDir, "\", 0, -1) - 1)
     folderu := Trimmer(folderu, "\")
     folderu := Trimmer(folderu, ".")
     If (b := InStr(folderu, "; "))
        folderu := SubStr(folderu, b+2)
     If folderu
        folderu := OutDir "\" folderu
  }

  folderu := StrReplace(folderu, "\\", "\")
  folderu := Trimmer(folderu, "\")
  folderu := Trimmer(folderu, ".")
  If (b := InStr(folderu, "; "))
     folderu := SubStr(folderu, b+2)

  wrongNames := 0
  testFolderu := SubStr(folderu, 4)
  Loop, Parse, testFolderu, \
  {
      IF (!filterFileName(A_LoopField) && A_LoopField)
         wrongNames := 1
  }

  If (InStr(folderu, "[group-by-month-year]") || InStr(folderu, "[group-by-file-types]") || InStr(folderu, "[group-by-years]"))
     groupingMode := 1

  If (!RegExMatch(folderu, "^(.\:\\.)") || wrongNames=1)
  {
     showTOOLtip("WARNING: Incorrect file path given...")
     SoundBeep, 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return
  }

  If (FolderExist(folderu) || groupingMode=1)
  {
     Sleep, 2
     QuickMoveFile2Dest(folderu, copyMoveDoLastOption, groupingMode)
  } Else If (StrLen(folderu)>4)
  {
     msgResult := msgBoxWrapper(appTitle, "Destination folder does not seem to exist:`n" folderu "\`n`nDo you want to create the folder?", 4, 0, "question")
     If (msgResult="yes")
     {
        FileCreateDir, % folderu
        If ErrorLevel
        {
           SoundBeep , 300, 100
           msgBoxWrapper(appTitle ": ERROR", "An unknown error occured while creating the folder...`n" folderu "\", 0, 0, "error")
           Return
        } Else
        {
           Sleep, 2
           QuickMoveFile2Dest(folderu, copyMoveDoLastOption, 0)
        }
     }
  }
  ; MsgBox, %folderu% -- %newentry%
}

RecentCopyMoveManager(entry2add) {
  entry2add := Trimmer(entry2add)
  mainListu := readRecentFileDesties(1)

  If StrLen(entry2add)<3
     Return

  Loop, Parse, mainListu,`n
  {
      If (A_LoopField=entry2add)
      {
         isAddedAlready := 1
         Break
      }
  }

  If (isAddedAlready=1)
     Return

  mainListu := entry2add "`n" mainListu
  Loop, Parse, mainListu, `n
  {
      If (A_Index>15)
         Break

      folderu := Trimmer(A_LoopField)
      folderu := Trimmer(folderu, "\")
      If (!FolderExist(folderu) || !InStr(folderu, ":\"))
         Continue

      countItemz++
      IniWrite, % folderu, % mainRecentsFile, RecentFDestinations, E%countItemz%
  }
}

QuickMoveFile2Dest(finalDest, goLastOption, groupingMode:=0) {
    If (slideShowRunning=1)
       ToggleSlideShowu()
 
    getSelectedFiles(0, 1)
    If (markedSelectFile>1)
    {
       batchCopyMoveFile(finalDest, groupingMode)
       Return
    } Else If (groupingMode=1)
    {
       msgBoxWrapper(appTitle ": ERROR", "You cannot group files into folders when only one file is selected. In this case, please provide a destination path without any [group-by-*] token.", 0, 0, "error")
       Return
    }

    file2rem := getIDimage(currentFileIndex)
    zPlitPath(file2rem, 0, OldOutFileName, OldOutDir)
    If !FileExist(file2rem)
    {
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       msgBoxWrapper(appTitle ": ERROR", "Failed to perform action. File not found or access denied...`n" OldOutFileName "`n" OldOutDir "\", 0, 0, "error")
       Return
    }

    If (OldOutDir=finalDest)
    {
       ResetImgLoadStatus()
       SoundBeep, 300, 100 
       msgBoxWrapper(appTitle ": WARNING", "Illegal operation detected. The destination folder is the same with the initial location:`n" finalDest "\", 0, 0, "exclamation")
       Return
    }

    CloseWindow("yes")
    Sleep, 2
    destroyGDIfileCache()
    FileGetTime, originalMtime, % file2rem, M
    FileGetTime, originalCtime, % file2rem, C
    file2save := finalDest "\" OldOutFileName

    thisFileExists := 0
    If (FileExist(file2save) && !FolderExist(file2save))
    {
       thisFileExists := 1
       file2save := askAboutFileCollision(file2rem, file2save, 0, goLastOption + 1, 0, performOverwrite)
    }

    If (file2save="abort" || !file2save)
    {
       If (UsrCopyMoveOperation!=2)
          SetTimer, InvokeCopyFiles, -150
       Else
          SetTimer, PanelMoveCopyFiles, -150
       Return
    }

    If (thisFileExists=1)
    {
       If (performOverwrite=1)
       {
          FileSetAttrib, -R, %file2save%
          Sleep, 5
          FileRecycle, %file2save%
          Sleep, 5
          mustPerformOperation := 1
       } Else If (performOverwrite!=2)
       {
          showTOOLtip("Operation aborted. A file with the same name already exists in the destination folder.`n" OldOutFileName "`n" finalDest "\")
          SoundBeep, 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SetTimer, ResetImgLoadStatus, -25
          Return
       } Else mustPerformOperation := 1
    } Else mustPerformOperation := 1

    If (mustPerformOperation=1)
    {
       operationExecuted := 1
       If (UsrCopyMoveOperation=2)
          FileMove, %file2rem%, %file2save%
       Else
          FileCopy, %file2rem%, %file2save%
       If ErrorLevel
          wasError := 1
    }

    If (wasError!=1 && operationExecuted=1)
    {
       If (originalMtime)
       {
          FileSetTime, % originalMtime, % file2save, M
          FileSetTime, % originalCtime, % file2save, C
       }

       prevFileMovePath := finalDest
       INIaction(1, "prevFileMovePath", "General")
       RecentCopyMoveManager(finalDest)
       actName := (UsrCopyMoveOperation=2) ? "moved" : "copied"
       zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
       showTOOLtip("File " actName " to...`n" OldOutFileName "`n" finalDest "\")
       If (UsrCopyMoveOperation=2)
       {
          resultedFilesList[currentFileIndex] := [file2save]
          If (SLDtypeLoaded=3)
             updateSQLdbEntry(OldOutFileName, OldOutDir, OldOutFileName, finalDest)
       }
       If (StrLen(filesFilter)>1 && UsrCopyMoveOperation=2)
          bckpResultedFilesList[filteredMap2mainList[currentFileIndex]] := [file2save]
       Sleep, 1
    } Else If (operationExecuted=1)
    {
       actName := (UsrCopyMoveOperation=2) ? "move" : "copy"
       showTOOLtip("ERROR: Failed to " actName " file:`n" OldOutFileName "To destination:`n" finalDest "\")
       SoundBeep, 300, 100
    }

    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, ResetImgLoadStatus, -25
}

batchCopyMoveFile(finalDest, groupingMode:=0) {
   Static lastInvoked := 1
   filesElected := getSelectedFiles(0, 1)
   If (A_TickCount - lastInvoked > 29500) || (filesElected>100)
   {
      wording := (UsrCopyMoveOperation=2) ? "MOVE" : "COPY"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to " wording " the selected files.`n`nSelected " filesElected " files`nDestination: " finalDest "\", 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   CloseWindow("yes")
   lastInvoked := A_TickCount
   friendly := (UsrCopyMoveOperation=2) ? "Moving " : "Copying "
   showTOOLtip(friendly filesElected " files to`n" finalDest "\`nPlease wait...")
   prevFileMovePath := finalDest
   RecentCopyMoveManager(finalDest)
   destroyGDIfileCache()
   Sleep, 25
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   nullvara := askAboutFileCollision(file2rem, file2save, 1, 3, 0, nullvar)
   countTFilez := filezMoved := failedFiles := skippedFiles := 0
   oFinalDest := finalDest
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      changeMcursor()
      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      zPlitPath(file2rem, 0, OldOutFileName, OldOutDir, OutFileNameNoExt, OutFileExt)
      countTFilez++
      If !FileExist(file2rem)
      {
         failedFiles++
         Continue
      }

      If (OldOutDir=finalDest)
      {
         skippedFiles++
         Continue
      }

      FileGetTime, originalMtime, % file2rem, M
      FileGetTime, originalCtime, % file2rem, C
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         If (skippedFiles>0)
            someErrors := "`n" skippedFiles " files were skipped"
         If (failedFiles>0)
            someErrors .= "`nFailed to perform action on " failedFiles " files..."

         showTOOLtip(friendly countTFilez "/" filesElected " files to`n" finalDest "\`nPlease wait..." someErrors, 0, 0, countTFilez/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      grouper := ""
      If (groupingMode=1)
      {
         If ((InStr(oFinalDest, "[group-by-month-year]") && originalMtime)
         || (InStr(oFinalDest, "[group-by-file-types]") && OutFileExt)
         || (InStr(oFinalDest, "[group-by-years]") && originalMtime))
         {
            FormatTime, grouper, % originalMtime, yyyy-MM-MMMM
            FormatTime, groupery, % originalMtime, yyyy
            finalDest := StrReplace(oFinalDest, "[group-by-month-year]", grouper)
            finalDest := StrReplace(finalDest, "[group-by-file-types]", OutFileExt)
            finalDest := StrReplace(finalDest, "[group-by-years]", groupery)
            If !FolderExist(finalDest)
            {
               FileCreateDir, % finalDest
               Sleep, 2
            }
         }
      }

      file2save := finalDest "\" OldOutFileName
      thisFileExists := wasError := operationExecuted := 0
      If (FileExist(file2save) && !FolderExist(file2save))
      {
         thisFileExists := 1
         file2save := askAboutFileCollision(file2rem, file2save, 1, 0, 0, performOverwrite)
      }
  
      If !file2save
      {
         skippedFiles++
         Continue
      } Else If (file2save="abort")
      {
         abandonAll := 1
         Break
      }
  
      If (thisFileExists=1)
      {
         If (performOverwrite=1)
         {
            FileSetAttrib, -R, %file2save%
            Sleep, 2
            FileRecycle, %file2save%
            Sleep, 2
            mustPerformOperation := 1
         } Else If (performOverwrite!=2)
         {
            skippedFiles++
            Continue
         } Else mustPerformOperation := 1
      } Else mustPerformOperation := 1

      If (mustPerformOperation=1)
      {
         operationExecuted := 1
         If (UsrCopyMoveOperation=2)
            FileMove, %file2rem%, %file2save%, 1
         Else
            FileCopy, %file2rem%, %file2save%, 1
         If ErrorLevel
            wasError := 1
      }

      If (wasError!=1 && operationExecuted=1)
      {
         If (originalMtime)
         {
            FileSetTime, % originalMtime, % file2save, M
            FileSetTime, % originalCtime, % file2save, C
         }

         filezMoved++
         zPlitPath(file2save, 0, OldOutFileName, OldOutDir)
         If (UsrCopyMoveOperation=2)
         {
            resultedFilesList[thisFileIndex] := [file2save, 1]
            If (SLDtypeLoaded=3)
               updateSQLdbEntry(OldOutFileName, OldOutDir, OldOutFileName, finalDest)
         }

         If (StrLen(filesFilter)>1 && UsrCopyMoveOperation=2)
            bckpResultedFilesList[filteredMap2mainList[thisFileIndex]] := [file2save, 1]
      } Else If (operationExecuted=1)
         failedFiles++

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (skippedFiles>0)
      someErrors := "`n" skippedFiles " files were skipped"
   If (failedFiles>0)
      someErrors .= "`nFailed to perform action on " failedFiles " files..."

   watchFolderDetails := ""
   If (InStr(CurrentSLD, "\favourite-images-list.SLD") && UsrCopyMoveOperation=2)
      renewFavesListBasedOnIndexList()

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (UsrCopyMoveOperation=2)
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " filezMoved " out of " filesElected " selected files were moved to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished moving " filezMoved " out of " filesElected " files to`n" finalDest "\" someErrors)
   } Else
   {
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " filezMoved " out of " filesElected " selected files were copied to`n" finalDest "\" someErrors)
      Else
         showTOOLtip("Finished copying " filezMoved " out of " filesElected " files to`n" finalDest "\" someErrors)
   }

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   lastInvoked := A_TickCount
}

batchConvert2format() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to convert " filesElected " files to ." rDesireWriteFMT " ? "
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."
      If (OnConvertKeepOriginals!=1)
         msgInfos .= "`n`nThe original files will be ERASED."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
   CloseWindow("yes")
   setImageLoading()
   showTOOLtip("Converting to ." rDesireWriteFMT A_Space filesElected " files, please wait...")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresConvertFormat(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("JPEG lossless processing: failed to initialize multi-threaded processing...")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   initFIMGmodule()
   skipDeadFiles := theseFailures := failedFiles := countTFilez := filesConverted := 0

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If (RegExMatch(imgPath, "i)(.\.(" rDesireWriteFMT "))$") || InStr(file2rem, "||") || !file2rem)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         zeitOperation := A_TickCount - startOperation
         percDone := " ( " Round((countTFilez / filesElected) * 100) "% )"
         percLeft := (1 - countTFilez / filesElected) * 100
         zeitLeft := (zeitOperation/countTFilez) * filesElected - zeitOperation
         etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
         etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
         If (failedFiles>0)
            etaTime .= "`nFor " failedFiles " files, the format conversion failed..."
         If (theseFailures>0)
            etaTime .= "`nUnable to remove " theseFailures " original files after format conversion..."
         If (skippedFiles>0)
            etaTime .= "`n" skippedFiles " files were skipped..."

         showTOOLtip("Converting to ." rDesireWriteFMT A_Space countTFilez "/" filesElected " files, please wait..." etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      countTFilez++
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
      If (FileExist(file2save) && !FolderExist(file2save))
         file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)

      If !file2save
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreConvertImgFormat(imgPath, file2save)
      If r
         failedFiles++
      Else
         filesConverted++

      If (OnConvertKeepOriginals!=1 && !r)
      {
         FileSetAttrib, -R, % imgPath
         Sleep, 2
         FileRecycle, % imgPath
         If ErrorLevel
            theseFailures++

         resultedFilesList[thisFileIndex] := [file2save, 1]
         If StrLen(filesFilter)>1
            bckpResultedFilesList[filteredMap2mainList[thisFileIndex]] := [file2save, 1]
      }
   }

   If (failedFiles>0)
      someErrors := "`nFor " failedFiles " files, the format conversion failed..."
   If (theseFailures>0)
      someErrors .= "`nUnable to remove " theseFailures " original files after format conversion..."
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped..."

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " filesConverted " out of " filesElected " selected files were converted to ." rDesireWriteFMT " until now..." someErrors)
   Else
      showTOOLtip("Finished converting to ." rDesireWriteFMT A_Space filesConverted " out of " filesElected " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

coreConvertImgFormat(imgPath, file2save) {
   If (PreserveDateTimeOnSave=1)
   {
      ; fnOutputDebug("got original date")
      FileGetTime, originalMtime, % imgPath, M
      FileGetTime, originalCtime, % imgPath, C
   }

   If (FIMfailed2init=1)
   {
      If FileExist(file2save)
         FileSetAttrib, -R, %file2save%

      pBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(pBitmap)<3
         Return -1

      rawFmt := Gdip_GetImageRawFormat(pBitmap)
      If (rawFmt="JPEG")
         RotateBMP2exifOrientation(pBitmap)

      changeMcursor()
      r := Gdip_SaveBitmapToFile(pBitmap, file2save, 90)
      trGdip_DisposeImage(pBitmap, 1)
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime "  -- fim-fail  " FIMfailed2init " ")
   } Else
   {
      loadArgs := 0
      GFT := FreeImage_GetFileType(imgPath)
      If (GFT=34)
         loadArgs := (userHQraw=1) ? 0 : 5
      Else If (GFT=2)
         loadArgs := 8

      hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
      If !hFIFimgA
         Return -1

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
      ColorsType := FreeImage_GetColorType(hFIFimgA)
      mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
      If (mustApplyToneMapping=1)
      {
         ; setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
         changeMcursor()
         hFIFimgB := FreeImage_ToneMapping(hFIFimgA, 0, 1.85, 0)
      }

      hFIFimgC := hFIFimgB ? hFIFimgB : hFIFimgA
      If (FileExist(file2save) && hFIFimgC)
      {
         Try FileSetAttrib, -R, % file2save
         Sleep, 1
         FileMove, % file2save, % file2save "-tmp"
         If !ErrorLevel
            tempFileExists := 1

         Sleep, 1
      }

      saveArg := 0
      If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
         saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
      Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
         saveArg := clampInRange(Round(userJpegQuality), 1, 100)

      imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
      If (RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$") && hFIFimgC)
      {
         changeMcursor()
         hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "24Bits")
         changeMcursor()
         r := FreeImage_Save(hFIFimgD, file2save, saveArg)
         FreeImage_UnLoad(hFIFimgD)
      } Else If hFIFimgC
      {
         r := FreeImage_Save(hFIFimgC, file2save, saveArg)
         If (!r && imgBPP!=32)
         {
            FileDelete, % file2save
            Sleep, 1
            changeMcursor()
            hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")
            changeMcursor()
            r := FreeImage_Save(hFIFimgD, file2save, saveArg)
            FreeImage_UnLoad(hFIFimgD)
          }
      }

      FreeImage_UnLoad(hFIFimgA)
      FreeImage_UnLoad(hFIFimgB)
      If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
      {
         r := 0
         FileDelete, % file2save
         Sleep, 1
         FileMove, % file2save "-tmp", % file2save
      } Else If (tempFileExists=1)
         FileDelete, % file2save "-tmp"

      r := !r
      If (PreserveDateTimeOnSave=1 && !r && originalMtime)
      {
         FileSetTime, % originalMtime, % file2save, M
         FileSetTime, % originalCtime, % file2save, C
         ; fnOutputDebug("original date ... set")
      } ; Else fnOutputDebug("set original date skipped...  " PreserveDateTimeOnSave "  ---  " r "  ---  " originalMtime " ")
   }
   Return r
}

convert2format() {
  Critical, on
  If (currentFileIndex=0)
     Return "err"

  If (slideShowRunning=1)
     ToggleSlideShowu()

  file2rem := getIDimage(currentFileIndex)
  If RegExMatch(file2rem, "i)(.\.(" rDesireWriteFMT "))$")
  {
     SoundBeep, 300, 100
     msgBoxWrapper(appTitle ": WARNING", "The image file seems to be already in the given file format: ." rDesireWriteFMT ". Please choose another format.", 0, 0, "exclamation")
     Return "err"
  }

  file2rem := StrReplace(file2rem, "||")
  zPlitPath(file2rem, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
  {
     ToolTip
     zPlitPath(file2save, 0, OutFileName, OutDir)
     msgResult := msgBoxWrapper(appTitle ": Confirmation", "A file with the same name already exists in the destination folder... Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
     forceOverwrite := (msgResult="Yes") ? 1 : 0
     If !forceOverwrite
        Return
  }

  CloseWindow("yes")
  destroyGDIfileCache()
  Sleep, 1
  setImageLoading()
  showTOOLtip("Converting image file, please wait...")
  If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
     FileCreateDir, % ResizeDestFolder

  destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
  file2save := destImgPath "\" OutNameNoExt "." rDesireWriteFMT
  If FileExist(file2save)
     FileSetAttrib, -R, %file2save%

  r := coreConvertImgFormat(file2rem, file2save)
  SetTimer, ResetImgLoadStatus, -50
  If r
     showTOOLtip("Failed to convert file...`n" OutFileName "`n" OutDir "\")
  Else
     showTOOLtip("File converted succesfully to ." rDesireWriteFMT "...`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")

  SoundBeep, % r ? 300 : 900, 100
  If (OnConvertKeepOriginals!=1 && !r)
  {
     Try FileSetAttrib, -R, %file2rem%
     Sleep, 1
     FileRecycle, %file2rem%
     If ErrorLevel
        showTOOLtip("Failed to remove original file. But the file was converted succesfully to ." rDesireWriteFMT "...`n" OutNameNoExt "." rDesireWriteFMT "`n" destImgPath "\")
     resultedFilesList[currentFileIndex] := [file2save]
     If StrLen(filesFilter)>1
        bckpResultedFilesList[filteredMap2mainList[currentFileIndex]] := [file2save]
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

OpenFolders(dummy:=0) {
   If (AnyWindowOpen || imageLoading=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If FolderExist(dummy)
      SelectedDir := dummy
   Else
      SelectedDir := openFoldersDialogWrapper(2, prevOpenFolderPath, "Select the folder to open recursively...")

   If (SelectedDir)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      newStaticFoldersListCache := []
      prevOpenFolderPath := StrReplace(SelectedDir, "|")
      INIaction(1, "prevOpenFolderPath", "General")
      coreOpenFolder(SelectedDir, 1, 1, 1)
      If (maxFilesIndex>0)
         SLDtypeLoaded := 1
      ; Else resetMainWin2Welcome()
   }
}

openFoldersDialogWrapper(optionz, startPath, msg:="") {
   Static defaultu := "<Use current folder>"
   doSuspendu(1)
   thisHwnd := (AnyWindowOpen>0) ? hSetWinGui : PVhwnd
   entriesList := defaultu "`n" recentOpenedFolders()
   r := SelectFolderEx(startPath, msg, thisHwnd, nullLabel, entriesList, 1, "History", entriesList)
   If (!InStr(r.SelectedCombo, defaultu) && StrLen(r.SelectedCombo)>3)
      z := r.SelectedCombo
   Else If StrLen(r.SelectedDir)>4
      z := r.SelectedDir

   SetTimer, dummyUnSuspendu, -150, 900
   lastLongOperationAbort := A_TickCount
   Return z
}

renewCurrentFilesList() {
   userSeenSlideImages := userSeenSessionImagesArray.Count()
   If (maxFilesIndex>1 && userSeenSlideImages>1 && skipSeenImagesSlider=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
   }

   prevRandyIMGs := []
   resultedFilesList := []
   lastRenameUndo := []
   markedSelectFile := maxFilesIndex := 0
   editingSelectionNow := prevRandyIMGnow := 0
   ForceRefreshNowThumbsList()
   updateUIctrl()
   currentFileIndex := 1
   prevLoadedImageIndex := ""
   currentImgModified := allImagesWereSeen := 0
   destroyGDIfileCache()
   discardViewPortCaches()
   disposeCacheIMGs()
   userSearchString := ""
   terminateIMGediting()
   If hSNDmedia
      StopMediaPlaying()
}

coreOpenFolder(thisFolder, doOptionals:=1, openFirst:=0, doReset:=0) {
   testThis := StrReplace(thisFolder, "|")
   mustOpenStartFolder := ""
   If FolderExist(testThis)
   {
      If (A_TickCount - scriptStartTime>350)
         CloseWindow()

      usrFilesFilteru := filesFilter := CurrentSLD := ""
      setWindowTitle("Indexing files, please wait...", 1)
      renewCurrentFilesList()
      ; activeSQLdb.Exec("DELETE FROM images;")
      r := GetFilesList(thisFolder "\*", "-", openFirst)
      If (maxFilesIndex<1 || !maxFilesIndex)
      {
         If (!CurrentSLD || doReset=1)
            resetMainWin2Welcome()
         Else
            FadeMainWindow()

         showTOOLtip("ERROR: Found no recognized image files in the folder...`n" thisFolder "\")
         SoundBeep, 300, 100
         setWindowTitle(appTitle " v" appVersion, 1)
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      GenerateRandyList()
      mustGenerateStaticFolders := 1
      DynamicFoldersList := thisFolder "`n"
      CurrentSLD := thisFolder
      watchFolderDetails := ""
      RecentFilesManager(CurrentSLD)
      If (r=1)
      {
         clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
         RemoveTooltip()
      } Else SetTimer, RemoveTooltip, % -msgDisplayTime

      If (doOptionals=1)
      {
         If (maxFilesIndex>0 && r!=1)
            RandomPicture()
         Else
            dummyTimerDelayiedImageDisplay(25)
      }
   } Else
   {
      setWindowTitle(appTitle " v" appVersion, 1)
      If (!CurrentSLD || maxFilesIndex<2 || !maxFilesIndex)
         resetMainWin2Welcome()
      Else
         FadeMainWindow()

      showTOOLtip("ERROR: The folder seems to be inexistent...`n" testThis "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

addDynamicFolderSQLdb(whichFolder, renewList, whichTable) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM dynamicfolders;")

    If !FolderExist(whichFolder)
       Return

    FileGetTime, fileMdate, % StrReplace(whichFolder, "|"), M
    SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO " whichTable " (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

addStaticFolderSQLdb(whichFolder, fileMdate, renewList) {
    If (renewList=1)
       activeSQLdb.Exec("DELETE FROM staticfolders;")

    SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES ('" whichFolder "', '" fileMdate "');"
    If !activeSQLdb.Exec(SQLStr)
    {
       stringA := whichFolder
       activeSQLdb.EscapeStr(stringA)
       ; MsgBox, % stringA "--" stringB 
       SQLstr := "INSERT INTO staticfolders (imgfolder, fmodified) VALUES (" stringA ", '" fileMdate "');"
       If !activeSQLdb.Exec(SQLStr)
          Sleep, 0
    }
}

RefreshImageFileAction() {
   isThumbMode := (thumbsDisplaying=1 && maxFilesIndex>1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (!useGdiBitmap() && !imgPath && isThumbMode!=1) || !imgPath
   {
      showTOOLtip("WARNING: No image file is currently loaded...")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If InStr(imgPath, "\temporary memory object\")
   {
      showTOOLtip("WARNING: This image is currently unsaved. Unable to perform action.")
      SoundBeep , 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   If askAboutFileSave(" and the original file will be reloaded")
      Return

   If (thumbsDisplaying!=1)
   {
      currentImgModified := 0
      discardViewPortCaches()
      terminateIMGediting()
      If (AutoDownScaleIMGs=1)
         AutoDownScaleIMGs := 2
      r := IDshowImage(currentFileIndex, 3)
      If !r
         informUserFileMissing()
      Else If (toolTipGuiCreated!=1)
         showTOOLtip("Image file reloaded...")
      thisIMGisDownScaled := 0
      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   } Else If (thumbsDisplaying=1)
      RefreshFilesList()
}

RefreshImageFile() {
   ; disposeCacheIMGs()
   r := IDshowImage(currentFileIndex, 3)
   If !r
      informUserFileMissing()
}

RefreshFilesList() {
  If !CurrentSLD
  {
     showTOOLtip("WARNING: No folder or files list index currently opened...")
     SoundBeep , 300, 100
     SetTimer, RemoveTooltip, % -msgDisplayTime//2
     Return
  }

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If InStr(CurrentSLD, "\favourite-images-list.SLD")
  {
     retrieveFavesAsList()
     Return
  } Else If InStr(CurrentSLD, "\viewed-images-history-")
     Return

  If RegExMatch(CurrentSLD, sldsPattern)
  {
     If askAboutFileSave(" and the files list will be reloaded")
        Return

     thisIndex := currentFileIndex
     OpenSLD(CurrentSLD, 1)
     currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
     dummyTimerDelayiedImageDisplay(50)
  } Else If StrLen(CurrentSLD)>3
     RegenerateEntireList()
     ; coreOpenFolder(CurrentSLD)
}

OpenDialogFiles(dummy:=0) {
    Static lastInvoked := A_TickCount
    If (AnyWindowOpen || imageLoading=1) || (A_TickCount - lastInvoked<150)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.sld*)"
    ; pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
    ; pattern .= "|QPV slideshows (*.sld;*.sldb)"

    patternObj := {}
    patternObj["All files"] := "*.*"
    patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
    patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4 ";*.ico;*.sld*"
    patternObj["QPV slideshows"] := "*.sld;*.sldb"
    If isWinXP
       FileSelectFile, imgPath, 3, % prevOpenFolderPath, Open Image file, % pattern
    Else
       imgPath := openFileDialogWrapper("O1", "-", prevOpenFolderPath, "Open image or slideshow...", patternObj, chosenOption, 3, "open-folder")

    lastInvoked := A_TickCount
    If !imgPath
       Return

    If (askAboutFileSave(" and another image will be loaded") && !InStr(chosenOption, "instance"))
       Return

   zPlitPath(imgPath, 0, OutFileName, SelectedDir)
   If FolderExist(SelectedDir)
   {
      If InStr(chosenOption, "instance")
      {
         If RegExMatch(imgPath, RegExFilesPattern)
            OpenWithNewQPVinstance(0, imgPath, 2)
         Else
            OpenNewQPVinstance(SelectedDir)
         Return
      }

      newStaticFoldersListCache := []
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      lastInvoked := A_TickCount
      If RegExMatch(imgPath, sldsPattern)
      {
         OpenSLD(imgPath)
         Return
      }

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      doNotRecursive := InStr(chosenOption, "perform") ? "" : "|"
      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath) && InStr(chosenOption, "selected"))
      {
         SLDtypeLoaded := 1
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg
         MenuOpenLastImg(imgPath)
      } Else 
      {
         coreOpenFolder(doNotRecursive SelectedDir, 0, 0, 1)
         If (doNotRecursive && maxFilesIndex<1)
         {
            msgResult := msgBoxWrapper(appTitle ": Confirmation", "You have selected " SelectedDir "\ to open without recursive scanning. QPV found no supported image files in the folder.`n`nWould you like to recursively scan the given folder for supported image files?", 4, 0, "question")
            If (msgResult="Yes")
               coreOpenFolder(SelectedDir, 0, 0, 1)
         }
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         If FileRexists(imgPath)
         {
            currentFileIndex := detectFileID(imgPath)
            If (allowRecordHistory=1)
               IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

            IDshowImage(currentFileIndex)
         } Else If OutFileName
         {
            msgBoxWrapper(appTitle ": ERROR", "The selected image file (" OutFileName ") seems to be malformed or unsupported.`n`nAnother file from the folder will be displayed now. Files indexed: " maxFilesIndex ".", 0, 0, "error")
            RandomPicture()
         }
      } Else If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         RandomPicture()
      } ; Else resetMainWin2Welcome()
   }
   lastInvoked := A_TickCount
}

askAboutFileSave(msg:="", lvls:=1, dummy:=0) {
   Static lastInvoked := 1, prevAnswer
   lvls := (minimizeMemUsage=1 || A_PtrSize=4) ? 1 : 2
   If (preventUndoLevels=1)
      lvls := -1

   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1) && (A_TickCount - lastInvoked<300)
      Return prevAnswer

   r := 0
   If (StrLen(UserMemBMP)>3 && undoLevelsRecorded>lvls && currentImgModified=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      msgResult := msgBoxWrapper(appTitle ": Save image", "The currently edited image is about to be discarded" msg "...`n`nDo you want to save the current image?", "&Save|&Discard|&Cancel", 0, "question")
      If (msgResult="Save")
      {
         SetTimer, PanelSaveImg, -150
         r := 1
      } Else If (msgResult="Discard")
         r := 0
      Else ; If (msgResult="Ok")
         r := 1

      lastInvoked := A_TickCount
   }

   prevAnswer := r
   Return r
}

MenuOpenLastImg(forceOpenGiven:=0) {
   If (thumbsDisplaying=1)
   {
      MenuDummyToggleThumbsMode()
      Sleep, 25
   }

   If !FileRexists(forceOpenGiven)
   {
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      LastOpenedImg := Trimmer(LastOpenedImg)
   } Else LastOpenedImg := Trimmer(forceOpenGiven)

   If RegExMatch(LastOpenedImg, RegExFilesPattern) && FileRexists(LastOpenedImg)
   {
      If askAboutFileSave(" and another image will be loaded")
         Return

      If (thumbsDisplaying=1)
         ToggleThumbsMode()

      renewCurrentFilesList()
      setImageLoading()
      currentFileIndex := maxFilesIndex := 1
      resultedFilesList[1, 1] := LastOpenedImg
      IDshowImage(currentFileIndex)
      zPlitPath(LastOpenedImg, 0, OutFileName, OutDir)
      DynamicFoldersList := OutDir "`n"
      prevOpenFolderPath := OutDir
      CurrentSLD := "|" OutDir
      SLDtypeLoaded := 1
      INIaction(1, "prevOpenFolderPath", "General")
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
      winPrefix := defineWinTitlePrefix()
  
      SetTimer, GDIupdaterResize, Off
      mustOpenStartFolder := OutDir
      currentFileIndex := detectFileID(LastOpenedImg)
      pVwinTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
      setWindowTitle(pVwinTitle, 1)
      SetTimer, RemoveTooltip, -250
      SetTimer, ResetImgLoadStatus, -50
      If (RegExMatch(OutFileName, "i)(\.gif)$") && totalFramesIndex>1 && animGIFsSupport=1)
      {
         animGIFplaying := 0
         allowNextSlide := 1
         prevAnimGIFwas := ""
         dummyTimerDelayiedImageDisplay(250)
      }
      If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
         CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)
   }
}

OpenArgFile(inputu) {
    setImageLoading()
    Global scriptStartTime := A_TickCount
    currentFileIndex := maxFilesIndex := 1
    ; usrColorDepth := imgFxMode := 1
    ; RenderOpaqueIMG := vpIMGrotation := FlipImgH := FlipImgV := 0
    resultedFilesList[1, 1] := inputu
    IDshowImage(currentFileIndex)
    Global scriptStartTime := A_TickCount
    zPlitPath(inputu, 0, OutFileName, OutDir)
    DynamicFoldersList := OutDir "`n"
    zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
    winPrefix := defineWinTitlePrefix()

    SetTimer, GDIupdaterResize, Off
    mustOpenStartFolder := OutDir
    ; coreOpenFolder("|" OutDir, 0)
    Global scriptStartTime := A_TickCount
    currentFileIndex := detectFileID(inputu)
    winTitle := winPrefix currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
    setWindowTitle(winTitle, 1)
    SetTimer, RemoveTooltip, -250
    SetTimer, ResetImgLoadStatus, -50
    CurrentSLD := "|" OutDir
    SLDtypeLoaded := 1
    If (FlipImgH=1 || FlipImgV=1 || vpIMGrotation>0 || imgFxMode>1 || usrColorDepth>1)
       CreateGuiButton("Display unaltered image,,HardResetImageView", 0, msgDisplayTime//1.5 + 500)

    ; Else resetMainWin2Welcome()
    ; IDshowImage(currentFileIndex)
}

addNewFile2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   pattern := "Common image formats (" openFptrn1 ";" openFptrn2 ";" openFptrn4 ")"
   pattern .= "|Camera RAW files (" openFptrn3 ";*.sti)"
   If (SLDtypeLoaded!=3)
      pattern .= "|QPV slideshows plain-text (*.sld)"

   ; patternObj := {}
   ; patternObj["All files"] := "*.*"
   ; patternObj["Camera RAW files"] := openFptrn3 ";*.sti"
   ; patternObj["Common image formats"] := openFptrn1 ";" openFptrn2 ";" openFptrn4
   ; If (SLDtypeLoaded!=3)
   ;     patternObj["QPV slideshows plain-text"] := "*.sld"

   imgsListu := openFileDialogWrapper("M", "AllowMultiSelect FileMustExist", prevOpenFolderPath, "Add image file(s) to the list...", pattern, null, 1)
   If !imgsListu
      Return "cancel"

   If AnyWindowOpen
      CloseWindow("yes")
   Sleep, 25
   If askAboutFileSave(" and the selected file(s) will be added to the list")
      Return

   showTOOLtip("Processing files list, please wait...")
   setImageLoading()
   If InStr(imgsListu, "`n")
      firstFile := Trimmer(SubStr(imgsListu, 1, InStr(imgsListu, "`n")))
   Else
      firstFile := Trimmer(imgsListu)

   zPlitPath(firstFile, 0, OutFileName, SelectedDir)
   countFiles := ST_Count(imgsListu, "`n")
   ; msgbox, % firstFile "a`n" countFiles "`n" imgsListu
   If StrLen(SelectedDir)>3
   {
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
   }

   If (RegExMatch(firstFile, "i)(.\.sld)$") && SLDtypeLoaded!=3)
   {
      If StrLen(filesFilter)>1
      {
         markedSelectFile := 0
         showTOOLtip("Deactivating the files list filter, please wait...")
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
         Sleep, 10
         RemoveTooltip()
      }

      mustOpenStartFolder := ""
      showTOOLtip("Importing slideshow file, please wait...`n" OutFileName "`n" SelectedDir "\")
      If (SLDtypeLoaded=2)
         DynamicFoldersList := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList

      FileReadLine, firstLine, % firstFile, 1
      mustRemQuotes := InStr(firstLine, "[General]") ? 0 : 1
      If !mustRemQuotes
      {
         IniRead, testDynaFolderz, % firstFile, DynamicFolderz, DF1, @
         If StrLen(testDynaFolderz)>4
            DynamicFoldersList .= "`n" coreLoadDynaFolders(firstFile)
      }
      Sort, DynamicFoldersList, UD`n
      res := sldGenerateFilesList(firstFile, 0, mustRemQuotes, 0)
      SoundBeep , 900, 100
      GenerateRandyList()
      RandomPicture()
   } Else If StrLen(imgsListu)>3
   {
      showTOOLtip("Processing files list, please wait...")
      setImageLoading()
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, SelectedDir)
      GenerateRandyList()
      currentFileIndex := maxFilesIndex - 1
      ForceRefreshNowThumbsList()
      dummyTimerDelayiedImageDisplay(50)
   }
   ResetImgLoadStatus()
   SetTimer, RemoveTooltip, % -msgDisplayTime//2
}

coreAddNewFiles(imgsListu, countFiles, SelectedDir, selectNewOnes:=0) {
    If CurrentSLD
       dropFilesSelection(1)

    showTOOLtip("Adding " countFiles " files into the current files list...")
    If StrLen(filesFilter)>1
    {
       usrFilesFilteru := filesFilter := ""
       FilterFilesIndex()
    }

    Loop, Parse, imgsListu, `n`r
    {
       line := Trimmer(A_LoopField)
       If StrLen(line)<3
          Continue

       changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          SLDhasFiles := 1
          maxFilesIndex++
          If (selectNewOnes=1)
             markedSelectFile++
          resultedFilesList[maxFilesIndex] := [line, selectNewOnes]
       }

       If (SLDtypeLoaded=3 && maxFilesIndex>1)
       {
          zPlitPath(line, 0, OutFileName, OutDir)
          FileGetTime, fileMdate, % line, M
          FileGetTime, fileCdate, % line, C
          FileGetSize, fileSizu, % line
          addSQLdbEntry(OutFileName, OutDir, fileSizu, fileMdate, fileCdate)
       }
    }

    If (!CurrentSLD && maxFilesIndex>0)
       CurrentSLD := SelectedDir "\newFile.SLD"

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

addNewFolder2list() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   SelectImg := openFoldersDialogWrapper("S2", prevOpenFolderPath, "Add new folder(s) to the list")
   If !Trim(SelectImg)
      Return "cancel"

   SelectedDir := Trimmer(SelectImg)
   If SelectedDir
   {
      If askAboutFileSave(" and new files will be added from the selected folder")
         Return

      If InStr(DynamicFoldersList, SelectedDir "`n")
      {
         msgResult := msgBoxWrapper(appTitle, "The folder you want to add, seems to be already indexed. Are you sure you want to add it again? This action will likely lead to duplicate entries in the list.`n`n" SelectedDir "\", 4, 0, "question")
         If (msgResult!="yes")
            Return "cancel"
      }

      msgResult := msgBoxWrapper(appTitle, "Do you want to scan for image files recursively, through all its subfolders?`n`n" SelectedDir "\", 3, 0, "question")
      If (msgResult="no")
         isRecursive := "|"
      Else If (msgResult="cancel")
         Return "cancel"

      CloseWindow("yes")
      Sleep, 1
      prevOpenFolderPath := SelectedDir
      INIaction(1, "prevOpenFolderPath", "General")
      coreAddNewFolder(isRecursive SelectedDir, 1)
      If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2)
      {
         FileReadLine, firstLine, % CurrentSLD, 1
         If (!InStr(firstLine, "[General]") || SLDcacheFilesList!=1)
            good2go := "null"
      } Else good2go := "null"
      If (SLDtypeLoaded=3)
         good2go := 0

      modus := isRecursive ? 1 : 0
      If (mustGenerateStaticFolders=0 && good2go!="null" && RegExMatch(CurrentSLD, sldsPattern))
         updateCachedStaticFolders(SelectedDir, modus)
      Else mustGenerateStaticFolders := 1

      listu := DynamicFoldersList "`n" isRecursive SelectedDir "`n"
      Sort, listu, UD`n
      DynamicFoldersList := listu
      If (SLDtypeLoaded=3)
         recreateDynaFoldersSQLdbList(listu)

      If !CurrentSLD
      {
         CurrentSLD := SelectedDir "\newFile.SLD"
         RandomPicture()
      }
   }
}

coreAddNewFolder(SelectedDir, remAll, noRandom:=0) {
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    markedSelectFile := 0
    If StrLen(filesFilter)>1
    {
       usrFilesFilteru := filesFilter := ""
       FilterFilesIndex()
    }

    If (remAll=1)
       thisFolder := StrReplace(SelectedDir, "|")
    Else
       thisFolder := SelectedDir

    remFilesFromList(thisFolder, 1)
    GetFilesList(SelectedDir "\*")
    GenerateRandyList()
    SoundBeep, 900, 100
    CurrentSLD := backCurrentSLD
    If (noRandom=1)
    {
       currentFileIndex := maxFilesIndex - 1
       IDshowImage(currentFileIndex)
    } Else RandomPicture()
}

detectFileID(imgPath) {
    Loop, % maxFilesIndex + 1
    {
       If (resultedFilesList[A_Index, 1]=imgPath)
       {
          good := A_Index
          Break
       }
    }
    If !good
       good := 1

    Return good
}

GuiDroppedFiles(imgsListu, foldersListu, sldFile, countFiles, isCtrlDown) {
   Critical, on
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked<900)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   lastInvoked := A_TickCount
   If (imgsListu && isCtrlDown=1)
   {
      OpenWithNewQPVinstance(0, imgsListu, countFiles)
      Return
   }

   If sldFile
   {
      OpenSLD(sldFile)
      lastInvoked := A_TickCount
      Return
   }

   If ((CurrentSLD || maxFilesIndex>1) && StrLen(foldersListu)>3)
      msgResult := msgBoxWrapper(appTitle, "Would you like to import the dropped folder(s) to the current files list?", "&Import|&New list|&Cancel", 1, "question")

   If (msgResult="cancel")
   {
      lastInvoked := A_TickCount
      Return
   } Else If InStr(msgResult, "new")
   {
      mainFoldersListu := CurrentSLD := DynamicFoldersList := ""
      renewCurrentFilesList()
      AnyWindowOpen := 1000
      resetMainWin2Welcome()
      AnyWindowOpen := ""
   }

   If StrLen(foldersListu)>3
   {
      mustOpenStartFolder := ""
      mainFoldersListu := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
      doStartLongOpDance()
      dropFilesSelection(1)
      showTOOLtip("Opening folders, please wait...")
      If StrLen(filesFilter)>1
      {
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
      }

      Loop, Parse, foldersListu,`n
      {
          linea := Trimmer(A_LoopField)
          If StrLen(linea)<4
             Continue

          changeMcursor()
          warningMsg := 0
          Loop, Parse, mainFoldersListu, `n
          {
              line := Trimmer(A_LoopField)
              If StrLen(line)<4
                 Continue

              If (line=linea)
                 warningMsg := 1
          }

          If (warningMsg=1)
             Continue

          stuffAdded := 1
          GetFilesList(linea "\*")
          DynamicFoldersList .= linea "`n"
          lastOne := linea
          If (SLDtypeLoaded=3)
             addDynamicFolderSQLdb(linea, 0, "dynamicfolders")
      }

      If (stuffAdded=1)
      {
         Sort, DynamicFoldersList, UD`n
         newStaticFoldersListCache := []
         mustGenerateStaticFolders := 1
         GenerateRandyList()
      }

      If !CurrentSLD
      {
         If FolderExist(StrReplace(Trimmer(DynamicFoldersList), "|"))
         {
            SLDtypeLoaded := 1
            CurrentSLD := Trimmer(DynamicFoldersList)
         } Else
         {
            SLDtypeLoaded := 2
            CurrentSLD := lastOne "\newFile.SLD"
         }
      }
      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      RandomPicture()
   } Else If (imgsListu && countFiles=1 && !CurrentSLD)
   {
      imgPath := Trimmer(imgsListu)
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      If !OutDir
      {
         lastInvoked := A_TickCount
         Return
      }

      If (RegExMatch(imgPath, RegExFilesPattern) && FileRexists(imgPath))
      {
         SLDtypeLoaded := 1
         lastInvoked := A_TickCount
         If (allowRecordHistory=1)
            IniWrite, % imgPath, % mainSettingsFile, General, LastOpenedImg

         MenuOpenLastImg(imgPath)
         lastInvoked := A_TickCount
         Return
      }

      showTOOLtip("Opening file...`n" imgPath)
      newStaticFoldersListCache := []
      dropFilesSelection(1)
      If StrLen(filesFilter)>1
      {
         usrFilesFilteru := filesFilter := ""
         FilterFilesIndex()
      }

      If !InStr(msgResult, "new")
      {
         prevMaxFilesIndex := maxFilesIndex
         prevFoldersDyna := DynamicFoldersList
         bckpResultedFilesList := resultedFilesList.Clone()
      }

      If (SLDtypeLoaded=3)
      {
         SLDtypeLoaded := 0
         activeSQLdb.CloseDB()
      }

      coreOpenFolder("|" OutDir, 0)
      If prevMaxFilesIndex
      {
         DynamicFoldersList .= prevFoldersDyna
         Loop, % prevMaxFilesIndex
         {
             r := bckpResultedFilesList[A_Index, 1]
             If (r && !InStr(r, "||"))
             {
                maxFilesIndex++
                resultedFilesList[maxFilesIndex, 1] := r
             }
         }
         bckpResultedFilesList := []
      }

      SetTimer, RemoveTooltip, % -msgDisplayTime
      If (maxFilesIndex>0)
      {
         SLDtypeLoaded := 1
         currentFileIndex := detectFileID(imgPath)
         IDshowImage(currentFileIndex)
      } Else resetMainWin2Welcome()
   } Else If StrLen(imgsListu)>3
   {
      mustOpenStartFolder := ""
      coreAddNewFiles(imgsListu, countFiles, prevOpenFolderPath)
      mustGenerateStaticFolders := 1
      GenerateRandyList()
      SetTimer, ResetImgLoadStatus, -50
      If (A_TickCount - lastInvoked>2000)
         SoundBeep, 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      currentFileIndex := maxFilesIndex
      dummyTimerDelayiedImageDisplay(50)
   }
   lastInvoked := A_TickCount
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

dummyShowToolTip() {
   showTOOLtip("nully")
}

showTOOLtip(msg, l:=0, z:=0, perc:=0) {
   Critical, on
   Static prevMsg
   If (msg="nully" && prevMsg)
      msg := prevMsg

   prevMsg := msg
   If (noTooltipMSGs=0 || thumbsDisplaying=1)
   {
      CreateOSDinfoLine(msg, 0, 0, perc)
      If (AnyWindowOpen>0 && WinActive("A")=hSetWinGui)
      {
         GetPhysicalCursorPos(mX, mY)
         ToolTip, % msg, % mX + 25, % mY + 25
      } Else If (AnyWindowOpen>0)
         ToolTip
   } Else
   {
      msg := StrReplace(msg, "`n", "  ")
      setWindowTitle(msg, 1)
   }
}

RemoveTooltip() {
   Tooltip
   CreateOSDinfoLine(1, 1)
   If (noTooltipMSGs=1)
   {
      clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
      winTitle := (CurrentSLD) ? pVwinTitle : appTitle
      setWindowTitle(winTitle, 1)
   }
}

associateSLDsNow() {
    FileAssociate("QPVslideshow",".sld", fullPath2exe)
    FileAssociate("QPVslideshow",".sldb", fullPath2exe)
}

associateWithImages() {
  Static FileFormatsCommon := "png|bmp|gif|jpg|tif|tga|webp|jpeg|tiff|exr|hdr|psd"
       , allFormats := "dib|tif|tiff|emf|wmf|rle|png|bmp|gif|jpg|jpeg|jpe|DDS|EXR|HDR|IFF|JBG|JNG|JP2|JXR|JIF|MNG|PBM|PGM|PPM|PCX|PFM|PSD|PCD|SGI|RAS|TGA|WBMP|WEBP|XBM|XPM|G3|LBM|J2K|J2C|WDP|HDP|KOA|PCT|PICT|PIC|TARGA|WAP|WBM|crw|cr2|nef|raf|mos|kdc|dcr|3fr|arw|bay|bmq|cap|cine|cs1|dc2|drf|dsc|erf|fff|ia|iiq|k25|kc2|mdc|mef|mrw|nrw|orf|pef|ptx|pxn|qtk|raw|rdc|rw2|rwz|sr2|srf|sti|x3f|jfif"

  Loop, Parse, FileFormatsCommon, |
  {
      If !A_LoopField
         Continue

      FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
  }
  Sleep, 25
  RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
  Sleep, 5
  FileDelete, %mainCompiledPath%\regFiles\*.reg
  FileDelete, %mainCompiledPath%\regFiles\*.bat
  msgResult := msgBoxWrapper(appTitle, appTitle " was now associated with common image file formats. Would you like to associate it with all the 85 supported file formats?", 4, 0, "question")
  If (msgResult="yes")
  {
     Loop, Parse, allFormats, |
     {
         If !A_LoopField
            Continue
 
         FileAssociate("QPVimage." A_LoopField,"." A_LoopField, fullPath2exe,,1)
     }
 
     Sleep, 25
     RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     Sleep, 5
     FileDelete, %mainCompiledPath%\regFiles\*.reg
     FileDelete, %mainCompiledPath%\regFiles\*.bat
  }
  addJournalEntry(appTitle " has been associated with image file formats")
}

closeDocuments() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (animGIFplaying=1)
   {
      DestroyGIFuWin()
      Return
   }

   If askAboutFileSave(". The current files list will be discarded as well")
      Return

   resetMainWin2Welcome()
   addJournalEntry("All images/documents closed.")
}

restartAppu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will restart")
      Return

   ; writeMainSettings()
   If A_IsCompiled
      Try Run, "%fullPath2exe%"
   Else
      Try Run, %unCompiledExePath%

   TrueCleanup(0)
   Sleep, 5
   ExitApp
}

exitAppu(dummy:=0) {
   If (A_IsSuspended && MsgBox2hwnd && dummy="external")
   {
      interfaceThread.ahkPostFunction("dummyTimerExit")
      terminateIMGediting()
      TrueCleanup()
      Return
   }

   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   If askAboutFileSave(" and the application will exit")
      Return

   terminateIMGediting()
   TrueCleanup()
}

InitGuiContextMenu() {
   If (slideShowRunning=1)
      ToggleSlideShowu()

   DestroyGIFuWin()
   SetTimer, BuildMainMenu, -5
   ; WinActivate, ahk_id %PVhwnd%
}

Win_SetMenu(Hwnd, hMenu=0) {
   hPrevMenu := DllCall("GetMenu", "uint", hwnd, "Uint")
   DllCall("SetMenu", "uint", hwnd, "uint", hMenu)
   return hPrevMenu
}

PathCompact(givenPath, CharMax) {
    If (StrLen(givenPath)>CharMax+3)
    {
       lastSlash := InStr(givenPath, "\", 0, 0)
       partB := SubStr(givenPath, lastSlash)
       If (StrLen(partB)>CharMax+2)
          partB := SubStr(givenPath, -CharMax)

       partA := SubStr(givenPath, 1, Max(CharMax - StrLen(partB), 3)) "..."
       Return partA partB
    } Else Return givenPath
}

createMenuCurrentFile() {
   Menu, PVtFile, Add, Cop&y file path(s) to clipboard`tShift+C, CopyImagePath
   Menu, PVtFile, Add, Copy file(s) (for Explorer)`tCtrl+C, MenuExplorerCopyFiles
   Menu, PVtFile, Add, C&ut file(s) (for Explorer)`tCtrl+X, MenuExplorerCutFiles
   Menu, PVtFile, Add, 
   If !markedSelectFile
      Menu, PVtFile, Add, &Open with external app`tO, OpenThisFileMenu

   ; If (thumbsDisplaying=1)
   friendly := markedSelectFile ? "Open files in new &QPV instances" : "Open file in a new &QPV instance"
   Menu, PVtFile, Add, % friendly, OpenWithNewQPVinstance
   If (!markedSelectFile && RegExMatch(CurrentSLD, sldsPattern))
      Menu, PVtFile, Add, &Open in QPV containing folder, OpenQPVfileFolder

   If !markedSelectFile
      Menu, PVtFile, Add, &Explore containing folder`tCtrl+E, OpenThisFileFolder

   If !markedSelectFile
      Menu, PVtFile, Add, Set as &wallpaper`tCtrl+W, setImageWallpaper

   Menu, PVtFile, Add, 
   If (thumbsDisplaying=1 && !markedSelectFile)
      Menu, PVtFile, Add, &Import into currently loaded image, importGivenFile

   If !markedSelectFile
      Menu, PVtFile, Add, &Select / deselect file`tTab, MenuMarkThisFileNow
   If (skipSeenImagesSlider=1 && thumbsDisplaying=1)
      Menu, PVtFile, Add, &Toggle SEEN status`tS, ToggleSeenIMGstatus

   Menu, PVtFile, Add, Con&vert file format(s) to...`tCtrl+K, PanelFileFormatConverter
   If markedSelectFile
   {
      file2rem := getIDimage(currentFileIndex)
      If RegExMatch(file2rem, "i)(.\.(jpg|jpeg))$")
         Menu, PVtFile, Add, &JPEG lossless operations`tK, PanelJpegPerformOperation
      Menu, PVtFile, Add, Resi&ze/rotate/crop images`tCtrl+R, PanelSimpleResizeRotate
      Menu, PVtFile, Add, &Auto-crop images`tAlt+Y, PanelImgAutoCrop
      If (imgFxMode>1)
         Menu, PVtFile, Add, Apply vie&wport color adjustments`tAlt+Shift+U, batchApplyColorsOnFiles
   }
   Menu, PVtFile, Add, &Delete file(s)`tDelete, DeletePicture
   Menu, PVtFile, Add, &Rename file(s)`tF2, PanelRenameThisFile
   Menu, PVtFile, Add,
   Menu, PVtFile, Add, &Move file(s) to...`tM, PanelMoveCopyFiles
   Menu, PVtFile, Add, &Copy file(s) to...`tC, InvokeCopyFiles
   Menu, PVtFile, Add,
   If !markedSelectFile
      Menu, PVtFile, Add, &File information`tAlt+Enter, PanelImageInfos
}

createMenuSoloFile() {
   Menu, PVtActFile, Add, &Open with external app`tO, OpenThisFileMenu
   Menu, PVtActFile, Add, Open file in a new &QPV instance, SoloOpenWithNewQPVinstance
   If RegExMatch(CurrentSLD, sldsPattern)
      Menu, PVtActFile, Add, &Open in QPV containing folder, OpenQPVfileFolder

   Menu, PVtActFile, Add, &Explore containing folder`tCtrl+E, OpenThisFileFolder
   Menu, PVtActFile, Add, Set as &wallpaper`tCtrl+W, setImageWallpaper

   If (thumbsDisplaying=1)
      Menu, PVtActFile, Add, &Import into currently loaded image, importGivenFile

   Menu, PVtActFile, Add, 
   If !markedSelectFile
      Menu, PVtActFile, Add, &Select / deselect file`tTab, MenuMarkThisFileNow
   Menu, PVtActFile, Add, Remove index entry`tAlt+Delete, InListMultiEntriesRemover
   Menu, PVtActFile, Add, Modify index entry`tCtrl+F2, PanelUpdateThisFileIndex
   Menu, PVtActFile, Add, 
   Menu, PVtActFile, Add, &Delete file`tDelete, DeleteActivePicture
   Menu, PVtActFile, Add, &Rename file`tShift+F2, SingularRenameFile
   Menu, PVtActFile, Add, &File information`tAlt+Enter, PanelImageInfos
}

MenuSelectAllAction() {
   selectEntireImage("r")
}

MenuDoOpenStartFolder() {
  If StrLen(mustOpenStartFolder)>3
     currentFileIndex := doOpenStartFolder()
   dummyTimerDelayiedImageDisplay(50)
   RemoveTooltip()
}

MenuToggleColorAdjustments() {
   If (imgFxMode=1)
   {
      ColorPanelTriggerImageUpdate("ignore-zoom")
   } Else
   {
      o_usrColorDepth := usrColorDepth
      imgFxMode := usrColorDepth := 1
      If (o_usrColorDepth=1)
         dummyTimerDelayiedImageDisplay(50)
      Else
         dummyTimerReloadThisPicture(50)
   }
}

MenuStartDrawingShapes() {
   startDrawingShape("shape")
}

MenuStartDrawingLines() {
   startDrawingShape("line")
}

BuildImgLiveEditMenu() {
      If (editingSelectionNow!=1 && !AnyWindowOpen) || (thumbsDisplaying=1)
         Return

      deleteMenus()
      Menu, PVedit, Add, Live tools, dummy
      Menu, PVedit, Disable, Live tools
      Menu, PVedit, Add, &Erase or fade area`tDelete, PanelEraseSelectedArea
      Menu, PVedit, Add, &Fill area or draw shapes`tAlt+Bksp, PanelFillSelectedArea
      Menu, PVedit, Add, &Draw predetermined lines or arcs`tShift+L, PanelDrawLines
      Menu, PVedit, Add, Dra&w freeform filled shape`tShift+P, MenuStartDrawingShapes
      Menu, PVedit, Add, Draw freeform outline`tP, MenuStartDrawingLines
      Menu, PVedit, Add, &Insert te&xt`tShift+T, PanelInsertTextArea
      Menu, PVedit, Add, &Adjust image vie&w`tU, PanelColorsAdjusterWindow
      If (AnyWindowOpen=10)
         Menu, PVedit, Check, &Adjust image vie&w`tU
      If (AnyWindowOpen=23)
         Menu, PVedit, Check, &Fill area or draw shapes`tAlt+Bksp
      Else If (AnyWindowOpen=25)
         Menu, PVedit, Check, &Erase or fade area`tDelete
      Else If (AnyWindowOpen=30)
         Menu, PVedit, Check, &Draw predetermined lines or arcs`tShift+L
      Else If (AnyWindowOpen=32)
         Menu, PVedit, Check, &Insert te&xt`tShift+T

      Menu, PVedit, Add,
      Menu, PVedit, Add, Other operations, dummy
      Menu, PVedit, Disable, Other operations
      Menu, PVedit, Add, Flip selected &horizontally`tShift+H, FlipSelectedAreaH
      Menu, PVedit, Add, Flip selected &vertically`tShift+V, FlipSelectedAreaV
      Menu, PVedit, Add, &Invert colors`tShift+I, InvertSelectedArea
      Menu, PVedit, Add, Desaturate color&s`tCtrl+G, GraySelectedArea
      If (AnyWindowOpen!=10)
         Menu, PVedit, Add, &Limit color effects to selection`tShift+U, ApplyColorAdjustsSelectedArea

      If (AnyWindowOpen!=10)
      {
         If (imgEditPanelOpened=1 && AnyWindowOpen)
            Menu, PVmenu, Add, &Toggle tool panel`tM-Click\F8, toggleImgEditPanelWindow
         If (AnyWindowOpen!=24 && AnyWindowOpen!=31)
            Menu, PVmenu, Add, S&witch tool, :PVedit
      } Else
      {
         Menu, PVmenu, Add, &Toggle panel`tM-Click\F8, toggleImgEditPanelWindow
         If (editingSelectionNow=1)
            Menu, PVmenu, Add, S&witch tool, :PVedit
         Menu, PVmenu, Add, &Close panel`tEsc, CloseWindow
         If (editingSelectionNow=1)
            Menu, PVmenu, Add, &Apply color effects to selection`tShift+U, ApplyColorAdjustsSelectedArea
         Menu, PVmenu, Add, &Activate viewport color adjustments`t\, MenuToggleColorAdjustments
         If (ForceNoColorMatrix!=1 && imgFxMode!=1)
            Menu, PVmenu, Check, &Activate viewport color adjustments`t\
         Menu, PVmenu, Add, &Reset all adjustments to defaults`tCtrl+\, BtnResetImageView
         Menu, PVmenu, Add,
      }

      If (imgEditPanelOpened=1 && AnyWindowOpen && AnyWindowOpen!=10)
      {
         Menu, PVmenu, Add, 
         Menu, PVmenu, Add, &Apply tool`tShift+Enter, applyIMGeditFunction
         Menu, PVmenu, Add, &Apply and close panel`tEnter, applyIMGeditFunctionClose
         Menu, PVmenu, Add, &Cancel (close panel)`tEsc, CloseWindow
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         Menu, PVmenu, Add, 
         Menu, PVmenu, Add, &Undo`tCtrl+Z, ImgUndoAction
         Menu, PVmenu, Add, &Redo`tCtrl+Y, ImgRedoAction
      }

      If (imgEditPanelOpened!=1 || AnyWindowOpen=10)
      {
         Menu, PVmenu, Add, &Show selection`tE, tlbrToggleImgSelection
         If (editingSelectionNow=1)
            Menu, PVmenu, Check, &Show selection`tE
         If (editingSelectionNow=1)
         {
            Menu, PVselv, Add, &Reset selection, newImgSelection
            Menu, PVselv, Add, Sho&w grid, ToggleSelectGrid
            If (showSelectionGrid=1)
               Menu, PVselv, Check, Sho&w grid
         } Else Menu, PVmenu, Add, &Select all`tCtrl+A, MenuSelectAllAction
      }

      If (undoLevelsRecorded>1 && undoLevelsRecorded!="" && editingSelectionNow=1)
      {
         Menu, PVselv, Add, 
         Menu, PVselv, Add, &Undo selection`tCtrl+Shift+Z, ImgSelUndoAct
         Menu, PVselv, Add, &Redo selection`tCtrl+Shift+Y, ImgSelRedoAct
      }

      If (editingSelectionNow=1)
      {
         Menu, PVselv, Add, 
         Menu, PVselv, Add, &Select all`tCtrl+A, MenuSelectAllAction
         If (lockSelectionAspectRatio=0)
            Menu, PVselv, Add, S&quare ratio selection [1:1]`tR, makeSquareSelection
         If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=24 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=10)
         {
            Menu, PVselv, Add, Elli&pse selection`tShift+E, toggleEllipseSelection
            If (EllipseSelectMode=1)
               Menu, PVselv, Check, Elli&pse selection`tShift+E
         }

         Menu, PVselv, Add, &Flip selection W/H`tI, flipSelectionWH
         Menu, PVselv, Add, &Limit selection to image area`tL, toggleLimitSelection
         Menu, PVselv, Add, 
         Menu, PVselv, Add, R&otate by 45°`tShift+R, MenuSelRotation
         Menu, PVselv, Add, R&eset rotation`tShift+\, resetSelectionRotation
         Menu, PVselv, Add, &Keep aspect ratio on rotation, ToggleSelKeepRatioRotation

         defiSelAR := defineSelectionAspectRatios()
         Menu, PVselv, Add, Toggle loc&k aspect ratio`tShift+A, toggleImgSelectionAspectRatio
         Menu, PVselv, Add, %defiSelAR%, dummy
         Menu, PVselv, Disable, %defiSelAR%

         If (lockSelectionAspectRatio>0)
            Menu, PVselv, Check, Toggle loc&k aspect ratio`tShift+A
         If (rotateSelBoundsKeepRatio=1)
            Menu, PVselv, Check, &Keep aspect ratio on rotation
         If (LimitSelectBoundsImg=1)
            Menu, PVselv, Check, &Limit selection to image area`tL
      }

      Menu, PVmenu, Add, 
      If (editingSelectionNow=1)
      {
         Try Menu, PVmenu, Add, &Selection area, :PVselv
         If !AnyWindowOpen
            Menu, PVmenu, Add, Selection &properties`tAlt+E, PanelIMGselProperties
      }

      Menu, PVmenu, Add, 
      Menu, PVmenu, Add, A&dapt image to window`t/, ToggleImageSizingMode
      If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
         Menu, PVmenu, Add, &Hide dynamic object`tD, hideLivePreviewObject
      If (IMGresizingMode=1)
         Menu, PVmenu, Check, A&dapt image to window`t/

      showThisMenu("PVmenu")
}

hideLivePreviewObject() {
   livePreviewsImageEditing(1, 2)
}

BuildMainMenu() {
   Static lastInvoked := 1
   If (toolTipGuiCreated=2)
      RemoveTooltip()

   If (drawingShapeNow=1)
   {
      stopDrawingShape()
      Return
   }

   If (imgEditPanelOpened=1)
   {
      deleteMenus()
      BuildImgLiveEditMenu()
      Return
   }

   If (AnyWindowOpen>0)
   {
      If ((A_TickCount - lastInvoked < 650) && !MsgBox2hwnd)
         CloseWindow()
      Else
         WinActivate, ahk_id %hSetWinGui%
      lastInvoked := A_TickCount
      Return
   }

   If (StrLen(hitTestSelectionPath)>2 && editingSelectionNow=1 && adjustNowSel=0 && imgSelLargerViewPort!=1)
   {
      GetMouseCoord2wind(PVhwnd, mX, mY)
      Gdip_SetPenWidth(pPen1d, SelDotsSize)
      hitB := Gdip_IsOutlineVisiblePathPoint(2NDglPG, hitTestSelectionPath, pPen1d, mX, mY)
      If (hitB=1)
      {
         BuildImgLiveEditMenu()
         Return
      }
   }

   SetTimer, drawWelcomeImg, Off
   deleteMenus()
   createMenuCurrentFile()
   ResetImgLoadStatus()
   Global lastWinDrag := A_TickCount
   sliSpeed := Round(slideShowDelay/1000, 2) " sec."
   Menu, PVslide, Add, &Start slideshow`tSpace, dummyInfoToggleSlideShowu
   Menu, PVslide, Add, Smoot&h transitions, ToggleSlidesTransitions
   Menu, PVslide, Add, &Easy slideshow stopping, ToggleEasySlideStop
   Menu, PVslide, Add, &Wait for GIFs to play once, ToggleGIFsPlayEntirely
   If (animGIFsSupport!=1 || alwaysOpenwithFIM=1)
      Menu, PVslide, Disable, &Wait for GIFs to play once
   Menu, PVslide, Add, S&kip already seen images, ToggleSkipSeenIMGs
   Menu, PVslide, Add, 
   Menu, PVslide, Add, De&fine slideshow duration`tShift+/, PanelDefineEntireSlideshowLength
   Menu, PVslide, Add, % EstimateSlideShowLength(1), dummy
   Menu, PVslide, Disable, % EstimateSlideShowLength(1)
   Menu, PVslide, Add,
   Menu, PVslide, Add, &Toggle slideshow mode`tS, SwitchSlideModes
   Menu, PVslide, Add, % DefineSlideShowType(), SwitchSlideModes
   Menu, PVslide, Disable, % DefineSlideShowType()
   Menu, PVslide, Add,
   Menu, PVslide, Add, &Increase speed`tComma [`,], IncreaseSlideSpeed
   Menu, PVslide, Add, &Decrease speed`tDot [.], DecreaseSlideSpeed
   Menu, PVslide, Add, Current speed: %sliSpeed%, DecreaseSlideSpeed
   Menu, PVslide, Disable, Current speed: %sliSpeed%
   If (skipSeenImagesSlider=1)
      Menu, PVslide, Check, S&kip already seen images
   If (allowGIFsPlayEntirely=1)
      Menu, PVslide, Check, &Wait for GIFs to play once
   If (doSlidesTransitions=1)
      Menu, PVslide, Check, Smoot&h transitions
   If (minimizeMemUsage=1)
      Menu, PVslide, Disable, Smoot&h transitions
   If (easySlideStoppage=1)
      Menu, PVslide, Check, &Easy slideshow stopping

   infolumosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(lumosAdjust, 2) : Round(lumosGrayAdjust, 2)
   infoGammosAdjust := (imgFxMode=2 || imgFxMode=3) ? Round(GammosAdjust, 2) : Round(GammosGrayAdjust, 2)
   infoSatAdjust := (imgFxMode=4) ? zatAdjust : Round(satAdjust*100)

   If (thumbsDisplaying=1)
   {
      infoThumbZoom := thumbsW "x" thumbsH " (" Round(thumbsZoomLevel*100) "%)"
      Menu, PVview, Add,
      Menu, PVview, Add, &Toggle aspect ratio`tT, ChangeThumbsAratio
      Menu, PVview, Add, % defineThumbsAratio(), ChangeThumbsAratio
      Menu, PVview, Disable, % defineThumbsAratio()
      Menu, PVview, Add,
      Menu, PVview, Add, Thumbnails size:, ChangeThumbsAratio
      Menu, PVview, Disable, Thumbnails size:
      Menu, PVview, Add, % infoThumbZoom, ChangeThumbsAratio
      Menu, PVview, Disable, % infoThumbZoom
   } Else
   {
      thisAlignInfo := defineImgAlign()
      If InStr(currIMGdetails.PixelFormat, "TONE-MAPPED")
         Menu, PVview, Add, &HDR tone-mapping, PanelAdjustToneMapping

      Menu, PVview, Add, Viewport and color adjustments panel`tU, PanelColorsAdjusterWindow
      If (editingSelectionNow!=1)
         Menu, PVview, Add, &Show selection area`tE, ToggleEditImgSelection

      friendlyPix := (coreDesiredPixFmt="0x21808") ? "24-RGB" : "32-RGBA"
      Menu, PVview, Add,
      Menu, PVview, Add, Pixel format mode: %friendlyPix%, ToggleCorePixFmt
      Menu, PVview, Add, Remove alpha channel, ToggleRenderOpaque
      Menu, PVview, Add, Image &alignment: %thisAlignInfo%`tA, ToggleIMGalign
      Menu, PVview, Add, Image &rotation: %vpIMGrotation%°`t9`, 0, MenuChangeImgRotationInVP
      Menu, PVview, Add,
      Menu, PVview, Add, &Toggle color depth`tQ, ToggleImgColorDepth
      Menu, PVview, Add, % defineColorDepth(), ToggleImgColorDepth
      Try Menu, PVview, Disable, % defineColorDepth()
      Menu, PVview, Add, &Toggle resizing mode`tT, ToggleImageSizingMode
      Menu, PVview, Add, % DefineImgSizing(), ToggleImageSizingMode
      Menu, PVview, Disable, % DefineImgSizing()
      If (RenderOpaqueIMG=1)
         Menu, PVview, Check, Remove alpha channel
   }

   Menu, PVview, Add,
   Menu, PVview, Add, &Toggle colors display mode`tF, ToggleImgFX
   Menu, PVview, Add, % DefineFXmodes(), ToggleImgFX
   Menu, PVview, Disable, % DefineFXmodes()
   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4)
   {
      Menu, PVview, Add, Br: %infolumosAdjust% / Ctr: %infoGammosAdjust% / dS: %infoSatAdjust%, ToggleImgFX
      Menu, PVview, Disable, Br: %infolumosAdjust% / Ctr: %infoGammosAdjust% / dS: %infoSatAdjust%
   }

   Menu, PVview, Add,
   If (thumbsDisplaying!=1)
   {
      Menu, PVview, Add, Mirror &horizontally`tH, TransformIMGh
      Menu, PVview, Add, Mirror &vertically`tV, TransformIMGv
      Menu, PVview, Add,
      Menu, PVview, Add, Reset image vie&w now`t\, ResetImageView
      Menu, PVview, Add, Reset adjustments on image change, ToggleAutoResetImageView
      If (resetImageViewOnChange=1)
         Menu, PVview, Check, Reset adjustments on image change
      If (FlipImgV=1)
         Menu, PVview, Check, Mirror &vertically`tV
      If (FlipImgH=1)
         Menu, PVview, Check, Mirror &horizontally`tH
   }

   Menu, PVnav, Add, &Skip missing files, ToggleSkipDeadFiles
   If (skipDeadFiles=1)
      Menu, PVnav, Check, &Skip missing files

   Menu, PVnav, Add,
   Menu, PVnav, Add, &First`tHome, FirstPicture
   Menu, PVnav, Add, &Previous`tPage down, PreviousPicture
   Menu, PVnav, Add, &Next`tPage up, NextPicture
   Menu, PVnav, Add, &Last`tEnd, LastPicture
   If (totalFramesIndex>0 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      Menu, PVnav, Add, Previous &frame`tShift+Page Down, prevDesiredFrame
      Menu, PVnav, Add, Ne&xt frame`tShift+Page Up, nextDesiredFrame
   }

   If (markedSelectFile>1 && thumbsDisplaying!=1)
   {
      Menu, PVnav, Add,
      Menu, PVnav, Add, F&irst selected`tCtrl+Home, jumpToFilesSelBorderFirst
      Menu, PVnav, Add, Pr&evious selected`tCtrl+Left, navSelectedFilesPrev
      Menu, PVnav, Add, Nex&t selected`tCtrl+Right, navSelectedFilesNext
      Menu, PVnav, Add, L&ast selected`tCtrl+End, jumpToFilesSelBorderLast
   }
   Menu, PVnav, Add,
   Menu, PVnav, Add, &Skip to index`tJ, PanelJump2index
   Menu, PVnav, Add, &Random`tShift+Bksp, RandomPicture
   Menu, PVnav, Add, Pre&v. random image`tBksp, PrevRandyPicture

   ; Menu, PVselv, Add, &Relative coordinates, toggleImgSelCoords
   ; Menu, PVselv, Add, 
   ; If (relativeImgSelCoords=1)
   ;    Menu, PVselv, Check, &Relative coordinates
   If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
   {
      Menu, PVselv, Add, &Undo`tCtrl+Shift+Z, ImgSelUndoAct
      Menu, PVselv, Add, &Redo`tCtrl+Shift+Y, ImgSelRedoAct
      Menu, PVselv, Add,
   }

   Menu, PVselv, Add, &Show selection area`tE, toggleImgSelection
   If (editingSelectionNow=1)
      Menu, PVselv, Check, &Show selection area`tE

   Menu, PVselv, Add, &Drop and reset`tCtrl+D, resetImgSelection
   Menu, PVselv, Add, &Reset, newImgSelection
   Menu, PVselv, Add, &Select all`tCtrl+A, selectEntireImage
   Menu, PVselv, Add, 
   If (lockSelectionAspectRatio=0)
      Menu, PVselv, Add, Transform to s&quare ratio (1:1)`tR, makeSquareSelection
   Menu, PVselv, Add, &Flip width / height, flipSelectionWH
   Menu, PVselv, Add, Ell&ipse selection`tShift+E, toggleEllipseSelection
   Menu, PVselv, Add, Limit selection to image bo&undaries`tL, toggleLimitSelection
   Menu, PVselv, Add, 
   Menu, PVselv, Add, R&otate by 45°`tShift+R, MenuSelRotation
   Menu, PVselv, Add, R&eset rotation`tShift+\, resetSelectionRotation
   Menu, PVselv, Add, &Keep aspect ratio on rotation, ToggleSelKeepRatioRotation
   defiSelAR := defineSelectionAspectRatios()
   Menu, PVselv, Add, Toggle loc&k aspect ratio`tShift+A, toggleImgSelectionAspectRatio
   Menu, PVselv, Add, %defiSelAR%, dummy
   Menu, PVselv, Disable, %defiSelAR%

   If (lockSelectionAspectRatio>0)
      Menu, PVselv, Check, Toggle loc&k aspect ratio`tShift+A

   Menu, PVselv, Add, 
   Menu, PVselv, Add, Sho&w grid, ToggleSelectGrid
   Menu, PVselv, Add, Properties`tAlt+E, PanelIMGselProperties
   If (rotateSelBoundsKeepRatio=1)
      Menu, PVselv, Check, &Keep aspect ratio on rotation
   If (LimitSelectBoundsImg=1)
      Menu, PVselv, Check, Limit selection to image bo&undaries`tL
   If (showSelectionGrid=1)
      Menu, PVselv, Check, Sho&w grid
   If (EllipseSelectMode=1)
      Menu, PVselv, Check, Ell&ipse selection`tShift+E

   Menu, PVedit, Add, New image`tCtrl+N, PanelNewImage
   If (thumbsDisplaying!=1 && (CurrentSLD || StrLen(UserMemBMP)>2))
   {
      If StrLen(UserMemBMP)<3
         Menu, PVedit, Add, &Save image as...`tCtrl+S, PanelSaveImg
      If (editingSelectionNow=1)
         Menu, PVedit, Add, Cut selected area`tCtrl+X, CutSelectedArea
      Menu, PVedit, Add, &Copy to clipboard`tCtrl+C, CopyImage2clip
   }
   Menu, PVedit, Add, Print image`tCtrl+P, PanelPrintImage
   Menu, PVedit, Add, Paste clipboard`tCtrl+V, PasteClipboardIMG
   If (thumbsDisplaying!=1 && editingSelectionNow=1 && (CurrentSLD || StrLen(UserMemBMP)>2))
      Menu, PVedit, Add, &Paste in place`tCtrl+Shift+V, PanelPasteInPlace

   Menu, PVedit, Add, 
   If (thumbsDisplaying!=1 && editingSelectionNow!=1 && imgSelX2=-1 && imgSelY2=-1 && (CurrentSLD || StrLen(UserMemBMP)>2))
   {
      Menu, PVedit, Add, Create &edit area`tE, newImgSelection
      Menu, PVedit, Add, &Select all`tCtrl+A, selectEntireImage
   } Else If (thumbsDisplaying!=1 && editingSelectionNow!=1 && (CurrentSLD || StrLen(UserMemBMP)>2))
   {
      Menu, PVedit, Add, Sho&w selection area`tE, ToggleEditImgSelection
      Menu, PVedit, Add, &Select all`tCtrl+A, selectEntireImage
   }

   If (thumbsDisplaying!=1 && (CurrentSLD || StrLen(UserMemBMP)>2))
   {
      Menu, PVedit, Add, Dra&w freeform filled shape`tShift+P, MenuStartDrawingShapes
      Menu, PVedit, Add, Draw freeform outline`tP, MenuStartDrawingLines
      Menu, PVedit, Add, &Adjust canvas size`tAlt+A, PanelAdjustImageCanvasSize
      Menu, PVedit, Add, &Blur/pixelize`tShift+B, PanelBlurSelectedArea
      Menu, PVedit, Add, &Invert colors`tShift+I, InvertSelectedArea
      Menu, PVedit, Add, Desaturate color&s`tCtrl+G, GraySelectedArea
   }

   If (!markedSelectFile && StrLen(UserMemBMP)<3 && currentFileIndex>0)
   {
      Menu, PVedit, Add,
      file2rem := getIDimage(currentFileIndex)
      If (RegExMatch(file2rem, "i)(.\.(jpg|jpeg))$") || markedSelectFile)
         Menu, PVedit, Add, &JPEG lossless operations`tK, PanelJpegPerformOperation
      Menu, PVedit, Add, &Resize/rotate/crop image`tCtrl+R, PanelSimpleResizeRotate
      Menu, PVedit, Add, &Auto-crop image`tAlt+Y, PanelImgAutoCrop
      Menu, PVedit, Add,
   }

   If (thumbsDisplaying!=1 && editingSelectionNow=1 && (CurrentSLD || StrLen(UserMemBMP)>2))
   {
      Menu, PVedit, Add, &Erase or fade area`tDelete, PanelEraseSelectedArea
      Menu, PVedit, Add, &Fill area or draw shapes`tAlt+Bksp, PanelFillSelectedArea
      Menu, PVedit, Add, &Draw predetermined lines or arcs`tShift+L, PanelDrawLines
      Menu, PVedit, Add, &Transform selected area`tCtrl+T, PanelTransformSelectedArea
      Menu, PVedit, Add, Insert te&xt`tShift+T, PanelInsertTextArea
      Menu, PVedit, Add, 
      Menu, PVedit, Add, Flip selected &horizontally`tShift+H, FlipSelectedAreaH
      Menu, PVedit, Add, Flip selected &vertically`tShift+V, FlipSelectedAreaV
      Menu, PVedit, Add, &Limit color effects to selection`tShift+U, ApplyColorAdjustsSelectedArea
      Menu, PVedit, Add, &Crop image to selection`tShift+Enter, CropImageInViewPortToSelection
      Menu, PVedit, Add, &Resize image to selection`tAlt+R, ResizeIMGviewportSelection
   }

   StringRight, infoPrevMovePath, prevFileMovePath, 25
   Menu, PVsort, Add, File details, dummy
   Menu, PVsort, Disable, File details
   Menu, PVsort, Add, &Path and name`tCtrl+1, ActSortName
   Menu, PVsort, Add, &Folder path`tCtrl+2, ActSortPath
   Menu, PVsort, Add, &File name`tCtrl+3, ActSortFileName
   Menu, PVsort, Add, File si&ze`tCtrl+4, ActSortSize
   Menu, PVsort, Add, &Modified date`tCtrl+5, ActSortModified
   Menu, PVsort, Add, &Created date`tCtrl+6, ActSortCreated
   If (SLDtypeLoaded=3)
   {
      Menu, PVsort, Add, &Use cached file details, TglUseCacheSLDinfo
      If (useCachedSLDdata=1)
         Menu, PVsort, Check, &Use cached file details
   }
   Menu, PVsort, Add
   Menu, PVsort, Add, Image information (slow), dummy
   Menu, PVsort, Disable, Image information (slow)
   Menu, PVsort, Add, &Resolution, PanelResolutionSorting
   Menu, PVsort, Add, &Histogram average, ActSortHistogramAvg
   Menu, PVsort, Add, Histo&gram median, ActSortHistogramMedian
   Menu, PVsort, Add, &Similarity (very slow), ActSortSimilarity
   Menu, PVsort, Add, 
   Menu, PVsort, Add, R&everse list`tCtrl+0, ReverseListNow
   Menu, PVsort, Add, R&andomize  list, RandomizeListNow

   defMenuRefresh := RegExMatch(CurrentSLD, sldsPattern) ? "&Reload .SLD file" : "&Refresh opened folder(s)"
   StringRight, defMenuRefreshItm, CurrentSLD, 30
   If defMenuRefreshItm
   {
      Menu, PVfList, Add, %defMenuRefresh%`tShift+F5, RefreshFilesList
      If RegExMatch(CurrentSLD, sldsPattern)
      {
         Menu, PVfList, Add, %defMenuRefreshItm%, RefreshFilesList
         Menu, PVfList, Disable, %defMenuRefreshItm%
      }
   }
   Menu, PVfList, Add,
   If (maxFilesIndex>1)
   {
      Menu, PVfList, Add, Insert file(s)`tInsert, addNewFile2list
      Menu, PVfList, Add, Add folder(s)`tShift+Insert, addNewFolder2list
      Menu, PVfList, Add, Manage folder(s) list`tAlt+U, PanelDynamicFolderzWindow
   }

   If (maxFilesIndex>2)
   {
      Menu, PVfList, Add, Save files list as .SLD`tCtrl+Shift+S, PanelSaveSlideShowu
      Menu, PVfList, Add,
      If !markedSelectFile
      {
         Menu, PVfList, Add, Remove active index entry`tAlt+Delete, InListMultiEntriesRemover
         Menu, PVfList, Add, Modify active index entry`tCtrl+F2, PanelUpdateThisFileIndex
      }

      Menu, PVfList, Add, Auto-remove entries of dead files, ToggleAutoRemEntries
      If (autoRemDeadEntry=1)
         Menu, PVfList, Check, Auto-remove entries of dead files
      ; Menu, PVfList, Add, Cache files list in .SLD file, ToggleSLDcache
      ; If (SLDcacheFilesList=1)
      ;    Menu, PVfList, Check, Cache files list in .SLD file
      Menu, PVfList, Add,
      If RegExMatch(CurrentSLD, sldsPattern)
         Menu, PVfList, Add, &Clean duplicate/inexistent entries, cleanFilesList
      If (RegExMatch(CurrentSLD, sldsPattern) && StrLen(DynamicFoldersList)>6)
         Menu, PVfList, Add, &Regenerate the entire list, RegenerateEntireList
      If (RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
         Menu, PVfList, Add, &Update files list selectively`tCtrl+U, PanelStaticFolderzManager
      If (skipSeenImagesSlider=1)
         Menu, PVfList, Add, Remove already seen ima&ges, removeFilesListSeenImages
      Menu, PVfList, Add, 
      Menu, PVfList, Add, &Search index`tCtrl+F3, PanelSearchIndex
      Menu, PVfList, Add, &Text filtering`tCtrl+F, PanelEnableFilesFilter
      If StrLen(filesFilter)>1
      {
         Menu, PVfList, Check, &Text filtering`tCtrl+F
         If (filesFilter!="||Prev-Files-Selection||")
            Menu, PVfList, Add, &Invert applied filter, invertFilesFilter
      }
      If (thumbsDisplaying!=1)
      {
         Menu, PVfList, Add,
         Menu, PVfList, Add, &Sort by, :PVsort
      }
   }

   Menu, PVperfs, Add, &Limit memory usage, ToggleLimitMemUsage
   Menu, PVperfs, Add, &Do not record undo levels, TogglePreventUndos
   If (preventUndoLevels=1)
      Menu, PVperfs, Check, &Do not record undo levels
   Menu, PVperfs, Add, &Allow multi-threaded processing (%realSystemCores%), PanelSetSystemCores
   If (minimizeMemUsage=1)
      Menu, PVperfs, Disable, &Allow multi-threaded processing (%realSystemCores%)

   If (A_PtrSize=4)
   {
      Menu, PVperfs, Disable, &Allow multi-threaded processing (%realSystemCores%)
      Menu, PVperfs, Disable, &Limit memory usage
      Menu, PVperfs, Check, &Limit memory usage
   }

   Menu, PVperfs, Add, &High quality image resampling, ToggleImgQuality
   If (thumbsDisplaying!=1)
   {
      Menu, PVperfs, Add, &Downscale images to viewport dimensions`tCtrl+Q, ToggleImgDownScaling
      If (AutoDownScaleIMGs=1)
         Menu, PVperfs, Check, &Downscale images to viewport dimensions`tCtrl+Q
   }
   Menu, PVperfs, Add, &Perform dithering on color depth changes, ToggleImgColorDepthDithering
   Menu, PVperfs, Add, &Load Camera RAW files in high quality, ToggleRAWquality
   If (minimizeMemUsage=1)
      Menu, PVperfs, Check, &Limit memory usage
   If (allowMultiCoreMode=1)
      Menu, PVperfs, Check, &Allow multi-threaded processing (%realSystemCores%)
   If (ColorDepthDithering=1)
      Menu, PVperfs, Check, &Perform dithering on color depth changes
   If (userimgQuality=1)
      Menu, PVperfs, Check, &High quality image resampling
   If (userHQraw=1)
      Menu, PVperfs, Check, &Load Camera RAW files in high quality

   Menu, PVprefs, Add, Save settings into a .SLD file, WritePrefsIntoSLD
   Menu, PVprefs, Add, &Never load settings from a .SLD, ToggleIgnoreSLDprefs
   If A_IsCompiled
   {
      Menu, PVprefs, Add, 
      Menu, PVprefs, Add, Associate with .SLD files, associateSLDsNow
      Menu, PVprefs, Add, Associate with image files, associateWithImages
   }

   Menu, PVprefs, Add, 
   Menu, PVprefs, Add, Load an&y image format using FreeImage, ToggleAlwaysFIMus
   ; If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0)
   Menu, PVprefs, Add, Performance options, :PVperfs
   Menu, PVprefs, Add, 
   If (thumbsDisplaying!=1)
   {
      Menu, PVprefs, Add, Auto-play an&imated GIFs, ToggleAnimGIFsupport
      If (animGIFsSupport=1)
         Menu, PVprefs, Check, Auto-play an&imated GIFs
      If (alwaysOpenwithFIM=1)
         Menu, PVprefs, Disable, Auto-play an&imated GIFs
   }

   Menu, PVprefs, Add, &Prompt before file delete, TogglePromptDelete
   If (askDeleteFiles=1)
      Menu, PVprefs, Check, &Prompt before file delete
   If (MustLoadSLDprefs=0)
      Menu, PVprefs, Check, &Never load settings from a .SLD

   Menu, PVprefs, Add, 
   If (skipSeenImagesSlider=1)
      Menu, PVprefs, Add, Seen images database options, PanelSeenIMGsOptions
   If FolderExist(thumbsCacheFolder)
      Menu, PVprefs, Add, Erase cached thumbnails, PanelOlderThanEraseThumbsCache
   Menu, PVprefs, Add, Cache / store generated thumbnails, ToggleThumbsCaching
   If (alwaysOpenwithFIM=1)
      Menu, PVprefs, Check, Load an&y image format using FreeImage
   If (enableThumbsCaching=1)
   {
      If (thumbsDisplaying=1)
         Menu, PVprefs, Add, Generate all thumbnails no&w, generateAllThumbsNow

      Menu, PVprefs, Check, Cache / store generated thumbnails
      friendly := (markedSelectFile>1) ? "Force refresh of selected thumbnails on scroll" : "Force refresh of thumbnails on scroll"
      If (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVprefs, Add, %friendly%`tAlt+F5, DeepRefreshThumbsNow
   }

   favesList := readFavesEntries()
   Loop, Parse, favesList, `n
   {
      If (A_Index>15)
         Break

      countItemz++
      If !Trimmer(A_LoopField)
         Continue

      entryu := PathCompact(A_LoopField, 30)
      If StrLen(entryu)>3
      {
         countFaved++
         Menu, PVfaves, Add, &%countItemz%. %entryu%, OpenFavesEntry
      }
   }

   If !countFaved
   {
      Menu, PVfaves, Add, No image added to favourites, dummy
      Menu, PVfaves, Disable, No image added to favourites
   } Else If (userAddedFavesCount>15)
   {
      moru := userAddedFavesCount - 15
      Menu, PVfaves, Add, ... and another %moru% images, dummy
      Menu, PVfaves, Disable, ... and another %moru% images
   }

   Menu, PVfaves, Add
   Menu, PVfaves, Add, &Cycle favourites list on open, ToggleCycleFavesOpen
   If (cycleFavesOpenIMG=1)
      Menu, PVfaves, Check, &Cycle favourites list on open

   Menu, PVfaves, Add, &Add/remove current image to favourites`tB, ToggleImgFavourites
   If !(maxFilesIndex>0 && CurrentSLD)
      Menu, PVfaves, Disable, &Add/remove current image to favourites`tB

   If (countFaved>1)
      Menu, PVfaves, Add, &Manage the favourites list, retrieveFavesAsList
   Menu, PVfaves, Add, &Remove all from favourites, eraseAllFavedIMGs

   If !(countFaved>2)
      Menu, PVfaves, Disable, &Remove all from favourites

   Menu, PVopenF, Add, &Image or slideshow`tCtrl+O, OpenDialogFiles
   Menu, PVopenF, Add, &Folder recursively`tShift+O, OpenFolders
   Menu, PVopenF, Add,
   Menu, PVopenF, Add, Ac&quire image (WIA), AcquireWIAimage
   Menu, PVopenF, Add, &New QPV instance`tCtrl+Shift+N, OpenNewQPVinstance

   countItemz := 0
   Menu, PVopenF, Add,
   If (maxFilesIndex<1 || !CurrentSLD)
      Menu, PVopenF, Add, Insert file(s)`tInsert, addNewFile2list

   If (allowRecordHistory=1)
   {
      Menu, PVopenF, Add,
      IniRead, LastOpenedImg, % mainSettingsFile, General, LastOpenedImg, @
      If (RegExMatch(Trimmer(LastOpenedImg), RegExFilesPattern) && FileRexists(Trimmer(LastOpenedImg)))
         Menu, PVopenF, Add, % "&0. " PathCompact(Trimmer(LastOpenedImg), 30), MenuOpenLastImg

      historyList := readRecentEntries(0, 0)
      Loop, Parse, historyList, `n
      {
         If (A_Index>10)
            Break

         countItemz++
         testThis := StrReplace(A_LoopField, "|")
         If (StrLen(A_LoopField)<4 || !FileExist(testThis))
            Continue

         entryu := PathCompact(testThis, 30)
         If InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= "\" ; entryu
         If !InStr(A_LoopField, "|") && !RegExMatch(A_LoopField, sldsPattern)
            entryu .= " (*)"
         If RegExMatch(A_LoopField, sldsPattern)
            entryu := "# " entryu

         Menu, PVopenF, Add, &%countItemz%. %entryu%, OpenRecentEntry
      }

      Menu, PVopenF, Add, 
      If FolderExist(prevFileSavePath)
         aListu := prevFileSavePath "`n"
      If (FolderExist(prevFileMovePath) && !InStr(aListu, prevFileMovePath "`n"))
         aListu .= prevFileMovePath "`n"
      If (FolderExist(prevOpenFolderPath) && !InStr(aListu, prevOpenFolderPath "`n"))
         aListu .= prevOpenFolderPath "`n"

      Loop, Parse, aListu, `n
      {
         If !A_LoopField
            Continue
         Menu, PVopenF, Add, % "O" A_Index ". " PathCompact(A_LoopField, 30), OpenRecentEntry
         ; Menu, PVopenF, Add, % "O" A_Index ". " SubStr(A_LoopField, -30), OpenRecentEntry
      }
   }

   Menu, PVopenF, Add, 
   If (countItemz>0)
      Menu, PVopenF, Add, &Erase opened history, EraseOpenedHistory

   Menu, PVopenF, Add, &Record recently opened, ToggleRecordOpenHistory
   If (allowRecordHistory=1)
      Menu, PVopenF, Check, &Record recently opened

   Menu, PVsounds, Add, &Edit image caption`tShift+N, PanelEditImgCaption
   Menu, PVsounds, Add, &Show image captions`tN, ToggleImgCaptions
   If (showImgAnnotations=1)
      Menu, PVsounds, Check, &Show image captions`tN

   Menu, PVsounds, Add, 
   If (SLDtypeLoaded=3)
      Menu, PVsounds, Add, Choose audio file, PanelBrowseAudioAnnotation
   Menu, PVsounds, Add, Play associated sound file`tX, PlayAudioFileAssociatedNow
   Menu, PVsounds, Add, Stop playing`tShift+X, StopMediaPlaying
   If !hSNDmedia
      Menu, PVsounds, Disable, Stop playing`tShift+X
   Menu, PVsounds, Add, 
   Menu, PVsounds, Add, Auto-play sound files, ToggleAutoPlaySND
   If (autoPlaySNDs=1)
      Menu, PVsounds, Check, Auto-play sound files
   Menu, PVsounds, Add, Slideshow speed based on audio length, ToggleSyncSlide2sndDuration
   If (syncSlideShow2Audios=1)
      Menu, PVsounds, Check, Slideshow speed based on audio length
   If (autoPlaySNDs!=1)
      Menu, PVsounds, Disable, Slideshow speed based on audio length
   Menu, PVsounds, Add, 
   Menu, PVsounds, Add, Change audio volume`t1`,2, ChangeVolume
   Menu, PVsounds, Add, Audio volume: %mediaSNDvolume%`%, dummy
   Menu, PVsounds, Disable, Audio volume: %mediaSNDvolume%`%

   Menu, PVfileSel, Add, &First`tCtrl+Home, jumpToFilesSelBorderFirst
   Menu, PVfileSel, Add, &Previous`tCtrl+Left, navSelectedFilesPrev
   Menu, PVfileSel, Add, &Next`tCtrl+Right, navSelectedFilesNext
   Menu, PVfileSel, Add, &Last`tCtrl+End, jumpToFilesSelBorderLast
   Menu, PVfileSel, Add, 
   Menu, PVfileSel, Add, Select/deselect file`tTab / Space, MenuMarkThisFileNow
   Menu, PVfileSel, Add, Select all`tCtrl+A, selectAllFiles
   Menu, PVfileSel, Add, Select none`tCtrl+D, dropFilesSelection
   Menu, PVfileSel, Add, Invert selection, invertFilesSelection
   Menu, PVfileSel, Add, 
   Menu, PVfileSel, Add, Filter files list to selected`tCtrl+Space, filterToFilesSelection

; main menu
   Menu, PVmenu, Add, &Open..., :PVopenF
   Menu, PVmenu, Add, Fa&vourites, :PVfaves
   If StrLen(mustOpenStartFolder)>3
      Menu, PVmenu, Add, &Scan files in folder`tSpace/Wheel, MenuDoOpenStartFolder
   If (thumbsDisplaying=1)
      Menu, PVmenu, Add, &Paste files`tCtrl+V, PasteClipboardIMG

   If (StrLen(UserMemBMP)>2 && thumbsDisplaying!=1)
   {
      Menu, PVmenu, Add,
      If (undoLevelsRecorded>1 && undoLevelsRecorded!="")
      {
         Menu, PVmenu, Add, &Undo`tCtrl+Z, ImgUndoAction
         Menu, PVmenu, Add, &Redo`tCtrl+Y, ImgRedoAction
      }
      Menu, PVmenu, Add, &Save image`tCtrl+S, PanelSaveImg
      If CurrentSLD
         Menu, PVmenu, Add, &Revert changes...`tF5, RefreshImageFileAction
   } Else If (StrLen(UserMemBMP)>2 && thumbsDisplaying=1)
      Menu, PVmenu, Add, &Return to image editing, MenuReturnIMGedit

   Menu, PVmenu, Add,
   If (thumbsDisplaying!=1)
      Menu, PVmenu, Add, &Edit image, :PVedit

   createMenuSoloFile()
   If (maxFilesIndex>0 && CurrentSLD)
   {
      infoThisFile := markedSelectFile ? "S&elected files" : "C&urrent file"
      If (thumbsDisplaying!=1 && editingSelectionNow=1)
         Menu, PVmenu, Add, Selec&tion area, :PVselv

      Menu, PVmenu, Add, % infoThisFile, :PVtFile
      If markedSelectFile
         Menu, PVmenu, Add, &Active file, :PVtActFile

      If (thumbsDisplaying=1) || (thumbsDisplaying!=1 && editingSelectionNow!=1)
         Menu, PVmenu, Add, Files index/l&ist, :PVfList

      If (thumbsDisplaying=1 && maxFilesIndex>1)
         Menu, PVmenu, Add, &Sort list by..., :PVsort

      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVmenu, Add, Image vie&w, :PVview

      If (thumbsDisplaying!=1)
         Menu, PVmenu, Add, &Annotation, :PVsounds

      If (maxFilesIndex>2 || mustOpenStartFolder)
      {
         Menu, PVmenu, Add, Navi&gation, :PVnav
         If (thumbsDisplaying!=1 && editingSelectionNow!=1)
            Menu, PVmenu, Add, Slideshow, :PVslide
      }
      Menu, PVmenu, Add,
   } Else If StrLen(UserMemBMP)>2
   {
      If (editingSelectionNow=1 && thumbsDisplaying!=1)
      {
         Menu, PVmenu, Add, Selec&tion, :PVselv
         Menu, PVmenu, Add, &Edit image, :PVedit
      }
      If (thumbsDisplaying!=1) || (thumbsDisplaying=1 && thumbnailsListMode!=1)
         Menu, PVmenu, Add, Image vie&w, :PVview
   }

   If (markedSelectFile && thumbsDisplaying!=1)
      Menu, PVmenu, Add, Dro&p files selection`tShift+Tab, dropFilesSelection
   Else If (markedSelectFile && thumbsDisplaying=1)
      Menu, PVmenu, Add, F&iles selection, :PVfileSel

   createMenuInterfaceOptions()
   If StrLen(filesFilter)>1
   {
      Menu, PVmenu, Add,
      Menu, PVmenu, Add, Remove files list filter`tCtrl+Space, remFilesListFilter
      Menu, PVmenu, Add,
   }

   Menu, PVmenu, Add, Inter&face, :PvUIprefs
   Menu, PVmenu, Add, Prefe&rences, :PVprefs
   If StrLen(UserMemBMP)<3
      Menu, PVmenu, Add, About`tF1, AboutWindow
   Menu, PVmenu, Add,
   Menu, PVmenu, Add, Restart`tShift+Esc, restartAppu
   Menu, PVmenu, Add, Exit`tEsc, exitAppu
   showThisMenu("PVmenu")
}

showThisMenu(menarg) {
   If (A_TickCount - lastOtherWinClose<10)
      Return

   doSuspendu(1)
   Menu, % menarg, Show
   isFakeWin := (prevOpenedWindow[5]=1 && AnyWindowOpen>0) ? 1 : 0
   If (isFakeWin=0)
      SetTimer, dummyUnSuspendu, -150
   Global lastWinDrag := A_TickCount
   Global lastOtherWinClose := A_TickCount
}

dummyUnSuspendu() {
   doSuspendu(0)
}

deleteMenus() {
    Static menusList := "PVmenu|PVperfs|PVfileSel|PVslide|PVnav|PVview|PVfList|PVtActFile|PVtFile|PVprefs|PvUIprefs|PVfaves|PVopenF|PVsort|PVedit|PVselv|PVsounds"
    Loop, Parse, menusList, |
        Try Menu, % A_LoopField, Delete
}

createMenuInterfaceOptions() {
   infoThumbsList := defineListViewModes()
   infoThumbsMode := (thumbsDisplaying=1) ? "Switch to image view" : "Switch to " infoThumbsList " list view"
   If (thumbsDisplaying=1)
      Menu, PvUIprefs, Add, Toggle view modes`tL, toggleListViewModeThumbs

   If (maxFilesIndex>1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, %infoThumbsMode%`tEnter/MClick, MenuDummyToggleThumbsMode
   If (maxFilesIndex>1 && !AnyWindowOpen && prevOpenedWindow[2])
      Menu, PvUIprefs, Add, Open pre&vious panel`tF8, openPreviousPanel

   If (thumbsDisplaying!=1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, &Toggle full-screen mode`tF11, ToggleFullScreenMode

   If (thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add, &Touch screen mode, ToggleTouchMode
      If (TouchScreenMode=1)
         Menu, PvUIprefs, Check, &Touch screen mode
   }

   Menu, PvUIprefs, Add, &Large UI fonts, ToggleLargeUIfonts
   Menu, PvUIprefs, Add, &Always on top, ToggleAllonTop
   Menu, PvUIprefs, Add, Show &quick bar`tF10, ToggleQuickBaru
   If (showMainMenuBar=1)
      Menu, PvUIprefs, Check, Show &quick bar`tF10

   If (thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add, &Hide title bar, ToggleTitleBaru
      If (getCaptionStyle(PVhwnd)=1)
         Menu, PvUIprefs, Check, &Hide title bar
   } Else If (thumbnailsListMode!=1 && thumbsDisplaying=1 && !AnyWindowOpen)
      Menu, PvUIprefs, Add, &Set thumbnails columns, PanelSetThumbCols

   Menu, PvUIprefs, Add,
   If (skipSeenImagesSlider=1)
   {
      Menu, PvUIprefs, Add, &Highlight already seen images, ToggleMarkSeenIMGs
      If (highlightAlreadySeenImages=1)
         Menu, PvUIprefs, Check, &Highlight already seen images
   }

   If (maxFilesIndex>0 && CurrentSLD && thumbsDisplaying!=1)
   {
      Menu, PvUIprefs, Add, &Viewport and image details`tI, ToggleInfoBoxu
      ; Menu, PvUIprefs, Add, No OSD messages, ToggleInfoToolTips
      Menu, PvUIprefs, Add, I&mage histogram`tShift+G, ToggleImgHistogram
      Menu, PvUIprefs, Add, Auto-display image navi&gator`tZ, ToggleImgNavBox
      Menu, PvUIprefs, Add, &Ambiental textured background, ToggleTexyBGR
      If (showHUDnavIMG=1)
         Menu, PvUIprefs, Check, Auto-display image navi&gator`tZ
      ; If (noTooltipMSGs=1)
      ;    Menu, PvUIprefs, Check, No OSD messages
      If (showHistogram>1)
         Menu, PvUIprefs, Check, I&mage histogram`tShift+G
      If (showInfoBoxHUD>=1)
         Menu, PvUIprefs, Check, &Viewport and image details`tI
 
      If (usrTextureBGR=1)
         Menu, PvUIprefs, Check, &Ambiental textured background
   }

   Menu, PvUIprefs, Add, 
   If !AnyWindowOpen
   {
      Menu, PvUIprefs, Add, Additional settings`tF12, openPrefsPanelWindow
      Menu, PvUIprefs, Add, Journal / session log`tShift + [``], PanelJournalWindow
   }

   If (PrefsLargeFonts=1)
      Menu, PvUIprefs, Check, &Large UI fonts
   If (getTopMopStyle(PVhwnd)=1)
      Menu, PvUIprefs, Check, &Always on top
}

EraseOpenedHistory() {
   Loop, 15
       IniWrite, 0, % mainRecentsFile, RecentOpen, E%A_Index%
   IniWrite, 0, % mainSettingsFile, General, LastOpenedImg
}

OpenRecentEntry() {
   If askAboutFileSave(" and another image will be loaded")
      Return

  startZeit := A_TickCount
  testOs := A_ThisMenuItem
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  If RegExMatch(testOs, "i)^(o1\. )")
     openThisu := prevFileSavePath
  Else If RegExMatch(testOs, "i)^(o2\. )")
     openThisu := prevFileMovePath
  Else If RegExMatch(testOs, "i)^(o3\. )")
     openThisu := prevOpenFolderPath

  If openThisu
  {
     coreOpenFolder("|" openThisu, 1, 0, 1)
     If (maxFilesIndex>0)
        SLDtypeLoaded := 1
     ; Else resetMainWin2Welcome()
     Return
  }

  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)
  IniRead, newEntry, % mainRecentsFile, RecentOpen, E%openThisu%, @
; MsgBox, %openthisu% -- %newentry%
  newEntry := Trimmer(newEntry)
  If StrLen(newEntry)>4
  {
     If RegExMatch(newEntry, sldsPattern)
     {
        OpenSLD(newEntry)
     } Else
     {
        prevOpenFolderPath := StrReplace(newEntry, "|")
        If FolderExist(prevOpenFolderPath)
           INIaction(1, "prevOpenFolderPath", "General")
        coreOpenFolder(newEntry, 1, 0, 1)
        If (maxFilesIndex>0)
           SLDtypeLoaded := 1
        ; Else resetMainWin2Welcome()
     }
  }
  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

OpenFavesEntry() {
  If askAboutFileSave(" and the selected image from favourites will be loaded")
     Return

  startZeit := A_TickCount
  testOs := A_ThisMenuItem
  If (SLDtypeLoaded=3)
  {
     SLDtypeLoaded := 0
     activeSQLdb.CloseDB()
  }

  openThisu := SubStr(testOs, 2, InStr(testOs, ". ")-2)

  FileReadLine, newEntry, % mainFavesFile, % openThisu
  ; IniRead, newEntry, % mainRecentsFile, favourites, E%openThisu%, @
  If !FileRexists(newEntry)
  {
     msgResult := msgBoxWrapper(appTitle ": ERROR", "The file you are trying to open seems to no longer exist. Would you like to remove it from the favourites list?", 4, 0, "question")
     If InStr(msgResult, "yes")
        ToggleImgFavourites(newEntry, "rem")
  } Else If (cycleFavesOpenIMG=1 && newEntry!="@" && StrLen(newEntry)>2)
  {
     retrieveFavesAsList(openThisu)
     Return
  } Else If (newEntry!="@" && StrLen(newEntry)>2)
  {
     MenuOpenLastImg(newEntry)
     resultedFilesList[currentFileIndex, 5] := 1
  }

  ; ToolTip, % (A_TickCount - startZeit) - (A_TickCount - startZeitIMGload) , , , 2
  ; SoundBeep 
}

INIaction(act, var, section, silentu:=0) {
  varValue := %var%
  If (act=1)
     IniWrite, %varValue%, % mainSettingsFile, %section%, %var%
  Else
     IniRead, %var%, % mainSettingsFile, %section%, %var%, %varValue%
  ; If (silentu=0 && ScriptInitialized!=1)
  ;    throwMSGwriteError()
}

ToggleFullScreenMode() {
   Static prevState := 1, o_TouchScreenMode := "a"
   If (thumbsDisplaying=1)
   {
      ; o_TouchScreenMode := TouchScreenMode
      ToggleThumbsMode()
      Return
   }

  ; If (tempBtnVisible!="null")
     ; DestroyTempBtnGui("now")

  prevState := !prevState
  If (prevState=0)
  {
     If (showMainMenuBar=1)
     {
        showMainMenuBar := 0
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        Win_SetMenu(PVhwnd, 0)
        TriggerMenuBarUpdate()
     }
     ; o_TouchScreenMode := TouchScreenMode
     If (userAllowWindowDrag=1)
        TouchScreenMode := 0
     isTitleBarHidden := 0
     If (editingSelectionNow=1)
       ToggleEditImgSelection()
     WinSet, Style, -0xC00000, ahk_id %PVhwnd%
     WinMaximize, ahk_id %PVhwnd%
  } Else
  {
     ; If (o_TouchScreenMode!="a")
     ;    TouchScreenMode := o_TouchScreenMode
     isTitleBarHidden := 1
     WinSet, Style, +0xC00000, ahk_id %PVhwnd%
     WinRestore, ahk_id %PVhwnd%
     INIaction(0, "showMainMenuBar", "General")
     INIaction(0, "TouchScreenMode", "General")
     If (showMainMenuBar=1)
     {
        interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
        TriggerMenuBarUpdate()
     }
  }

  interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
  interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
  interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
  ; INIaction(1, "isTitleBarHidden", "General")
  ; INIaction(1, "TouchScreenMode", "General")

  SetTimer, dummyFullScreenButtons, -350
}

dummyFullScreenButtons() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  If (editingSelectionNow=1 || showHistogram>1 || showInfoBoxHUD>=1)
  {
     2ndLabel := "Hide viewport elements"
     2ndact := "turnOffViewportStuff"
  }

  If (userAllowWindowDrag=1 && isTitleBarHidden=0)
  {
     1stLabel := "Deactivate window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else If (userAllowWindowDrag=0 && isTitleBarHidden=0)
  {
     1stLabel := "Allow window dragging"
     1stact := "toggleWindowDraggableMode"
  } Else ; If (isTitleBarHidden=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  showTOOLtip(friendly)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

toggleWindowDraggableMode() {
   userAllowWindowDrag := !userAllowWindowDrag
   If (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1)
      TouchScreenMode := 0
   Else If (userAllowWindowDrag=0)
      INIaction(0, "TouchScreenMode", "General")

   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   interfaceThread.ahkassign("userAllowWindowDrag", userAllowWindowDrag)
   INIaction(1, "userAllowWindowDrag", "General")
}

turnOffViewportStuff() {
   If (showHistogram>1 || showInfoBoxHUD>=1)
      ToggleHistoInfoBoxu()
   If (editingSelectionNow=1)
      toggleImgSelection()
   DestroyTempBtnGui("now")
}

ToggleAllonTop() {
   isAlwaysOnTop := !isAlwaysOnTop
   WinSet, AlwaysOnTop, % isAlwaysOnTop, ahk_id %PVhwnd%
   INIaction(1, "isAlwaysOnTop", "General")
   interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
}

ToggleEasySlideStop() {
   easySlideStoppage := !easySlideStoppage
   INIaction(1, "easySlideStoppage", "General")
}

ToggleSelKeepRatioRotation() {
   rotateSelBoundsKeepRatio := !rotateSelBoundsKeepRatio
   INIaction(1, "rotateSelBoundsKeepRatio", "General")
   If (editingSelectionNow=1 && thumbsDisplaying!=1)
      SetTimer, dummyRefreshImgSelectionWindow, -10
}

ToggleGIFsPlayEntirely() {
   allowGIFsPlayEntirely := !allowGIFsPlayEntirely
   INIaction(1, "allowGIFsPlayEntirely", "General")
}

ToggleSkipSeenIMGs() {
   skipSeenImagesSlider := !skipSeenImagesSlider
   If (sqlFailedInit=1 && skipSeenImagesSlider=1)
   {
      skipSeenImagesSlider := 0
      msgBoxWrapper(appTitle ": ERROR", "An unknown error occured when attempting to initialize SqlLite Database.`n`nFeature not available...", 0, 0, "error")
   }
   INIaction(1, "skipSeenImagesSlider", "General")
}

ToggleAutoResetImageView() {
   If (AnyWindowOpen=10)
      GuiControlGet, resetImageViewOnChange, SettingsGUIA:, resetImageViewOnChange
   Else
      resetImageViewOnChange := !resetImageViewOnChange

   INIaction(1, "resetImageViewOnChange", "General")
}

toggleListViewModeThumbs() {
   If (thumbsDisplaying!=1)
      Return

   If (thumbnailsListMode!=1)
   {
      thumbsListViewMode := 1
      thumbnailsListMode := 1
   } Else
   {
      thumbnailsListMode := 1
      thumbsListViewMode++
      If (thumbsListViewMode>=4)
         thumbsListViewMode := thumbnailsListMode := 0
   }

   INIaction(1, "thumbnailsListMode", "General")
   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   If (thumbnailsListMode!=1)
      initAHKhThumbThreads()
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)

   friendly := defineListViewModes()
   If (StrLen(userSearchString)>1 && thumbnailsListMode=1)
      friendly .= "`nHighlighting files matching search criteria:`n" userSearchString

   showTOOLtip("List view: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

defineListViewModes() {
   infoThumbsSize := (thumbsDisplaying=1) ? " (" thumbsW " x " thumbsH " px )" : ""
   If (thumbnailsListMode!=1)
      friendly := "THUMBNAILS"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=1)
      friendly := "COMPACT"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=2)
      friendly := "FILE DETAILS"
   Else If (thumbnailsListMode=1 && thumbsListViewMode=3)
      friendly := "IMAGE DETAILS"

   Return friendly
}

ToggleAutoPlaySND() {
   autoPlaySNDs := !autoPlaySNDs
   INIaction(1, "autoPlaySNDs", "General")
}

ToggleSyncSlide2sndDuration() {
   syncSlideShow2Audios := !syncSlideShow2Audios
   INIaction(1, "syncSlideShow2Audios", "General")
}

ToggleSlidesTransitions() {
   doSlidesTransitions := !doSlidesTransitions
   INIaction(1, "doSlidesTransitions", "General")
}

ToggleMarkSeenIMGs() {
   highlightAlreadySeenImages := !highlightAlreadySeenImages
   INIaction(1, "highlightAlreadySeenImages", "General")
   ForceRefreshNowThumbsList()
   If (thumbsDisplaying=1)
      dummyTimerDelayiedImageDisplay(50)
}

TglUseCacheSLDinfo() {
   useCachedSLDdata := !useCachedSLDdata
   INIaction(1, "useCachedSLDdata", "General")
   showTOOLtip("In SQL slideshow databases, file sizes and dates are cached.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleHistoInfoBoxu() {
   prevState := (showHistogram>1 || showInfoBoxHUD>=1) ? 1 : 0
   imgPath := getIDimage(currentFileIndex)
   If (prevState!=1)
   {
      If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
         Return
   }

   showHistogram := (prevState=0) ? 1 : 0
   showInfoBoxHUD := (prevState=0) ? 1 : 2
   ToggleImgHistogram(1)
   ToggleInfoBoxu()
   RemoveTooltip()
}

ToggleInfoBoxu() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55) || (thumbsDisplaying=1)
       Return

    lastInvoked := A_TickCount
    showInfoBoxHUD++
    showInfoBoxHUD := clampInRange(showInfoBoxHUD, 0, 2, 1)
    INIaction(1, "showInfoBoxHUD", "General")
    SetTimer, dummyRefreshImgSelectionWindow, -50
    ; dummyTimerDelayiedImageDisplay(50)
}

ToggleImgCaptions() {
    Static lastInvoked := 1
    If (thumbsDisplaying=1)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    showImgAnnotations := !showImgAnnotations
    INIaction(1, "showImgAnnotations", "General")
    SetTimer, dummyRefreshImgSelectionWindow, -50
    If (showImgAnnotations=1)
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       textFile := OutDir "\" OutNameNoExt ".txt"
       If (SLDtypeLoaded=3)
          textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

       If (!FileExist(textFile) && SLDtypeLoaded!=3) || (!textFileContent && SLDtypeLoaded=3)
          showTOOLtip("Display image captions: ACTIVATED`n" OutNameNoExt ".txt (NOT FOUND)`nNo image caption / annotation file associated`nPress Shift+N to create/edit one.")
       Else
          showTOOLtip("Display image captions: ACTIVATED")
    } Else showTOOLtip("Display image captions: DEACTIVATED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleMultiLineStatus() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 55)
       Return

    lastInvoked := A_TickCount
    multilineStatusBar := !multilineStatusBar
    INIaction(1, "multilineStatusBar", "General")
    dummyTimerDelayiedImageDisplay(50)
    CreateGuiButton("File options,,invokeFileOptionsMenu", 0, msgDisplayTime//1.5 + 500)
}

invokeFileOptionsMenu() {
   deleteMenus()
   createMenuCurrentFile()
   showThisMenu("PVtFile")
}

toggleImgSelCoords() {
   relativeImgSelCoords := !relativeImgSelCoords
   calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)
   INIaction(1, "relativeImgSelCoords", "General")
}

ToggleRenderOpaque() {
   RenderOpaqueIMG := !RenderOpaqueIMG
   INIaction(1, "RenderOpaqueIMG", "General")
   If (currIMGdetails.HasAlpha=1 && thumbsDisplaying!=1)
      RefreshImageFile()
}

ToggleSelectGrid() {
   showSelectionGrid := !showSelectionGrid
   INIaction(1, "showSelectionGrid", "General")
   If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleEllipseSelection() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   EllipseSelectMode := !EllipseSelectMode
   INIaction(1, "EllipseSelectMode", "General")
   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
}

toggleImgSelectionAspectRatio() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   lockSelectionAspectRatio++
   If (lockSelectionAspectRatio>5)
      lockSelectionAspectRatio := 0
   friendly := defineSelectionAspectRatios()
   INIaction(1, "desiredSelAspectRatio", "General")
   INIaction(1, "lockSelectionAspectRatio", "General")
   showTOOLtip("Lock selection aspect ratio: " friendly)
   SetTimer, RemoveTooltip, % -msgDisplayTime
   dummyRefreshImgSelectionWindow()
}

defineSelectionAspectRatios() {
   Static types := {0:"NONE", 1:"SQUARE [1:1]", 2:"SDTV [4:3]", 3:"35mm film [3:2]", 4:"HDTV [16:9]", 5:"Wide screens [16:10]"}
   If (lockSelectionAspectRatio=1)
      desiredSelAspectRatio := 1
   Else If (lockSelectionAspectRatio=2)
      desiredSelAspectRatio := 4/3
   Else If (lockSelectionAspectRatio=3)
      desiredSelAspectRatio := 3/2
   Else If (lockSelectionAspectRatio=4)
      desiredSelAspectRatio := 16/9
   Else If (lockSelectionAspectRatio=5)
      desiredSelAspectRatio := 16/10
   Else
      desiredSelAspectRatio := 0

   Return types[lockSelectionAspectRatio]
}

ToggleRecordOpenHistory() {
   allowRecordHistory := !allowRecordHistory
   INIaction(1, "allowRecordHistory", "General")
   If !allowRecordHistory
      EraseOpenedHistory()
}

toggleLimitSelection() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   LimitSelectBoundsImg := !LimitSelectBoundsImg
   INIaction(1, "LimitSelectBoundsImg", "General")
   friendly := (LimitSelectBoundsImg=1) ? "ON" : "off"
   showTOOLtip("Limit selection to image boundaries: " friendly)
   If (imgEditPanelOpened=1)
      dummyRefreshImgSelectionWindow()
   Else If (thumbsDisplaying!=1)
      dummyTimerDelayiedImageDisplay(25)
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleAlwaysFIMus() {
   alwaysOpenwithFIM := !alwaysOpenwithFIM
   r := initFIMGmodule()
   If InStr(r, "err - 126")
      friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2015."
   Else If InStr(r, "err - 404")
      friendly := "`n`nThe FreeImage.dll file seems to be missing..."

   INIaction(1, "alwaysOpenwithFIM", "General")
   If (FIMfailed2init=1)
      msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Various image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
   Else If (thumbsDisplaying!=1 && CurrentSLD && maxFilesIndex>0 && StrLen(UserMemBMP)<4)
      RefreshImageFileAction()
}

ToggleAnimGIFsupport() {
   animGIFsSupport := !animGIFsSupport
   INIaction(1, "animGIFsSupport", "General")
}

ToggleAutoRemEntries() {
   autoRemDeadEntry := !autoRemDeadEntry
   INIaction(1, "autoRemDeadEntry", "General")
}

ToggleSLDcache() {
   SLDcacheFilesList := !SLDcacheFilesList
   INIaction(1, "SLDcacheFilesList", "General")
}

TogglePromptDelete() {
   askDeleteFiles := !askDeleteFiles
   INIaction(1, "askDeleteFiles", "General")
}

ToggleTitleBaruNow(dummy:=0) {
   If (getCaptionStyle(PVhwnd)=0)
   {
      isTitleBarHidden := 0
      If (userAllowWindowDrag=1)
         TouchScreenMode := 0
      ; If (editingSelectionNow=1)
      ;    ToggleEditImgSelection()
      WinSet, Style, -0xC00000, ahk_id %PVhwnd%
   } Else
   {
      isTitleBarHidden := 1
      WinSet, Style, +0xC00000, ahk_id %PVhwnd%
   }
   interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
   interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
   INIaction(1, "isTitleBarHidden", "General")
   ; INIaction(1, "TouchScreenMode", "General")
   ; If (isTitleBarHidden=0)
   If (drawingShapeNow!=1)
      SetTimer, dummyToggleTitleBarActionBtns, -350
}

dummyToggleTitleBarActionBtns() {
  friendly := (TouchScreenMode=1) ? "Touch screen mode: ENABLED" : "Touch screen mode: DISABLED"
  friendly .= (userAllowWindowDrag=1 && getCaptionStyle(PVhwnd)=1) ? "`nAllow window dragging: ENABLED" : "`nAllow window dragging: DISABLED"
  friendly := Trimmer(friendly)
  1stLabel := (userAllowWindowDrag=1 && isTitleBarHidden=0) ? "Deactivate window dragging" : "Allow window dragging"
  1stact := "toggleWindowDraggableMode"
  If (TouchScreenMode!=1)
  {
     2ndLabel := "Activate touch screen mode"
     2ndact := "ToggleTouchMode"
  }
  If (getCaptionStyle(PVhwnd)!=1)
  {
     1stLabel := "Interface options"
     1stact := "OpenUImenu"
  }

  ; If (isTitleBarHidden=0)
  CreateGuiButton(1stLabel ",," 1stact "||" 2ndLabel ",," 2ndact, "force", msgDisplayTime + 500)
  showTOOLtip(friendly)
  SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleQuickBaru() {
   Static lastInvoked := 1
   showMainMenuBar := !showMainMenuBar
   INIaction(1, "showMainMenuBar", "General")
   interfaceThread.ahkassign("showMainMenuBar", showMainMenuBar)
   If !showMainMenuBar
      Win_SetMenu(PVhwnd, 0)

   TriggerMenuBarUpdate()
   If (A_TickCount - lastInvoked > 900)
      CreateGuiButton("Interface options,,OpenUImenu", 0, msgDisplayTime//1.5 + 500)

   lastInvoked := A_TickCount
}

ToggleTitleBaru() {
   SetTimer, ToggleTitleBaruNow, -150
}

ToggleInfoToolTips() {
    noTooltipMSGs := !noTooltipMSGs
    INIaction(1, "noTooltipMSGs", "General")
}

ToggleLargeUIfonts() {
    PrefsLargeFonts := !PrefsLargeFonts
    ; If (AnyWindowOpen=14)
    ;    openPrefsPanelWindow()

    calcHUDsize()
    INIaction(1, "PrefsLargeFonts", "General")
    thisFunc := prevOpenedWindow[2]
    If (AnyWindowOpen && thisfunc)
    {
       CloseWindow("yes")
       Sleep, 5
       openPreviousPanel("forced")
    }
}

ToggleTexyBGR() {
    usrTextureBGR := !usrTextureBGR
    INIaction(1, "usrTextureBGR", "General")
    RefreshImageFile()
}

ToggleImgNavBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
       Return

    showHUDnavIMG := !showHUDnavIMG
    INIaction(1, "showHUDnavIMG", "General")
    dummyTimerDelayiedImageDisplay(25)
    SetTimer, dummyNavBoxInfo, -150
    lastInvoked := A_TickCount
}

ToggleImgNavSizeBox() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1) || (showHUDnavIMG!=1) || (IMGlargerViewPort!=1)
       Return

    HUDnavBoxSize := (HUDnavBoxSize=75) ? 125 : 75
    dummyTimerDelayiedImageDisplay(25)
    lastInvoked := A_TickCount
}

dummyNavBoxInfo() {
    friendly := (IMGlargerViewPort=1) ? "" : "`nThe navigator will be displayed`nwhen the image is larger than the viewport."
    If (showHUDnavIMG=1)
       showTOOLtip("Image navigator display: AUTO" friendly)
    Else
       showTOOLtip("Image navigator: OFF")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

ToggleImgHistogram(direction) {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    If (direction=1)
       showHistogram++
    Else
       showHistogram--

    showHistogram := clampInRange(showHistogram, 1, 6, 1)
    INIaction(1, "showHistogram", "General")
    If (showHistogram>1)
       showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode())
    Else
       showTOOLtip("Histogram: NONE")

    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, showHistogram, % showHistogram
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
    lastInvoked := A_TickCount
}

ToggleHistogramMode() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 50) || (thumbsDisplaying=1 || showHistogram<=1)
       Return

    ; HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
    lastInvoked := A_TickCount
    histogramMode++
    histogramMode := clampInRange(histogramMode, 1, 3, 1)
    INIaction(1, "histogramMode", "General")
    showTOOLtip("Histogram: " defineHistogramType() "`nGraph focus: " defineHistogramMode())
    SetTimer, RemoveTooltip, % -msgDisplayTime
    dummyTimerDelayiedImageDisplay(50)
    If (AnyWindowOpen=10 && imgEditPanelOpened=1)
    {
       GuiControl, SettingsGUIA: Choose, histogramMode, % histogramMode
       updatePanelColorsInfo()
       updatePanelColorSliderz()
    }
}

defineHistogramType() {
    If (showHistogram=1)
       friendly := "NONE"
    Else If (showHistogram=2)
       friendly := "LUMINANCE"
    Else If (showHistogram=3)
       friendly := "RED"
    Else If (showHistogram=4)
       friendly := "GREEN"
    Else If (showHistogram=5)
       friendly := "BLUE"
    Else If (showHistogram=6)
       friendly := "ALL MIXED"

    Return friendly
}

defineHistogramMode() {
    If (histogramMode=1)
       friendly := "LOWS"
    Else If (histogramMode=2)
       friendly := "BALANCED"
    Else If (histogramMode=3)
       friendly := "PEAKS"

    Return friendly
}

ToggleThumbsCaching() {
    enableThumbsCaching := !enableThumbsCaching
    INIaction(1, "enableThumbsCaching", "General")
}

ToggleSkipDeadFiles() {
    skipDeadFiles := !skipDeadFiles
    INIaction(1, "skipDeadFiles", "General")
}

ToggleIgnoreSLDprefs() {
    MustLoadSLDprefs := !MustLoadSLDprefs
    INIaction(1, "MustLoadSLDprefs", "General")
}

ToggleCycleFavesOpen() {
    cycleFavesOpenIMG := !cycleFavesOpenIMG
    INIaction(1, "cycleFavesOpenIMG", "General")
}

ToggleImgQuality(modus:=0) {
    userimgQuality := !userimgQuality
    If (modus="highu")
       userimgQuality := 1
    Else If (modus="lowu")
       userimgQuality := 0

    imgQuality := (userimgQuality=1) ? 7 : 5
    PixelMode := (userimgQuality=1) ? 2 : 0
    smoothMode := (userimgQuality=1) ? 4 : 1
    compositingQuality := (userimgQuality=1) ? 0 : 1

    Gdip_SetInterpolationMode(glPG, imgQuality)
    Gdip_SetPixelOffsetMode(glPG, PixelMode)
    Gdip_SetSmoothingMode(glPG, smoothMode)
    Gdip_SetCompositingQuality(glPG, compositingQuality)

    Gdip_SetInterpolationMode(2NDglPG, imgQuality)
    Gdip_SetPixelOffsetMode(2NDglPG, PixelMode)
    Gdip_SetSmoothingMode(2NDglPG, smoothMode)
    Gdip_SetCompositingQuality(2NDglPG, compositingQuality)
    INIaction(1, "userimgQuality", "General")
}

ToggleRAWquality() {
    userHQraw := !userHQraw
    INIaction(1, "userHQraw", "General")
}

ToggleMultiCoreSupport() {
    allowMultiCoreMode := !allowMultiCoreMode
    INIaction(1, "allowMultiCoreMode", "General")
    If (thumbsDisplaying=1 && thumbnailsListMode!=1 && multiCoreThumbsInitGood="n")
       initAHKhThumbThreads()
}

ToggleLimitMemUsage() {
    minimizeMemUsage := !minimizeMemUsage
    INIaction(1, "minimizeMemUsage", "General")
    If (minimizeMemUsage=1)
    {
       msgBoxWrapper(appTitle ": WARNING", "By limiting memory usage, the performance of Quick Picto Viewer will likely be drastically reduced. Additionally, some features or functions might be disabled.", 0, 0, "exclamation")
       discardViewPortCaches()
    }
}

TogglePreventUndos() {
    preventUndoLevels := !preventUndoLevels
    maxMemUndoLevels := (preventUndoLevels=1) ? 100 : 979394
}

ToggleImgColorDepthDithering() {
    ColorDepthDithering := !ColorDepthDithering
    INIaction(1, "ColorDepthDithering", "General")
    If (thumbsDisplaying!=1)
       RefreshImageFile()
}

ToggleImgDownScaling() {
    If (thumbsDisplaying=1 || StrLen(UserMemBMP)>3)
       Return

    If (slideShowRunning=1)
       ToggleSlideShowu()

    AutoDownScaleIMGs := !AutoDownScaleIMGs
    INIaction(1, "AutoDownScaleIMGs", "General")
    If (AutoDownScaleIMGs=1)
       showTOOLtip("Images larger than the screen resolution will be`ndownscaled prior to any potential effect.")
    Else
       showTOOLtip("Downscaling: DISABLED")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    SetTimer, RefreshImageFileAction, -300
}

ToggleTouchMode() {
    TouchScreenMode := !TouchScreenMode
    interfaceThread.ahkassign("isTitleBarHidden", isTitleBarHidden)
    interfaceThread.ahkassign("TouchScreenMode", TouchScreenMode)
    INIaction(1, "TouchScreenMode", "General")
    INIaction(1, "isTitleBarHidden", "General")
    If (getCaptionStyle(PVhwnd)=1 && TouchScreenMode=1 && userAllowWindowDrag=1)
       toggleWindowDraggableMode()
}

defineWinTitlePrefix() {
   Static FXmodesLabels := {2:"cP", 3:"cAUTO", 4:"cGR", 5:"cR", 6:"cG", 7:"cB", 8:"cA", 9:"cI"}

   If StrLen(UserMemBMP)>1
      winPrefix .= "IMAGE EDITING | "

   If StrLen(usrFilesFilteru)>1
      winPrefix .= "F "

   If hSNDmedia
      winPrefix .= "(A) "

   If (editingSelectionNow=1)
      winPrefix .= "SEL "

   If (slideShowRunning=1)
   {
      winPrefix .= "s"
      If (SlideHowMode=1)
         winPrefix .= "R "
      Else If (SlideHowMode=2)
         winPrefix .= "B "
      Else If (SlideHowMode=3)
         winPrefix .= "F "
   }
   If (usrColorDepth>1)
      winPrefix .= internalColorDepth  " bits "

   If (FlipImgV=1)
      winPrefix .= "V "
   If (FlipImgH=1)
      winPrefix .= "H "

   If (thisIMGisDownScaled=1)
      winPrefix .= "DWS "

   If FXmodesLabels.HasKey(imgFxMode)
      winPrefix .= FXmodesLabels[imgFxMode] A_Space

   If (IMGresizingMode=3)
      winPrefix .= "O "
   Else If (IMGresizingMode=4)
      winPrefix .= "Z "

   Return winPrefix
}

calculateTouchMargins(ByRef thisX, ByRef thisY, ByRef thisW, ByRef thisH) {
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   thisX := (editingSelectionNow=1) ? mainWidth//8 : mainWidth//7
   thisY := (editingSelectionNow=1) ? mainHeight//6 : mainHeight//5
   thisW := mainWidth - thisX*2
   thisH := mainHeight - thisY*2
}

drawWelcomeImg() {
    Critical, on
    If StrLen(UserMemBMP)>2
       thisClippyIMG := 1

    If (maxFilesIndex>0 || thisClippyIMG=1 || StrLen(CurrentSLD)>1 || AnyWindowOpen>0)
       Return

    If (A_TickCount - scriptStartTime>450)
    {
       If (identifyThisWin()!=1)
          Return
    }

    thisZeit := A_TickCount
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Random, modelu, 1, 7
    Random, iterations, 10, 30
    BMPcache := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, "0xE200B")
    If BMPcache
       G := trGdip_GraphicsFromImage(A_ThisFunc, BMPcache)

    If (!BMPcache || !G)
    {
       addJournalEntry("Welcome screen failed to render... mainBMP=" BMPcache " -- pG=" G)
       setWindowTitle(appTitle " v" appVersion, 1)
       SetTimer, drawWelcomeImg, Off
       Return
    }

    pBr4 := Gdip_BrushCreateSolid(0x66030201)
    trGdip_GraphicsClear(A_ThisFunc, G, "0xFF" WindowBgrColor)
    coredrawWelcomeImg(G, pBrushWinBGR, pBr4, modelu, iterations, mainWidth, mainHeight, 5, 5)

    getColors := (imgFxMode=3 || imgFxMode=8) ? 0 : 1
    If (getColors=1)
       decideGDIPimageFX(matrix, imageAttribs, zEffect)

    If !isWinXP
       pEffect := Gdip_CreateEffect(1, 20, 0, 0)

    If pEffect
       Gdip_BitmapApplyEffect(BMPcache, pEffect)

    trGdip_DrawImage(A_ThisFunc, glPG, BMPcache, 0, 0, mainWidth, mainHeight, 0, 0, mainWidth, mainHeight,,, imageAttribs)
    Gdip_AddPathGradient(glPG, 0, 0, mainWidth, mainHeight, mainWidth//2, mainHeight//2, "0x00000000", "0x55000000", 1, 0, 0, 1)

    If (TouchScreenMode=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//11
       Penuha := Gdip_CreatePen("0x34334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x05EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x10778877)
       Gdip_FillRectangle(glPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(glPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(glPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)

       Gdip_SetClipRect(glPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(glPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(glPG)
       Gdip_DrawRectangle(glPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(glPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)
    }

    r2 := LrydWinUpdt(hGDIwin, glHDC)
    Gdip_DeleteBrush(pBr4)
    trGdip_DisposeImage(BMPcache, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeEffect(zEffect)
    Gdip_DisposeImageAttributes(imageAttribs)

    Gdip_DeleteGraphics(G)
    addJournalEntry("Welcome screen rendered in " A_TickCount - thisZeit " ms.")
    setWindowTitle(appTitle " v" appVersion, 1)
    If (A_TickCount - thisZeit<250)
       SetTimer, drawWelcomeImg, -3500
    Else
       SetTimer, drawWelcomeImg, Off
}

coredrawWelcomeImg(G, bgrBrush, overBrush, modelu, iterations, mainWidth, mainHeight, minX, minY) {
    pBr1 := Gdip_BrushCreateSolid(0x33882211)
    pBr2 := Gdip_BrushCreateSolid(0x33112288)
    pBr3 := Gdip_BrushCreateSolid(0x33118822)
    pBr5 := Gdip_BrushCreateSolid(0x88939291)
    ; MsgBox, % minX "--" minY "`n" mainWidth "--" mainHeight "`n" bgrBrush
    ; Gdip_FillRectangle(G, bgrBrush, 0, 0, mainWidth, mainHeight)
    If (GetKeyState("CapsLock", "T") && G=glPG && !AnyWindowOpen)
       Gdip_FillRectangle(G, pBr5, 0, 0, mainWidth, mainHeight)

    If (modelu=1)
    {
       Loop, % iterations
       {  
          Random, xPos, % minX, % mainWidth
          Random, yPos, % minY, % mainHeight
          Random, w, % minX, % mainWidth
          Random, h, % minY, % mainHeight
          w += 10
          h += 10
          Random, tBrsh, 1, 3
          ; MsgBox, % xPos "--" yPos "`n" w "--" h "`n" tBrsh
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=2)
    {
       Loop, % iterations
       {
          Random, xPos, % minX, % mainWidth
          Random, yPos, % minY, % mainHeight
          Random, w, % minX, % mainWidth//2 + mainHeight//2
          w += 5
          h := w
          Random, tBrsh, 1, 3
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=3 || modelu=5)
    {
       Random, moduz, 1, 9
       Loop, % iterations
       {  
          Random, w, 5, % mainWidth//1.5 + mainHeight//1.5
          w += 5
          h := w
          Random, deviation, -25, 25
          If (modelu=5)
             Random, moduz, 1, 9

          If (moduz=1)
          {
             xPos := mainWidth//2 - w//2 + deviation
             yPos := mainHeight//2 - h//2 + deviation
          } Else If (moduz=2)
          {
             xPos := 1 - w//2 + deviation
             yPos := mainHeight//2 - h//2 + deviation
          } Else If (moduz=3)
          {
             xPos := 1 - w//2 + deviation
             yPos := 1 - h//2 + deviation
          } Else If (moduz=4)
          {
             xPos := mainWidth//2 - w//2 + deviation
             yPos := 1 - h//2 + deviation
          } Else If (moduz=5)
          {
             xPos := mainWidth - w//2 + deviation
             yPos := 1 - h//2 + deviation
          } Else If (moduz=6)
          {
             xPos := mainWidth - w//2 + deviation
             yPos := mainHeight - h//2 + deviation
          } Else If (moduz=7)
          {
             xPos := mainWidth//2 - w//2 + deviation
             yPos := mainHeight - h//2 + deviation
          } Else If (moduz=8)
          {
             xPos := mainWidth - w//2 + deviation
             yPos := mainHeight//2 - h//2 + deviation
          } Else
          {
             xPos := 1 - w//2 + deviation
             yPos := mainHeight - h//2 + deviation
          }
          Random, tBrsh, 1, 3
          Gdip_FillEllipse(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else If (modelu=6) ; maurer rose; implemented by hellbent
    {
       Random, iterations, 2, 5
       PetalPenA := Gdip_CreatePenFromBrush(pBr5, thickness)
       Loop, % iterations
       {
          Random, thickness, 2, 3
          Random, tBrsh, 1, 3
          Random, ttBrsh, 1, 3
          Random, Rany, 1, 9
          Random, Petals, 2, 7
          PetalPen := Gdip_CreatePenFromBrush(pBr%ttBrsh%, thickness)
          SweepPen := Gdip_CreatePenFromBrush(pBr%tBrsh%, thickness)
          PetalList := SweepList := mainWidth//2 "," mainHeight//2 "|", Sweep := Rany
          Loop, 360
          {
              SweepList .= CalculateSweep(A_Index*Sweep, Petals, mainWidth//2, mainHeight//2)
              PetalList .= CalculateSweep(A_Index*3.14159/180, Petals, mainWidth//2, mainHeight//2)
          }
          PetalList .= mainWidth//2 "," mainHeight//2
          SweepList .= mainWidth//2 "," mainHeight//2
          Gdip_DrawLines(G, PetalPenA, PetalList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, SweepPen, SweepList)
          Gdip_DrawLines(G, PetalPen, PetalList)
          Gdip_DeletePen(PetalPen)
          Gdip_DeletePen(SweepPen)
       }
       Gdip_DeletePen(PetalPenA)
    } Else If (modelu=4)
    {
       Loop, % iterations
       {  
          Random, xPos, % minX, % mainWidth
          y := 0
          Random, w, % minX, % mainWidth//2
          w += 5
          h := mainHeight
          Random, tBrsh, 1, 3
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    } Else ; If (modelu=6)
    {
       Loop, % iterations
       {  
          x := 0
          Random, yPos, % minY, % mainHeight
          w := mainWidth
          Random, h, % minY, % mainHeight//2
          h += 5
          Random, tBrsh, 1, 3
          Gdip_FillRectangle(G, pBr%tBrsh%, xPos, yPos, w, h)
       }
    }

    If (!GetKeyState("Shift", "P") || G!=glPG)
       Gdip_FillRectangle(G, overBrush, 0, 0, mainWidth, mainHeight)

    Gdip_DeleteBrush(pBr1)
    Gdip_DeleteBrush(pBr2)
    Gdip_DeleteBrush(pBr3)
    Gdip_DeleteBrush(pBr5)
}

CalculateSweep(InputValue, Petals, w, h) {
   r:=((w+h)//2)*Sin(Petals*InputValue)
   x:=r*cos(InputValue)+w
   y:=r*sin(InputValue)+h
   return x "," y "|"
}

addJournalEntry(msg) {
    Static currentEntry := 0, maxEntries := 256, lastError, prevEntry
    If (slideShowRunning=1 && slideShowDelay<300)
       Return

    If (msg="get_last_err")
       Return lastError

    If (msg="WinTitle: " pVwinTitle) || InStr(msg, "WinTitle: " appTitle " v" appVersion) || (msg="Loading...") || (slideShowRunning=1 && slideShowDelay<600) || (animGIFplaying=1)
       Return

    ; mamUsage := GetProcessMemoryUsage(QPVpid)
    ; If (A_PtrSize=8)
    ;    systemMemInfo := GlobalMemoryStatusEx()
    ; thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    ; memUsage := "Mem: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " 
    ; ToolTip, % memUsage , , , 2

    If (hasInitSpecialMode=1 || prevEntry=msg)
       Return

    fnOutputDebug("User journal: " StrReplace(msg, "`n", " | "))
    If ((InStr(msg, "error") || InStr(msg, "fail")) && !InStr(msg, "dialog box:"))
       lastError := msg

    currentEntry++
    prevEntry := msg
    QPVjournal.InsertAt(1, getCurrentDate() ":`n" msg "`n")
    If (currentEntry>maxEntries)
    {
       currentEntry := maxEntries
       QPVjournal.Pop()
    }
}

getCurrentDate() {
   FormatTime, CurrentTimeB,, H:mm:ss
   FormatTime, CurrentDateB,, ShortDate
   Return CurrentDateB ", " CurrentTimeB
}

destroyGDIPcanvas() {
    qpvCanvasHasInit := 0
    Gdi_SelectObject(glHDC, glOBM)
    If glHbitmap
       Gdi_DeleteObject(glHbitmap)
    If glHDC
       Gdi_DeleteDC(glHDC)
    If glPG
       Gdip_DeleteGraphics(glPG)

    Gdi_SelectObject(2NDglHDC, 2NDglOBM)
    If 2NDglHbitmap
       Gdi_DeleteObject(2NDglHbitmap)
    If 2NDglHDC
       Gdi_DeleteDC(2NDglHDC)
    If 2NDglPG
       Gdip_DeleteGraphics(2NDglPG)

    glHbitmap := 2NDglHbitmap := ""
    glHDC := 2NDglHDC := ""
    glPG := 2NDglPG := ""
}

createGDIPcanvas(W:=0, H:=0) {
   Critical, on
   Static prevDimensions, hasInit
   If (A_TickCount - lastMenuBarUpdated<700)
      Return

   If (W=0 && H=0)
      GetWinClientSize(W, H, PVhwnd, 0)

   newDimensions := "w" W "-h" H "-mbar" showMainMenuBar
   doAgain := (prevDimensions!=newDimensions) ? 1 : 0
   If (!qpvCanvasHasInit || doAgain=1)
   {
      If (hasInit=1)
         destroyGDIPcanvas()

      ; gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
      imgQuality := (userimgQuality=1) ? 7 : 5
      If (minimizeMemUsage=1)
         imgQuality := ""    ; interpolation mode

      PixelMode := (userimgQuality=1) ? 2 : 0
      smoothMode := (userimgQuality=1) ? 4 : 1
      compositingQuality := (userimgQuality=1) ? 0 : 1
      glHDC := Gdi_CreateCompatibleDC()
      glHbitmap := Gdi_CreateDIBSection(W, H)
      glOBM := Gdi_SelectObject(glHDC, glHbitmap)
      glPG := Gdip_GraphicsFromHDC(glHDC, 0, imgQuality, smoothMode,, compositingQuality)
      Gdip_SetPixelOffsetMode(glPG, PixelMode)

      2NDglHDC := Gdi_CreateCompatibleDC()
      2NDglHbitmap := Gdi_CreateDIBSection(W, H)
      2NDglOBM := Gdi_SelectObject(2NDglHDC, 2NDglHbitmap)
      2NDglPG := Gdip_GraphicsFromHDC(2NDglHDC, 0, imgQuality, smoothMode,, compositingQuality)
      Gdip_SetPixelOffsetMode(2NDglPG, PixelMode)

      hasInit := 1
      prevDimensions := newDimensions
      addJournalEntry("Canvas infos: " prevDimensions " - glPG:" glPG " - glHDC:" glHDC " - glOBM:" glOBM " - glHbmp:" glHbitmap " - 2NDglPG:" 2NDglPG " - 2NDglHDC:" 2NDglHDC " - 2NDglOBM:" 2NDglOBM " - 2NDglHbmp:" 2NDglHbitmap)
      If (!glPG || !glHDC || !glHbitmap || !glOBM || !2NDglPG || !2NDglHDC || !2NDglOBM || !2NDglHbitmap)
      {
         qpvCanvasHasInit := 0
         prevDimensions := "r"
         ; MsgBox, 48, %appTitle%, ERROR: Unable to initialize GDI+ window...`n`nThe program will probably malfunction or crash.
         msgResult := msgBoxWrapper(appTitle ": FATAL ERROR", appTitle " was unable to initialize the GDI+ window required to display images.`n`nWould you like to try initialize it again? By choosing to continue, the application may malfunction.", "&Try again|&Continue|&Exit", 1, "error")
         If InStr(msgResult, "again")
         {
            createGDIPcanvas()
            Return
         } Else If InStr(msgResult, "exit")
         {
            hasInitSpecialMode := 1
            ForceExitNow()
            Return
         }
      } Else
      {
         qpvCanvasHasInit := 1
         addJournalEntry("Main canvas created: " W " x " H " px.")
      }
   }
}

InitGDIpStuff() {
; create pens and brushes
   pPen1 := Gdip_CreatePen("0xCCbbccbb", 3)
   pPen1d := Gdip_CreatePen("0xCCbbccbb", 3)
   Gdip_SetPenDashArray(pPen1d, "1.1,1.1")
   pPen2 := Gdip_CreatePen("0xBBffccbb", 3)
   pPen3 := Gdip_CreatePen("0x66334433", imgHUDbaseUnit//8)
   pPen4 := Gdip_CreatePen("0x88998899", imgHUDbaseUnit//11)
   pPen5 := Gdip_CreatePen("0x880088FF", imgHUDbaseUnit//11.5)
   pPen6 := Gdip_CreatePen("0xDD998822", imgHUDbaseUnit//6)
   Gdip_SetPenDashArray(pPen4, "0.5,0.5")
   pBrushA := Gdip_BrushCreateSolid("0x90898898")
   pBrushB := Gdip_BrushCreateSolid("0xBB898898")
   pBrushC := Gdip_BrushCreateSolid("0x77898898")
   pBrushD := Gdip_BrushCreateSolid("0xDDbbccFF")
   pBrushE := Gdip_BrushCreateSolid("0x77333333")
   pBrushF := Gdip_BrushCreateSolid("0x33667766")
   pBrushZ := Gdip_BrushCreateSolid("0xFF000000")

   ; createCheckersBrush(20)
   pBrushHatchLow := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)
   pBrushHatchLiw := Gdip_BrushCreateHatch("0xff111111", "0xff999999", 50)
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
   GroupAdd, QPVwindows, ahk_id %PVhwnd%
   GroupAdd, QPVwindows, ahk_id %hGDIthumbsWin%
   GroupAdd, QPVwindows, ahk_id %hGDIwin%
   GroupAdd, QPVwindows, ahk_id %hGDIselectWin%
   GroupAdd, QPVwindows, ahk_id %hGDIinfosWin%
}

useHatchedBrush(dummy:=0) {
   Static last := 0
   If (dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha!=1)
      Return
   Else If (coreDesiredPixFmt="0x21808" || dummy="vp" && imgFxMode=8 && currIMGdetails.HasAlpha=1)
      Return pBrushZ
   Else z := last ? pBrushHatchLow : pBrushHatchLiw
   ; ToolTip, % last "=" z , , , 2
   last := !last
   Return z
}

ToggleSeenIMGstatus() {
   initSeenImagesListDB()
   If (thumbsDisplaying!=1 || sqlFailedInit=1)
      Return

   If (slideShowRunning=1)
      ToggleSlideShowu()

   mustRem := 0 
   imgPath := getIDimage(currentFileIndex)
   cachedAllSessionsSeen["z" StringToASC(imgPath)] := ""
   resultedFilesList[currentFileIndex, 3] := ""
   seenImagesDB.Exec("COMMIT TRANSACTION;")
   If retrieveSeenImageDBentry(imgPath, currentFileIndex)
      mustRem := 1 
   
   If markedSelectFile
   {
      prevMSGdisplay := A_TickCount
      startOperation := A_TickCount
      countFilez := 0
      getSelectedFiles(0, 1)
      friendly := (mustRem=1) ? "UNSEEN" : "SEEN"
      showTOOLtip("Marking as " friendly " 0 / " markedSelectFile " images, please wait...")
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      doStartLongOpDance()
      Loop, % maxFilesIndex
      {
         isSelected := resultedFilesList[A_Index, 2]
         If (isSelected!=1)
            Continue
      
         executingCanceableOperation := A_TickCount
         If (A_TickCount - prevMSGdisplay>2000)
         {
            zeitOperation := A_TickCount - startOperation
            percDone := " ( " Round((countFilez / markedSelectFile) * 100) "% )"
            percLeft := (1 - countFilez / markedSelectFile) * 100
            zeitLeft := (zeitOperation/countFilez) * markedSelectFile - zeitOperation
            etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
            etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
            showTOOLtip("Marking as " friendly A_Space countFilez " / " markedSelectFile " images, please wait..." etaTime, 0, 0, countFilez / markedSelectFile)
            prevMSGdisplay := A_TickCount
         }

         If (determineTerminateOperation()=1)
         {
            abandonAll := 1
            Break
         }

         countFilez++
         resultedFilesList[A_Index, 3] := ""
         cachedAllSessionsSeen["z" StringToASC(imgPath)] := ""
         imgPath := getIDimage(A_Index)
         If (mustRem=1)
            deleteSQLseenEntry(imgPath, A_Index)
         Else
            recordSeenIMGdbEntry(imgPath, A_Index, 0)
      }

      seenImagesDB.Exec("COMMIT TRANSACTION;")
      If (abandonAll=1)
         showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected images were marked as " friendly ".")
      Else
         showTOOLtip("Finished marking " countFilez " images as " friendly ".")

      SetTimer, ResetImgLoadStatus, -50
      SoundBeep, % (abandonAll=1) ? 300 : 900, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
   } Else
   {
      If (mustRem=1)
         deleteSQLseenEntry(imgPath, currentFileIndex)
      Else
         recordSeenIMGdbEntry(imgPath, currentFileIndex, 1)
      seenImagesDB.Exec("COMMIT TRANSACTION;")
   }

   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(50)
}

CleanDeadFilesSeenImagesDB() {
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If AnyWindowOpen
     CloseWindow("yes")

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to purge no longer existent files from the list of seen images?`n`nThis action is irreversible and may take awhile...", "&Continue|C&ancel", 2, "question")
   If !InStr(msgResult, "continue")
      Return

  startOperation := A_TickCount
  showTOOLtip("Removing entries of inexistent files from the already seen images database, please wait...")
  seenImagesDB.Exec("BEGIN TRANSACTION;")
  doStartLongOpDance()
  prevMSGdisplay := A_TickCount
  startOperation := A_TickCount
  entriesCount := entriesScanned := entriesDoneCount := 0
  RecordSet := ""
  SQL := "SELECT imgfile FROM images;"
  If !seenImagesDB.Query(SQL, RecordSet)
     Return 0

  entries := []
  Loop
  {
      If (RegExMatch(Row[1], RegExFilesPattern))
      {
         entriesCount++
         entries[entriesCount] := Row[1]
      }
      RC := RecordSet.Next(Row)
  } Until (RC<1)
  RecordSet.Free()

  Loop, % entriesCount + 1
  {
      item := Trimmer(entries[A_Index])
      If !FileExist(item)
      {
         deleteSQLseenEntry(item, 0)
         entriesDoneCount++
      }

      entriesScanned++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         zeitOperation := A_TickCount - startOperation
         percDone := " ( " Round((entriesScanned / entriesCount) * 100) "% )"
         percLeft := (1 - entriesScanned / entriesCount) * 100
         zeitLeft := (zeitOperation/entriesScanned) * entriesCount - zeitOperation
         etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
         etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
         showTOOLtip("Removing entries of inexistent files from the already seen images database, please wait...`n" entriesScanned " / " entriesCount " entries scanned`n" entriesDoneCount " entries to inexistent files removed" etaTime, 0, 0, entriesScanned / entriesCount)
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  seenImagesDB.Exec("COMMIT TRANSACTION;")
  seenImagesDB.Exec("VACUUM main;")

  zeitOperation := A_TickCount - startOperation
  etaTime := "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3))
  If (abandonAll=1)
     etaTime .= "`nOperation aborted. " entriesScanned " / " entriesCount " entries were scanned until now."

  showTOOLtip(entriesDoneCount " entries of inexistent files were removed from the database" etaTime)
  SetTimer, ResetImgLoadStatus, -50
  SoundBeep, 900, 100
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return entries
}

retrieveEntireSeenImagesDB(ByRef entriesCount, doSorting, applyFilter:=0) {
  entriesCount := 0
  RecordSet := ""
  filteru := Strlen(applyFilter)>1 ? " WHERE imgViewDate LIKE '" applyFilter "%'" : ""
  orderu := (doSorting=1) ? " ORDER BY imgViewDate;" : ";"
  SQL := "SELECT imgfile FROM images" filteru orderu
  If !seenImagesDB.Query(SQL, RecordSet)
     Return 0

  entries := []
  Loop
  {
      ; entries[CalcStringHash(Row[1], 0x8003)] := Row[1]
      If RegExMatch(Row[1], RegExFilesPattern)
      {
         entriesCount++
         If (doSorting=1)
            entries[entriesCount] := Row[1]
         Else
            entries["z" StringToASC(Row[1])] := Row[1]
      }
      RC := RecordSet.Next(Row)
  } Until (RC<1)

  addJournalEntry("Recorded seen images: " entriesCount "`nRetrieved entries: " entries.Count())
  RecordSet.Free()
  Return entries
}

deleteSQLseenEntry(imgPath, thisIndex) {
  SQLstr := "DELETE FROM images WHERE (imgfile='" imgPath "');"
  If !seenImagesDB.Exec(SQLStr)
  {
     stringA := imgPath
     seenImagesDB.EscapeStr(stringA)
     SQLstr := "DELETE FROM images WHERE (imgfile=" stringA ");"
     seenImagesDB.Exec(SQLStr)
  }
  resultedFilesList[thisIndex, 3] := 0
}

retrieveSeenImageDBentry(imgPath, thisIndex, listMode:=0) {
  Static lastInvoked := 1

  If (!imgPath || (A_TickCount - lastInvoked<350) && (slideShowRunning!=1))
     Return 0

  If (resultedFilesList[thisIndex, 3]=1)
     Return 1
  Else If (resultedFilesList[thisIndex, 3]=0 && thumbsDisplaying=1)
     Return 0

  zu := cachedAllSessionsSeen["z" StringToASC(imgPath)]
  If (zu=imgPath && imgPath)
  {
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else If (thumbsDisplaying=1 && zu=0)
     Return 0
 
  initSeenImagesListDB()
  If (sqlFailedInit=1)
     Return 0

  RecordSet := ""
  stringA := imgPath
  seenImagesDB.EscapeStr(stringA)
  SQL := "SELECT imgfile FROM images WHERE imgfile=" stringA " COLLATE NOCASE;"
  If !seenImagesDB.Query(SQL, RecordSet)
     Return 0

  Loop
  {
      entries .= Row[1] "`n"
      RC := RecordSet.Next(Row)
  } Until (RC<1)

  RecordSet.Free()
  entries := Trimmer(entries)
  If StrLen(entries)>5
  {
     cachedAllSessionsSeen["z" StringToASC(imgPath)] := imgPath
     resultedFilesList[thisIndex, 3] := 1
     Return 1
  } Else
  {
     cachedAllSessionsSeen["z" StringToASC(imgPath)] := 0
     resultedFilesList[thisIndex, 3] := 0
     Return 0
  }

  lastInvoked := A_TickCount
}

recordSeenIMGdbEntry(imgPath, thisIndex, doCommits:=1) {
   Static invoked := 0
   If (resultedFilesList[thisIndex, 3]=1)
      Return

   If (doCommits=1)
      initSeenImagesListDB()

   If (sqlFailedInit=1)
      Return

   FormatTime, currDate, , yyyy-MM-dd@HH
   MD5name := currDate
   resultedFilesList[thisIndex, 3] := 1
   cachedAllSessionsSeen["z" StringToASC(imgPath)] := imgPath
   ; If (thumbsDisplaying!=1)
   ;    userSeenSlideImages++

   SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES ('" imgPath "', '" MD5name "');"
   If !seenImagesDB.Exec(SQLStr)
   {
      stringA := imgPath
      seenImagesDB.EscapeStr(stringA)
      stringB := MD5name
      seenImagesDB.EscapeStr(stringB)
      ; MsgBox, % stringA "--" stringB 
      SQLstr := "REPLACE INTO images (imgfile, imgViewDate) VALUES (" stringA ", " stringB "');"
      seenImagesDB.Exec(SQLStr)
   }

   If (invoked>15 && doCommits=1)
   {
      seenImagesDB.Exec("COMMIT TRANSACTION;")
      Sleep, -1
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      invoked := 0
   }

   invoked++
}

eraseSeenIMGsDB() {
   initSeenImagesListDB()
   If (sqlFailedInit=1)
      Return 0

   If !seenImagesDB
      Return

   msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to delete the list of seen images?`n`nThis action is irreversible. The actual files will be untouched, only the list of seen images is going to be erased.", "&Erase list|&Cancel", 2, "exclamation")
   If !InStr(msgResult, "erase list")
      Return

   If AnyWindowOpen
      CloseWindow("yes")

   seenImagesDB.Close()
   FileDelete, % mainCompiledPath "\seenImagesList.db"
   Sleep, 5
   seenImagesDB := ""
   showTOOLtip("Already seen images list is now empty.`nEntries will be added only if the option`nto skip seen images is activated.")
   SetTimer, RemoveTooltip, % -msgDisplayTime
   If (skipSeenImagesSlider=1)
      initSeenImagesListDB()
}

initSeenImagesListDB() {
   If (sqlFailedInit=-1 || sqlFailedInit=1)
      Return

   If FileExist(mainCompiledPath "\seenImagesList.db")
      alreadyExisting := 1

   seenImagesDB := new SQLiteDB
   sqlFailedInit := seenImagesDB.hasFailedInit
   If !seenImagesDB.OpenDB(mainCompiledPath "\seenImagesList.db")
   {
      skipSeenImagesSlider := 0
      sqlFailedInit := 1
   } Else If (alreadyExisting!=1)
   {
      SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE, imgViewDate TEXT, PRIMARY KEY(imgfile ASC)); CREATE INDEX imgsIndex ON images (imgfile COLLATE NOCASE);"
      If !seenImagesDB.Exec(SQL)
      {
         skipSeenImagesSlider := 0
         sqlFailedInit := 1
      } Else
      {
         sqlFailedInit := -1
         seenImagesDB.Exec("BEGIN TRANSACTION;")
      }
   } Else
   {
      seenImagesDB.Exec("BEGIN TRANSACTION;")
      sqlFailedInit := -1
   }
}

SLDinitSQLdb(fileNamu) {
   activeSQLdb.CloseDB()
   Sleep, 5
   activeSQLdb := new SQLiteDB
   activeSQLdb.OpenDB(fileNamu)
      ; Return -1

   SQL := "CREATE TABLE images (imgfile TEXT COLLATE NOCASE, imgfolder TEXT COLLATE NOCASE, fsize NUMERIC, fmodified NUMERIC, fcreated NUMERIC, imgwidth NUMERIC, imgheight NUMERIC, imgavg NUMERIC, imgmedian NUMERIC, imgCaption TEXT, imgAudio TEXT, PRIMARY KEY(imgfolder ASC, imgfile ASC));"
   SQL .= "CREATE TABLE imagesData (imgfile TEXT COLLATE NOCASE, imgCaption TEXT, imgAudio TEXT COLLATE NOCASE, PRIMARY KEY(imgfile ASC));"
   SQL .= "CREATE TABLE dynamicfolders (imgfolder TEXT COLLATE NOCASE, fmodified NUMERIC, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE staticfolders (imgfolder TEXT COLLATE NOCASE, fmodified NUMERIC, PRIMARY KEY(imgfolder ASC));"
   SQL .= "CREATE TABLE settings (paramz TEXT COLLATE NOCASE, valuez TEXT COLLATE NOCASE, PRIMARY KEY(paramz ASC, valuez ASC));"
   If !activeSQLdb.Exec(SQL)
      Return activeSQLdb.ErrorMsg
}

createCheckersBrush(size) {
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, size, size, "0xE200B")
   If !pBitmap
      Return

   pBr1 := Gdip_BrushCreateSolid("0x99ffFFff")
   pBr2 := Gdip_BrushCreateSolid("0x99515151")
   pBr3 := Gdip_BrushCreateHatch("0xff999999", "0xff111111", 50)

   G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   Gdip_FillRectangle(G, pBr3, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr2, 0, 0, size, size)
   Gdip_FillRectangle(G, pBr1, 0, 0, size//2, size//2)
   Gdip_FillRectangle(G, pBr1, size//2, size//2, size//2, size//2)
   Gdip_DeleteGraphics(G)
   pBrushHatch := Gdip_CreateTextureBrush(pBitmap, 0, 0, 0, size, size)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DeleteBrush(pBr1)
   Gdip_DeleteBrush(pBr2)
   Gdip_DeleteBrush(pBr3)
   setTexHatchScale(zoomLevel)
}

refreshWinBGRbrush() {
   If pBrushWinBGR
      Gdip_DeleteBrush(pBrushWinBGR)
   Sleep, 0
   pBrushWinBGR := Gdip_BrushCreateSolid("0xFF" WindowBgrColor)
}

dummy() {
  Sleep, 0
}

setImageLoading() {
  If (slideShowRunning=1 || animGIFplaying=1 || drawingShapeNow=1 || hasInitSpecialMode=1)
     Return

  imageLoading := 1
  changeMcursor("busy-img")
}

ResetImgLoadStatus() {
  If (slideShowRunning=1 || animGIFplaying=1) && (imageLoading!=1 && runningLongOperation!=1)
  {
     If (imageLoading=1)
        SetTimer, ResetImgLoadStatus, -70
     Return
  }

  If !GetKeyState("LButton")
  {
     changeMcursor("normal-extra")
     runningLongOperation := 0
     mustAbandonCurrentOperations := imageLoading := 0
  } Else If (imageLoading=1)
     SetTimer, ResetImgLoadStatus, -70
}

ShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
  Static prevImgPath, lastInvoked := 1

  If (slideShowRunning=1)
  {
     slideShowRunning := interfaceThread.ahkgetvar.slideShowRunning
     If (slideShowRunning!=1)
        prevSlideShowStop := A_TickCount
  }

  doIT := ((A_TickCount - lastInvoked<125) && (drawModeAzeit>180 && LastPrevFastDisplay!=1 && prevDrawingMode=1)) || (drawModeBzeit>200 && prevDrawingMode=3 && LastPrevFastDisplay!=1) || ((A_TickCount - lastInvoked<65) && (prevImgPath!=imgPath && drawModeAzeit>50)) || ((A_TickCount - lastInvoked<10) && prevDrawingMode=1) ? 1 : 0
  If (A_TickCount - prevColorAdjustZeit<90) || (animGIFplaying=1 || slideShowRunning=1)
     doIT := 0

  If (usePrevious=0 && ForceIMGload=0 && AnyWindowOpen!=10
  && doIT=1 && !diffIMGdecX && !diffIMGdecY && thumbsDisplaying!=1)
  {
     ; If (noTooltipMSGs=1)
     ;   SetTimer, RemoveTooltip, Off
     ; ToolTip, % Exception("", -1).Line "`n" Exception("", -1).What, , , 2
     zPlitPath(imgPath, 0, OutFileName, OutDir)
     If (vpIMGrotation>0)
        zoomu := " @ " vpIMGrotation "°"
     If (IMGresizingMode=4)
        zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"
     winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
     winPrefix := defineWinTitlePrefix()
     pVwinTitle := winPrefix winTitle
     setWindowTitle(pVwinTitle, 1)
     lastInvoked := A_TickCount
     dummyFastImageChangePlaceHolder(OutFileName, OutDir)
     ; SetTimer, dummyFastImageChangePlaceHolder, -15
     dummyTimerReloadThisPicture(550)
     prevImgPath := imgPath
  } Else
  {
     If (animGIFplaying=1)
        usePrevious := 0

     prevImgPath := imgPath
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount

     coreShowTheImage(imgPath, usePrevious, ForceIMGload)
     If (thumbsDisplaying=1) && (A_TickCount - prevFullThumbsUpdate < 200) ; && (prevStartIndex!=prevFullIndexThumbsUpdate)
        prevTryThumbsUpdate := A_TickCount
  }

  lastInvoked := A_TickCount
}

coreShowTheImage(imgPath, usePrevious:=0, ForceIMGload:=0) {
   Critical, on
   Static prevImgPath, lastInvoked2 := 1, counteru
        , lastInvoked := 1, prevPicCtrl := 1

   WinGet, winStateu, MinMax, ahk_id %PVhwnd%
   If (winStateu=-1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()
      DestroyGIFuWin()
      Return
   }

   startZeitIMGload := A_TickCount
   SetTimer, ResetImgLoadStatus, Off
   ThisPrev := (ForceIMGload=1 || usePrevious=2) ? 1 : 0
   If (imgPath=prevImgPath && StrLen(prevImgPath)>3 && ThisPrev!=1)
      usePrevious := 1

   If (usePrevious=2 || ForceIMGload=1)  ; force no caching
   {
      If (ForceIMGload=1)
         prevImgPath := 1
      usePrevious := 0
   }

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"
   If (IMGresizingMode=4)
      zoomu := " [" Round(zoomLevel * 100) "%" zoomu "]"

   winTitle := currentFileIndex "/" maxFilesIndex zoomu " | " OutFileName " | " OutDir "\"
   If (thumbsDisplaying=1)
   {
      filesSelInfo := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
      SetTimer, UpdateThumbsScreen, -10
      pVwinTitle := filesSelInfo "THUMBS: " winTitle
      setWindowTitle(pVwinTitle, 1)
      If (imageLoading=1)
         SetTimer, ResetImgLoadStatus, -15
      Return
   }

   If !gdiBitmap
   {
      usePrevious := 0
      ForceIMGload := 1
   }
   ; ToolTip, % AprevImgCall "`n" BprevImgCall "`n" imgPath,,,2
   If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath)) && (ForceIMGload=0) || StrLen(UserMemBMP)>1
      ignoreFileCheck := 1

   If (!FileRexists(imgPath) && usePrevious=0 && ignoreFileCheck!=1)
   {
      destroyGDIfileCache()
      DestroyGIFuWin()
      If (hSNDmedia && autoPlaySNDs!=1)
         StopMediaPlaying()
      If (slideShowRunning=1)
         invokeExternalSlideshowHandler()

      If (WinActive("A")=PVhwnd)
      {
         winTitle := "[*] " winTitle
         pVwinTitle := winTitle
         setWindowTitle(pVwinTitle, 1)
         showTOOLtip("ERROR: File not found or access denied...`n" OutFileName "`n" OutDir "\")
         SetTimer, RemoveTooltip, % -msgDisplayTime
      }

      If (imgPath!=prevImgPath)
      {
         If (minimizeMemUsage=1)
            terminateIMGediting()

         If (A_TickCount - lastInvoked2>125) && (A_TickCount - lastInvoked>95)
         {
            SoundBeep, 300, 50
            lastInvoked2 := A_TickCount
         }
 
         If (autoRemDeadEntry=1)
            remCurrentEntry(0, 1)
         lastInvoked := A_TickCount
         SetTimer, ResetImgLoadStatus, -15
         Return "fail"
      }
   }

   If (A_TickCount - lastInvoked>85) && (A_TickCount - lastInvoked2>85)
   || (slideShowRunning=1 || animGIFplaying=1 || usePrevious=1 || oldZoomLevel || ForceIMGload=1 || diffIMGdecX || diffIMGdecY || LastPrevFastDisplay=1)
   {
       lastInvoked := A_TickCount
       r2 := ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload)
       ; msgbox, % r2
       If InStr(r2, "error")
       {
          DestroyGIFuWin()
          destroyGDIfileCache()
          If (hSNDmedia && autoPlaySNDs!=1)
             StopMediaPlaying()
          If (slideShowRunning=1)
             invokeExternalSlideshowHandler()

          If (WinActive("A")=PVhwnd)
          {
             friendly := (A_PtrSize=4) ? "`nOr, insufficient memory..." : ""
             showTOOLtip("ERROR: Unable to display the image...`nPossibly malformed image file format." friendly "`n" r2)
             SetTimer, RemoveTooltip, % -msgDisplayTime
          } Else
          {
             setWindowTitle("ERROR: Unable to display the image...`nPossibly malformed image file format." friendly "`n" r2)
             Sleep, 500
          }
          winTitle := "[*] " winTitle
          pVwinTitle := winTitle
          setWindowTitle(pVwinTitle, 1)
          SetTimer, ResetImgLoadStatus, -15
          If (slideShowRunning!=1)
             SoundBeep, 300, 100
          Return "fail"
       } Else prevImgPath := imgPath
       lastInvoked := A_TickCount
   } Else
   {
      ; If (noTooltipMSGs=1)
      ;    SetTimer, RemoveTooltip, Off
      winPrefix := defineWinTitlePrefix()
      pVwinTitle := winPrefix winTitle
      setWindowTitle(pVwinTitle, 1)
      delayu := (A_TickCount - prevFastDisplay < 500) ? 110 : 325
      dummyFastImageChangePlaceHolder(OutFileName, OutDir)
      dummyTimerReloadThisPicture(delayu)
   }
   ; SetTimer, ResetImgLoadStatus, -15
   lastInvoked2 := A_TickCount
}

dummyFastImageChangePlaceHolder(OutFileName, OutDir) {
   Static lastInvoked := 1, prevImgPath
   If (A_TickCount - lastInvoked<50) || (noTooltipMSGs=1)
      Return

   lastInvoked := A_TickCount
   entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
   If (entireString=prevImgPath)
      Return

   prevImgPath := entireString
   CreateOSDinfoLine(entireString, 0, 1, currentFileIndex/maxFilesIndex)
   SetTimer, RemoveTooltip, -500
}

calcImgSize(modus, imgW, imgH, GuiW, GuiH, ByRef ResizedW, ByRef ResizedH) {
   PicRatio := Round(imgW/imgH, 5)
   GuiRatio := Round(GuiW/GuiH, 5)
   If (imgW <= GuiW) && (imgH <= GuiH)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
      If (ResizedH>GuiH)
      {
         ResizedH := (imgH <= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
         ResizedW := Round(ResizedH * PicRatio)
      }   

      If (modus=2)
      {
         ResizedW := imgW
         ResizedH := imgH
      }
   } Else If (PicRatio > GuiRatio)
   {
      ResizedW := GuiW
      ResizedH := Round(ResizedW / PicRatio)
   } Else
   {
      ResizedH := (imgH >= GuiH) ? GuiH : imgH         ;set the maximum picture height to the original height
      ResizedW := Round(ResizedH * PicRatio)
   }

   If (modus=5)
   {
      ResizedW := GuiW
      ResizedH := GuiH
   }
}

ResizeImageGDIwin(imgPath, usePrevious, ForceIMGload) {
    Critical, on
    Static oImgW, oImgH, prevImgPath, lastTitleChange := 1
         , IDprevImgPath, tinyW, tinyH, wscale

    setImageLoading()
    If (editingSelectionNow=1 && IMGresizingMode=5)
       IMGresizingMode := 1

    setWindowTitle("Loading file | " imgPath)
    changeMcursor()
    calcScreenLimits()
    ; If (winGDIcreated!=1)
    ;   createGDIwin()
    ; o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
    extraID := ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation RenderOpaqueIMG usrTextureBGR usrColorDepth bwDithering
    IDthisImgPath := imgPath "-" userHQraw extraID
    If (imgPath!=prevImgPath || IDthisImgPath!=IDprevImgPath || !gdiBitmap || ForceIMGload=1)
    {
       gdiBMPchanged := 1
       ; ToolTip, % ForceIMGload, , , 2
       If (imgPath!=prevImgPath) && (currentFileIndex!=0)
       {
          terminateIMGediting()
          desiredFrameIndex := 0
          If (AutoDownScaleIMGs=2)
             AutoDownScaleIMGs := 1
       }

       mustReloadIMG := (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath) || (ForceIMGload=1) ? 1 : 0
       If (IDthisImgPath!=IDprevImgPath && imgPath=prevImgPath)
       {
          usePrevious := 0
          mustReloadIMG := ForceIMGload := 1
          If (currentFileIndex!=0)
             GdipCleanMain(6)
       }

       disposeCacheIMGs()
       changeMcursor()
       r1 := CloneMainBMP(imgPath, oImgW, oImgH, mustReloadIMG, hasFullReloaded)
       abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
       If (imgFxMode=3 && r1!="error" && abortImgLoad<3)
       {
          setWindowTitle("Calculating auto-color adjustments")
          AdaptiveImgLight(gdiBitmap, imgPath, oImgW, oImgH)
       }

       If (abortImgLoad>2)
       {
          o_ImgQuality := userimgQuality
          If (userimgQuality=1)
             ToggleImgQuality("lowu")
          If (desiredFrameIndex<1 && (usrColorDepth>1 || vpIMGrotation>0))
          {
             setWindowTitle("Image processing aborted...")
             showTOOLtip("Image processing aborted...")
             SetTimer, RemoveTooltip, % -msgDisplayTime//2
          }
       }
    }

    If (!gdiBitmap || r1="error")
    {
       If (o_ImgQuality=1)
          ToggleImgQuality("highu")
       If (AutoDownScaleIMGs=2)
          AutoDownScaleIMGs := 1

       prevImgPath := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       FadeMainWindow()
       SetTimer, ResetImgLoadStatus, -15
       r := (r1="error") ? r1 : 0
       Return r
    }

   prevImgPath := imgPath
   IDprevImgPath := imgPath "-" userHQraw extraID
   GetWinClientSize(GuiW, GuiH, PVhwnd, 0)
   imgW := oImgW
   imgH := oImgH
   decideUndoLevelsAccepted(imgW, imgH)

   calcImgSize(IMGresizingMode, oimgW, oimgH, GuiW, GuiH, ResizedW, ResizedH)
   If (IMGresizingMode=3) ; original [100%]
   {
      lGuiW := (GuiW>imgW) ? imgW : GuiW
      lGuiH := (GuiH>imgH) ? imgH : GuiH
      ws := Round(ResizedW / imgW * 100)
      If (ws<100)
      {
         ws := Round(((lGuiW*lGuiH) / (imgW*imgH)) * 100)
         ws .= "% visible"
      } Else If (ws>100)
      {
         ws := "100%"
      } Else ws .= "%"
      zoomLevel := 1
      ResizedW := imgW
      ResizedH := imgH
   } Else If (IMGresizingMode=4) ; custom zoom level
   {
      ResizedW := Round(imgW * zoomLevel, 3)
      ResizedH := Round(imgH * zoomLevel, 3)
      ws := Round(zoomLevel * 100) "%"
   } Else
   {
      zoomLevel := Round(ResizedW / imgW, 3)
      ws := Round(ResizedW / imgW * 100) "%"
   }

   ; ToolTip, % imgW ", " oImgW ", " roImgW ", " ResizedW ,,, 2
   IMGlargerViewPort := ((ResizedH-5>GuiH+1) || (ResizedW-5>GuiW+1)) ? 1 : 0
   If (noTooltipMSGs=1)
      SetTimer, RemoveTooltip, Off
   If (vpIMGrotation>0)
      zoomu := " @ " vpIMGrotation "°"

   zPlitPath(imgPath, 0, OutFileName, OutDir)
   winPrefix := defineWinTitlePrefix()
   winTitle := winPrefix currentFileIndex "/" maxFilesIndex " [" ws zoomu "] | " OutFileName " | " OutDir "\"
   If (A_TickCount - lastTitleChange>300)
      setWindowTitle("Adapting image to viewport...")

   prevResizedVPimgW := ResizedW := Round(ResizedW)
   prevResizedVPimgH := ResizedH := Round(ResizedH)
   prevMaxSelX := roImgW ? roImgW : oImgW
   prevMaxSelY := roImgH ? roImgH : oImgH
   If (editingSelectionNow=1 && relativeImgSelCoords=1 && gdiBMPchanged=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   GDIfadeVPcache := trGdip_DisposeImage(GDIfadeVPcache, 1)
   If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && animGIFplaying!=1 && slideShowDelay>950)
      GDIfadeVPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)

   changeMcursor()
   pVwinTitle := infoFilesSel infoFrames winTitle
   r := QPV_ShowImgonGui(ResizedW, ResizedH, GuiW, GuiH, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, wasPrevious)
   delayu := (A_TickCount - prevFastDisplay < 300) ? 90 : 550
   If (wasPrevious=1 && animGIFplaying!=1)
      dummyTimerReloadThisPicture(delayu)

   infoFilesSel := (markedSelectFile>0) ? "[ " markedSelectFile " ] " : ""
   If (totalFramesIndex>0)
      infoFrames := "["  desiredFrameIndex "/" totalFramesIndex "] "

   setWindowTitle(pVwinTitle, 1)
   lastTitleChange := A_TickCount
   If (o_ImgQuality=1)
      ToggleImgQuality("highu")

   SetTimer, ResetImgLoadStatus, -15
   Return r
}

drawinfoBox(mainWidth, mainHeight, directRefresh:=0) {
    Static prevMsg, prevOSDfnt
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)
    imgPath := StrReplace(imgPath, "||")
    infoFilesSel := (markedSelectFile>0) ? "`nFiles selected: " markedSelectFile : ""
    If (totalFramesIndex>0 || currIMGdetails.Frames>1)
    {
       thisFramesInfo := (totalFramesIndex>0) ? totalFramesIndex : currIMGdetails.Frames
       infoFrames := "`nMultiple pages: "  desiredFrameIndex " / " thisFramesInfo
    }

    zPlitPath(imgPath, 0, fileNamu, folderu, OutNameNoExt)
    If FileExist(imgPath)
    {
       FileGetSize, fileSizu, % ImgPath, K
       FileGetTime, FileDateM, % ImgPath, M
       FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
       fileMsg := "`n" groupDigits(fileSizu) " Kb | " FileDateM
    } Else If (currentFileIndex!=0)
       fileMsg := "`nFile not found or access denied..."

    fileRelatedInfos := (StrLen(folderu)>3) ? folderu "\`n[ " groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " ] " fileNamu fileMsg : ""
    If (vpIMGrotation>0)
       infoRotate := " @ " vpIMGrotation "°"

    infoSizing := "`nRescaling mode: " DefineImgSizing()
    If (IMGresizingMode!=5)
    {
       infoSizing .= (IMGresizingMode!=4) ? " | " Round(zoomLevel*100) "%" infoRotate : infoRotate
       If (showInfoBoxHUD=2)
          infoSizing .= "`nViewport alignment: " defineImgAlign()
    }

    infoRes := "`nResolution: " groupDigits(maxSelX) " x " groupDigits(maxSelY) " px | " Round((maxSelX*maxSelY)/1000000,2) " MPx"
    If (thisIMGisDownScaled=1 && AutoDownScaleIMGs=1)
       infoRes .= " | DOWNSCALED"
    If (currIMGdetails.TooLargeGDI=1)
       infoRes .= "`nOriginal resolution: " groupDigits(currIMGdetails.Width) " x " groupDigits(currIMGdetails.Height) " px | " Round((currIMGdetails.Width*currIMGdetails.Height)/1000000,2) " MPx"
    ; infoRes := "`nResolution (W x H): " thisW " x " thisH " px [ " Round(zoomLevel*100) "%" infoRotate " ]"

    If StrLen(UserMemBMP)>2
       infoEditing := "IMAGE EDITING MODE`n"
    If (StrLen(UserMemBMP)>2 && showInfoBoxHUD=2)
       infoEditing .= "Undo levels recorded: " currentUndoLevel " / " undoLevelsRecorded "`n"

    If (showInfoBoxHUD=1)
    {
       entireString := infoEditing fileRelatedInfos infoRes infoSizing infoFrames
       thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfntSize OSDbgrColor OSDtextColor
       If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
       {
          prevOSDfnt := thisOSDfnt
          infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
          infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, 1)
          prevMsg := entireString
       }
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxGdiCached)
       Return
    }

    mamUsage := GetProcessMemoryUsage(QPVpid)
    If (A_PtrSize=8)
       systemMemInfo := GlobalMemoryStatusEx()
    thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/1500063598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/systemMemInfo.TotalPhys)*100, 1)
    totalMemoryLoad := (A_PtrSize=8) ? "/ " Round(systemMemInfo.TotalPhys/1024**3, 1) " GB" : "/ 1.5 GB"
    memUsage := "`nMemory usage: " Round(max(mamUsage[1], mamUsage[8]) / 1024**2, 1) " MB " totalMemoryLoad " | " thisMemoryLoad "%"
    sliSpeed := Round(slideShowDelay/1000, 2) " sec."
    If (slideShowRunning=1)
       infoSlider := "`nSlideshow running: " DefineSlideShowType() " @ " sliSpeed

    infoMirroring := defineIMGmirroring()
    If (editingSelectionNow=1)
    {
       imgSelW := groupDigits(max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2))
       imgSelH := groupDigits(max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2))
       If (relativeImgSelCoords=1)
       {
          x1 := " [ " Round(prcSelX1 * 100) "%, "
          y1 := Round(prcSelY1 * 100) "% ]"
          wP := " [ " Round((prcSelX2 - prcSelX1) * 100) "%, "
          hP := Round((prcSelY2 - prcSelY1) * 100) "% ]"
          ; moreSelInfo := "`nCoordinates relative to image size"
       }
       friendlySelectionType := (EllipseSelectMode=1) ? "Ellipse" : "Rectangular"
       infoLocked := (lockSelectionAspectRatio>0) ? "`n  Locked aspect ratio: " defineSelectionAspectRatios() : "`n  Aspect ratio: " Round(imgSelW/imgSelH, 2)
       infoLocked .= (LimitSelectBoundsImg=1) ? "`n  Selection area limited to image boundaries" : ""
       infoSelection := "`n `n" friendlySelectionType " selection coordinates:`n  X / Y: " ImgSelX1 ", " ImgSelY1 x1 y1 "`n  W / H: " imgSelW ", " imgSelH wP hP moreSelInfo "`n  Rotation: " vPselRotation "°" infoLocked
    }
    If (SLDtypeLoaded=2)
       infoThisSLD := "`nFiles list opened:`n" PathCompact(CurrentSLD, 40)
    Else If (SLDtypeLoaded=3)
       infoThisSLD := "`nFiles list SQL database opened:`n" PathCompact(CurrentSLD, 40)

    If (usrColorDepth>1)
       infoColorDepth := "`nSimulated color depth: " defineColorDepth()

    If StrLen(usrFilesFilteru)>1
       infoFilteru := "`nFiles list filtered from " groupDigits(bckpMaxFilesIndex) " down to " groupDigits(maxFilesIndex) ".`nFilter pattern: " usrFilesFilteru

    totalZeit := A_TickCount - startZeitIMGload + 2
    InfoLoadTime := "`nViewport size: " groupDigits(mainWidth) " x " groupDigits(mainHeight) " px"
    If (totalZeit>=10 && directRefresh=1)
    {
       InfoLoadTime .= "`nViewport refresh speed: ~" totalZeit " milisec."
       If (currIMGdetails.HasAlpha=1)
          InfoLoadTime .= " (*)"
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " | " sndMediaPos hSNDmediaDuration
       }
       infoAudio := "`nAudio file associated: " OutFileName mediaDuration statusMedia
    }

    If (animGIFplaying=1)
       infoAnim := "`nGIF animation playing at " GIFspeedDelay " ms / frame."

    If (imgFxMode>1 || usrColorDepth>1)
       infoColors := "`nColors display mode: " DefineFXmodes()
    infoPixFmt := "`nImage format: " currIMGdetails.PixelFormat " | " currIMGdetails.RawFormat
    If (resultedFilesList[currentFileIndex, 5]=1)
       infoFaved := "`nImage in favourites list"

    entireString := infoEditing fileRelatedInfos infoFaved infoRes infoPixFmt memUsage infoSizing infoMirroring infoColors infoColorDepth infoFrames infoAnim InfoLoadTime infoThisSLD infoFilesSel infoAudio infoSlider infoFilteru infoSelection 
    thisOSDfnt := OSDFontName FlipImgH FlipImgV OSDfntSize OSDbgrColor OSDtextColor
    If (prevMsg!=entireString || prevOSDfnt!=thisOSDfnt)
    {
       prevOSDfnt := thisOSDfnt 
       infoBoxGdiCached := trGdip_DisposeImage(infoBoxGdiCached, 1)
       infoBoxGdiCached := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 1, 1)
       prevMsg := entireString
    }

    If infoBoxGdiCached
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxGdiCached)
    entireString := ""
}

drawAnnotationBox(mainWidth, mainHeight) {
    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    imgPath := getIDimage(currentFileIndex)

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       zPlitPath(thisSNDfile, 0, OutFileName, null)
       If hSNDmedia
          statusMedia := " - " MCI_Status(hSNDmedia)

       If hSNDmediaDuration
       {
          If hSNDmedia
          {
             sndMediaPos := MCI_Position(hSNDmedia)
             sndMediaPos := (sndMediaPos>3500) ? MCI_ToHHMMSS(sndMediaPos) " / " : ""
             If (sndMediaPos=hSNDmediaDuration)
                sndMediaPos := ""
          }
          mediaDuration := " (" sndMediaPos hSNDmediaDuration  ")"
       }
       If mediaDuration
          infoAudio := "Audio file associated" mediaDuration statusMedia "`n"
    } ; Else If (autoPlaySNDs=1)
      ;  infoAudio := "No audio file associated.`n"


    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    textFile := OutDir "\" OutNameNoExt ".txt"

    If (SLDtypeLoaded=3)
       textFileContent := retrieveSQLdbEntryCaption(imgPath, "imgCaption")

    If !textFileContent
    {
       Try FileRead, textFileContent, % textFile
       If StrLen(textFileContent)<1
          textFileContent := ""
    }

    entireString := infoAudio textFileContent
    If !entireString
       Return

    infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.1, mainWidth, mainHeight, OSDtextColor, OSDbgrColor, 0, 1, usrTextAlign)
    Gdip_GetImageDimensions(infoBoxBMP, imgW, imgH)
    thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
    thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
    If (usrTextAlign="Left")
       thisPosX := 0
    Else If (usrTextAlign="Center")
       thisPosX := (scrollBarVx>0) ? scrollBarVx//2 - imgW//2 : mainWidth//2 - imgW//2

    If infoBoxBMP
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, thisPosX, thisPosY)
    infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
}

clampInRange(value, min, max, reverse:=0) {
   If (reverse=1)
   {
      If (value>max)
         value := min
      Else If (value<min)
         value := max
   } Else
   {
      If (value>max)
         value := max
      Else If (value<min)
         value := min
   }

   Return value
}

clampValue(value, min, max) {
   If (value>max && max!="-")
      value := max
   Else If (value<min && min!="-")
      value := min

   Return value
}

changeOSDfontSize(direction) {
  stepu := (OSDfntSize>30) ? 5 : 2
  If (direction=1)
     OSDfntSize += stepu
  Else
     OSDfntSize -= stepu

  OSDfntSize := clampInRange(OSDfntSize, 15, 350)
  INIaction(1, "OSDfntSize", "General")
  showTOOLtip("OSD font size: " OSDfntSize, 0, 0, OSDfntSize/350)
  SetTimer, RemoveTooltip, % -msgDisplayTime
  calcHUDsize()
  recalculateThumbsSizes()
  If (thumbnailsListMode=1 && thumbsDisplaying=1)
  {
     ForceRefreshNowThumbsList()
     dummyTimerDelayiedImageDisplay(25)
  } Else If (thumbsDisplaying=1)
     SetTimer, mainGdipWinThumbsGrid, -25
  Else If (CurrentSLD && maxFilesIndex>0)
     SetTimer, dummyRefreshImgSelectionWindow, -25
}

determineGDIsmallCacheSize() {
  Resized := []
  Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
  Size := ((imgW//10)*(imgH//10)>98765) ? 10 : 6
  If ((imgW//10)*(imgH//10)>234567)
     Size := 15
  If ((imgW//10)*(imgH//10)>345678)
     Size := 20
  If ((imgW//10)*(imgH//10)>678901)
     Size := 25
  If ((imgW//10)*(imgH//10)>1597654)
     Size := 30
  If ((imgW//10)*(imgH//10)<44765)
     Size := 3

  If (minimizeMemUsage=1)
     Size := Size*2

  Resized.W := Round(imgW//Size) + 2
  Resized.H := Round(imgH//Size) + 2
  Resized.T := Resized.W//2 + Resized.H//2
  Resized.imgW := imgW
  Resized.imgH := imgH
  Resized.TGDI := imgW//2 + imgH//2
  Return Resized
}

RescaleBMPtiny() {
  Critical, on
  Static prevImgPath
  If (Strlen(gdiBitmapSmall)>3 && prevImgPath=gdiBitmapIDentire)
     Return gdiBitmapSmall

  gdiBitmapSmall := trGdip_DisposeImage(gdiBitmapSmall, 1)
  Resized := determineGDIsmallCacheSize()
  If StrLen(gdiBMPvPsize)>3 
  {
     Gdip_GetImageDimensions(gdiBMPvPsize, otherW, otherH)
     otherTotalIMGres := otherW//2 + otherH//2
  }

  thisImgQuality := (userimgQuality=1) ? 3 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  whichBitmap := (StrLen(gdiBMPvPsize)>3 && otherTotalIMGres>Resized.T*1.1) ? gdiBMPvPsize : gdiBitmap
  changeMcursor()
  gdiBitmapSmall := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, Resized.W, Resized.H, 0, thisImgQuality, -1)
  ; gdiBitmapSmall := Gdi_ResizeBitmap(whichBitmap, Resized.W, Resized.H, 0, 4)

  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBitmapSmall)>3
     Return gdiBitmapSmall
}

RescaleBMPtinyVPsize(GuiW, GuiH) {
  Critical, on

  Static prevImgPath
  If (StrLen(gdiBMPvPsize)>3 && prevImgPath=gdiBitmapIDentire)
     Return gdiBMPvPsize

  gdiBMPvPsize := trGdip_DisposeImage(gdiBMPvPsize, 1)
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  If (minimizeMemUsage=1)
     thisImgQuality := ""

  changeMcursor()
  initQPVmainDLL()
  gdiBMPvPsize := trGdip_ResizeBitmap(A_ThisFunc, gdiBitmap, Floor(GuiW*1.2), Floor(GuiH*1.2), 0, thisImgQuality, -1)
  prevImgPath := gdiBitmapIDentire
  If StrLen(gdiBMPvPsize)>3
     Return gdiBMPvPsize
}

setGIFframesDelay() {
   GIFspeedDelay := (totalFramesIndex>75) ? 35 : 45
   If (totalFramesIndex>195)
      GIFspeedDelay := 20
   Else If (totalFramesIndex<15)
      GIFspeedDelay := 60

   If (totalFramesIndex<8)
      GIFspeedDelay := 85
}

multiPageFileManaging(oBitmap) {
   rawFmt := Gdip_GetImageRawFormat(oBitmap)
   totalFramesIndex := Gdip_GetBitmapFramesCount(oBitmap) - 1
   If (totalFramesIndex<0)
      totalFramesIndex := 0

   If (desiredFrameIndex>=totalFramesIndex)
      desiredFrameIndex := totalFramesIndex

   setGIFframesDelay()
   If (totalFramesIndex>0 && slideShowRunning=1 && SlideHowMode=1 && animGIFsSupport!=1)
      Random, desiredFrameIndex, 0, % totalFramesIndex

   If RegExMatch(rawFmt, "i)(gif|tiff)$")
      Gdip_BitmapSelectActiveFrame(oBitmap, desiredFrameIndex)
}

LoadFileWithWIA(imgPath, fastMode) {
   oBitmap := 0
   setWindowTitle("Loading file through WIA: " imgPath)
   Try wiaImg := WIA_LoadImage(imgPath)
   If IsObject(wiaImg)
   {
      mainLoadedIMGdetails.File := imgPath
      mainLoadedIMGdetails.Width := wiaImg.Width
      mainLoadedIMGdetails.Height := wiaImg.Height
      mainLoadedIMGdetails.Frames := wiaImg.FrameCount
      mainLoadedIMGdetails.HasAlpha := wiaImg.IsAlphaPixelFormat
      If (wiaImg.IsAlphaPixelFormat=1)
         extraPixelFormat := "A"
      If (wiaImg.IsIndexedPixelFormat)
         extraPixelFormat .= " [INDEXED-" wiaImg.IsIndexedPixelFormat "]"
      If (wiaImg.IsExtendedPixelFormat)
         extraPixelFormat .= " [EXTENDED-" wiaImg.IsExtendedPixelFormat "]"
      mainLoadedIMGdetails.PixelFormat := wiaImg.PixelDepth "-bit RGB" extraPixelFormat
      mainLoadedIMGdetails.RawFormat := WIA_GetImageFormatID(wiaImg)
      mainLoadedIMGdetails.OpenedWith := "Windows Image Acquisition (WIA)"
      mainLoadedIMGdetails.TooLargeGDI := 0
   } Else
   {
      addJournalEntry("Failed to load image file using WIA...`n" imgPath)
      Return
   }

   capMaxGDIbmpSize32bits()
   If (wiaImg.width*wiaImg.height>maxGDIbmpSize) && (IsObject(wiaImg) && fastMode!=1)
   {
      setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits...")
      changeMcursor()
      Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1)
      If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
         Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
   }

   If (wiaImg.width>32500 || wiaImg.height>32500) && (IsObject(wiaImg) && fastMode!=1)
   {
      setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits...")
      changeMcursor()
      Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, 32500, 32500, 1)
      If (!IsObject(ScaledWiaIMG) && A_PtrSize=4)
         Try ScaledWiaIMG := WIA_ScaleImage(wiaImg, Round(Sqrt(maxGDIbmpSize//2)), Round(Sqrt(maxGDIbmpSize//2)), 1)
   }

   If IsObject(ScaledWiaIMG)
      mainLoadedIMGdetails.TooLargeGDI := 1

   If IsObject(wiaImg)
      Try PicObj := ScaledWiaIMG.Height ? WIA_GetImageBitmap(ScaledWiaIMG) : WIA_GetImageBitmap(wiaImg)

   If (PicObj.Handle)
   {
      setWindowTitle("Converting WIA image format to GDI+ bitmap...")
      changeMcursor()
      If wiaImg.IsAlphaPixelFormat
         oBitmap := trGdip_CreateARGBBitmapFromHBITMAP(PicObj.Handle)
      Else
         oBitmap := trGdip_CreateBitmapFromHBITMAP(PicObj.Handle)
      Gdi_DeleteObject(PicObj.Handle)
   }

   wiaImg := ""
   PicObj := ""
   Return oBitmap
}

LoadBitmapFromFileu(imgPath, noBPPconv:=0, forceGDIp:=0, allowCaching:=0, allowMemBMP:=0) {
  Static prevMD5nameA, prevMD5nameB

  GDIbmpFileConnected := 1
  totalFramesIndex := 0
  coreIMGzeitLoad := A_TickCount
  If (allowMemBMP=1 && StrLen(UserMemBMP)>2)
  {
     currIMGdetails.PixelFormat := Gdip_GetImagePixelFormat(UserMemBMP, 2)
     If (currIMGdetails.HasAlpha!=1)
        currIMGdetails.PixelFormat := StrReplace(currIMGdetails.PixelFormat, "A")

     currIMGdetails.RawFormat := Gdip_GetImageRawFormat(UserMemBMP)
     ; currIMGdetails.HasAlpha := InStr(currIMGdetails.PixelFormat, "argb") ? 1 : 0
     currIMGdetails.Frames := 1
     prevMD5nameA := prevMD5nameB := ""
     ; If (minimizeMemUsage=1)
        destroyGDIfileCache()
     Return trGdip_CloneBitmap(A_ThisFunc, UserMemBMP)
  }

  If (allowCaching=1)
  {
     MD5name := generateThumbName(imgPath, 1)
     thisMD5name := MD5name imgPath userHQraw alwaysOpenwithFIM cmrRAWtoneMapAlgo cmrRAWtoneMapParamA cmrRAWtoneMapParamB
     If (thisMD5name=prevMD5nameA && StrLen(GDIcacheSRCfileA)>2 && StrLen(prevMD5nameA)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileA "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileA)
        currIMGdetails := AbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileA)
     } Else If (thisMD5name=prevMD5nameB && StrLen(GDIcacheSRCfileB)>2 && StrLen(prevMD5nameB)>2)
     {
        addJournalEntry("Used unprocessed cached GDI bitmap ID: " GDIcacheSRCfileB "`n" imgPath)
        multiPageFileManaging(GDIcacheSRCfileB)
        currIMGdetails := BbackupIMGdetails.Clone()
        Return trGdip_CloneBitmap(A_ThisFunc, GDIcacheSRCfileB)
     }
  }

  If RegExMatch(imgPath, RegExFIMformPtrn) || (alwaysOpenwithFIM=1 && forceGDIp=0)
  {
     oBitmap := LoadFimFile(imgPath, noBPPconv)
     If (thumbsDisplaying!=1)
        addJournalEntry("Image loaded with FreeImage:`n" imgPath)
     GDIbmpFileConnected := 0
  } Else
  {
     changeMcursor()
     oBitmap := trGdip_CreateBitmapFromFile(imgPath)
     capMaxGDIbmpSize32bits()
     If StrLen(oBitmap)>2
     {
        pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
        Gdip_GetImageDimensions(oBitmap, imgW, imgH)
        mainLoadedIMGdetails.File := imgPath
        mainLoadedIMGdetails.Width := imgW
        mainLoadedIMGdetails.Height := imgH
        mainLoadedIMGdetails.Frames := Gdip_GetBitmapFramesCount(oBitmap) - 1
        mainLoadedIMGdetails.HasAlpha := InStr(pixFmt, "argb") ? 1 : 0
        mainLoadedIMGdetails.PixelFormat := pixFmt
        mainLoadedIMGdetails.RawFormat := Gdip_GetImageRawFormat(oBitmap)
        mainLoadedIMGdetails.OpenedWith := "GDI+"
        mainLoadedIMGdetails.TooLargeGDI := 0
        If (imgW<1) || (imgH<1) || InStr(pixFmt, "0x")
        {
           mustOpenWithWia := 1
        } Else If ((imgW*imgH>maxGDIbmpSize) || (imgW>32500) || (imgH>32500)) && (noBPPconv=0)
        {
           setWindowTitle("Rescaling image to GDI+ maximum image dimensions limits...")
           If (imgW*imgH>maxGDIbmpSize) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), 1, 3, -1)
           Else If (imgW>32500) || (imgH>32500) && (A_PtrSize!=4)
              nBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, 32500, 32500, 1, 3, -1)

           If StrLen(nBitmap)>3
           {
              mainLoadedIMGdetails.TooLargeGDI := 1
              oBitmap := trGdip_DisposeImage(oBitmap, 1)
              oBitmap := nBitmap
           } Else mustOpenWithWia := 1
        }
     } Else mustOpenWithWia := 1

     If (mustOpenWithWia=1 && noBPPconv=0) ; || (allowCaching=1)
     {
        loadedWith := 2
        oBitmap := trGdip_DisposeImage(oBitmap, 1)
        oBitmap := LoadFileWithWIA(imgPath, noBPPconv)
        GDIbmpFileConnected := 0
     }

     If StrLen(oBitmap)<4 ; || InStr(pixFmt, "0x"))
     {
        loadedWith := 3
        GDIbmpFileConnected := 0
        oBitmap := LoadFimFile(imgPath, noBPPconv)
     } Else If (allowMemBMP=1 && !InStr(pixFmt, "0x"))
        multiPageFileManaging(oBitmap)

     If (thumbsDisplaying!=1)
     {
        If (loadedWith=2)
           addJournalEntry("Image loaded with WIA:`n" imgPath)
        Else If (loadedWith=3)
           addJournalEntry("Image loaded with FreeImage:`n" imgPath)
        Else
           addJournalEntry("Image loaded with GDI+:`n" imgPath)
     }
  }

  If (allowCaching=1 && StrLen(oBitmap)>2)
  {
     userSeenSessionImagesArray["z" StringToASC(imgPath)] := imgPath
     prevMD5nameB := prevMD5nameA
     prevMD5nameA := thisMD5name
     idGDIcacheSRCfileB := idGDIcacheSRCfileA
     idGDIcacheSRCfileA := GDIbmpFileConnected MD5name imgPath
     GDIcacheSRCfileB := trGdip_DisposeImage(GDIcacheSRCfileB, 1)
     GDIcacheSRCfileB := GDIcacheSRCfileA
     GDIcacheSRCfileA := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
     BbackupIMGdetails := AbackupIMGdetails.Clone()
     AbackupIMGdetails := mainLoadedIMGdetails.Clone()
  }

  If (allowMemBMP=1)
     currIMGdetails := mainLoadedIMGdetails.Clone()
  Return oBitmap
}

RotateBMP2exifOrientation(oBitmap) {
   exifOrientation := Gdip_GetPropertyItem(oBitmap, 0x112)
   orientation := exifOrientation.Value
   ; MsgBox, % orientation
   If (orientation=6)
      Gdip_ImageRotateFlip(oBitmap, 1)
   Else If (orientation=8)
      Gdip_ImageRotateFlip(oBitmap, 3)
   Else If (orientation=3)
      Gdip_ImageRotateFlip(oBitmap, 2)
   Else If (orientation=2)
      Gdip_ImageRotateFlip(oBitmap, 4)
   Else If (orientation=5)
      Gdip_ImageRotateFlip(oBitmap, 5)
   Else If (orientation=4)
      Gdip_ImageRotateFlip(oBitmap, 6)
   Else If (orientation=7)
      Gdip_ImageRotateFlip(oBitmap, 7)
}

capMaxGDIbmpSize32bits() {
  If (A_PtrSize=4)
  {
     mamUsage := GetProcessMemoryUsage(QPVpid)
     If !mamUsage[1]
        Return

     maxGDIbmpSize := ((2115473648 - mamUsage[1] - mamUsage[8]//2)//4)//1.9
     If (maxGDIbmpSize<10101)
        maxGDIbmpSize := 10101
  }
}

Gdip_CloneBmpPargbArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:=0, KeepPixelFormat:=0, ignoreBounds:=0) {
   thisPixFmt := !PixelFormat ? coreDesiredPixFmt : PixelFormat
   If (ignoreBounds=1 && w>0 && h>0)
   {
       newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, w, h, thisPixFmt)
       If StrLen(newBitmap)>2
       {
          G2 := trGdip_GraphicsFromImage(A_ThisFunc "() initially invoked by " funcu, newBitmap, 3)
          If G2
             r1 := trGdip_DrawImage(A_ThisFunc "() initially invoked by " funcu, G2, pBitmap, 0, 0, w, h, x, y, w, h)

          Gdip_DeleteGraphics(G2)
          If (r1="fail" || !G2)
          {
             trGdip_DisposeImage(newBitmap, 1)
             newBitmap := ""
          }
       }
   } Else
     newBitmap := trGdip_CloneBitmapArea(A_ThisFunc "<-" funcu, pBitmap, x, y, w, h, thisPixFmt, KeepPixelFormat)

   If StrLen(newBitmap)<3
   {
      baseMsg := "Unable to create internal PARGB bitmap clone to apply operations on image... Error occured in " A_ThisFunc "() invoked by " funcu  "() for pBMP=" pBitmap ". "
      generalInternalErrorMsgBox(gdipLastError, baseMsg)
      newBitmap := ""
   }

   Return newBitmap
}

generalInternalErrorMsgBox(err, baseMsg, silentMode:=0) {
   Static forceSilent := 0

   If err
      message := "`n`n" Gdip_ErrorHandler(err, 0)

   friendly := (A_PtrSize=4) ? "`n`nPossible cause: memory limit reached." : ""
   friendly .= (A_PtrSize=4 && A_is64BitOS) ? " Please use the 64-bits edition of this application." : ""
   If (InStr(message, "out_of_memory") && maxMemUndoLevels>12012)
      maxMemUndoLevels -= 100000

   addJournalEntry(baseMsg message friendly)
   If (runningLongOperation!=1 && hasInitSpecialMode!=1 && silentMode!=1 && forceSilent!=1)
   {
      If (imgEditPanelOpened=1)
         TextInAreaLivePreview := FillAreaLivePreview := PasteInPlaceLivePreview := 0
      ; SoundBeep, 300, 100
      simpleMsgBoxWrapper(appTitle ": ERROR", baseMsg message friendly, 0, 0, "error")
      If (InStr(baseMsg, glPG) || InStr(baseMsg, 2NDglPG))
      {
         info := (debugModa=1) ? "" : "You can start QPV with /qpv-debug to view all error messages in a debug viewer."
         msgResult := msgBoxWrapper(appTitle, "It seems you are receving errors related to core viewport components. Would you like to no longer receive GDI+ error messages ?`n`nAnyhow, the application will likely continue to malfunction, but at least in silence..", 4, 0, "question")
         If (msgResult="yes")
            forceSilent := 1
      }
   }
}

CloneMainBMP(imgPath, ByRef imgW, ByRef imgH, mustReloadIMG, ByRef hasFullReloaded) {
  Critical, on
  Static AprevImgDownScaled := 0, BprevImgDownScaled := 0, lastInvoked := 1

  totalFramesIndex := 0
  GDIbmpFileConnected := 1
  hasFullReloaded := CountGIFframes := 0
  MD5name := generateThumbName(imgPath, 1)
  o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
  o_AutoDownScaleIMGs := (AutoDownScaleIMGs>0) ? 1 : 0
  thisImgCall := MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation RenderOpaqueIMG
  If !FileRexists(imgPath) && (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath))
     thisImgCall := InStr(AprevImgCall, imgPath) ? SubStr(AprevImgCall, 2) : SubStr(BprevImgCall, 2)

  gdiBitmap := trGdip_DisposeImage(gdiBitmap, 1)
  file2load := thumbsCacheFolder "\big-" alwaysOpenwithFIM userHQraw MD5name ".png"
  ignoreCache := (RegExMatch(imgPath, "i)(.\.gif)$") && animGIFsSupport=1) || (minimizeMemUsage=1) || StrLen(UserMemBMP)>2 ? 1 : mustReloadIMG
  ; MsgBox, % imgPath "`n" AbackupIMGdetails.File "`n" BbackupIMGdetails.File "`n" CbackupIMGdetails.File
  If (SubStr(AprevImgCall, 2)=thisImgCall && StrLen(AprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := AprevImgDownScaled
     Gdip_GetImageDimensions(AprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, AprevGdiBitmap)
     addJournalEntry("Used cached GDI bitmap ID: " AprevGdiBitmap "`n" imgPath)
     gdiBitmapIDcall := AprevImgCall
     gdiBitmapIDentire := AprevImgCall gdiBitmap
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     Return 
  } Else If (SubStr(BprevImgCall, 2)=thisImgCall && StrLen(BprevGdiBitmap)>2 && ignoreCache=0)
  {
     UserMemBMP := trGdip_DisposeImage(UserMemBMP, 1)
     thisIMGisDownScaled := BprevImgDownScaled
     Gdip_GetImageDimensions(BprevGdiBitmap, imgW, imgH)
     gdiBitmap := trGdip_CloneBitmap(A_ThisFunc, BprevGdiBitmap)
     gdiBitmapIDcall := BprevImgCall
     gdiBitmapIDentire := BprevImgCall gdiBitmap
     addJournalEntry("Used cached GDI bitmap ID: " BprevGdiBitmap "`n" imgPath)
     If (imgPath=AbackupIMGdetails.File)
        currIMGdetails := AbackupIMGdetails.Clone()
     Else If (imgPath=BbackupIMGdetails.File)
        currIMGdetails := BbackupIMGdetails.Clone()
     extractAmbientalTexture()
     Return
  }

  If (slideShowRunning!=1 && desiredFrameIndex<1) && (A_TickCount - lastInvoked>250)
     GdipCleanMain(6)

  interfaceThread.ahkassign("canCancelImageLoad", 1)
  changeMcursor()
  preventDownScaling := (IMGresizingMode=3) || (StrLen(UserMemBMP)>2) || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  thisImgPath := (preventDownScaling!=1 && FileExist(file2load) && AutoDownScaleIMGs=1) ? file2load : imgPath
  thisIMGisDownScaled := (thisImgPath!=imgPath && AutoDownScaleIMGs=1) ? 1 : 0
  allowCaching := !minimizeMemUsage
  If StrLen(UserMemBMP)>2
     thisIMGisDownScaled := allowCaching := 0

  oBitmap := LoadBitmapFromFileu(thisImgPath, 0, 0, allowCaching, 1)
  ; MsgBox, % obitmap
  If !oBitmap
     Return "error"

  lastInvoked := A_TickCount
  slowFileLoad := (A_TickCount - coreIMGzeitLoad > 450) ? 1 : 0
  hasFullReloaded := 1

  rawFmt := Gdip_GetImageRawFormat(oBitmap)
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (RegExMatch(rawFmt, "i)(bmp|png|tiff)$") && currIMGdetails.HasAlpha=1 && StrLen(UserMemBMP)<3)
  {
     ERR := Gdip_GetHistogram(oBitmap, 7, histoArray, 0, 0)
     If !ERR
     {
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 0, 254))
               HasAlpha := 1
        }

        currIMGdetails.HasAlpha := HasAlpha
     }
     ; ToolTip, % ERR " = " HasAlpha " = " rawFmt , , , 2
  }

  If (RegExMatch(rawFmt, "i)(gif|tiff)$") && totalFramesIndex>0)
     multiFrameImg := 1
  Else If (rawFmt="JPEG")
     RotateBMP2exifOrientation(oBitmap)

  If (rawFmt="gif" && totalFramesIndex>0)
  {
     gifLoaded := 1
     CountGIFframes := (animGIFsSupport=1) ? totalFramesIndex : 0
  }

  If (rawFmt="MEMORYBMP")
     GDIbmpFileConnected := 0

  If (AnyWindowOpen=17 && performAutoCropNow=1 && usrAutoCropGenerateSelection=0)
  {
     GDIbmpFileConnected := 0
     hasAutoCropped := 1
     setWindowTitle("Auto-cropping image...")
     xBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap)
     kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
     FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
     trGdip_DisposeImage(xBitmap, 1)
     If StrLen(kBitmap)>3
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        oBitmap := kBitmap
     }
  }

  Gdip_GetImageDimensions(oBitmap, imgW, imgH)
  totalIMGres := imgW + imgH
  totalScreenRes := ResolutionWidth + ResolutionHeight
  thisImgQuality := (userimgQuality=1) ? 7 : 5
  preventDownScaling := (multiFrameImg=1) || (IMGresizingMode=3) || StrLen(UserMemBMP)>2 || (currentFileIndex=0) || (IMGresizingMode=4 && zoomLevel>1.5) ? 1 : 0
  If (hasAutoCropped!=1 && preventDownScaling!=1 && !FileExist(file2load) && AutoDownScaleIMGs=1 && totalIMGres/totalScreenRes>1.3)
  {
     setWindowTitle("Downscaling large image to viewport...")
     thisImgQuality := (userimgQuality=1) ? "" : 5
     roImgW := imgW, roImgH := imgH
     calcIMGdimensions(imgW, imgH, ResolutionWidth, ResolutionHeight, newW, newH)
     imgW := newW, imgH := newH
     totalIMGres := newW + newH
     slowFileLoad := 0
     thisIMGisDownScaled := 1
     mustSaveFile := (multiFrameImg!=1 && enableThumbsCaching=1) ? 1 : 0
  } ; Else thisIMGisDownScaled := 0
  If (minimizeMemUsage=1 && rawFmt!="MEMORYBMP")
     thisImgQuality := ""

  If !newW
     newW := imgW
  If !newH
     newH := imgH

  BprevImgDownScaled := AprevImgDownScaled
  AprevImgDownScaled := thisIMGisDownScaled
  If (currIMGdetails.HasAlpha!=1 || gifLoaded=1)
     brushRequired := 1

  changeMcursor()
  If (thisIMGisDownScaled=1 || animGIFplaying=1 || gifLoaded=1 || minimizeMemUsage!=1 && rawFmt!="MEMORYBMP")
  {
     rBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, newW, newH, 0, thisImgQuality, -1)
     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
        If (mustSaveFile=1 && thisIMGisDownScaled=1)
           z := Gdip_SaveBitmapToFile(rBitmap, file2load, 90)
     } Else rBitmap := oBitmap
  } Else
  {
     If (currIMGdetails.HasAlpha=1)
        rBitmap := cloneGDItoMem(A_ThisFunc, oBitmap)
     If rBitmap
     {
        GDIbmpFileConnected := 0
        trGdip_DisposeImage(oBitmap, 1)
     } Else rBitmap := oBitmap
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && currIMGdetails.HasAlpha=1 && RenderOpaqueIMG=1 && gifLoaded!=1)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Removing alpha-channel")
     changeMcursor()
     nBitmap := trGdip_RenderPixelsOpaque(rBitmap, pBrushWinBGR)
     If StrLen(nBitmap)>2
     {
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     }
     brushRequired := 1
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && vpIMGrotation>0)
  {
     setWindowTitle("Rotating image at " vpIMGrotation "°...")
     brushu := (brushRequired=1) ? pBrushWinBGR : ""
     ; nBitmap := simpleFreeImgRotate(rBitmap, vpIMGrotation)
     changeMcursor()
     nBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, rBitmap, vpIMGrotation, brushu, imgQuality, -1)
     If StrLen(nBitmap)>3
     {
        Gdip_GetImageDimensions(nBitmap, imgW, imgH)
        newW := imgW, newH := imgH
        trGdip_DisposeImage(rBitmap, 1)
        rBitmap := nBitmap
     } Else vpIMGrotation := 0
  }

  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  If (abortImgLoad<3 && bwDithering=1 && imgFxMode=4)
  {
     GDIbmpFileConnected := 0
     setWindowTitle("Converting image to black and white with dithering...")
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)

     zBitmap := trGdip_BitmapConvertGray(rBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
     trGdip_DisposeImage(rBitmap, 1)
     rBitmap := zBitmap
     E := Gdip_BitmapSetColorDepth(rBitmap, "BW", 1)
  } Else If (usrColorDepth>1)
  {
     infoColorDepth := defineColorDepth()
     setWindowTitle("Converting image to " infoColorDepth)
     If (currIMGdetails.HasAlpha=1)
        E := Gdip_BitmapSetColorDepth(rBitmap, 24, 1)
     E := Gdip_BitmapSetColorDepth(rBitmap, internalColorDepth, ColorDepthDithering)
  }

  BprevImgCall := AprevImgCall
  AprevImgCall := GDIbmpFileConnected MD5name imgPath o_bwDithering ColorDepthDithering o_AutoDownScaleIMGs vpIMGrotation RenderOpaqueIMG
  gdiBitmapIDcall := AprevImgCall
  gdiBitmapIDentire := AprevImgCall rBitmap
  gdiBitmap := rBitmap
  abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
  extractAmbientalTexture(abortImgLoad)
  BprevGdiBitmap := trGdip_DisposeImage(BprevGdiBitmap, 1)
  If (allowCaching=1)
  {
     BprevGdiBitmap := AprevGdiBitmap
     AprevGdiBitmap := trGdip_CloneBitmap(A_ThisFunc, gdiBitmap)
  }
  imgW := newW, imgH := newH
}

extractAmbientalTexture(abortImgLoad:=0) {
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (abortImgLoad<3 && usrTextureBGR=1 && IMGresizingMode!=5 && confirmTexBGR=1)
    {
       setWindowTitle("Extracting image texture for the window background")
       decideGDIPimageFX(matrix, imageAttribs, pEffect)
       AmbientalTexBrush := Gdip_CreateTextureBrush(useGdiBitmap(), 3, 3, 3, 150, 150, matrix, 0, 0, 0, imageAttribs)
       If imageAttribs
          Gdip_DisposeImageAttributes(imageAttribs)
       If pEffect
          Gdip_DisposeEffect(pEffect)
    }

    preventScreenOff()
    OnImgFileChangeActions(0)
    If (autoPlaySNDs=1)
    {
       AutoPlayAudioFileAssociated()
       identifyAudioMediaLength()
    }
}

OnImgFileChangeActions(forceThis) {
  Static prevImgPath := ""
  imgPath := currentFileIndex "=" getIDimage(currentFileIndex)
  If (imgPath=prevImgPath && forceThis=0)
  {
     Return
  } Else
  {
     SetTimer, RemoveTooltip, -200
     If (LimitSelectBoundsImg!=1 && editingSelectionNow=1)
        correctActiveSelectionAreaViewPort()
     GIFframesPlayied := 0
     allowNextSlide := 1
     If (A_TickCount - lastGIFdestroy > 950)
        prevAnimGIFwas := ""
     If (AutoDownScaleIMGs=2)
        AutoDownScaleIMGs := 1
     If (hSNDmedia && autoPlaySNDs!=1)
        StopMediaPlaying()
     If (slideShowRunning=1) ;  && (animGIFplaying!=1 || totalFramesIndex<2))
        invokeExternalSlideshowHandler()
  }

  prevImgPath := imgPath
}

invokeExternalSlideshowHandler() {
   allowNextSlide := 1
   interfaceThread.ahkassign("animGIFplaying", animGIFplaying)
   interfaceThread.ahkassign("allowNextSlide", allowNextSlide)
   interfaceThread.ahkPostFunction("dummySlideshow")
}

identifyAudioMediaLength() {
   If hSNDmedia
   {
      milisec := MCI_Length(hSNDmedia)
      hSNDmediaDuration := MCI_ToHHMMSS(milisec)
      If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
   } Else If (syncSlideShow2Audios=1 && slideShowRunning=1)
         resetSlideshowTimer(0, 1)
}

IdentifyAudioFileAssociated() {
    imgPath := getIDimage(currentFileIndex)
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
    If (SLDtypeLoaded=3)
    {
       AudioFileu := retrieveSQLdbEntryCaption(imgPath, "imgAudio")
       If StrLen(AudioFileu)>3 && FileExist(AudioFileu)
          Return AudioFileu
    }

    audioFile1 := OutDir "\" OutNameNoExt ".WAv"
    audioFile2 := OutDir "\" OutNameNoExt ".WMA"
    audioFile3 := OutDir "\" OutNameNoExt ".MP3"

    If FileRexists(audioFile1)
       thisSNDfile := audioFile1
    Else If FileRexists(audioFile2)
       thisSNDfile := audioFile2
    Else If FileRexists(audioFile3)
       thisSNDfile := audioFile3
    Else
       thisSNDfile := 0
    Return thisSNDfile
}

PlayAudioFileAssociatedNow() {
    If (thumbsDisplaying=1)
       Return

    ohSNDmediaFile := hSNDmediaFile
    ohSNDmedia := hSNDmedia
    StopMediaPlaying()
    If (ohSNDmediaFile && ohSNDmedia)
    {
       zPlitPath(ohSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("Media file stopped: `n" OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       dummyTimerDelayiedImageDisplay(50)
       Return
    }

    thisSNDfile := IdentifyAudioFileAssociated()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       identifyAudioMediaLength()
       zPlitPath(hSNDmediaFile, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       thisMsg := (E || !hSNDmedia) ? "ERROR: " E " - " hSNDmedia ". Unable to play media file: `n" : "Media file now playing: `n(" hSNDmediaDuration ") " 
       showTOOLtip(thisMsg OutFileName "`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime

       If (E || !hSNDmedia)
          StopMediaPlaying()
       dummyTimerDelayiedImageDisplay(50)
    } Else
    {
       imgPath := getIDimage(currentFileIndex)
       zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
       showTOOLtip("WARNING: No media file found to play...`n" OutNameNoExt " (.WAV / .WMA / .MP3)`n" OutDir "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
    }
}

AutoPlayAudioFileAssociated() {
    Static prevAudioFile
    thisSNDfile := IdentifyAudioFileAssociated()
    If (thisSNDfile=prevAudioFile && StrLen(thisSNDfile)>3)
       Return

    StopMediaPlaying()
    If thisSNDfile
    {
       hSNDmediaFile := thisSNDfile
       hSNDmedia := MCI_Open(hSNDmediaFile,,,0)
       E := MCI_Play(hSNDmedia)
       If (E || !hSNDmedia)
          StopMediaPlaying()
       Else
          prevAudioFile := hSNDmediaFile
    } Else prevAudioFile := ""
}

StopMediaPlaying() {
    If hSNDmedia
    {
       MCI_Stop(hSNDmedia)
       hSNDmediaDuration := hSNDmedia := hSNDmediaFile := ""
    }
}

createHistogramBMP(whichBitmap) {
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   mpxu := Round((imgW*imgH)/1000000,2)
   If (mpxu>7.5 && StrLen(whichBitmap)>2)
      whichBMP := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, 520, 520, 1, 3, -1)
   Else
      whichBMP := whichBitmap

   If StrLen(whichBMP)<3
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram - no bitmap given...")
      Return
   }

   If (showHistogram=2)
   {
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
   } Else If (showHistogram=3)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlArray, 0, 0)
   } Else If (showHistogram=4)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlArray, 0)
   } Else If (showHistogram=5)
   {
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlArray)
   } Else If (showHistogram=6)
   {
      setWindowTitle("Calculating histogram...")
      ERR := Gdip_GetHistogram(whichBmp, 3, brLvlArray, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, brLvlR, 0, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, brLvlG, 0)
      ERR := Gdip_GetHistogram(whichBmp, 2, 0, 0, brLvlB)
      brLvlFakeArray := []
      Loop, 257
      {
          thisIndex := A_Index - 1
          thisMax := max(brLvlR[thisIndex], brLvlG[thisIndex], brLvlB[thisIndex])
          brLvlFakeArray[thisIndex] := Round(thisMax/1.25)
          ; MsgBox, % thisMax
      }
   }

   If ERR
   {
      addJournalEntry(A_ThisFunc "(): failed to generate histogram... " Gdip_ErrorHandler(err, 0))
      Return
   }

   Gdip_GetImageDimensions(whichBMP, imgW, imgH)
   zr2ndMaxV := r2ndMaxV := 0
   minBrLvlV := TotalPixelz := imgW * imgH
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If (nrPixelz="")
          Continue

       stringArray .= nrPixelz "." (thisIndex+1) "`n"
       If (nrPixelz>0)
          stringArray2 .= (thisIndex+1) "." nrPixelz "`n"
       If (nrPixelz>1)
          stringArray3 .= (thisIndex+1) "." nrPixelz "`n"
       sumTotalBr += nrPixelz * (thisIndex+1)
       SimpleSumTotalBr += nrPixelz
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }
       If (nrPixelz<modePointV && nrPixelz>r2ndMaxV)
          r2ndMaxV := nrPixelz
       If (nrPixelz>zr2ndMaxV)
          zr2ndMaxV := nrPixelz

       If (nrPixelz<minBrLvlV && nrPixelz>2)
       {
          minBrLvlV := nrPixelz
          minBrLvlK := thisIndex
       }
   }

   Sort, stringArray, ND`n
   RstringArray := stringArray
   Sort, RstringArray, RND`n
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   avgBrLvlK := Round(sumTotalBr/TotalPixelz - 1, 1)
   thisVal := minu := maxu := 0
   Loop, 256
   {
      thisVal := brLvlArray[Round(avgBrLvlK) - A_Index]
      If (thisVal>0 && !minu)
      {
         minu := thisVal
         Break
      }
   }

   Loop, 256
   {
      thisVal := brLvlArray[A_Index + Round(avgBrLvlK)]
      If (thisVal>0 && !maxu)
      {
         maxu := thisVal
         Break
      }
   }

   avgBrLvlV := (minu + maxu)//2 ;  brLvlArray[Round(avgBrLvlK)]
   modePointK2 := ST_ReadLine(stringArray, "L")
   modePointK2 := StrSplit(modePointK2, ".")
   modePointK3 := ST_ReadLine(RstringArray, 2)
   modePointK3 := StrSplit(modePointK3, ".")
   modePointK4 := ST_ReadLine(RstringArray, 3)
   modePointK4 := StrSplit(modePointK4, ".")
   modePointK5 := ST_ReadLine(RstringArray, 4)
   modePointK5 := StrSplit(modePointK5, ".")
   rangeA := ST_ReadLine(stringArray3, 1)
   rangeA := StrSplit(rangeA, ".")
   rangeB := ST_ReadLine(stringArray3, "L")
   rangeB := StrSplit(rangeB, ".")
   Loop, 256
   {
       minBrLvlK2 := ST_ReadLine(stringArray, A_Index)
       minBrLvlK2 := StrSplit(minBrLvlK2, ".")
       If (minBrLvlK2[1]=0)
          Continue
       If (minBrLvlK2[2]>0)
          Break
   }

   rangeC := rangeB[1] - rangeA[1] + 1
   meanValue := SimpleSumTotalBr/rangeC
   meanValuePrc := Round(meanValue/TotalPixelz * 100)
   meanValuePrc := (meanValuePrc>0) ? " (" meanValuePrc "%) " : ""
   2ndMaxVa := (r2ndMaxV + avgBrLvlV)//2 + minBrLvlV
   2ndMaxVb := (r2ndMaxV + meanValue)//2 + minBrLvlV
   Loop, 256
   {
       lookMean := ST_ReadLine(stringArray, A_Index)
       lookMean := StrSplit(lookMean, ".")
       thisMean := lookMean[1]
       If (thisMean>meanValue)
       {
          meanValueK := Round((prevMean + lookMean[2] - 1)/2, 1)
          Break
       } prevMean := lookMean[2]
   }

   meanValueK := !meanValueK ? "" : " | Mean: " meanValueK meanValuePrc
   Loop, 256
   {
       lookValue := ST_ReadLine(stringArray2, A_Index)
       lookValue := StrSplit(lookValue, ".")
       thisSum += lookValue[2]
       If (thisSum>TotalPixelz//2)
       {
          medianValue := lookValue[1] - 1
          Break
       }
   }

   modePointKm := ST_ReadLine(stringArray, 2)
   modePointKm := StrSplit(modePointKm, ".")
   ; f2ndMaxV := (2ndMaxVa + 2ndMaxVb)//2 + avgBrLvlV//2
   f2ndMaxV := (histogramMode=2) ? (avgBrLvlV + (modePointK3[1] + modePointK4[1] + modePointK5[1])//3)//2 : (r2ndMaxV + zr2ndMaxV)//2    ; + modePointKm[1]//2
   If (f2ndMaxV>r2ndMaxV && histogramMode=2)
      f2ndMaxV := (r2ndMaxV + f2ndMaxV)//2
   If (histogramMode=1)
      f2ndMaxV := (avgBrLvlV + minBrLvlK2[1])//2
   ; ToolTip, % avgBrLvlV "--" minBrLvlK2[1] "--" r2ndMaxV , , , 2
   peakPrc := Round(modePointK2[1]/TotalPixelz * 100)
   peakPrc := (peakPrc>0) ? " (" peakPrc "%)" : ""
   minPrc := Round(minBrLvlK2[1]/TotalPixelz * 100)
   minPrc := (minPrc>0) ? " (" minPrc "%)" : ""
   medianPrc := Round(lookValue[2]/TotalPixelz * 100)
   medianPrc := (medianPrc>0) ? " (" medianPrc "%)" : ""
   avgPrc := Round(avgBrLvlV/TotalPixelz * 100)
   avgPrc := (avgPrc>0) ? " (" avgPrc "%)" : ""
   Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
   TotalPixelzSpaced := groupDigits(imgW*imgH)

   infoRange := "(" defineHistogramMode() ") " defineHistogramType() " range: " rangeA[1] - 1 " - " rangeB[1] - 1 " (" rangeC ")"
   infoPeak := "`nMode: " modePointK2[2] - 1 peakPrc
   infoAvg := " | Avg: " avgBrLvlK avgPrc " | Min: " minBrLvlK2[2] - 1 minPrc
   infoMin := "`nMedian: " medianValue medianPrc meanValueK
   entireString := infoRange infoPeak infoAvg infoMin "`nTotal pixels: " TotalPixelzSpaced
   If (slideShowRunning=1)
      infoBoxBMP := trGdip_CreateBitmap(A_ThisFunc, 5, 5)
   Else
      infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.5, mainWidth//1.3, mainHeight//1.3, OSDtextColor, OSDbgrColor, 1, 0)
   ; tooltip, % "|" TotalPixelz "|" modePointV ", " 2ndMaxV ", " avgBrLvlV " || "  maxW "," maxH  ;  `n" PointsList
   Scale := (slideShowRunning=1) ? imgHUDbaseUnit/50 : imgHUDbaseUnit/40
   If (rangeC<2)
      f2ndMaxV := modePointK2[1] - 1
   If (f2ndMaxV<250)
      f2ndMaxV := 250

   thisData := (showHistogram=6) ? brLvlFakeArray : brLvlArray
   thisOpacity := (showHistogram=6) ? "0xCC" : "0xFF"
   If (showHistogram=3)
      thisGraphColor := "0xFFFF3300"
   Else If (showHistogram=4)
      thisGraphColor := "0xFF33FF33"
   Else If (showHistogram=5)
      thisGraphColor := "0xFF3366FF"
   Else
      thisGraphColor := thisOpacity OSDtextColor

   HistogramBMP := drawHistogram(thisData, f2ndMaxV, 256, Scale, thisGraphColor, "0xEE" OSDbgrColor, imgHUDbaseUnit//3, infoBoxBMP)
   trGdip_DisposeImage(infoBoxBMP, 1)
   If (whichBMP!=whichBitmap && StrLen(whichBMP)>2)
      trGdip_DisposeImage(whichBMP, 1)
}

groupDigits(nrIn, delim:=" ") {
   If StrLen(nrin)>3
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 2)
   If StrLen(nrin)>7
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 6)
   If StrLen(nrin)>11
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 10)
   If StrLen(nrin)>15
      nrIn := ST_Insert(delim, nrIn, StrLen(nrIn) - 14)
   Return nrIn
}

defineRelativeSelCoords(maxSelX, maxSelY) {
   prcSelX1 := imgSelX1/maxSelX
   prcSelY1 := imgSelY1/maxSelY
   prcSelX2 := imgSelX2/maxSelX
   prcSelY2 := imgSelY2/maxSelY
}

capSelectionRelativeCoords() {
   If (prcSelX1<0)
      prcSelX1 := 0
   Else If (prcSelX1>=1)
      prcSelX1 := 0.99

   If (prcSelY1<0)
      prcSelY1 := 0
   Else If (prcSelY1>=1)
      prcSelY1 := 0.99

   If (prcSelX2<0.001)
      prcSelX2 := 0.001
   Else If (prcSelX2>1)
      prcSelX2 := 1

   If (prcSelY2<0.001)
      prcSelY2 := 0.001
   Else If (prcSelY2>1)
      prcSelY2 := 1
}

calcRelativeSelCoords(whichBitmap, imgW:=0, imgH:=0) {
   If (imgSelX1=0 && imgSelY1=0 && imgSelX2=-1 && imgSelY2=-1)
      Return

   If (!imgW || !imgH)
      Gdip_GetImageDimensions(whichBitmap, imgW, imgH)

   imgSelX1 := Round(prcSelX1*imgW)
   imgSelY1 := Round(prcSelY1*imgH)
   imgSelX2 := Round(prcSelX2*imgW)
   imgSelY2 := Round(prcSelY2*imgH)
   nImgSelX1 := imgSelX1 := min(imgSelX1, imgSelX2)
   nImgSelY1 := imgSelY1 := min(imgSelY1, imgSelY2)
   nimgSelX2 := max(imgSelX1, imgSelX2)
   nimgSelY2 := max(imgSelY1, imgSelY2)

   kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   If (kimgSelW>32500)
      nImgSelX2 := nImgSelX1 + 32500
   If (kimgSelH>32500)
      nImgSelY2 := nImgSelY1 + 32500

   If (kimgSelH*kimgSelW>23125**2)
   {
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      scaleu := (kimgSelH*kimgSelW)/(23125**2)
      nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
      nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
      kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
      kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
      If (kimgSelW>32500)
         nImgSelX2 := nImgSelX1 + 32500
      If (kimgSelH>32500)
         nImgSelY2 := nImgSelY1 + 32500
   }

   ImgSelX2 := nImgSelX2
   ImgSelY2 := nImgSelY2
}

AdaptiveImgLight(whichImg, imgPath, Width, Height) {
   If isWinXP
   {
      addJournalEntry("Automatic colors adjustments is deactivated on " A_OSVersion)
      Return
   }

   startZeit := A_TickCount
   If (Width=1 && Height=1)
      Gdip_GetImageDimensions(whichImg, Width, Height)

   mustRem := 0
   If ((Width//10*Height//10)>18500)
   {
      ; calcIMGdimensions(Width, Height, 900, 900, newWidth, newHeight)
      rBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichImg, 900, 900, 1, 3, -1)
      If !rBitmap
         Return -1
      Else
         mustRem := 1

      whichImg := rBitmap
   }

   Gdip_GetImageDimensions(whichImg, Width, Height)
   xCrop := Width//11
   yCrop := Height//11
   wCrop := Width - xCrop*2 + 1
   hCrop := Height - yCrop*2 + 1

   cropBMP := Gdip_CloneBmpPargbArea(A_ThisFunc, whichImg, xCrop, yCrop, wCrop, hCrop)
   If !cropBMP
      Return -1

   brLvlArray := [], ArrChR := [], ArrChG := [], ArrChB := []
   rMinBrLvl := minBrLvl := 256
   modePointV := lumosAdjust := 1
   maxBrLvl := sumTotalBr := countTotalPixelz := thisBrLvl := 0
   GammosAdjust := countBrightPixelz := countMidPixelz := countDarkPixelz := 0

   ERR := Gdip_GetHistogram(cropBMP, 2, ArrChR, ArrChG, ArrChB)
   pEffect := Gdip_CreateEffect(6, 0, -99, 0)
   If !ERR
   {
      If pEffect
         rT := Gdip_BitmapApplyEffect(cropBMP, pEffect)
   
      Gdip_DisposeEffect(pEffect)
      ERR := Gdip_GetHistogram(cropBMP, 3, brLvlArray, 0, 0)
   }

   trGdip_DisposeImage(cropBMP, 1)
   If (mustRem=1)
      trGdip_DisposeImage(rBitmap, 1)

   If ERR
      Return -1

   rTotalPixelz := Width*Height
   TotalPixelz := wCrop*hCrop
   otherThreshold := (usrAdaptiveThreshold>0) ? usrAdaptiveThreshold : 2
   minMaxThreshold := Floor(rTotalPixelz*0.000015) + usrAdaptiveThreshold
   If (minMaxThreshold<1)
      minMaxThreshold := 1

   ; gather image histogram statistics
   Loop, 256
   {
       thisIndex := A_Index - 1
       nrPixelz := brLvlArray[thisIndex]
       If !nrPixelz
          Continue

       sumTotalBr += nrPixelz * thisIndex
       If (nrPixelz>modePointV)
       {
          modePointV := nrPixelz
          modePointK := thisIndex
       }

       If (thisIndex>maxBrLvl && nrPixelz>minMaxThreshold)
          maxBrLvl := thisIndex

       If (thisIndex<minBrLvl && nrPixelz>minMaxThreshold)
          minBrLvl := thisIndex

       If (thisIndex<rMinBrLvl && nrPixelz>otherThreshold)
          rMinBrLvl := thisIndex

       If (isInRange(thisIndex, 4, 40))
          countDarkPixelz += nrPixelz
       Else If (isInRange(thisIndex, 170, 253))
          countBrightPixelz += nrPixelz
       Else If (isInRange(thisIndex, 50, 165))
          countMidPixelz += nrPixelz
   }

   avgBrLvl := Round(sumTotalBr/TotalPixelz)
   Loop, 23
   {
       nrPixelz := brLvlArray[avgBrLvl - 11 + A_Index]
       If nrPixelz
          countFlatties += nrPixelz
   }

   Loop, 11
   {
       nrPixelz := brLvlArray[modePointK - 6 + A_Index]
       If nrPixelz
          countModies += nrPixelz
   }

   aMinBrLvl := (rMinBrLvl + minBrLvl)//2
   Loop, 10
   {
       nrPixelz := brLvlArray[aMinBrLvl + A_Index]
       If nrPixelz
          countLowestPx += nrPixelz
   }
   percmodePx := Round((countModies/TotalPixelz)*100, 4)
   percBrgPx := Round((countBrightPixelz/TotalPixelz) * 100, 4)
   percLowPx := Round((countLowestPx/TotalPixelz) * 100, 4)
   percDrkPx := Round((countDarkPixelz/TotalPixelz) * 100, 4)
   percMidPixu := Round((countMidPixelz/TotalPixelz) * 100, 4)
   oPercAvgPx := Round((countFlatties/TotalPixelz) * 100, 4)
   If (percmodePx<=0.00015)
      percmodePx += 0.000156
   If (percMidPixu<=0.00015)
      percMidPixu += 0.000156
   If (percBrgPx<=0.00025)
      percBrgPx += 0.000256
   If (percDrkPx<=0.001)
      percDrkPx += 0.01512
   percAvgPx := Round((oPercAvgPx + percmodePx + percMidPixu)/3, 4)
   percMidPx := 100 - percBrgPx - percDrkPx
   If (percMidPx<=0.00025)
      percMidPx += 0.000256

   ; make the image brighter if max. luminance [maxBrLvl] is less than 255
   multiplieruA := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
   If (percBrgPx>1.25)
      multiplieruA := multiplieruA - Round(percMidPx/450, 4)

   multiplieruB := 255.1/maxBrLvl + (percDrkPx/8 + (255.1 - avgBrLvl)/15 + (255.1 - modePointK)/10)/50 - percBrgPx/25 - ((percMidPixu + percMidPx)/2)/40
   multiplieru := (multiplieruA + multiplieruB)/2

   If (multiplieru<=1)
      multiplieru := 1.0002
   If (multiplieru<=1.15)
   {
      multiplieruC := 255.1/maxBrLvl + (percDrkPx + (255.1 - avgBrLvl)/3 + (255.1 - (modePointK+avgBrLvl)/2)/3)/(500 + maxBrLvl*2 + avgBrLvl*10)
      If (percBrgPx>1.25)
         multiplieruC := multiplieruC - Round(percMidPx/450, 4)
      multiplieru := multiplieruC/1.25
      If (multiplieru<=1)
         multiplieru := 1.0002
   }

   lumosAdjust := multiplieru
   GammosAdjust := - lumosAdjust/40 + 0.025 + ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/3.25
   realGammos := Round(1 - ((percDrkPx + percAvgPx)/(900 + percBrgPx*100 + avgBrLvl*2))/1.25, 3)

   ; make the image darker when lacking contrast or min. luminance level [minBrLvl] is higher than 1
   darkerOffsetA := rMinBrLvl*multiplieru
   darkerOffsetA := (darkerOffsetA - 3)/105
   darkerOffsetB := (aMinBrLvl/multiplieru/(200 - percBrgPx/4) + percBrgPx/percDrkPx/avgBrLvl/300)/1.5
   darkerOffsetC := (minBrLvl/multiplieru)/250 + avgBrLvl/(600 - avgBrLvl/10)
   darkerOffset := (darkerOffsetA + darkerOffsetB)/2 - percLowPx/700
   testGammosAdjust := GammosAdjust - darkerOffset/1.1
   If (testGammosAdjust>-0.02 && aMinBrLvl>3)
      darkerOffset := darkerOffsetC/1.5
   If (darkerOffset<=0)
      darkerOffset := 0.00001

   lumosAdjust := lumosAdjust + darkerOffset
   GammosAdjust := GammosAdjust - darkerOffset/1.1

   If (autoAdjustMode=2)
   {
      lumosAdjust := multiplieru := 255.1/maxBrLvl
      GammosAdjust := - lumosAdjust/40 + 0.025
   } Else If (autoAdjustMode=3)
   {
      darkerOffset := rMinBrLvl/255
      lumosAdjust := 1 + darkerOffset*1.1
      GammosAdjust := 0 - darkerOffset*1.3
   }

   ; adjust saturation
   If (doSatAdjusts=1)
   {
      Loop, 256
      {
          thisIndex := A_Index
          nrPixR := ArrChR[thisIndex]
          nrPixG := ArrChG[thisIndex]
          nrPixB := ArrChB[thisIndex]
          If (nrPixR="" || nrPixG="" || nrPixB="")
             Continue
 
          sumTotalR += nrPixR * thisIndex
          sumTotalG += nrPixG * thisIndex
          sumTotalB += nrPixB * thisIndex
          BrLvlDifs := max(NrPixR, NrPixG, NrPixB) - min(NrPixR, NrPixG, NrPixB)
          If (BrLvlDifs<minMaxThreshold*2) || (nrPixR+nrPixB+nrPixB<minMaxThreshold*3)
             Continue
          tNrPixR += nrPixR
          tNrPixG += nrPixG
          tNrPixB += nrPixB
          tNrPixAll += max(NrPixR, NrPixG, NrPixB)
          AllBrLvlDifs += BrLvlDifs
      }
   }
   BrLvlDiffX := max(tNrPixR, tNrPixG, tNrPixB) - min(tNrPixR, tNrPixG, tNrPixB)
   PrcLvlDiffX := Round((BrLvlDiffX/tNrPixAll)*100, 4)
   PrcLvlDiffXa := Round((AllBrLvlDifs/tNrPixAll)*100, 4)

   v1a := ArrChR[maxBrLvl]
   v2a := ArrChG[maxBrLvl]
   v3a := ArrChB[maxBrLvl]
   v1b := ArrChR[maxBrLvl - 1]
   v2b := ArrChG[maxBrLvl - 1]
   v3b := ArrChB[maxBrLvl - 1]
   v1e := ArrChR[modePointK]
   v2e := ArrChG[modePointK]
   v3e := ArrChB[modePointK]
   ; hmmu := max(v1a, v2a, v3a) " -- " min(v1a, v2a, v3a) " -- " v1a "," v2a "," v3a

   BrLvlDiffA := max(v1a, v2a, v3a) - min(v1a, v2a, v3a)
   BrLvlDiffB := max(v1b, v2b, v3b) - min(v1b, v2b, v3b)
   BrLvlDiffE := max(v1e, v2e, v3e) - min(v1e, v2e, v3e)
   PrcLvlDiffA := Round((BrLvlDiffA/max(v1a, v2a, v3a))*100, 4)
   PrcLvlDiffB := Round((BrLvlDiffB/max(v1b, v2b, v3b))*100, 4)
   PrcLvlDiffE := Round((BrLvlDiffE/max(v1e, v2e, v3e))*100, 4)
   avgLvlsDiff := (PrcLvlDiffA + PrcLvlDiffB + PrcLvlDiffE)/3

   satAdjust := 1
   satLevel := (lumosAdjust - GammosAdjust - 1)/15 - percDrkPx/50
   If (satLevel<0)
      satLevel := 0
   satAdjust := 1 - satLevel
   If (satAdjust<0.5)
      satAdjust := 0.5
   Else If (PrcLvlDiffX>0.5)
      satAdjust := satAdjust - PrcLvlDiffX/50 + 0.02

   If (PrcLvlDiffX<0.2)
   {
      PrcLvlDiffX := Round((3*BrLvlDiffX/TotalPixelz)*100, 4)
      satAdjust := satAdjust + PrcLvlDiffX/40 + 0.02
   }

   If (avgLvlsDiff>95)
      satAdjust := satAdjust - (avgLvlsDiff - 95)/100 + 0.02
   Else If (avgLvlsDiff<20)
      satAdjust := satAdjust + (20 - avgLvlsDiff)/100

   If (PrcLvlDiffXa>50)
      satAdjust -= PrcLvlDiffXa/1000
   Else
      satAdjust += PrcLvlDiffXa/700

   avgBrLvlR := Round(sumTotalR/TotalPixelz)
   avgBrLvlG := Round(sumTotalG/TotalPixelz)
   avgBrLvlB := Round(sumTotalB/TotalPixelz)
   chnlDiffs := max(avgBrLvlR, avgBrLvlG, avgBrLvlB) - min(avgBrLvlR, avgBrLvlG, avgBrLvlB)
   chnlDiffs := Round((chnlDiffs/maxBrLvl)*100, 4)
   If (avgBrLvlR>240 || avgBrLvlG>240 || avgBrLvlB>240) && (avgBrLvlR!=avgBrLvlB || avgBrLvlR!=avgBrLvlG ||  avgBrLvlB!=avgBrLvlG)
      satAdjust -= 0.05

   If (satAdjust<0.86)
      satAdjust += percDrkPx/800
   If (satAdjust<0.70)
      satAdjust := 0.70

   If (satAdjust>0.8 && chnlDiffs>=20)
      satAdjust -= chnlDiffs>50 ? chnlDiffs/825 : chnlDiffs/950
   Else If (chnlDiffs<11)
      satAdjust += (100 - chnlDiffs)/950

   otherz := (avgBrLvlG + avgBrLvlB)//1.5
   rLevelu := (avgBrLvlR>otherz+5 && avgBrLvlR<100 && otherz/avgBrLvlR<0.5) ? 1 - otherz/avgBrLvlR : 0
   satAdjust -= rLevelu/11
   otherz := (avgBrLvlR + avgBrLvlB)//1.5
   gLevelu := (avgBrLvlG>otherz+5 && avgBrLvlG<100 && otherz/avgBrLvlG<0.5) ? 1 - otherz/avgBrLvlG : 0
   satAdjust -= gLevelu/11
   otherz := (avgBrLvlG + avgBrLvlR)//1.5
   bLevelu := (avgBrLvlB>otherz+5 && avgBrLvlB<100 && otherz/avgBrLvlB<0.5) ? 1 - otherz/avgBrLvlB : 0
   satAdjust -= bLevelu/11
   If (doSatAdjusts!=1)
      satAdjust := 1

   ; execTime := A_TickCount - startZeit
   ; ToolTip, % redLevelu ",avgRGB=" avgBrLvlR ", " avgBrLvlG ", " avgBrLvlB ", ChnlDiff=" chnlDiffs  ", AvgLvlDif=" avgLvlsDiff " %, diffA=" PrcLvlDiffA " %, diffE=" PrcLvlDiffE " %, diffX=" PrcLvlDiffX "/" PrcLvlDiffXa "% `nTh=" minMaxThreshold ", min=" minBrLvl "/" rMinBrLvl ", max=" maxBrLvl ", A=" avgBrLvl ", mP=" modePointK " [" modePointV " / " percmodePx "% ]"  ",`nL=" percBrgPx "%, D=" percDrkPx "%, Dl=" percLowPx "%, Mr=" percMidPx "% / Mo=" percMidPixu "%, oAvg=" oPercAvgPx "%, fAvg=" percAvgPx "%`ncL=" lumosAdjust ", cG=" GammosAdjust ", cS=" satAdjust ", T=" execTime "ms",,, 2
}

createVPnavBox(ByRef pBitmap, ByRef imgW, ByRef imgH, ByRef posX, ByRef posY, ByRef fImgW, ByRef fImgH) {
   Static lastState := 1
   pBitmap := ""
   navBoxu := coreCreateVPnavBox()
   If StrLen(navBoxu)<3
      Return

   Gdip_GetImageDimensions(navBoxu, fImgW, fImgH)
   Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   posX := imgW//2 - fImgW//2
   posY := imgH//2 - fImgH//2

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")
   If StrLen(pBitmap)<3
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      Return
   }

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      pBitmap := ""
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   E := trGdip_DrawImage(A_ThisFunc, Gu, navBoxu, posX, posY, fImgW, fImgH)
   If (E="fail")
   {
      pBitmap := ""
      Gdip_DeleteGraphics(Gu)
      trGdip_DisposeImage(navBoxu, 1)
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }

   Gdip_SetClipRect(Gu, posX, posY, fImgW, fImgH, 4)
   borderu := Round(imgW*0.0095)
   Gdip_FillRectangle(Gu, pBrushE, posX - borderu, posY - borderu, fImgW + borderu*2, fImgH + borderu*2)
   Gdip_ResetClip(Gu)

   If (editingSelectionNow=1)
   {
      calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      If (zImgSelW<borderu*2 || zImgSelH<borderu*2)
         Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

      If (zImgSelW<borderu*2)
         zImgSelW := borderu*2
      If (zImgSelH<borderu*2)
         zImgSelH := borderu*2

      pPath := createImgSelPath(posX + zimgSelPx, posY + zimgSelPy, zimgSelW, zimgSelH, EllipseSelectMode)
      Gdip_RotatePathAtCenter(pPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)
      Gdip_SetClipPath(Gu, pPath, 0)
      If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
         thisBrush := lastState ? pBrushA : pBrushD
      Else
         thisBrush := pBrushA
      Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
      Gdip_DeletePath(pPath)
      Gdip_ResetClip(Gu)
   }

   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   obju := createImgSelection2Win(prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, prevMaxSelX, prevMaxSelY, mainWidth, mainHeight, 1)
   coords := obju.x1 "|" obju.y1 "|" obju.x2 "|" obju.y2
   calcImgSelection2bmp(1, oimgW, oimgH, fimgW, fimgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2, 0, 0, coords)
   If (zImgSelW<borderu*2)
      zImgSelW := borderu*2
   If (zImgSelH<borderu*2)
      zImgSelH := borderu*2

   If (zImgSelW<borderu*6 || zImgSelH<borderu*6)
      thisBrush := lastState ? pBrushC : pBrushD
   Else
      thisBrush := pBrushC

   Gdip_FillRectangle(Gu, thisBrush, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH)
   Gdip_SetClipRect(Gu, posX + zImgSelPx, posY + zImgSelPy, zimgSelW, zimgSelH, 4)
   borderu := Round(imgW*0.006)
   Gdip_FillRectangle(Gu, pBrushE, posX + zImgSelPx - borderu, posY + zImgSelPy - borderu, zimgSelW + borderu*2, zimgSelH + borderu*2)

   Gdip_ResetClip(Gu)
   Gdip_SetClipRect(Gu, borderu, borderu, imgW - borderu*2, imgH - borderu*2, 4)
   Gdip_FillRectangle(Gu, pBrushE, 0, 0, imgW, imgH)
   lastState := !lastState
   Gdip_DeleteGraphics(Gu)
   Return pBitmap
}

coreCreateVPnavBox() {
   Static lastCall, prevBMP

   thisCall := "a" gdiBitmap gdiBitmapIDcall currentFileIndex getIDimage(currentFileIndex) currentUndoLevel undoLevelsRecorded UserMemBMP imgHUDbaseUnit OSDfntSize HUDnavBoxSize
   If (thisCall=lastCall)
      Return prevBMP

   prevBMP := trGdip_DisposeImage(prevBMP, 1)
   imgW := imgH := Ceil(HUDnavBoxSize * imgHUDbaseUnit/20)
   Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
   calcIMGdimensions(rImgW, rImgH, imgW, imgH, ResizedW, ResizedH)

   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, "0xE200B")
   If !pBitmap
      Return

   Gu := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap)
   If !Gu
   {
      trGdip_DisposeImage(pBitmap, 1)
      Return
   }
   ; Gdip_FillRectangle(Gu, pBrushE, 0, 0, ResizedW, ResizedH)
   posX := posY := 0
   E := trGdip_DrawImage(A_ThisFunc, Gu, useGdiBitmap(), posX, posY, ResizedW, ResizedH)
   Gdip_DeleteGraphics(Gu)
   prevBMP := (E!="fail") ? pBitmap : ""
   lastCall := (E!="fail") ? thisCall : ""
   If (E="fail")
      pBitmap := trGdip_DisposeImage(pBitmap, 1)

   Return pBitmap
}

ImageNavClickResponder(mX, mY, mainWidth, mainHeight) {
   If (FlipImgV=1)
      mY := mainHeight - mY
   If (FlipImgH=1)
      mX := mainWidth - mX

   prcW := mX/mainWidth
   prcH := mY/mainHeight
   ; ToolTip, % mX "==" mY "==" mainWidth "==" mainHeight "==" prcW "==" prcH , , , 2
   prcW := (prcW>0.5) ? prcW - 0.5 : 0.5 - prcW
   prcH := (prcH>0.5) ? prcH - 0.5 : 0.5 - prcH
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   decX := Round(((imgW)*prcW) * zoomLevel)
   decY := Round(((imgH)*prcH) * zoomLevel)
   prcW := mX/mainWidth
   prcH := mY/mainHeight
   If (prcW>0.5 || imageAligned=1)
      decX := -decX
   If (prcH>0.5 || imageAligned=1)
      decY := -decY
   IMGdecalageX := decX
   IMGdecalageY := decY

   If (LastPrevFastDisplay=1 || PannedFastDisplay=1)
      coreReloadThisPicture()
   Else
      filterDelayiedImageDisplay()

   ; dummyTimerDelayiedImageDisplay(50)
}

drawHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath) {
    Static prevImgPath, lastInvoked := 1

    maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
    pBrush := (mode=2) ? pBrushB : pBrushA
    indicWidth := 150
    lineThickns := imgHUDbaseUnit
    lineThickns2 := lineThickns//4
    If (showHistogram>1)
    {
       thisImgCall := imgPath currentFileIndex zoomLevel IMGresizingMode imgFxMode showHistogram gdiBitmap undoLevelsRecorded currentUndoLevel UserMemBMP OSDfntSize histogramMode
       thisSizingModes := (IMGresizingMode=1 || IMGresizingMode=2 || IMGresizingMode=5) || (IMGresizingMode=4 && IMGlargerViewPort!=1) ? 1 : 0
       If (imgFxMode!=1 || thisSizingModes!=1 || animGIFplaying=1 || desiredFrameIndex>0)
       {
          prevImgPath := 0
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
          If StrLen(tempBMP)>2
          {
             thisPosX := (DestPosX<0) ? 0 : DestPosX
             thisPosY := (DestPosY<0) ? 0 : DestPosY
             thisW := (newW>mainWidth) ? mainWidth : newW
             thisH := (newH>mainHeight) ? mainHeight : newH
             thisVPimg := Gdip_CloneBmpPargbArea(A_ThisFunc, tempBMP, thisPosX + 1, thisPosY + 1, thisW - 2, thisH - 2)
             createHistogramBMP(thisVPimg)
             trGdip_DisposeImage(thisVPimg, 1)
             trGdip_DisposeImage(tempBMP, 1)
          }
       } Else If (prevImgPath!=thisImgCall) && (A_TickCount - lastInvoked>50)
       {
          lastInvoked := A_TickCount
          prevImgPath := thisImgCall
          HistogramBMP := trGdip_DisposeImage(HistogramBMP, 1)
          If StrLen(gdiBitmap)>3
             createHistogramBMP(gdiBitmap)
       }
    } Else prevImgCall := 0

    If (mode=2 && IMGresizingMode=4 && IMGlargerViewPort=1)
    {
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Gdip_SetPenWidth(pPen1d, thisThick)
       Gdip_DrawRectangle(glPG, pPen1d, thisX, thisY, thisW, thisH)
    } Else If (mode=1)
    {
       thisThick := imgHUDbaseUnit//11
       If (showSelectionGrid=1 || imgSelLargerViewPort=1) && (editingSelectionNow=1)
       {
          Gdip_SetPenWidth(pPen4, thisThick)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX + newW//2 - thisThick//4, DestPosY, thisThick//2, newH)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX, DestPosY + newH//2 - thisThick//4, newW, thisThick//2)
       }

       If (borderAroundImage=1) || (editingSelectionNow=1 && LimitSelectBoundsImg=1)
          Gdip_DrawRectangle(glPG, pPen4, DestPosX - thisThick/2, DestPosY - thisThick/2, newW + thisThick, newH + thisThick)
    }

; visual markers for image viewing conditions

    If (markedSelectFile || FlipImgV=1 || FlipImgH=1 || IMGlargerViewPort=1 || imgFxMode>1)
    {
       If (FlipImgH=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - indicWidth//2, mainHeight//2 - lineThickns2//2, indicWidth, lineThickns2, lineThickns2//2)
       If (FlipImgV=1 && mode=2)
          Gdip_FillRoundedRectangle2(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//2, lineThickns2, indicWidth, lineThickns2//2)
       If (imgFxMode>1 && mode=2)
       {
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//4, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2, 0, 180)
          Gdip_FillPie(glPG, pBrush, mainWidth//2 - indicWidth//8, mainHeight//2 - indicWidth//8, indicWidth//4, indicWidth//4, 180, 360)
       }

       If (IMGlargerViewPort=1)
       {
          marginErr := (mode=2) ? 12 : 25
          lineThickns2 := (mode=2) ? lineThickns : lineThickns//3
          If (newH>mainHeight)
          {
             If (DestPosY<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, lineThickns2//2)
              If (DestPosY>-newH+mainHeight+marginErr)
                 Gdip_FillRectangle(glPG, pBrush, 0, mainHeight - lineThickns2//2, mainWidth, lineThickns2//2)
          }

          If (newW>mainWidth)
          {
             If (DestPosX<-marginErr)
                Gdip_FillRectangle(glPG, pBrush, 0, 0, lineThickns2//2, mainHeight)
              If (DestPosX>-newW+mainWidth+marginErr)
                 Gdip_FillRectangle(glPG, pBrush, mainWidth - lineThickns2//2, 0, lineThickns2//2, mainHeight)
          }
       }

       imgPathArray := resultedFilesList[currentFileIndex]
       imgPathSelected := imgPathArray[2]
       If (imgPathSelected=1)
       {
          thisThick := (mode=2) ? lineThickns//2.5 : lineThickns//4.2
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen3, 0, 0, mainWidth, mainHeight)
          Gdip_DrawRectangle(glPG, pPen1d, 0, 0, mainWidth, mainHeight)
       } Else If (markedSelectFile)
       {
          sqSize := (mode=2) ? lineThickns + lineThickns2 : lineThickns
          sqPosX := mainWidth - sqSize
          Gdip_FillRectangle(glPG, pBrush, sqPosX, 0, sqSize, sqSize)
          thisThick := lineThickns//9
          Gdip_SetPenWidth(pPen1d, thisThick)
          Gdip_DrawRectangle(glPG, pPen1d, sqPosX, 0, sqSize, sqSize)
       }
    }

    lineThickns := imgHUDbaseUnit//9
    If (mode=2)
       lineThickns :=  imgHUDbaseUnit//10

; highlight usePrevious=1 mode

    If (mode=2 && imgFxMode=1)
    {
       indicWidth := (zoomLevel<1) ? Round(120 * zoomLevel) : 110
       If (indicWidth<50)
          indicWidth := 50
       Gdip_SetPenWidth(pPen2, lineThickns)
       Gdip_FillRectangle(glPG, pBrush, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
       Gdip_DrawRectangle(glPG, pPen2, mainWidth//2 - lineThickns2//2, mainHeight//2 - indicWidth//4, indicWidth//2, indicWidth//2)
    }

; draw the scrollbar indicators

    prcVisX := mainWidth/newW
    prcVisY := mainHeight/newH
    knobW := Round(mainWidth*prcVisX)
    knobH := Round(mainHeight*prcVisY)
    If (knobH<15)
       knobH := 15
    If (knobW<15)
       knobW := 15

    Ax := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    Ax := Round(Ax*maxSelX)
    Ay := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    Ay := Round(Ay*maxSelY)
    knobX := Round((Ax/maxSelX)*mainWidth)
    knobY := Round((Ay/maxSelY)*mainHeight) 
    knobSize := (mode=2) ? imgHUDbaseUnit//2 : imgHUDbaseUnit//3
    If (knobW<mainWidth - 5) && (IMGresizingMode=4)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, knobX, 0, knobW, knobSize)
       scrollBarHy := mainHeight - knobSize
       Gdip_FillRectangle(glPG, pBrushE, 0, scrollBarHy, mainWidth, knobSize)
       Gdip_FillRectangle(glPG, pBrushD, knobX, scrollBarHy + 5, knobW, knobSize)
    } Else scrollBarHy := 0

    If (knobH<mainHeight - 5) && (IMGresizingMode=4)
    {
       ; Gdip_FillRectangle(glPG, pBrushA, 0, knobY, knobSize, knobH)
       scrollBarVx := mainWidth - knobSize
       Gdip_FillRectangle(glPG, pBrushE, scrollBarVx, 0, knobSize, mainHeight)
       Gdip_FillRectangle(glPG, pBrushD, scrollBarVx + 5, knobY, knobSize, knobH)
    } Else scrollBarVx := 0

; highlight number of frames and the current frame in multi-frame images [tiff and gif]

    If (totalFramesIndex>0)
    {
        bulletSize := imgHUDbaseUnit//3
        totalBulletsWidth := bulletSize * totalFramesIndex
        If (totalBulletsWidth>mainWidth)
           bulletsPerc := Round(desiredFrameIndex/totalFramesIndex, 3)
        maxBullets := Round(mainWidth/bulletSize)
        centerPos := bulletsPerc ? 0 : mainWidth//2 - totalBulletsWidth//2
        If (centerPos<0)
           centerPos := 0
        Loop, % totalFramesIndex + 1
        {
            If bulletsPerc
               whichBrush := (A_Index/maxBullets<bulletsPerc) || (desiredFrameIndex=totalFramesIndex) ? pBrushA : pBrushE
            Else
               whichBrush := (A_Index - 1 <= desiredFrameIndex) ? pBrushA : pBrushE
            Gdip_FillEllipse(glPG, whichBrush, centerPos + bulletSize * (A_Index - 1), mainHeight - bulletSize, bulletSize, bulletSize)
            If (A_index>maxBullets)
               Break
        }
    }

    If (adjustNowSel=1)
       Return

    If (showHistogram>1 && StrLen(HistogramBMP)>3)
    { 
       Gdip_GetImageDimensions(HistogramBMP, imgW, imgH)
       thisPosX := (scrollBarVx>0) ? scrollBarVx - imgW : mainWidth - imgW
       thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
       If (FlipImgH=1 || FlipImgV=1)
       {
          tempBMP := trGdip_CloneBitmap(A_ThisFunc, HistogramBMP)
          flipBitmapAccordingToViewPort(tempBMP, 1)
          E := trGdip_DrawImage(A_ThisFunc, glPG, tempBMP, thisPosX, thisPosY)
          trGdip_DisposeImage(tempBMP, 1)
       } Else E := trGdip_DrawImage(A_ThisFunc, glPG, HistogramBMP, thisPosX, thisPosY,,,,,,, 0.9)

       If (FlipImgH=1)
          thisPosX := 0 + Round(mainWidth - scrollBarVx)
       If (FlipImgV=1)
          thisPosY := 0 + Round(mainHeight - scrollBarHy)

       HUDobjHistoBoxu[1] := imgW, HUDobjHistoBoxu[2] := imgH
       HUDobjHistoBoxu[3] := thisPosX, HUDobjHistoBoxu[4] := thisPosY
       hasDrawnHistoMap := (E="fail") ? 0 : 1
    } Else hasDrawnHistoMap := 0

    additionalHUDelements(mode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, 1)
}

drawLiveCreateShape() {
    PointsList := Trimmer(customShapePoints)
    Loop, Parse, PointsList, "|"
    {
       If !A_LoopField
          Continue
       splitu := StrSplit(A_LoopField, ",")
       xu := splitu[1] - (initialDrawingStartCoords[1] - prevDestPosX)
       yu := splitu[2] - (initialDrawingStartCoords[2] - prevDestPosY)
       newShape .= xu "," yu "|"
    }

    PointsList := newShape
    GetMouseCoord2wind(PVhwnd, mX, mY)
    If (FlipImgH=1 || FlipImgV=1)
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    gmX := (FlipImgH=1) ? mainWidth - mX : mX
    gmY := (FlipImgV=1) ? mainHeight - mY : mY
    MouseGetPos, , , OutputVarWin,,3
    If (OutputVarWin!=tempBtnVisible)
       PointsList := PointsList gmX "," gmY "|"

    PointsList := Trimmer(PointsList, "|")
    If (PenuDrawLive && ST_Count(PointsList, "|")<=1)
    {
       Gdip_SetPenWidth(pPen4, imgHUDbaseUnit//11)
       Gdip_DrawLines(2NDglPG, pPen4, PointsList)
    } Else If (PenuDrawLive)
    {
       If (drawingLiveMode=1)
       {
          If (closedLineCustomShape=1)
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawClosedCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawPolygon(2NDglPG, PenuDrawLive, PointsList)
          } Else
          {
             If (cardinalCurveCustomShape=1)
                Gdip_DrawCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
             Else
                Gdip_DrawLines(2NDglPG, PenuDrawLive, PointsList)
          }
       } Else
       {
          If (cardinalCurveCustomShape=1)
             Gdip_FillClosedCurve(2NDglPG, PenuDrawLive, PointsList, tensionCurveCustomShape)
          Else
             Gdip_FillPolygon(2NDglPG, PenuDrawLive, PointsList)
       }
    }
}

convertCustomShape2toRelativeCoords(PointsList, setSelection:=1) {
    PointsList := Trimmer(PointsList)
    PointsList := Trimmer(PointsList, "|")
    If (ST_Count(PointsList, "|")<2)
       Return

    ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    pathu := Gdip_CreatePath()
    If pathu
    {
       Gdip_AddPathPolygon(pathu, PointsList)
       bounds := Gdip_GetPathWorldBounds(pathu)
    }

    If (setSelection=1)
    {
       xe := - (initialDrawingStartCoords[1] - prevDestPosX)
       ye := - (initialDrawingStartCoords[2] - prevDestPosY)
       MouseCoords2Image(bounds.x + xe, bounds.y + ye, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX1, imgSelY1)
       MouseCoords2Image(bounds.x + xe + bounds.w, bounds.y + ye + bounds.h, LimitSelectBoundsImg, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, ImgSelX2, imgSelY2)
       Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
       defineRelativeSelCoords(imgW, imgH)
       initialCustomShapeCoords := imgSelX1 "|" imgSelY1 "|" bounds.w "|" bounds.h
       INIaction(1, "initialCustomShapeCoords", "General")
    }

    Loop, Parse, PointsList, "|"
    {
       splitu := StrSplit(A_LoopField, ",")
       xu := (splitu[1] - bounds.x) / bounds.w ; mainWidth
       yu := (splitu[2] - bounds.y) / bounds.h ; mainHeight
       ; If (A_Index=1)
       ;    closure := xu "," yu
       newShape .= xu "," yu "|"
    }
    If pathu
       Gdip_DeletePath(pathu)
    PointsList := Trimmer(newShape, "|") ; closure
    Return PointsList
    ; SetTimer, dummyRefreshImgSelectionWindow, -150
    ; ToolTip, % customShapePoints , , , 2
}

convertCustomShape2toReferencedArea(PointsList, refX, refY, refW, refH) {
    drawingShapeNow := 0
    PointsList := Trimmer(PointsList)
    PointsList := Trimmer(PointsList, "|")
    If (ST_Count(PointsList, "|")<2)
       Return

    Loop, Parse, PointsList, "|"
    {
       If !A_LoopField
          Continue
       splitu := StrSplit(A_LoopField, ",")
       xu := refW * splitu[1] + refX
       yu := refH * splitu[2] + refY
       If (!xu || !yu)
          Continue

       newShape .= xu "," yu "|"
    }

    Return Trimmer(newShape, "|")
}

additionalHUDelements(mode:=0, mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0, directRefresh:=0) {
    Critical, on

    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
    setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)

    If (drawingShapeNow=1)
       drawLiveCreateShape()
    Else If (editingSelectionNow=1 && mode=2)
       drawImgSelectionOnWindow("prev", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=1)
       drawImgSelectionOnWindow("active", "-", "-", "-", mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    Else If (editingSelectionNow=1 && mode=3)
       drawImgSelectionOnWindow("return", "-", "-", "-", mainWidth, mainHeight)

    If (showImgAnnotations=1 && !AnyWindowOpen && drawingShapeNow!=1 && currentUndoLevel<3)
       drawAnnotationBox(mainWidth, mainHeight)

    If (showInfoBoxHUD>=1 && drawingShapeNow!=1)
       drawinfoBox(mainWidth, mainHeight, directRefresh)

    If (imgEditPanelOpened=1 && AnyWindowOpen!=10 && drawingShapeNow!=1 && imgSelOutViewPort!=1 && mode!=2)
       livePreviewsImageEditing()

    If (showHUDnavIMG=1 && IMGlargerViewPort=1 && drawingShapeNow!=1)
    {
       createVPnavBox(navBoxu, imgW, imgH, diffX, diffY, zImgW, zImgH)
       thisPosX := 0
       thisPosY := (scrollBarHy>0) ? scrollBarHy - imgH : mainHeight - imgH
       If navBoxu
          ERR := trGdip_DrawImage(A_ThisFunc, 2NDglPG, navBoxu, thisPosX, thisPosY)

       hasDrawnImageMap := (navBoxu && !ERR) ? 1 : 0
       If (FlipImgH=1)
          thisPosX := mainWidth - imgW
       ; ToolTip, % scrollBarVx "==" scrollBarHy , , , 2
       If (FlipImgV=1)
          thisPosY := 0 + Round(mainHeight - scrollBarHy)

       If navBoxu
          HUDobjNavBoxu := [zImgW, zImgH, thisPosX + diffX, thisPosY + diffY, imgW, imgH, thisPosX, thisPosY]
       trGdip_DisposeImage(navBoxu, 1)
    }

    Gdip_ResetWorldTransform(2NDglPG)
    r2 := LrydWinUpdt(hGDIselectwin, 2NDglHDC)
}

dummyLivePreviewsImageEditing() {
   livePreviewsImageEditing(1)
}

getColorMatrix() {
    matrix := ""
    If (ForceNoColorMatrix=1 && AnyWindowOpen=10) || (imgFxMode=1)
       Return matrix

    If (imgFxMode=4 && bwDithering=0)       ; grayscale
       matrix := GenerateColorMatrix(2, lumosGrayAdjust, GammosGrayAdjust + 0.0001)
    Else If (imgFxMode=5)       ; grayscale R
       matrix := GenerateColorMatrix(3)
    Else If (imgFxMode=6)       ; grayscale G
       matrix := GenerateColorMatrix(4)
    Else If (imgFxMode=7)       ; grayscale B
       matrix := GenerateColorMatrix(5)
    Else If (imgFxMode=8)  ; alpha channel
       matrix := GenerateColorMatrix(7)
    Else If (imgFxMode=9)  ; negative / invert
       matrix := GenerateColorMatrix(6)
    Else If (imgFxMode=10)  ; sepia
       matrix := GenerateColorMatrix(8)
    Else If (imgFxMode=2 || imgFxMode=3) ; personalized
       matrix := GenerateColorMatrix(1, lumosAdjust, GammosAdjust + 0.0001, satAdjust, 1, chnRdecalage, chnGdecalage, chnBdecalage)
    Return matrix
}

decideGDIPimageFX(ByRef matrix, ByRef imageAttribs, ByRef pEffect) {
    Static colorzFX := {1:0, 2:1, 3:2, 4:5, 5:6, 6:7, 7:8, 8:9, 9:11}
    matrix := imageAttribs := pEffect := ""
    matrix := getColorMatrix()
    If (thumbsDisplaying=1 && (imgFxMode=3 || imgFxMode=8))
       matrix := ""

    thisFXapplies := (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) ? 1 : 0
    mustCreateAttribs := (realGammos!=1 && imgThreshold=0 && !matrix) || (ForceNoColorMatrix=1 || imgFxMode=1) ? 0 : 1
    If (mustCreateAttribs=1)
    {
       imageAttribs := Gdip_CreateImageAttributes()
       Gdip_SetImageAttributesColorMatrix(Matrix, imageAttribs)
       If (imgThreshold>0 && thisFXapplies=1 && ForceNoColorMatrix=0)
          Gdip_SetImageAttributesThreshold(imageAttribs, imgThreshold)
       If (realGammos!=1 && thisFXapplies=1 && ForceNoColorMatrix=0)
          Gdip_SetImageAttributesGamma(imageAttribs, realGammos)
    }

    If isWinXP
       Return "a" paramA paramB thisFXapplies applyAdjusts o_bwDithering specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust

    o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
    applyAdjusts := (ForceNoColorMatrix=1) ? 0 : 1
    thisZatAdjust := (imgFxMode=4 && bwDithering=0 && zatAdjust=0) ? -40 : zatAdjust
    If (thisZatAdjust=0 && hueAdjust=0 && lummyAdjust=0) || !colorzFX[specialColorFXmode]
       applyAdjusts := 0

    paramA := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXmode : hueAdjust
    paramB := colorzFX[specialColorFXmode]=11 ? uiColorCurveFXchannel : thisZatAdjust
    If (colorzFX[specialColorFXmode]=1)
       paramB := 0

    If (thisFXapplies=1 && applyAdjusts=1 && o_bwDithering=0)
       pEffect := Gdip_CreateEffect(colorzFX[specialColorFXmode], paramA, paramB, lummyAdjust)

    Return "a" paramA paramB thisFXapplies applyAdjusts o_bwDithering specialColorFXmode uiColorCurveFXchannel uiColorCurveFXmode lummyAdjust lumosAdjust lumosGrayAdjust GammosAdjust GammosGrayAdjust realGammos imgThreshold thisZatAdjust mustCreateAttribs imgFxMode ForceNoColorMatrix matrix zatAdjust
}

QPV_ShowImgonGuiPrev(whichBitmap, newW, newH, mainWidth, mainHeight, usePrevious, imgPath) {
    Critical, on
    Static prevUpdate, displayFastWas := 1
    If (A_TickCount - prevUpdate > 700)
       displayFastWas := 1

    prevUpdate := A_TickCount
    thisZeit := A_TickCount
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    ; whichImg := (usePrevious=1 && gdiBitmapSmall && imgFxMode!=8 && animGIFplaying!=1) || (usePrevious=3) ? gdiBitmapSmall : gdiBitmap
    If (imgFxMode=8)
       whichBitmap := gdiBitmap

    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    thisIMGres := imgW + imgH
    thisWinRes := mainWidth + mainHeight
    interpoImgQuality := (userimgQuality=1) ? 7 : 5
    If ((pEffect || displayFastWas=0) && userimgQuality=1) || (usePrevious=3 && slideShowRunning!=1)
    {
       thisLowMode := 1
       Gdip_SetInterpolationMode(glPG, 5)
    }

    dpX := clampInRange(DestPosX + 1, 0, mainWidth)
    dpY := clampInRange(DestPosY + 1, 0, mainHeight)
    kW := clampInRange(newW - 2, 0, mainWidth)
    kH := clampInRange(newH - 2, 0, mainHeight)

    bonus := 0
    setMainCanvasTransform(mainWidth, mainHeight)
    zL := (zoomLevel<1) ? 1 : zoomLevel*2
    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight)
    trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)
    If (imgFxMode!=8 && animGIFplaying!=1 && currIMGdetails.HasAlpha=1 && RenderOpaqueIMG!=1)
    || (currIMGdetails.HasAlpha=1 && RenderOpaqueIMG!=1 && imgFxMode=8)
       Gdip_FillRectangle(glPG, useHatchedBrush("vp"), dpX, dpY, kW, kH)

    If (newW>mainWidth || newH>mainHeight)
    {
       bonus := Round(5*zoomLevel)
       newW += bonus, newH += bonus
       mainWidth += bonus, mainHeight += bonus

       x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
       PointX1 := Round(x1*imgW)
       y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
       PointY1 := Round(y1*imgH)
       prcW := mainWidth/newW
       prcH := mainHeight/newH
       PointX2 := Round(PointX1 + imgW*prcW)
       PointY2 := Round(PointY1 + imgH*prcH)
       If (PointX2>imgW)
          PointX2 := imgW
       If (PointY2>imgH)
          PointY2 := imgH
       ; tooltip, % PointX1 "," pointY1 " | " PointX2 "," PointY2 " | " thisW "," thisH
    } ; Else r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, DestPosX, DestPosY, newW, newH, 0, 0, imgW, imgH, matrix, 2, imageAttribs)
    dPosX := (newW>mainWidth) ? 0 : DestPosX
    dPosY := (newH>mainHeight) ? 0 : DestPosY
    dW := (newW>mainWidth) ? mainWidth : newW
    dH := (newH>mainHeight) ? mainHeight : newH
    sPosX := (newW>mainWidth) ? PointX1 : 0
    sPosY := (newH>mainHeight) ? PointY1 : 0
    sW := (newW>mainWidth) ? PointX2 - PointX1 : imgW
    sH := (newH>mainHeight) ? PointY2 - PointY1 : imgH
    ; ToolTip, % mainHeight "--" dH "--" sH ,,,2

    thisScalarX := (newW>mainWidth) ? 1 : 0
    thisScalarY := (newH>mainHeight) ? 1 : 0
    If (pEffect && !isWinXP)
    {
       dhMatrix := Gdip_CreateMatrix()
       Gdip_TranslateMatrix(dhMatrix, dPosX - sPosX, dPosY - sPosY, 1)
       Gdip_ScaleMatrix(dhMatrix, dW/sW, 1, thisScalarX)
       Gdip_ScaleMatrix(dhMatrix, 1, dH/sH, thisScalarY)
    }

    If (pEffect && dhMatrix && !isWinXP)
       r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, whichBitmap,,, sPosX, sPosY, sW, sH, matrix, pEffect, imageAttribs, dhMatrix)
    Else ; If (pEffect || imageAttribs)
       r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, dPosX, dPosY, dW, dH, sPosX, sPosY, sW, sH, matrix, 2, imageAttribs)

    newW -= bonus, newH -= bonus
    mainWidth -= bonus, mainHeight -= bonus
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0
    If (usrTextureBGR=1 && confirmTexBGR=1)
    {
       Gdip_SetClipRect(glPG, DestPosX, DestPosY, newW, newH, 4)
       Gdip_FillRectangle(glPG, AmbientalTexBrush, 0, 0, mainWidth, mainHeight)
       ; pBrush := Gdip_BrushCreateSolid("0x22000000")
       ; Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, mainHeight)
       ; Gdip_DeleteBrush(pBrush)
       Gdip_ResetClip(glPG)
    }

    Gdip_DeleteMatrix(dhMatrix)
    If (thisLowMode=1)
       Gdip_SetInterpolationMode(glPG, interpoImgQuality)

    diffIMGdecX := diffIMGdecY := 0
    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    If (usePrevious!=3)
    {
       prevDestPosX := DestPosX
       prevDestPosY := DestPosY
    }

    whichMode := (usePrevious=3 || imgFxMode=8 || animGIFplaying=1) ? 1 : 2
    drawHUDelements(whichMode, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)

    Gdip_DisposeImageAttributes(imageAttribs)
    If (thisLowMode!=1)
       displayFastWas := (A_TickCount - thisZeit < 100) ? 1 : 0

    prevDrawingMode := (thisLowMode=1 || userimgQuality=0) ? 3 : 2
    drawModeBzeit := A_TickCount - thisZeit
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
    {
       setGIFframesDelay()
       autoChangeDesiredFrame("start", imgPath)
       SetTimer, autoChangeDesiredFrame, % GIFspeedDelay
    } Else autoChangeDesiredFrame("stop")
    
    r2 := LrydWinUpdt(hGDIwin, glHDC)
    r := (r1!=0 || !r2) ? 0 : 1
    If (r1!=0)
       r := Gdip_ErrorHandler(r1, 0, A_ThisFunc)
    Else If !r2
       r := "UpdateLayeredWindow_Error"

    Return r
}

testSelectOutsideImgEntirely(pBitmap) {
     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     Gdip_GetImageDimensions(pBitmap, imgW, imgH)
     If (nimgSelX1<0)
        nimgSelX1 := 0
     If (nimgSelY1<0)
        nimgSelY1 := 0

     If (nimgSelX2<5)
        nimgSelX2 := 1
     If (nimgSelY2<5)
        nimgSelY2 := 1

     If (nimgSelX1>imgW-5)
        nimgSelX1 := ImgW-1
     If (nimgSelY1>ImgH-5)
        nimgSelY1 := imgH-1

     If (nimgSelX2>imgW)
        nimgSelX2 := imgW
     If (nimgSelY2>imgH)
        nimgSelY2 := imgH

     isOutside := 0
     imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     If (imgSelW<3 || imgSelH<3)
        isOutside := 1

     ; If (nimgSelX1<2 && nimgSelY1<2 && nimgSelX2<5 && nimgSelY2<5)
     ;    isOutside := 1

     ; If (nimgSelX1>ImgW-5 && nimgSelY1>imgH-5 && nimgSelX2>imgW && nimgSelY2>imgH)
     ;    isOutside := 1
     Return isOutside
}

distanceBetweenTwoPoints(x1,y1,x2,y2) {
   Return Sqrt((x2 - x1)**2+(y2 - y1)**2)
}

ViewPortSelectionManageCoords(mainWidth, mainHeight, dpX, dpY, maxSelX, maxSelY, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, ByRef zImgSelX1, ByRef zImgSelY1, ByRef zImgSelX2, ByRef zImgSelY2, ByRef vPimgSelW, ByRef vPimgSelH, ByRef vPimgSelPx, ByRef vPimgSelPy) {
     If (LimitSelectBoundsImg=1)
     {
        If (imgSelX1<0)
           imgSelX1 := 0
        If (imgSelY1<0)
           imgSelY1 := 0
 
        If (imgSelX2<2)
           imgSelX2 := 2
        If (imgSelY2<2)
           imgSelY2 := 2
     }

     nImgSelX1 := min(imgSelX1, imgSelX2)
     nImgSelY1 := min(imgSelY1, imgSelY2)
     nimgSelX2 := max(imgSelX1, imgSelX2)
     nimgSelY2 := max(imgSelY1, imgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
     kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
     kimgSelRatio := Round(kimgSelW/kimgSelH, 2)

     If (lockSelectionAspectRatio>0 && kimgSelRatio!=Round(desiredSelAspectRatio, 2) && desiredSelAspectRatio && !adjustingSelDotNow)
     {
        If (nimgSelX1<=2 && (nimgSelX2 > maxSelX - 3) && LimitSelectBoundsImg=1)
        {
           nImgSelX1 := 0
           nimgSelX2 := maxSelX
           nimgSelY2 := nimgSelY1 + Round(maxSelX/desiredSelAspectRatio)
        } Else
        {
           avgWH := min(kimgSelW, kimgSelH)
           nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
           nimgSelY2 := nimgSelY1 + avgWH
           If (LimitSelectBoundsImg=1 && nImgSelX2>maxSelX)
           {
              tX2 := Abs(nImgSelX2 - maxSelX)
              rescaleu := 1 - tX2/avgWH
              avgWH := Floor(min(kimgSelW, kimgSelH)*rescaleu)
              nimgSelX2 := nimgSelX1 + Round(avgWH*desiredSelAspectRatio)
              nimgSelY2 := nimgSelY1 + avgWH
              zuzu := maxSelX - nImgSelX2
              If (nimgSelX1>2)
              {
                 nImgSelX1 += zuzu
                 nImgSelY1 += zuzu
                 nimgSelX2 += zuzu
                 nimgSelY2 += zuzu
              }              ; ToolTip, % nImgSelX2 "==" tX2 "==" rescaleu , , , 2
           }
        }
     }

     If (kimgSelW>32500)
        nImgSelX2 := nImgSelX1 + 32500
     If (kimgSelH>32500)
        nImgSelY2 := nImgSelY1 + 32500
     If (kimgSelH*kimgSelW>23125**2)
     {
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        scaleu := (kimgSelH*kimgSelW)/(23125**2)
        nImgSelX2 := nImgSelX1 + Floor(kimgSelW/scaleu)
        nImgSelY2 := nImgSelY1 + Floor(kimgSelH/scaleu)
        kimgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
        kimgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
        If (kimgSelW>32500)
           nImgSelX2 := nImgSelX1 + 32500
        If (kimgSelH>32500)
           nImgSelY2 := nImgSelY1 + 32500
     }

     If (editingSelectionNow=1)
        defineRelativeSelCoords(maxSelX, maxSelY)

     If (LimitSelectBoundsImg=1)
        capSelectionRelativeCoords()

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)

     minSizu := SelDotsSize*2
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<minSizu)
        vPimgSelW := minSizu
     If (vPimgSelH<minSizu)
        vPimgSelH := minSizu

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)

     minMargin := (mainWidth*0.025 + mainHeight*0.205)//2
     imgSelLargerViewPort := (vPimgSelPx<minMargin && vPimgSelPy<minMargin) && (vPimgSelPx + vPimgSelW>mainWidth - minMargin) && (vPimgSelPy + vPimgSelH>mainHeight - minMargin) ? 1 : 0
     imgSelOutViewPort := 0
     If (vPimgSelPx>mainWidth - minSizu)
     {
        vPimgSelPx := mainWidth - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy>mainHeight - minSizu)
     {
        vPimgSelPy := mainHeight - minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPx + vPimgSelW<minSizu)
     {
        vPimgSelW := minSizu*2
        vPimgSelPx := -minSizu
        imgSelOutViewPort := 1
     }

     If (vPimgSelPy + vPimgSelH<minSizu)
     {
        vPimgSelH := minSizu*2
        vPimgSelPy := -minSizu
        imgSelOutViewPort := 1
     }

     dotsSize := SelDotsSize
     selDotX := vPimgSelPx - dotsSize//2
     selDotY := vPimgSelPy - dotsSize//2
     selDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotBx := vPimgSelPx + vPimgSelW - dotsSize//2
     selDotBy := vPimgSelPy - dotsSize//2
     selDotCx := vPimgSelPx - dotsSize//2
     selDotCy := vPimgSelPy + vPimgSelH - dotsSize//2
     selDotDx := vPimgSelPx + vPimgSelW//2 - dotsSize//2
     selDotDy := vPimgSelPy + vPimgSelH//2 - dotsSize//2

     If (AnyWindowOpen=31 && PasteInPlaceToolMode=1 && imgEditPanelOpened=1)
        prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY)
}

prevModeViewPortSelectionManager(dpX, dpY, maxSelX, maxSelY) {
     If (LimitSelectBoundsImg=1)
     {
        If (previmgSelX1<0)
           previmgSelX1 := 0
        If (previmgSelY1<0)
           previmgSelY1 := 0
 
        If (previmgSelX2<2)
           previmgSelX2 := 2
        If (previmgSelY2<2)
           previmgSelY2 := 2
     }

     nImgSelX1 := min(previmgSelX1, previmgSelX2)
     nImgSelY1 := min(previmgSelY1, previmgSelY2)
     nimgSelX2 := max(previmgSelX1, previmgSelX2)
     nimgSelY2 := max(previmgSelY1, previmgSelY2)

     If (LimitSelectBoundsImg=1)
     {
        If (nImgSelX1>maxSelX)
           nImgSelX1 := maxSelX - 5
        If (nImgSelY1>maxSelY)
           nImgSelY1 := maxSelY - 5
        If (nImgSelX2>maxSelX)
           nImgSelX2 := maxSelX
        If (nImgSelY2>maxSelY)
           nImgSelY2 := maxSelY
     }

     zImgSelX1 := Round(nImgSelX1*zoomLevel)
     zImgSelX2 := Round(nImgSelX2*zoomLevel)
     zImgSelY1 := Round(nImgSelY1*zoomLevel)
     zImgSelY2 := Round(nImgSelY2*zoomLevel)
     vPimgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
     vPimgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
     If (vPimgSelW<2)
        vPimgSelW := 2
     If (vPimgSelH<2)
        vPimgSelH := 2

     vPimgSelPx := dpX + min(zImgSelX1, zImgSelX2)
     vPimgSelPy := dpY + min(zImgSelY1, zImgSelY2)
     dotsSize := SelDotsSize
     prevSelDotX := vPimgSelPx - dotsSize//2
     prevSelDotY := vPimgSelPy - dotsSize//2
     prevSelDotAx := vPimgSelPx + vPimgSelW - dotsSize//2
     prevSelDotAy := vPimgSelPy + vPimgSelH - dotsSize//2
}

createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, ellipse) {
   ImgSelPath := Gdip_CreatePath()
   If (ellipse=1)
     Gdip_AddPathEllipse(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   Else
     Gdip_AddPathRectangle(ImgSelPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
   Sleep, -1
   Return ImgSelPath
}

drawImgSelectionOnWindow(operation, theMsg:="", colorBox:="", dotActive:="", mainWidth:=0, mainHeight:=0, newW:=0, newH:=0, DestPosX:=0, DestPosY:=0) {
     Static prevMsg, infoBoxBMP, lineThickns, infoW, infoH, pBr0, zPen
          , infoPosX, infoPosY, prevuDPx, prevuDPy, prevNewW, prevNewH

     SelDotsSize := dotsSize := (PrefsLargeFonts=1) ? imgHUDbaseUnit//3 : imgHUDbaseUnit//3.25
     maxSelX := prevMaxSelX, maxSelY := prevMaxSelY
     ; ForceRefreshNowThumbsList()
     If (operation="return")
     {
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        operation := "active"
        newW := prevNewW, newH := prevNewH
        ; DestPosX := prevuDPx, DestPosY := prevuDPy
        DestPosX := prevDestPosX, DestPosY := prevDestPosY
        ; clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
     }

     If !zPen
     {
        zPen := Gdip_CreatePen("0x99446644", imgHUDbaseUnit//10)
        ; Gdip_SetPenDashArray(zPen, "0.2,0.2")
     }

     If (AnyWindowOpen=26 && tinyPrevAreaCoordX="C")
        updateTinyPreviewArea(DestPosX, DestPosY, newW, newH)

     If (operation="init")
     {
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        If StrLen(hitTestSelectionPath)>1
        {
           Gdip_DeletePath(hitTestSelectionPath)
           hitTestSelectionPath := ""
        }

        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        setMainCanvasTransform(mainWidth, mainHeight, 2NDglPG)
        InfoW := InfoH := ""
        lineThickns := imgHUDbaseUnit//9
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//13)
     } Else If (operation="prev")
     {
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)
        clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns :=  imgHUDbaseUnit//10
        Gdip_SetPenWidth(pPen1, lineThickns)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevDestPosX, prevDestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
        If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=24)
           Gdip_RotatePathAtCenter(ImgSelPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)

        Gdip_SetClipRect(2NDglPG, 0, 0, mainWidth, mainHeight)
        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//7)
        Gdip_DrawPath(2NDglPG, zPen, ImgSelPath)
        Gdip_DrawPath(2NDglPG, pPen1, ImgSelPath)
        ; If (imgEditPanelOpened!=1)
        ; {
        ;    Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        ;    Gdip_FillRectangle(2NDglPG, pBrushF, 0, 0, mainWidth, mainHeight)
        ;    Gdip_ResetClip(2NDglPG)
        ; }

        Gdip_ResetClip(2NDglPG)
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="active")
     {
        prevNewH := newH, prevNewW := newW
        prevuDPx := DestPosX, prevuDPy := DestPosY
        lineThickns := (editingSelectionNow!=1) ? imgHUDbaseUnit//13 : imgHUDbaseUnit//9

        Gdip_SetPenWidth(zPen, imgHUDbaseUnit//12)
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight)

        ViewPortSelectionManageCoords(mainWidth, mainHeight, DestPosX, DestPosY, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 

        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
        If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=24)
           Gdip_RotatePathAtCenter(ImgSelPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)

        pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        whichPen := (EllipseSelectMode=1) ? zPen : pPen
        Gdip_DrawPath(2NDglPG, whichPen, ImgSelPath)
        ; If (EllipseSelectMode=1) || ((showSelectionGrid=1 || imgSelLargerViewPort=1) && (EllipseSelectMode!=1))
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (EllipseSelectMode=1)
           Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        thisExterior := (editingSelectionNow=1) ? pBrushE : pBrushF
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1)
           Gdip_FillRectangle(2NDglPG, pBrushF, 0, 0, mainWidth, mainHeight)
        If (editingSelectionNow=1)
        {
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
           If (imgEditPanelOpened!=1)
              Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        }

        Gdip_ResetClip(2NDglPG)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           If (imgSelLargerViewPort=1)
           {
              Gdip_DrawRectangle(2NDglPG, whichPen, 1, 1, mainWidth - 1, mainHeight - 1)
              Gdip_DrawRectangle(2NDglPG, pPen, mainWidth*0.15, mainHeight*0.15, mainWidth - mainWidth*0.3, mainHeight - mainHeight*0.3)
           }
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        If (editingSelectionNow=1)
        {
           If StrLen(hitTestSelectionPath)>1
           {
              Gdip_DeletePath(hitTestSelectionPath)
              hitTestSelectionPath := ""
           }

           If (FlipImgV=1)
              imgSelPy := mainHeight - imgSelPy - imgSelH
           If (FlipImgH=1)
              imgSelPx := mainWidth - imgSelPx - imgSelW

           If (imgSelLargerViewPort!=1)
           {
              hitTestSelectionPath := Gdip_CreatePath()
              Gdip_AddPathRectangle(hitTestSelectionPath, imgSelPx, imgSelPy, imgSelW, imgSelH)
           }
           whichFunc := (vPselRotation!=0) ? "Ellipse" : "Rectangle"
           ; Gdip_RotatePathAtCenter(hitTestSelectionPath, vPselRotation)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
           Gdip_Fill%whichFunc%(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
           If (vPselRotation!=0)
              Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx - dotsSize/3.5, SelDotDy - dotsSize/3.5, dotsSize*1.5, dotsSize*1.5)
           Gdip_FillEllipse(2NDglPG, pBrushE, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)
     } Else If (operation="live")
     {
        lineThickns := imgHUDbaseUnit/9
        trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBGRcolor, 1)
        ViewPortSelectionManageCoords(mainWidth, mainHeight, prevuDPx, prevuDPy, maxSelX, maxSelY, nImgSelX1, nImgSelY1, nImgSelX2, nImgSelY2, zImgSelX1, zImgSelY1, zImgSelX2, zImgSelY2, imgSelW, imgSelH, imgSelPx, imgSelPy)
        imgSelX1 := nImgSelX1, imgSelY1 := nImgSelY1 
        imgSelX2 := nimgSelX2, imgSelY2 := nimgSelY2 
        ImgSelPath := createImgSelPath(imgSelPx, imgSelPy, imgSelW, imgSelH, EllipseSelectMode)
        If (imgEditPanelOpened!=1 || AnyWindowOpen=10 || AnyWindowOpen=25 || AnyWindowOpen=31 || AnyWindowOpen=24)
           Gdip_RotatePathAtCenter(ImgSelPath, vPselRotation, 1, 1, rotateSelBoundsKeepRatio)

        Gdip_SetPenWidth(pPen1d, lineThickns//2 + 1)
        Gdip_SetClipPath(2NDglPG, ImgSelPath, 4)
        If (imgEditPanelOpened!=1)
           Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, mainHeight)
        Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        Gdip_DrawLine(2NDglPG, zPen, zImgSelX1 + prevDestPosX, 0, zImgSelX1 + prevDestPosX, mainHeight)
        Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY1 + prevDestPosY, mainWidth, zImgSelY1 + prevDestPosY)
        Gdip_DrawLine(2NDglPG, zPen, zImgSelX2 + prevDestPosX, 0, zImgSelX2 + prevDestPosX, mainHeight)
        Gdip_DrawLine(2NDglPG, zPen, 0, zImgSelY2 + prevDestPosY, mainWidth, zImgSelY2 + prevDestPosY)
        Gdip_DrawRectangle(2NDglPG, pPen1d, imgSelPx, imgSelPy, imgSelW, imgSelH)
        pathBounds := Gdip_GetPathWorldBounds(ImgSelPath)
        Gdip_DrawRectangle(2NDglPG, zPen, pathBounds.x, pathBounds.y, pathBounds.w, pathBounds.h)
        Gdip_ResetClip(2NDglPG)
        If (IMGlargerViewPort!=1)
           Gdip_DrawRectangle(2NDglPG, pPen4, prevuDPx, prevuDPy, prevResizedVPimgW, prevResizedVPimgH)

        If (imgSelW>125 && imgSelH>125 && noTooltipMSGs=0 && minimizeMemUsage!=1 && dotActive!=10 && !InStr(theMsg, "offset"))
        {
           cornersPreview := coreCaptureImgCorners(useGdiBitmap(), 6, 100)
           Gdip_GetImageDimensions(cornersPreview, cImgW, cImgH)
           cX := imgSelPx + imgSelW//2 - cImgW//2
           cY := imgSelPy + imgSelH//2 - cImgH//2
           cX := clampInRange(cX, 0, mainWidth - cImgW)
           cY := clampInRange(cY, 0, mainHeight - cImgH)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, cornersPreview, cX, cY)
           trGdip_DisposeImage(cornersPreview, 1)
        }

        If (noTooltipMSGs=0 && minimizeMemUsage!=1)
        {
            If (dotActive=10)
            {
               theMsg := SubStr(theMsg, InStr(theMsg, "rotation"))
               fScale := 0.9
            } Else fScale := 1.3

           infoBoxBMP := drawTextInBox(theMsg, OSDFontName, OSDfntSize//fScale, mainWidth//2, mainHeight//2, OSDtextColor, OSDbgrColor, 1, 1)
           colorBoxH := colorBox ? imgHUDbaseUnit//7 : 1
           Gdip_GetImageDimensions(infoBoxBMP, infoW, infoH)
           If (imgSelPy + imgSelH + 5 < mainHeight - infoH)
           {
              infoPosY := (imgSelPy + imgSelH<5) ? 5 : imgSelPy + imgSelH + 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           } Else
           {
              otherPos := 1
              infoPosY := (imgSelPy - infoH - colorBoxH <20) ? 5 : imgSelPy - infoH - colorBoxH - 20
              If (infoPosY + infoH + colorBoxH>mainHeight)
                 infoPosY := mainHeight - infoH - colorBoxH
           }
 
           If (dotActive=4 || otherPos=1) && (dotActive!=3)
           {
              infoPosX := imgSelPx  + imgSelW - infoW - 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           } Else
           { 
              infoPosX := (imgSelPx<5) ? 5 : imgSelPx + 25
              If (infoPosX + infoW>mainWidth)
                 infoPosX := mainWidth - infoW
           }
 
           If colorBox
           {
              pBr0 := Gdip_BrushCreateSolid(colorBox)
              Gdip_FillRectangle(2NDglPG, pBr0, infoPosX, infoPosY + infoH, infoW, colorBoxH)
              Gdip_DeleteBrush(pBr0)
           }
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, infoPosX, infoPosY,,,,,,, 0.8)
           infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        }

        ; Gdip_FillRectangle(2NDglPG, pBrushC, imgSelPx, imgSelPy, imgSelW, imgSelH)
        If (showSelectionGrid=1 || imgSelLargerViewPort=1 || EllipseSelectMode=1)
        {
           whichPen := (EllipseSelectMode=1) ? pPen : zPen
           ; Gdip_DrawEllipse(2NDglPG, zPen, imgSelPx, imgSelPy, imgSelW, imgSelH)
        }
        pPen := (editingSelectionNow=1) ? pPen1d : pPen1
        Gdip_SetPenWidth(pPen, lineThickns)
        Gdip_DrawPath(2NDglPG, pPen, ImgSelPath)

        If (showSelectionGrid=1 || imgSelLargerViewPort=1)
        {
           Gdip_SetClipRect(2NDglPG, imgSelPx, imgSelPy, imgSelW, imgSelH, 0)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx + Round(imgSelW * 0.33), imgSelPy - 900, imgSelW - Round(imgSelW * 0.33) * 2, imgSelH + 2000)
           Gdip_DrawRectangle(2NDglPG, zPen, imgSelPx - 900, imgSelPy + Round(imgSelH * 0.33), imgSelW + 2000, imgSelH - Round(imgSelH * 0.33) * 2)
           Gdip_ResetClip(2NDglPG)
        }

        Gdip_FillRectangle(2NDglPG, pBrushD, selDotX, selDotY, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotAx, SelDotAy, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotBx, SelDotBy, dotsSize, dotsSize)
        Gdip_FillRectangle(2NDglPG, pBrushD, SelDotCx, SelDotCy, dotsSize, dotsSize)
        If (dotActive=10)
        {
            ; Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize*2, dotsSize*2)
            Gdip_FillEllipse(2NDglPG, pBrushD, SelDotDx, SelDotDy, dotsSize, dotsSize)
        }
        If StrLen(ImgSelPath)>2
           Gdip_DeletePath(ImgSelPath)

        If (imgEditPanelOpened=1 && AnyWindowOpen!=10)
        {
           r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
           livePreviewsImageEditing()
        } Else r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
     } Else If (operation="end")
     {
        InfoW := InfoH := ""
        ; Gdip_ResetWorldTransform(2NDglPG)
        infoBoxBMP := trGdip_DisposeImage(infoBoxBMP, 1)
        If pBr0
        {
           Gdip_DeleteBrush(pBr0)
           pBr0 := ""
        }

        Gdip_ResetWorldTransform(2NDglPG)
        SetTimer, dummyRefreshImgSelectionWindow, -25
     }
     If (AnyWindowOpen=26)
     {
        ImageCoords2Window(tinyPrevAreaCoordX, tinyPrevAreaCoordY, DestPosX, DestPosY, dotsSize*2, outX, outY)
        Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, dotsSize*2, dotsSize*2)
        Gdip_FillRectangle(2NDglPG, pBrushE, outX, outY, dotsSize*2, dotsSize*2)
     }
}

dummyRefreshImgSelectionWindow() {
     Static prevStatus
     If (editingSelectionNow=1 && IMGresizingMode=5)
     {
        thisu := 1
        IMGresizingMode := 1
     }

     If (imgSelX2=-1 && imgSelY2=-1 && editingSelectionNow=1) || (thisu=1)
     {
        dummyTimerDelayiedImageDisplay(25)
        Return
     }

     GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
     If (drawingShapeNow=1)
        GetMouseCoord2wind(PVhwnd, mX, mY)

     thisState := "a" mX mY mainWidth mainHeight closedLineCustomShape tensionCurveCustomShape cardinalCurveCustomShape
     If (thisState!=prevStatus) || (drawingShapeNow!=1)
     {
        ; ToolTip, % thisState " -- " A_TickCount , , , 2
        additionalHUDelements(3, mainWidth, mainHeight)
        prevStatus := thisState
     }
}

QPV_ShowImgonGui(newW, newH, mainWidth, mainHeight, usePrevious, imgPath, ForceIMGload, hasFullReloaded, gdiBMPchanged, ByRef wasPrevious) {
    Critical, on
    Static IDviewPortCache, PREVtestIDvPcache
    If (ForceIMGload=1)
       IDviewPortCache := PREVtestIDvPcache := ""

    prevLoadedImageIndex := currentFileIndex
    createGDIPcanvas(mainWidth, mainHeight)
    testIDvPcache := imgPath zoomLevel IMGresizingMode imageAligned IMGdecalageX IMGdecalageY mainWidth mainHeight desiredFrameIndex gdiBitmap
    If (CountGIFframes>1 && !AnyWindowOpen && animGIFsSupport=1 && prevAnimGIFwas!=imgPath)
       mustPlayAnim := 1
    Else
       DestroyGIFuWin()

    If StrLen(gdiBMPvPsize)>3
    {
       Gdip_GetImageDimensions(gdiBMPvPsize, gImgW, gImgH)
    } Else
    {
       gImgW := mainWidth
       gImgH := mainHeight
    }

    totalNewSize := newW//2 + newH//2
    totalVPsize := mainWidth//2 + mainHeight//2
    totalVPcacheSize := gImgW//2 + gImgH//2
    gdiSmallSize := determineGDIsmallCacheSize()
    totalMainGDIsize := gdiSmallSize.TGDI
    If (usePrevious=1)
    {
       smallestSize := min(totalVPcacheSize, gdiSmallSize.T)
       largestSize := max(totalVPcacheSize, gdiSmallSize.T)
       If (totalNewSize>smallestSize*16)
          mustGenerate := (largestSize=totalVPcacheSize) ? 1 : 2
       Else
          mustGenerate := (smallestSize=totalVPcacheSize) ? 1 : 2

       If (totalNewSize>totalMainGDIsize*6)
       {
          whichBitmap := gdiBitmap
          mustGenerate := 0
       }
       ; msgbox, % "lol " mustGenerate
    } Else
    {
       Strarrayu := Round(totalVPcacheSize*2) "|" gdiBMPvPsize "|1`n"
       Strarrayu .= gdiSmallSize.T "|" gdiBitmapSmall "|2`n"
       Strarrayu .= totalMainGDIsize "|" gdiBitmap "|0`n"
       Strarrayu .= totalNewSize "|new|0"
       Sort, Strarrayu, ND`n
       arrayu := StrSplit(Strarrayu, "`n")
       Loop, 6
       {
            If InStr(arrayu[A_Index], "|new")
            {
               thisIndex := A_Index
               Break
            }
       }
       If (thisIndex=4)
          ItemArrayu := StrSplit(arrayu[3], "|")
       Else
          ItemArrayu := StrSplit(arrayu[thisIndex + 1], "|")
       ; MsgBox, % Strarrayu "`nlol" thisIndex
       mustGenerate := ItemArrayu[3]
    }
    If (IMGresizingMode=3 || zoomLevel=1)
       mustGenerate := 0
    If (mustGenerate=1 && minimizeMemUsage=1 && usePrevious=1)
       mustGenerate := 2
    If (minimizeMemUsage=1 && usePrevious!=1)
       mustGenerate := 0

    If (mustGenerate=1)
       whichBitmap := RescaleBMPtinyVPsize(mainWidth, mainHeight)
    Else If (mustGenerate=2)
       whichBitmap := RescaleBMPtiny()
    Else
       whichBitmap := gdiBitmap

    ; Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    ; ToolTip, % "lol " mustGenerate "`n" imgW "--" imgH , , , 2
    If (usePrevious=1 && testIDvPcache!=PREVtestIDvPcache) || (mustPlayAnim=1) || (imgFxMode=8 && currIMGdetails.HasAlpha=1 && RenderOpaqueIMG!=1)
    {
       ; SoundBeep , 900, 100
       If (skipSeenImagesSlider=1 && gdiBMPchanged=1)
          recordSeenIMGdbEntry(imgPath, currentFileIndex)

       wasPrevious := usePrevious
       IDviewPortCache := PREVtestIDvPcache := ""
       r := QPV_ShowImgonGuiPrev(whichBitmap, newW, newH, mainWidth, mainHeight, usePrevious, imgPath)
       oldZoomLevel := ""
       interfaceThread.ahkassign("canCancelImageLoad", 0)
       Return r
    } Else wasPrevious := 0

    interfaceThread.ahkassign("canCancelImageLoad", 0)
    startZeit := A_TickCount
    oldZoomLevel := matrix := ""
    prevDrawingMode := 1
    Gdip_GetImageDimensions(whichBitmap, imgW, imgH)
    calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY)
    remDestPosX := DestPosX - prevDestPosX
    remDestPosY := DestPosY - prevDestPosY
    If (diffIMGdecX || diffIMGdecY) && (remDestPosX || remDestPosY)
    {
       diffIMGdecX := remDestPosX
       diffIMGdecY := remDestPosY
    } Else diffIMGdecX := diffIMGdecY := 0
    If (minimizeMemUsage=1)
       diffIMGdecX := diffIMGdecY := 0

    If !(currIMGdetails.HasAlpha=1 && RenderOpaqueIMG=1)
       zL := (zoomLevel<1) ? 1 : zoomLevel*2

    dpX := clampInRange(DestPosX + 1, 0, mainWidth)
    dpY := clampInRange(DestPosY + 1, 0, mainHeight)
    kW := clampInRange(newW - 2, 0, mainWidth)
    kH := clampInRange(newH - 2, 0, mainHeight)
    Gdip_ResetClip(glPG)
    If (imgFxMode!=8)
    {
       If (currIMGdetails.HasAlpha=1 && RenderOpaqueIMG!=1)
          zr := Gdip_FillRectangle(glPG, useHatchedBrush("vp"), dpX, dpY, kW, kH)
    }

    ; ToolTip, % zr "rr==" gdipLastError "==" currIMGdetails.HasAlpha "==" undoLevelsArray[currentUndoLevel, 5] "==" pBrushHatchLow, , , 2
    thisIDviewPortCache := imgPath zoomLevel IMGresizingMode imageAligned IMGdecalageX IMGdecalageY mainWidth mainHeight usePrevious desiredFrameIndex gdiBitmap whichBitmap
    If (thisIDviewPortCache!=IDviewPortCache || !ViewPortBMPcache || CountGIFframes>1) && (usePrevious!=1)
    {
       prevDestPosX := DestPosX
       prevDestPosY := DestPosY
       canvasClipped := (diffIMGdecX || diffIMGdecY) && (IMGresizingMode=4) ? 1 : 0
       nZL := (zoomLevel<1) ? 1 : zoomLevel / 2
       marginErr := (canvasClipped=1) ? 1.25*nZL : 0
       thisMainWidth := (canvasClipped=1 && diffIMGdecX) ? Abs(diffIMGdecX) + 1 : mainWidth
       thisMainHeight := (canvasClipped=1 && diffIMGdecY) ? Abs(diffIMGdecY) + marginErr : mainHeight
       If (thisMainWidth<mainWidth && thisMainHeight<mainHeight)
       {
          ignoreSomeOptimizations := 1
          thisMainWidth := mainWidth
          thisMainHeight := mainHeight
       }

       If ((newW>thisMainWidth) || (newH>thisMainHeight))
       {
          x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
          PointX1 := (x1*imgW)
          y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
          PointY1 := (y1*imgH)
          prcW := thisMainWidth/newW
          prcH := thisMainHeight/newH
          oPrcW := (mainWidth - thisMainWidth)/newW
          oPrcH := (mainHeight - thisMainHeight)/newH
          If (diffIMGdecX<0 && canvasClipped=1 && ignoreSomeOptimizations!=1)
             PointX1 := (PointX1 + imgW*oPrcW)
          If (diffIMGdecY<0 && canvasClipped=1 && ignoreSomeOptimizations!=1)
             PointY1 := (PointY1 + imgH*oPrcH)
          PointX2 := (PointX1 + imgW*prcW)
          PointY2 := (PointY1 + imgH*prcH)
          If (PointX2>imgW)
             PointX2 := imgW
          If (PointY2>imgH)
             PointY2 := imgH
       } ; Else r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, DestPosX, DestPosY, newW, newH, 0, 0, imgW, imgH, matrix, 2, imageAttribs)

       dPosX := (newW>thisMainWidth) ? 0 : DestPosX
       If (canvasClipped=1 && thisMainWidth!=mainWidth && diffIMGdecX<0)
          dPosX := mainWidth - thisMainWidth
 
       dPosY := (newH>thisMainHeight) ? 0 : DestPosY
       If (canvasClipped=1 && thisMainHeight!=mainHeight && diffIMGdecY<0)
          dPosY := mainHeight - thisMainHeight 
 
       dW := (newW>thisMainWidth) ? thisMainWidth : newW
       dH := (newH>thisMainHeight) ? thisMainHeight : newH
       If (canvasClipped=1 && thisMainHeight!=mainHeight && userimgQuality=0)
          dH += nZL

       sPosX := (newW>thisMainWidth) ? (PointX1) : 0
       sPosY := (newH>thisMainHeight) ? (PointY1) : 0
       sW := (newW>thisMainWidth) ? (PointX2 - PointX1) : imgW
       sH := (newH>thisMainHeight) ? (PointY2 - PointY1) : imgH
       If (canvasClipped=1 && ignoreSomeOptimizations=1)
       {
          If ViewPortBMPcache
             r0 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache)
          Gdip_SetClipRect(glPG, diffIMGdecX, diffIMGdecY, mainWidth, mainHeight, 4)
       }
       r1 := trGdip_DrawImage(A_ThisFunc, glPG, whichBitmap, dPosX, dPosY, dW, dH, sPosX, sPosY, sW, sH,,2)
       ; Tooltip, % dPosX "," dPosY "|" dW "," dH "`n" sPosX "," sPosY "|" sW "," sH "`n" newW "," newH "|" thisMainWidth "," thisMainHeight "|" mainWidth "," mainHeight "`n" diffIMGdecX "," diffIMGdecY " || " canvasClipped "," ignoreSomeOptimizations
       If (canvasClipped=1 && ignoreSomeOptimizations=1)
          Gdip_ResetClip(glPG)

       ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
       ; mustDisplay := 1
       If (usePrevious!=1)
       {
          If (IMGresizingMode=4 && canvasClipped=1 && ViewPortBMPcache)
          {
             prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)
             prevGDIvpCache := trGdip_CloneBitmap(A_ThisFunc, ViewPortBMPcache)
          }

          ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
          IDviewPortCache := thisIDviewPortCache
          PREVtestIDvPcache := testIDvPcache
          ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       }
    } ; Else mustDisplay := 1
    ; tooltip, % dontMove " - " diffIMGdecX " - " diffIMGdecY " - " r3

    If (diffIMGdecX || diffIMGdecY) && (prevGDIvpCache && canvasClipped=1)
    {
       r3 := trGdip_DrawImage(A_ThisFunc, glPG, prevGDIvpCache, diffIMGdecX, diffIMGdecY)
       mustRecache := 1
    }

    diffIMGdecX := diffIMGdecY := 0
    If (mustRecache=1)
    {
       ViewPortBMPcache := trGdip_DisposeImage(ViewPortBMPcache, 1)
       ViewPortBMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
    } Else prevGDIvpCache := trGdip_DisposeImage(prevGDIvpCache, 1)

    setMainCanvasTransform(mainWidth, mainHeight)
    confirmTexBGR := (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270) ? 1 : 0

    ; Gdip_SetClipRect(glPG, DestPosX, DestPosY, newW, newH)
    Gdip_SetClipRect(glPG, 0, 0, mainWidth, mainHeight, 0)
    decideGDIPimageFX(matrix, imageAttribs, pEffect)
    If !pEffect ; && imageAttribs)
       r4 := trGdip_DrawImage(A_ThisFunc, glPG, ViewPortBMPcache,,,,,,,,,,, imageAttribs)
    Else ; If (pEffect || imageAttribs)
       r4 := trGdip_DrawImageFX(A_ThisFunc, glPG, ViewPortBMPcache, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)

    Gdip_SetClipRect(glPG, DestPosX + 1, DestPosY + 1, newW - 2, newH - 2, 4)
    If (usrTextureBGR=1 && confirmTexBGR=1)
    {
       Gdip_FillRectangle(glPG, AmbientalTexBrush, 0, 0, mainWidth, mainHeight)
       ; pBrush := Gdip_BrushCreateSolid("0x11000000")
       ; Gdip_FillRectangle(glPG, pBrush, 0, 0, mainWidth, mainHeight)
       ; Gdip_DeleteBrush(pBrush)
    } Else trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)

    Gdip_ResetClip(glPG)
    drawHUDelements(1, mainWidth, mainHeight, newW, newH, DestPosX, DestPosY, imgPath)
    Gdip_ResetWorldTransform(glPG)
    If (minimizeMemUsage!=1 && slideShowRunning=1 && doSlidesTransitions=1 && slideShowDelay>950 && GDIfadeVPcache && animGIFplaying!=1)
    {
       setWindowTitle(pVwinTitle, 1)
       ForceRefreshNowThumbsList()
       tempBMP := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
       ToggleVisibilityWindow("show", hGDIthumbsWin)

       trGdip_DrawImage(A_ThisFunc, glPG, GDIfadeVPcache)
       r2 := LrydWinUpdt(hGDIwin, glHDC)
       Loop, 255
       {
           opacity := 255 - A_Index*12
           If (opacity<2)
              Break

           dummyPos := (A_OSVersion!="WIN_7") ? 0 : ""
           r2 := UpdateLayeredWindow(hGDIwin, glHDC, dummyPos, dummyPos, mainWidth, mainHeight, opacity)
           Sleep, 1
       }
       trGdip_DrawImage(A_ThisFunc, glPG, tempBMP)
       trGdip_DisposeImage(tempBMP, 1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBGRcolor)
       imageHasFaded := 1
    }

    r2 := LrydWinUpdt(hGDIwin, glHDC)
    If (imageHasFaded=1)
       r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)

    If pEffect
       Gdip_DisposeEffect(pEffect)

    If imageAttribs
       Gdip_DisposeImageAttributes(imageAttribs)

    if (r0!=0)
       fR := r0
    Else if (r1!=0)
       fR := r1
    Else if (r3!=0)
       fR := r3
    Else if (r4!=0)
       fR := r4

    If (fR!=0)
       r := Gdip_ErrorHandler(fR, 0, A_ThisFunc)
    Else If !r2
       r := "UpdateLayeredWindow_Error"

    totalZeit := A_TickCount - startZeitIMGload
    thisZeit := A_TickCount - startZeit
    If (totalZeit<150)
       prevFastDisplay := A_TickCount

    ; prevFullIMGload := A_TickCount
    LastPrevFastDisplay := (totalZeit<125 && usePrevious=0) ? 1 : 0
    PannedFastDisplay := (thisZeit<100 && usePrevious=0 && canvasClipped=1) || (canvasClipped!=1 && minimizeMemUsage!=1) ? 1 : 0
    drawModeAzeit := A_TickCount - startZeit
    If (hasFullReloaded=1 && imageHasFaded!=1)
    {
       fullLoadZeit := A_TickCount - startZeitIMGload
       fullLoadZeit2 := (fullLoadZeit + drawModeCzeit)//2
       drawModeCzeit := max(fullLoadZeit, fullLoadZeit2)
    }
    If (skipSeenImagesSlider=1 && gdiBMPchanged=1 && !InStr(r, "error"))
       recordSeenIMGdbEntry(imgPath, currentFileIndex)

    ; ToolTip, % thisZeit ", " totalZeit ", " drawModeCzeit "==" prevGDIvpCache ,,,2
    Return r
}

getCaptionStyle(hwnd) {
  WinGet, Stylu, Style, ahk_id %hwnd%
  r := (Stylu & 0xC00000) ? 0 : 1
  Return r
}

getTopMopStyle(hwnd) {
  WinGet, Stylu, ExStyle, ahk_id %hwnd%
  r := (Stylu & 0x8) ? 1 : 0
  Return r
}

updateUIctrl() {
    interfaceThread.ahkassign("editingSelectionNow", editingSelectionNow)
    interfaceThread.ahkassign("isAlwaysOnTop", isAlwaysOnTop)
    interfaceThread.ahkPostFunction("updateUIctrl")
}

selectAllFiles() {
    Static selMode := 0
    If (maxFilesIndex<3)
       Return

    selMode := !selMode
    selectFilesRange(1, maxFilesIndex, selMode)
    markedSelectFile := (selMode=1) ? maxFilesIndex : 0
    SetTimer, mainGdipWinThumbsGrid, -10
}

ToggleEditImgSelection(dummy:=0) {
  Critical, on
  imgPath := getIDimage(currentFileIndex)
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  DestroyGIFuWin()
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  ; If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (getCaptionStyle(PVhwnd)=1)
     ToggleTitleBaruNow()

  editingSelectionNow := (dummy="show-edit") ? 1 : !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  MouseMoveResponder()
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

selectEntireImage(act:=0) {
   imgPath := getIDimage(currentFileIndex)
   If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD) || !imgPath
      Return

   If (getCaptionStyle(PVhwnd)=1)
      ToggleTitleBaruNow()

   DestroyGIFuWin()
   If (slideShowRunning=1)
      ToggleSlideShowu()

   If (editingSelectionNow=1)
      recordSelUndoLevelNow()

   vpr := vPselRotation
   Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
   If (ImgSelX2=imgW && imgSelY2=imgH
   && imgSelX1=0 && imgSelY1=0 && editingSelectionNow=1)
   {
      resetImgSelection()
      If (act="r" && imgEditPanelOpened!=1)
         Return
   } Else
   {
      ImgSelX2 := imgW, imgSelY2 := imgH
      imgSelX1 := imgSelY1 := 0
   }

   vPselRotation := vpr
   editingSelectionNow := 1
   updateUIctrl()
   clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
   ; SetTimer, MouseMoveResponder, -50
   SetTimer, dummyRefreshImgSelectionWindow, -25
   ; dummyTimerDelayiedImageDisplay(25)
}

changeSelectZoom(direction) {
    If (editingSelectionNow!=1 || thumbsDisplaying=1)
       Return

    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)
    If (direction=-1)
    {
       imgSelW -= Round(imgSelW*0.02)
       imgSelH -= Round(imgSelH*0.02)
       imgSelX1 += Round(imgSelW*0.01)
       imgSelY1 += Round(imgSelH*0.01)
    } Else
    {
       imgSelW += Round(imgSelW*0.02)
       imgSelH += Round(imgSelH*0.02)
       imgSelX1 -= Round(imgSelW*0.01)
       imgSelY1 -= Round(imgSelH*0.01)
    }

    imgSelX2 := Round(imgSelX1 + imgSelW)
    imgSelY2 := Round(imgSelY1 + imgSelH)
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

arrowKeysAdjustSelectionArea(direction, modus, extraUmphf:=1) {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    factoru := (zoomLevel>2) ? 1 : 2 - zoomLevel
    stepu := Round(2 * (factoru + 0.1))
    If (stepu<2)
       stepu := 2

    stepu := stepu * extraUmphf
    If (FlipImgH=1 && InStr(direction, "1"))
       direction := (direction=1) ? -1 : 1

    If (FlipImgV=1 && InStr(direction, "2"))
       direction := (direction=2) ? -2 : 2

    If (modus=1) ; reposition selection
    {
       If (direction=1)
          imgSelX1 += stepu
       Else If (direction=-1)
          imgSelX1 -= stepu
       Else If (direction=2)
          imgSelY1 += stepu
       Else If (direction=-2)
          imgSelY1 -= stepu
    } Else If (modus=2)
    {
       If (direction=1)
          imgSelX2 += stepu
       Else If (direction=-1)
          imgSelX2 -= stepu
       Else If (direction=2)
          imgSelY2 += stepu
       Else If (direction=-2)
          imgSelY2 -= stepu
    }
    SetTimer, dummyRefreshImgSelectionWindow, -10
    SetTimer, dummyShowSelCoordsInfos, -25
}

dummyShowSelCoordsInfos() {
    imgSelW := max(ImgSelX1, ImgSelX2) - min(ImgSelX1, ImgSelX2)
    imgSelH := max(ImgSelY1, ImgSelY2) - min(ImgSelY1, ImgSelY2)

    theRatio := "`nRatio: " Round(imgSelW/imgSelH, 2)
    theRatio .= "`nRotation: " Round(vPselRotation, 2) "° "

    theMsg := "X / Y: " ImgSelX1 ", " ImgSelY1 "`nW / H: " imgSelW ", " imgSelH theRatio
    showTOOLtip(theMsg)
    SetTimer, RemoveTooltip, -500
}

toggleImgSelection() {
  If (thumbsDisplaying=1)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()
  
  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  editingSelectionNow := !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

tlbrToggleImgSelection() {
  If (thumbsDisplaying=1) || (!useGdiBitmap() && !CurrentSLD)
     Return

  If (slideShowRunning=1)
     ToggleSlideShowu()

  If (imgSelX2=-1 && imgSelY2=-1)
  {
     ToggleEditImgSelection()
     Return
  }

  If (editingSelectionNow!=1)
     correctActiveSelectionAreaViewPort()

  If (relativeImgSelCoords=1)
     calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

  If (editingSelectionNow=1)
     recordSelUndoLevelNow()

  editingSelectionNow := !editingSelectionNow
  updateUIctrl()
  clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(25)
}

resetImgSelection() {
  If (thumbsDisplaying=1)
     Return

  If (slideShowRunning=1 && editingSelectionNow!=1)
     Return

  imgSelX1 := imgSelY1 := vPselRotation := 0
  imgSelX2 := imgSelY2 := -1
  editingSelectionNow := 0
  updateUIctrl()
  SetTimer, MouseMoveResponder, -90
  SetTimer, dummyRefreshImgSelectionWindow, -25
  ; dummyTimerDelayiedImageDisplay(50)
}

newImgSelection() {
  IMGdecalageX := IMGdecalageY := vPselRotation := 0
  resetImgSelection()
  Sleep, -1
  ToggleEditImgSelection()
}

createDefaultSizedSelectionArea(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight) {
    If (imgSelX2="C" && imgSelY2="C" && useGdiBitmap())
    {
       GetMouseCoord2wind(PVhwnd, mX, mY)
       MouseCoords2Image(mX - 200, mY - 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX1, imgSelY1)
       MouseCoords2Image(mX + 200, mY + 200, 1, prevDestPosX, prevDestPosY, prevResizedVPimgW, prevResizedVPimgH, imgSelX2, imgSelY2)
       Gdip_GetImageDimensions(useGdiBitmap(), rImgW, rImgH)
       defineRelativeSelCoords(rImgW, rImgH)
    } Else If (imgSelX2=-1 && imgSelY2=-1)
    {
       obju := createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, 2)
       imgSelX1 := obju.x1, imgSelY1 := obju.y1
       imgSelX2 := obju.x2, imgSelY2 := obju.y2
    }
}

createImgSelection2Win(DestPosX, DestPosY, newW, newH, maxSelX, maxSelY, mainWidth, mainHeight, factor) {
    obju := []
    x1 := (DestPosX<0) ? Abs(DestPosX)/newW : 0
    SelX1 := Round(x1*maxSelX)
    y1 := (DestPosY<0) ? Abs(DestPosY)/newH : 0
    SelY1 := Round(y1*maxSelY)
    SelX2 := Round(SelX1 + (mainWidth/factor)/zoomLevel) + 5
    SelY2 := Round(SelY1 + (mainHeight/factor)/zoomLevel) + 5
    If (SelX2>maxSelX/factor && newW<mainWidth)
       SelX2 := maxSelX//factor
    If (SelY2>maxSelY/factor && newH<mainHeight)
       SelY2 := maxSelY//factor

    obju.x1 := SelX1, obju.y1 := SelY1
    obju.x2 := SelX2, obju.y2 := SelY2
    Return obju  
}
correctActiveSelectionAreaViewPort() {
    Static prevDimensions
    If (imgSelX2=-1 && imgSelY2=-1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    theseDimensions := imgW "," imgH
    If (theseDimensions=prevDimensions)
       Return

    capSelectionRelativeCoords()
    calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    ; msgbox, % x1 "--" x2 "--" y1 "--" y2
    imgSelX1 := X1, imgSelY1 := Y1
    imgSelX2 := X2, imgSelY2 := Y2
    prevDimensions := imgW "," imgH
}

coremakeSquareSelection(imgW, imgH) {
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    avg := (imgSelW+imgSelH)//2
    avg := clampInRange(avg, 5, min(imgW, imgH))
    imgSelX2 := X1 + avg
    imgSelY2 := Y1 + avg
    prcSelX2 := imgSelX2/prevMaxSelX
    If (prcSelX2>1)
       prcSelX2 := 1

    prcSelY2 := imgSelY2/prevMaxSelY
    If (prcSelY2>1)
       prcSelY2 := 1

    Sleep, 1
    If (LimitSelectBoundsImg=1)
       dummyRefreshImgSelectionWindow()
}

makeSquareSelection() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1 || lockSelectionAspectRatio>0)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    doLoops := (LimitSelectBoundsImg=1) ? 20 : 1
    Loop, % doLoops
       coremakeSquareSelection(imgW, imgH)

    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

resetSelectionRotation() {
   vPselRotation := 0
   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

MenuSelRotation() {
   If (editingSelectionNow!=1 || thumbsDisplaying=1)
      Return

   VPselRotation := Round(VPselRotation) + 45
   If (VPselRotation>350)
      VPselRotation := 0

   SetTimer, dummyRefreshImgSelectionWindow, -10
   SetTimer, dummyShowSelCoordsInfos, -20
}

flipSelectionWH() {
    If (thumbsDisplaying=1 || editingSelectionNow!=1)
       Return

    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    calcImgSelection2bmp(1, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    If (imgSelW=imgSelH)
       Return

    Gdip_GetRotatedDimensions(imgSelW, imgSelH, 90, rimgSelW, rimgSelH)
    imgSelX2 := X1 + Floor(rimgSelW)
    imgSelY2 := Y1 + Floor(rimgSelH)
    SetTimer, MouseMoveResponder, -90
    SetTimer, dummyRefreshImgSelectionWindow, -25
    ; dummyTimerDelayiedImageDisplay(25)
}

ImageCoords2Window(inputX, inputY, DestPosX, DestPosY, dotSize, ByRef outX, ByRef outY) {
   outX := Round(inputX*zoomLevel) + DestPosX - dotSize//2
   outY := Round(inputY*zoomLevel) + DestPosY - dotSize//2
}

MouseCoords2Image(mX, mY, limitBounds, dPosX, dPosY, newW, newH, ByRef x, ByRef y) {
    x1 := (dPosX<0) ? mX + Abs(dPosX) : mX - Abs(dPosX)
    y1 := (dPosY<0) ? mY + Abs(dPosY) : mY - Abs(dPosY)
    If (limitBounds=1)
    {
       x1 := clampInRange(x1, 0, newW)
       y1 := clampInRange(y1, 0, newH)
    }
    prcx1 := x1/newW
    prcy1 := y1/newH
    Gdip_GetImageDimensions(useGdiBitmap(), imgW, imgH)
    x := Round(imgW * prcx1)
    y := Round(imgH * prcy1)
    ; ToolTip, % mX " -- " mY "`n" x " -- " y "`n" DestPosX " -- " DestPosY "`n" newW " -- " newH "`n" prcx1 " -- " prcy1, , , 2
}

updateTinyPreviewArea(DestPosX, DestPosY, newW, newH) {
    If (tinyPrevAreaCoordX="C" || tinyPrevAreaCoordY="C")
    {
       GetMouseCoord2wind(hGDIwin, mX, mY)
       MouseCoords2Image(mX, mY, 1, DestPosX, DestPosY, newW, newH, x, y)
       tinyPrevAreaCoordX := x, tinyPrevAreaCoordY := y
       WinActivate, ahk_id %hSetWinGui%
       SetTimer, updateUIblurPreview, -100
    } 
}

destroyBlacked() {
  If (imageLoading=1)
  {
     SetTimer, destroyBlacked, -50
     Return
  }
  BlackedCreator(1, 1)
}


ToggleVisibilityWindow(actu, winIDu) {
   Static prevState
   thisState := actu "-" winIDu
   If (thisState=prevState)
      Return

   If (actu="show")
      WinSet, Region,, ahk_id %winIDu%
   Else
      WinSet, Region, 0-0 w1 h1, ahk_id %winIDu%

   prevState := thisState
}

FadeMainWindow() {
   ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
   ; Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
   ; yBrush := Gdip_BrushCreateSolid("0x88" WindowBgrColor)
   ; Gdip_FillRectangle(glPG, yBrush, 0, 0, mainWidth, mainHeight)
   ; Gdip_DeleteBrush(yBrush)
   r2 := LrydWinUpdt(hGDIwin, glHDC, 150)
}

GdipCleanMain(modus:=0) {
    If (modus=2)
    {
       ; BlackedCreator(128)
       ; SetTimer, destroyBlacked, -100
       GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
       Gdi_FillShape(glHDC, 0, 0, mainWidth, mainHeight, WindowBgrColor, 1)
       r2 := LrydWinUpdt(hGDIwin, glHDC, 200)
       Return
    }

    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    opacity := (modus=1) ? "0xFF" : "0x50"
    If (modus=4 || modus=5 || modus=6)
    {
       ; BMPcache := trGdip_CreateBitmapFromHBITMAP(glHbitmap)
       If (modus=4)
       {
          graphPath := Gdip_CreatePath()
          x1 := mainWidth//2 - 45
          x2 := mainWidth//2 + 45
          x3 := mainWidth//2
          y1 := mainHeight//2
          y2 := mainHeight//2
          y3 := mainHeight//2 - 200
          PointsList := x1 "," y1 "|" x2 "," y2 "|" x3 "," y3
          Gdip_AddPathPolygon(graphPath, PointsList)
          Gdip_RotatePathAtCenter(graphPath, vpIMGrotation)
       }

       ; trGdip_DrawImage(A_ThisFunc, glPG, BMPcache)
       If (modus=5 || modus=6)
       {
          If (vpIMGrotation>0)
             zoomu := " @ " vpIMGrotation "°"
          zoomu := Round(zoomLevel * 100) "%" zoomu
          thisInfo := max(oldZoomLevel, zoomLevel) - min(oldZoomLevel, zoomLevel)
          If (modus=6)
             thisInfo := zoomu := "( - )"

          If thisInfo
          {
             thisFntSize := (modus!=6) ? OSDfntSize*1.25 : OSDfntSize*0.75
             infoBoxBMP := drawTextInBox(zoomu, OSDFontName, thisFntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             Gdip_GetImageDimensions(infoBoxBMP, Wi, He)
             If (modus=5)
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2)
             Else
                trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP, mainWidth//2 - Wi//2, mainHeight//2 - He//2,,,,,,, 0.45)
             trGdip_DisposeImage(infoBoxBMP, 1)
          } Else
          {
             imgPath := getIDimage(currentFileIndex)
             zPlitPath(imgPath, 0, OutFileName, OutDir)
             entireString := "[ " currentFileIndex " / " maxFilesIndex " ] " OutFileName "`n" OutDir "\"
             infoBoxBMP := drawTextInBox(entireString, OSDFontName, OSDfntSize, mainWidth//1.25, mainHeight//1.25, OSDtextColor, OSDbgrColor, 1, 0)
             trGdip_DrawImage(A_ThisFunc, glPG, infoBoxBMP)
             trGdip_DisposeImage(infoBoxBMP, 1)
             oldZoomLevel := zoomLevel
          }
       }

       If (modus=4)
       {
          thisW := thisH := 250
          Gdip_FillEllipse(glPG, pBrushE, mainWidth//2 - thisW//2, mainHeight//2 - thisH + 30, thisW, thisH)
          Gdip_FillPath(glPG, pBrushD, graphPath)
          Gdip_DeletePath(graphPath)
       }
       thisOpacity := (modus!=6) ? "0x22" : "0x33"
       Random, hu, 6, 8
       Random, ha, 6, 8
       clr := thisOpacity . ha . hu . ha . hu . ha . hu
       widthu := imgHUDbaseUnit//3
       yPen := Gdip_CreatePen(clr, widthu)
       Gdip_DrawRectangle(glPG, yPen, 0, 0, mainWidth, mainHeight)
       Gdip_DeletePen(yPen)
       r2 := LrydWinUpdt(hGDIwin, glHDC, 225)
       ; trGdip_DisposeImage(BMPcache)
    } Else 
    {
       trGdip_GraphicsClear(A_ThisFunc, glPG, opacity WindowBgrColor)
       r2 := LrydWinUpdt(hGDIwin, glHDC)
    }
}

clearGivenGDIwin(Gu, DCu, hwnd) {
    trGdip_GraphicsClear(A_ThisFunc, Gu, "0x00" WindowBgrColor, 1)
    r := LrydWinUpdt(hwnd, DCu)
    Return r
}

QPV_listThumbnailsGridMode() {
    setImageLoading()
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xFF" WindowBgrColor)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    zBru := Gdip_BrushCreateSolid("0x66994433")
    rowIndex := 0
    columnIndex := -1
    prevMSGdisplay := A_TickCount
    If (highlightAlreadySeenImages=1 && skipSeenImagesSlider=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    testRegEx := SubStr(userSearchString, 1, 2)
    If (testRegEx!="\>" && userSearchString)
       thisSearchString := JEE_StrRegExLiteral(userSearchString)
    Else
       thisSearchString := SubStr(userSearchString, 3)

    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPath := StrReplace(imgPath, "||")

        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        ; Gdip_FillRectangle(2NDglPG, pBrushWinBGR, DestPosX, DestPosY, thumbsW, thumbsH)
        If (StrLen(imgPath)>2 && thumbsListViewMode<=1)
        {
           zPlitPath(imgPath, 0, fileNamu, folderu)
           entireString := fileNamu "`n" folderu "\"
           If (markSearchMatches=1)
           {
              If (!filterCoreString(imgPath, 2, thisSearchString) && userSearchString)
                 Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           }
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=2)
        {
           zPlitPath(imgPath, 0, fileNamu, folderu)
           Try FileGetSize, fileSizu, % imgPath, K
           Try FileGetTime, FileDateM, % imgPath, M
           Try FileGetTime, FileDateC, % imgPath, C
           Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
           Try FormatTime, FileDateC, % FileDateC, dd/MM/yyyy, HH:mm
           If FileExist(imgPath)
           {
              fileMsg := FileDateC " | " FileDateM " | " groupDigits(fileSizu) " Kb"
              ; op := GetImgFileDimension(imgPath, Width, Height)
              ; mgpx := (op=1) ? Round((Width*Height)/1000000,2) " MPx | " : ""
           } Else fileMsg := "Error gathering data..."

           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If (fileSizu<2 && !InStr(fileMsg, "error"))
              Gdip_FillRectangle(2NDglPG, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           Else If (!filterCoreString(imgPath, 2, thisSearchString) && userSearchString && markSearchMatches=1)
              Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
        } Else If (StrLen(imgPath)>1 && thumbsListViewMode=3)
        {
           thumbBMP := LoadBitmapFromFileu(imgPath, 1)
           Width := mainLoadedIMGdetails.Width
           Height := mainLoadedIMGdetails.Height
           CountFrames := mainLoadedIMGdetails.Frames
           pixFmt := mainLoadedIMGdetails.PixelFormat
           CountFrames := (CountFrames>1) ? " | " CountFrames " frames" : ""
           zPlitPath(imgPath, 0, fileNamu, folderu)
           Try FileGetSize, fileSizu, % imgPath, K

           mgpx := StrLen(thumbBMP)>2 ? Round((Width*Height)/1000000,2) " MPx | " : ""
           If (FileExist(imgPath) && StrLen(thumbBMP)>2)
              fileMsg := groupDigits(Width) " x " groupDigits(Height) " | " pixFmt CountFrames " | " groupDigits(fileSizu) " Kb"
           Else
              fileMsg := "Error gathering data..."

           trGdip_DisposeImage(thumbBMP, 1)
           entireString := mgpx fileNamu "`n" folderu "\`n" fileMsg
           If ((Width<2 || Height<2 || fileSizu<2) && !InStr(fileMsg, "error"))
              Gdip_FillRectangle(2NDglPG, zBru, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
           Else If (!filterCoreString(imgPath, 2, thisSearchString) && userSearchString && markSearchMatches=1)
              Gdip_FillRectangle(2NDglPG, pBrushD, DestPosX + thumbsW - Ceil(thumbsW*0.05) - 4, DestPosY + 4, Ceil(thumbsW*0.05), thumbsH - 8)
        }

        If StrLen(entireString)>2
        {
           infoBoxBMP2 := drawTextInBox(entireString, OSDFontName, OSDfntSize//1.25, thumbsW, thumbsH, OSDtextColor, WindowBGRcolor, 1, 0)
           trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
           infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           entireString := ""
        }

        If (highlightAlreadySeenImages=1 && skipSeenImagesSlider=1)
        {
           If retrieveSeenImageDBentry(imgPath, thisFileIndex, 1)
              Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (A_TickCount - prevMSGdisplay > 450)
        {
           prevMSGdisplay := A_TickCount
           r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)
        } Else If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           Break
        }
    }

    Gdip_DeleteBrush(zBru)
    r2 := LrydWinUpdt(hGDIthumbsWin, 2NDglHDC)
    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    prevFullThumbsUpdate := A_TickCount
    SetTimer, ResetImgLoadStatus, -15
    prevFullThumbsUpdate := A_TickCount
}

mainGdipWinThumbsGrid(mustDestroyBrushes:=0, mustShowNames:=0) {
    Critical, on
    Static pBrush1, pBrush2, pBrush3, pBrush4, pBrush5
         , brushesCreated, prevIndexu

    If (mustDestroyBrushes=1 && brushesCreated=1)
    {
       Gdip_DeleteBrush(pBrush1)
       Gdip_DeleteBrush(pBrush2)
       Gdip_DeleteBrush(pBrush3)
       Gdip_DeleteBrush(pBrush4)
       Gdip_DeleteBrush(pBrush5)
       brushesCreated := 0
       Return
    } Else If (mustDestroyBrushes=1)
       Return

    If (brushesCreated!=1)
    {
       pBrush1 := Gdip_BrushCreateSolid("0x88999999")
       pBrush2 := Gdip_BrushCreateSolid("0x55999999")
       pBrush3 := Gdip_BrushCreateSolid("0x39999922")
       pBrush4 := Gdip_BrushCreateSolid("0x55404040")
       pBrush5 := Gdip_BrushCreateSolid("0x66334433")
       brushesCreated := 1
    }

    If StrLen(hitTestSelectionPath)>1
    {
       Gdip_DeletePath(hitTestSelectionPath)
       hitTestSelectionPath := ""
    }

    selectorWidth := imgHUDbaseUnit//6
    If (selectorWidth>min(thumbsW, thumbsH)*0.3)
       selectorWidth := Round(min(thumbsW, thumbsH)*0.3)

    Gdip_SetPenWidth(pPen6, selectorWidth)
    Gdip_SetPenWidth(pPen1d, selectorWidth//2)
    Gdip_SetPenWidth(pPen5, selectorWidth//2)
    hitTestSelectionPath := Gdip_CreatePath()
    trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    rowIndex := 0
    columnIndex := -1
    If (startIndex=prevIndexu)
       prevIndexu := ""

    Loop, % maxItemsW*maxItemsH*2
    {
        thisFileIndex := startIndex + A_Index - 1
        imgPath := resultedFilesList[thisFileIndex, 1]
        imgPathSelected := resultedFilesList[thisFileIndex, 2]
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH)
           Break

        DestPosX := thumbsW*columnIndex
        DestPosY := thumbsH*rowIndex
        If (mustShowNames=1)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
           If StrLen(imgPath)<4
              Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (mustShowNames=1 && thisFileIndex=startIndex && StrLen(imgPath)>5)
        {
           mustDrawBoxNow := 1
        } Else If (mustShowNames=2 && StrLen(imgPath)>5)
        {
           Gdip_FillRectangle(2NDglPG, pBrushE, DestPosX + 1, DestPosY + 1, thumbsW - 2, thumbsH - 2)
        } Else If (StrLen(imgPath)>5 && !mustShowNames && thumbnailsListMode!=1)
        {
           If !FileRexists(imgPath)
           {
              infoBoxBMP2 := drawTextInBox("! " thisFileIndex, OSDFontName, OSDfntSize//1.5, thumbsW, thumbsH, OSDtextColor, OSDbgrColor, 0, 0)
              trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP2, DestPosX, DestPosY)
              infoBoxBMP2 := trGdip_DisposeImage(infoBoxBMP2, 1)
           }
        }

        If (!mustShowNames && StrLen(ImgPath)>5)
        {
           If !FileRexists(imgPath)
              Gdip_FillRectangle(2NDglPG, pBrush4, DestPosX, DestPosY, thumbsW, thumbsH)
        }

        If (resultedFilesList[thisFileIndex, 3]=1)
           Gdip_DrawRectangle(2NDglPG, pPen5, DestPosX, DestPosY, thumbsW, thumbsH)
        If (resultedFilesList[thisFileIndex, 5]=1)
           Gdip_DrawRectangle(2NDglPG, pPen1d, DestPosX, DestPosY, thumbsW, thumbsH)

        If (thisFileIndex=currentFileIndex)
        {
           ; Gdip_FillRectangle(2NDglPG, pBrush1, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_DrawRectangle(2NDglPG, pPen6, DestPosX, DestPosY, thumbsW, thumbsH)
           If (noTooltipMSGs=0 || mustShowNames=1)
           {
              Gdip_AddPathRectangle(hitTestSelectionPath, DestPosX, DestPosY, thumbsW, thumbsH)
              zPlitPath(imgPath, mustDrawBoxNow, fileNamu, folderu)
              Try FileGetSize, fileSizu, % ImgPath, K
              Try FileGetTime, FileDateM, % ImgPath, M
              Try FormatTime, FileDateM, % FileDateM, dd/MM/yyyy, HH:mm
              If FileExist(imgPath)
                 fileMsg := groupDigits(fileSizu) " Kb | " FileDateM
              Else
                 fileMsg := "File not found or access denied"

              delim := (multilineStatusBar=1 || mustShowNames=1) ? "`n" : " | "
              theMsg := groupDigits(currentFileIndex) " / " groupDigits(maxFilesIndex) " | " fileNamu " | " fileMsg delim folderu "\"
           }
        }

        If (imgPathSelected=1)
        {
           countSel++
           Gdip_DrawRectangle(2NDglPG, pPen3, DestPosX, DestPosY, thumbsW, thumbsH)
           Gdip_FillRectangle(2NDglPG, pBrush3, DestPosX, DestPosY, thumbsW, thumbsH)
        }
    }

    If (countSel>markedSelectFile && countSel>1 && markedSelectFile>1)
       SetTimer, dummyRecountSelectedFiles, -100

    If (mustDrawBoxNow=1 || mustShowNames=1)
    {
       knobSize := imgHUDbaseUnit//3.5
       Gdip_FillRectangle(2NDglPG, pBrushE, 0, 0, mainWidth, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, Round(mainWidth*(currentFileIndex/maxFilesIndex)), knobSize//2)
    }

    prevIndexu := startIndex
    If markedSelectFile
    {
       Gdip_FillRectangle(2NDglPG, pBrush1, 0, 0, mainWidth, imgHUDbaseUnit//5)
       theMsg := markedSelectFile " selected | " theMsg
    }

    If StrLen(filesFilter)>1
       theMsg .= "`nFiles list filtered: " usrFilesFilteru

    scrollYpos := startIndex/maxFilesIndex
    scrollYpos := Round(mainHeight*scrollYpos)
    thisFileIndex := currentFileIndex
    If (thisFileIndex>maxFilesIndex - maxItemsPage)
       thisFileIndex := maxFilesIndex - maxItemsPage

    scrollHeight := (maxItemsPage/maxFilesIndex)*100
    scrollHeight := Ceil((mainHeight/100)*scrollHeight)
    If (scrollHeight<15)
       scrollHeight := 15

    If ((mustShowNames=1 || noTooltipMSGs=0) && StrLen(theMsg)>1)
    {
       infoBoxBMP := drawTextInBox(theMsg, OSDFontName, Round(OSDfntSize*0.9), mainWidth, mainHeight//3, OSDtextColor, OSDbgrColor, 1)
       Gdip_GetImageDimensions(infoBoxBMP, ThumbsStatusBarW, ThumbsStatusBarH)
       trGdip_DrawImage(A_ThisFunc, 2NDglPG, infoBoxBMP, -1, mainHeight - ThumbsStatusBarH)
       trGdip_DisposeImage(infoBoxBMP, 1)
    }

    lineThickns := imgHUDbaseUnit//3.25
    If (scrollHeight<mainHeight)
    {
       Gdip_FillRectangle(2NDglPG, pBrushE, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_AddPathRectangle(hitTestSelectionPath, mainWidth - lineThickns, 0, lineThickns, mainHeight)
       Gdip_FillRectangle(2NDglPG, pBrushD, mainWidth - lineThickns + 5, scrollYpos, lineThickns, scrollHeight)
    }

    SetTimer, ResetImgLoadStatus, -25
    r2 := LrydWinUpdt(hGDIselectWin, 2NDglHDC)
    If (toolTipGuiCreated=2)
    {
       clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
       toolTipGuiCreated := 0
    }
}

dummyRecountSelectedFiles() {
   getSelectedFiles(0, 1)
}

EraseThumbsCache(dummy:=0, remCacheOldDays:=0) {
   startZeit := A_TickCount
   showTOOLtip("Emptying thumbnails cache, please wait...")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countTFilez := countFilez := 0
   Loop, Files, %thumbsCacheFolder%\*.*
   {
      If !(A_LoopFileExt="tiff" || A_LoopFileExt="png" || A_LoopFileExt="jpg")
         Continue

      changeMcursor()
      timeNow := %A_Now%
      EnvSub, timeNow, %A_LoopFileTimeCreated%, Days
      mustRem := (timeNow>remCacheOldDays && dummy="daysITis") ? 1 : 0
      countTFilez++
      If (mustRem=1 || dummy!="daysITis")
      {
         FileDelete, % A_LoopFileFullPath
         If !ErrorLevel
            countFilez++
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         showTOOLtip("Emptying thumbnails cache, please wait...`n" countFilez " removed until now.")
         prevMSGdisplay := A_TickCount
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
   }

   If (dummy="daysITis")
   {
      moreInfo := " out of " countTFilez
      friendly := " older than " remCacheOldDays " days"
   }


   If (abandonAll=1)
      showTOOLtip("Operation aborted. Removed " countFilez " cached thumbnails until now...")
   Else If (A_TickCount - startZeit>1500) || (dummy="daysITis")
      showTOOLtip("Finished removing " countFilez moreInfo " cached thumbnails" friendly)
   
   remCacheOldDays := 0
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

createThumbsFolder() {
    If !FolderExist(thumbsCacheFolder)
    {
       FileCreateDir, %thumbsCacheFolder%
       If ErrorLevel
          Return "error"
    }
}

generateImgThumbCache(imgPath, newImgSize) {
    Critical, on
    r := createThumbsFolder()
    If (r="error")
       Return r

    MD5name := generateThumbName(imgPath)
    file2save := thumbsCacheFolder "\" MD5name ".jpg"
    thisImgFile := FileExist(file2save) ? file2save : imgPath
    whichLIB := (thisImgFile=file2save) ? 1 : 0
    changeMcursor()
    oBitmap := LoadBitmapFromFileu(thisImgFile, 0, whichLIB)
    If !oBitmap
       Return "error"

    Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    calcIMGdimensions(imgW, imgH, newImgSize, newImgSize, ResizedW, ResizedH)
    If (isInRange(imgW, ResizedW - 15, ResizedW + 15) && isInRange(imgH, ResizedH - 15, ResizedH + 15))
    {
       cacheUsed := 1
       ResizedW -= 50
       ResizedH -= 50
    }
    changeMcursor()
    thisImgQuality := (userimgQuality=1) ? 3 : 5
    thumbBMP := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, ResizedW, ResizedH, 0, thisImgQuality, -1)
    trGdip_DisposeImage(oBitmap, 1)
    If (cacheUsed=1)
       Sleep, 1

    changeMcursor()
    r := Gdip_SaveBitmapToFile(thumbBMP, file2save)
    trGdip_DisposeImage(thumbBMP, 1)
}

setPriorityThread(level, handle:="A") {
  If (handle="A" || !handle)
     handle := DllCall("GetCurrentThread")
  Return DllCall("SetThreadPriority", "UPtr", handle, "Int", level)
}

ObjToString(obj) {
  if (!IsObject(obj))
    return obj
  str := "`n{"
  for key, value in obj
    str .= "`n" key ": " ObjToString(value) ","
  return str "`n}"
}

CustomObjToString(obj) {
  if (!IsObject(obj))
    return obj
;  str := "|&|"
  for key, value in obj
    str .= "?" key "|" CustomaObjToString(value)
  return str ; "|&|"
}

CustomaObjToString(obj) {
  if (!IsObject(obj))
    return obj
 ; str := "/&/"
  for key, value in obj
    str .= "<" ObjToString(value) "@"
  return str ; "/&/"
}

StrToObject(stringu) {
  newArrayu := []
  Loop, Parse, stringu, ?
  {
      If !A_LoopField
         Continue
      lineArrayu := StrSplit(A_LoopField, "|<")
      thisIndex := lineArrayu[1]
      preparedOther := StrReplace(lineArrayu[2], "@")
      otherLineArrayu := StrSplit(preparedOther, "<")
      ; MsgBox, % A_LoopField "`n" thisIndex "`n" preparedOther "`n" otherLineArrayu[1] "`n" lineArrayu[2] "`n" A_Index
      Loop, % otherLineArrayu.Count()
          newArrayu[thisIndex, A_Index] := otherLineArrayu[A_Index]
  }
  ; MsgBox, % CustomObjToString(newArrayu)
  Sleep, 50
  Return newArrayu
}

generateAllThumbsNow() {
   Static chunkSize := 1500
   If (thumbsDisplaying!=1 || maxFilesIndex<3 || !CurrentSLD)
      Return

   currentFileIndex := 1
   thumbsListViewMode := thumbnailsListMode := 0
   ; If (thumbnailsListMode!=1)
   ;    initAHKhThumbThreads()

   INIaction(1, "thumbnailsListMode", "General")
   INIaction(1, "thumbsListViewMode", "General")
   recalculateThumbsSizes()
   loopTimes := Ceil(maxFilesIndex/chunkSize)
   startZeit := A_TickCount
   Loop, % loopTimes
   {
      currentFileIndex := (A_Index - 1) * chunkSize
      If !currentFileIndex
         currentFileIndex := 1

      r := QPV_ShowThumbnails("all", A_Index * chunkSize, startZeit)
      If r
         Break
   }
 
   currentFileIndex := 1
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(90)
   SoundBeep , 900, 100
   SetTimer, ResetImgLoadStatus, -25
   RemoveTooltip()
}

QPV_ShowThumbnails(modus:=0, allStarter:=0, allStartZeit:=0) {
    Critical, on

    prevFullThumbsUpdate := A_TickCount
    mainStartZeit := A_TickCount
    thumbsInfoYielder(maxItemsW, maxItemsH, maxItemsPage, maxPages, startIndex, mainWidth, mainHeight)
    If (modus="all")
    {
       maxItemsW := maxItemsH := allStarter//2 + 1
       maxItemsPage := allStarter + 1
       ; MsgBox, % maxItemsPage
    }

    If (thumbnailsListMode=1)
    {
       QPV_listThumbnailsGridMode()
       Return
    }

    setImageLoading()
    If (minimizeMemUsage!=1)
    {
       thumbsBitmap := trGdip_CreateBitmap(A_ThisFunc, mainWidth, mainHeight, "0xE200B")
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbsBitmap, 5, 1)
       If !G2
       {
          trGdip_DisposeImage(thumbsBitmap, 1)
          thumbsBitmap := ""
          G2 := glPG
       }
    } Else G2 := glPG

    hasUpdated := rowIndex := imgsListed := 0
    maxImgSize := maxZeit := columnIndex := -1
    fnOutputDebug("Begin show " maxItemsPage " thumbs from index " startIndex)
    setPriorityThread(-2)
    DestroyGIFuWin()
    createThumbsFolder()
    trGdip_GraphicsClear(A_ThisFunc, glPG, "0xFF" WindowBgrColor)
    If (highlightAlreadySeenImages=1 && skipSeenImagesSlider=1)
       Gdip_SetPenWidth(pPen5, imgHUDbaseUnit//11.5)

    ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, mainWidth + 5, mainHeight + 5)
    prevGUIupdate := A_TickCount
    thisImgQuality := (userimgQuality=1) ? 7 : 5
    imgsListArrayThumbs := []
    lastMsg := imgsMustPaint := imgsNotCached := 0
    doStartLongOpDance()
    Loop, % maxItemsW*maxItemsH*2
    {
        If (modus="all" && maxFilesIndex>100)
        {
           If (determineTerminateOperation()=1)
           {
              fnOutputDebug("ThumbsMode. User abandoned the operation during preparations phase of generate all thumbs.")
              abandonAll := 1
              hasUpdated := 0
              Break
           }
        }

        thisFileIndex := startIndex + A_Index - 1
        columnIndex++
        If (columnIndex>=maxItemsW)
        {
           rowIndex++
           columnIndex := 0
        }

        If (rowIndex>=maxItemsH || thisFileIndex>maxFilesIndex) || (modus="all" && thisFileIndex>allStarter)
        {
           ; If (thisFileIndex>maxFilesIndex)
           ;    SoundBeep , 300, 100
           Break
        }

        If (modus="all") && (A_TickCount - lastMsg > 450)
        {
           lastMsg := A_TickCount
           showTOOLtip("Preparing to generate all thumbnails: " thisFileIndex "/" maxFilesIndex, 0, 0, thisFileIndex / maxFilesIndex)
        }

        imgPath := StrReplace(getIDimage(thisFileIndex), "||")
        thisFileDead := (StrLen(imgPath)<5 || !FileRexists(imgPath)) ? 1 : 0
        DestPosX := thumbsW//2 + thumbsW*columnIndex
        DestPosY := thumbsH//2 + thumbsH*rowIndex
        memCached := wasThumbCached := 0
        MD5name := generateThumbName(imgPath, 1, 1)
        isForceRefresh := resultedFilesList[thisFileIndex, 4]
        If (thisFileDead=1)
        {
           imgsListArrayThumbs[thisFileIndex] := ["x", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else If StrLen(imgThumbsCacheIDsArray[MD5name])>0
        {
           memCached := 1
           imgsListArrayThumbs[thisFileIndex] := ["m", 0, imgPath, MD5name, DestPosX, DestPosY, MD5name]
        } Else
        {
           wasThumbCached := (isForceRefresh=1) ? 0 : checkThumbExists(MD5name, imgPath, file2load)
           fnOutputDebug("Thumb = " thisFileIndex  " cached=" wasThumbCached " original file: " imgPath " thumb file: " file2load)
           If (wasThumbCached=1)
              imgsListArrayThumbs[thisFileIndex] := ["f", 0, imgPath, file2load, DestPosX, DestPosY, MD5name]
        }

        If (currentFileIndex=thisFileIndex)
        {
           sizeSquare := 36 + zoomLevel*15
           Gdip_FillRectangle(glPG, pBrushA, DestPosX - sizeSquare//2, DestPosY - sizeSquare//2, sizeSquare, sizeSquare)
        }

        imgsMustPaint++
        If (memCached=1 || wasThumbCached=1 || thisFileDead=1) && (isForceRefresh!=1)
           Continue

        imgsNotCached++
        ; Gdip_FillRectangle(glPG, pBrushE, DestPosX - 10, DestPosY - 10, 20, 20)
        file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
        If (isForceRefresh=1)
        {
           FileDelete, % file2save
           resultedFilesList[thisFileIndex, 4] := 0
        }

        thisW := imgPath ? "w" : "x"
        imgsListArrayThumbs[thisFileIndex] := [thisW, 0, imgPath, file2save, DestPosX, DestPosY, MD5name]
        ;    fnoutputdebug("thumbs prepare " imgPath "|" thisFileIndex "|" MD5name)
    }

   limitCores := realSystemCores + 1
   filesPerCore := imgsNotCached//limitCores
   If (filesPerCore<2 && limitCores>1)
   {
      systemCores := imgsNotCached//2
      filesPerCore := imgsNotCached//systemCores
   } Else systemCores := limitCores

   thisPID := QPVpid
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>1 && multiCoreThumbsInitGood=1) ? 1 : 0
   fnOutputDebug("ThumbsMode. Init. doMultiCore:" mustDoMultiCore ", cores:" systemCores ", filesPerCore:" filesPerCore ", imgsNotCached:" imgsNotCached ", imgsMustPaint:" imgsMustPaint)
   mamUsage := GetProcessMemoryUsage(thisPID)
   systemMemInfo := GlobalMemoryStatusEx()
   thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
   fnOutputDebug("ThumbsMode. Memory usage: " thisMemoryLoad "%")
   If (thisMemoryLoad>70 || isWinXP=1)
   {
      fnOutputDebug("ThumbsMode. Memory usage above 70%. Multi-threaded thumbnails generation deactivated.")
      mustDoMultiCore := 0
   }

   ; how much time in miliseconds can an image take to load and not be cached
   timePerImg := 1550//imgsNotCached
   If (timePerImg<25 || modus="all")
      timePerImg := 25
   Else If (timePerImg>300)
      timePerImg := 300

   timePerImgMultiCore := (modus="all") ? 25 : timePerImg*2 + limitCores*2
   If (timePerImgMultiCore>350)
      timePerImgMultiCore := 350

   If (mustDoMultiCore=1)
   {
      fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. Cores: " limitCores)
      Loop, % limitCores
          thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
      ; fnOutputDebug("ThumbsMode. Clean multi-core GDIs mess. DONE")
   } Else limitCores := 1

   thisFileIndex := MD5name := Bindex := hasUpdated := rowIndex := imgsListed := lastMsg := 0
   imgsHavePainted := thisNonCachedImg := coreIndex := threadIndex := memCached := lapsOccured := totalLoops := 0
   lowestGiven := maxIndexu := maxImgSize := maxZeit := columnIndex := -1
   prevCoreEventZeit := A_TickCount - 2
    ; MsgBox, % filesPerCore "--" imgsMustPaint "--" imgsNotCached "--" imgsListArrayThumbs.Length()
   interfaceThread.ahkassign("alterFilesIndex", 0)
   If (abandonAll!=1)
   {
      Loop
      {
          alterFilesIndex := interfaceThread.ahkgetvar.alterFilesIndex
          If (alterFilesIndex>1 && lapsOccured>3)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation by scrolling.")
             userScrolled := 1
             Break
          }

          totalLoops++
          If (determineTerminateOperation()=1)
          {
             fnOutputDebug("ThumbsMode. User abandoned the operation.")
             abandonAll := 1
             hasUpdated := 0
             Break
          }

          ; Sleep, 0
          Bindex++
          If (Bindex>imgsMustPaint)
          {
             lapsOccured++
             Bindex := 1
          }

          thisFileIndex := startIndex + Bindex - 1
          If (mustEndLoop=1)
          {
             fnOutputDebug("ThumbsMode. Must end loop = 1. laps " lapsOccured "  -- loops " totalLoops "  -- inner " innerLoops " ")
             hasUpdated := 0
             Break
          }

          If (imgsHavePainted>=imgsMustPaint)
             mustEndLoop := 1

          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          If (cacheType="d")
             Continue

          If (cacheType="x")
          {
             fnOutputDebug("ThumbsMode. Failed to generate. " thisFileIndex " .")
             imgsListArrayThumbs[thisFileIndex, 1] := "d"
             thumbsFailures++
             imgsHavePainted++
             Continue
          }

          If (modus="all") && (A_TickCount - lastMsg > 650)
          {
             lastMsg := A_TickCount
             allStuffPerc := (startIndex + imgsHavePainted) / maxFilesIndex
             percDone := " ( " Round(allStuffPerc*100) "% )"
             If (mustDoMultiCore=1)
                showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " startIndex + imgsHavePainted "/" maxFilesIndex "`nUsing multi-threaded processing.`nElapsed time: " SecToHHMMSS((A_TickCount - allStartZeit)/1000) percDone, 0, 0, allStuffPerc)
             Else
                showTOOLtip("Generating all thumbnails at " thumbsSizeQuality "px: " startIndex + imgsHavePainted "/" maxFilesIndex "`nElapsed time: " SecToHHMMSS((A_TickCount - allStartZeit)/1000) percDone, 0, 0, allStuffPerc)
          }

          innerLoops++
          If (cacheType="w" && mustDoMultiCore=1)
          {
             ; Sleep, -1
             thisCoreDoneLine := ""
             thisCoreDoneArr := ""
             whichCoreBusy := imgsListArrayThumbs[thisFileIndex, 2]
             mamUsage := GetProcessMemoryUsage(thisPID)
             systemMemInfo := GlobalMemoryStatusEx()
             thisMemoryLoad := (A_PtrSize=4) ? Round((mamUsage[1]/2104763598)*100, 1) : Round((max(mamUsage[1], mamUsage[8])/Round(systemMemInfo.TotalPhys*0.9))*100, 1)
             If (A_TickCount - prevCoreEventZeit>69500 && innerLoops>2 && lapsOccured>2 && totalLoops>2)
             {
                fnOutputDebug("ThumbsMode. Wait time since last new core started ... exceeded.  " thisFileIndex " . Loop. Break. Now.")
                Break
             }

             If (whichCoreBusy>0)
             {
                hasThumbFailed := thumbThread%whichCoreBusy%.AHKgetvar.operationFailed
                thisCoreDoneLine := thumbThread%whichCoreBusy%.AHKgetvar.resultsList
                thisCoreDoneArr := StrSplit(thisCoreDoneLine, "|")
                waitDataCollect := thumbThread%whichCoreBusy%.AHKgetvar.waitDataCollect
                If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && thisCoreDoneArr[5]=Bindex && waitDataCollect=1)
                {
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "fim"
                   imgsListArrayThumbs[thisCoreDoneArr[3], 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisCoreDoneArr[3], 1] := "x"
                   }
                } Else If (thisCoreDoneArr[1]=1 && thisCoreDoneArr[4]=whichCoreBusy && waitDataCollect=1)
                {
                   ; SoundBeep 
                   thumbThread%whichCoreBusy%.ahkassign("waitDataCollect", 0)
                   thisFileIndex := thisCoreDoneArr[3]
                   Bindex := thisCoreDoneArr[5]
                   thisPBitmap := StrLen(thisCoreDoneArr[2])>2 ? thisCoreDoneArr[2] : 0
                   imgsListArrayThumbs[thisFileIndex, 1] := "fim"
                   imgsListArrayThumbs[thisFileIndex, 2] := thisPBitmap
                   If (hasThumbFailed=1)
                   {
                      prevCoreEventZeit := A_TickCount
                      thumbThread%whichCoreBusy%.ahkassign("operationFailed", 0)
                      fnOutputDebug("ThumbsMode. Failed to generate - file index: " thisFileIndex " core: " whichCoreBusy)
                      imgsListArrayThumbs[thisFileIndex, 1] := "x"
                   }
                } Else Continue
             } Else
             {
                coreIndex++
                If (coreIndex>limitCores)
                   coreIndex := 1

                thisCoreDone := thumbThread%coreIndex%.AHKgetvar.operationDone
                waitDataCollect := thumbThread%coreIndex%.AHKgetvar.waitDataCollect
                hasThumbFailed := thumbThread%coreIndex%.AHKgetvar.operationFailed
                If (thisMemoryLoad<90 && thisCoreDone=1 && waitDataCollect<1 && hasThumbFailed=0)
                {
                   prevCoreEventZeit := A_TickCount
                   thumbThread%coreIndex%.ahkassign("operationDone", 0)
                   thumbThread%coreIndex%.ahkassign("waitDataCollect", 0)
                   thisPath := imgsListArrayThumbs[thisFileIndex, 3]
                   thisSavePath := imgsListArrayThumbs[thisFileIndex, 4]
                   thumbThread%coreIndex%.ahkPostFunction("MonoGenerateThumb", thisPath, thisSavePath, enableThumbsCaching, thumbsSizeQuality, timePerImgMultiCore, coreIndex, thisFileIndex, Bindex)
                   imgsListArrayThumbs[thisFileIndex, 2] := coreIndex
                   fnOutputDebug("ThumbsMode. Work assigned to thread. IMG #" thisFileIndex ". Core " coreindex " ")
                }
                Continue
             }
          }

          ; Sleep, 1
          changeMcursor()
          startZeit := A_TickCount
          cacheType := imgsListArrayThumbs[thisFileIndex, 1]
          fnOutputDebug("thumbs inner " thisCoreDoneLine " -- cT" cacheType " --cB" whichCoreBusy  " -- " reallyThreadsDone " -- loops infos " A_Index " -- " innerLoops " -- " lapsOccured " -- " totalLoops " -- " imgsHavePainted " -- " imgsMustPaint)
          fimCached := mustDisposeImgNow := 0
          wasCacheFile := thumbCachable := WasMemCached := hasNowMemCached := 0
          If (cacheType="w")
          {
             If (mustDoMultiCore=1)
                Continue

             ; mustDisposeImgNow := 1
             thumbCachable := 1
             imgsListArrayThumbs[thisFileIndex, 1] := "f"
             file2load := imgsListArrayThumbs[thisFileIndex, 3]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
          } Else If (cacheType="m")
          {
             WasMemCached := 1
             MD5name := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := imgThumbsCacheArray[imgThumbsCacheIDsArray[MD5name], 1]
          } Else If (cacheType="f")
          {
             wasCacheFile := 1
             file2load := imgsListArrayThumbs[thisFileIndex, 4]
             oBitmap := LoadBitmapFromFileu(file2load, 0, 1)
          } Else If (cacheType="fim")
          {
             fimCached := 1
             oBitmap := imgsListArrayThumbs[thisFileIndex, 2]
             If !oBitmap
             {
                ; mustDisposeImgNow := 1
                cacheType := "f"
                wasCacheFile := 1
                fimCached := 0
                file2load := imgsListArrayThumbs[thisFileIndex, 4]
                fnOutputDebug("missing thumb cached with a FIM thread " thisFileIndex ". Trying to load file... " file2load)

                If !FileRexists(file2load)
                {
                   wasCacheFile := fimCached := 0
                   thumbCachable := 1
                   file2load := imgsListArrayThumbs[thisFileIndex, 3]
                }
                oBitmap := LoadBitmapFromFileu(file2load, 0)
             }
          }

          extendedLoops++
          imgsListArrayThumbs[thisFileIndex, 1] := "d"
          imgPath := imgsListArrayThumbs[thisFileIndex, 3]
          MD5name := imgsListArrayThumbs[thisFileIndex, 7]
          file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)

          If (!oBitmap || !FileExist(imgPath) || !imgW || !imgH)
          {
             If (WasMemCached=1)
             {
                wasThumbCached := checkThumbExists(MD5name, imgPath, file2load)
                imgsListArrayThumbs[thisFileIndex, 1] := FileExist(file2load) ? "fim" : "w"
                imgsListArrayThumbs[thisFileIndex, 2] := 0
                imgsListArrayThumbs[thisFileIndex, 4] := file2load
             } Else imgsHavePainted++

             fnOutputDebug("broken thumb: mem" WasMemCached " -- w" imgW "-- h" imgH "-- obj bmp id" oBitmap)
             Continue
          } Else imgsHavePainted++

          If (thumbCachable=1)
          {
             fnOutputDebug("must resize GDI object thumbCachable=1. " oBitmap)
             zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thumbsW, thumbsH, 1, thisImgQuality, -1)
             If zBitmap
             {
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. " oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object thumbCachable=1. DONE")
                oBitmap := zBitmap
             }
          } Else If (WasMemCached!=1 && modus!="all")
          {
             fnOutputDebug("must clone GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
             zBitmap := cloneGDItoMem(A_ThisFunc, oBitmap, imgW, imgH)
             If (fimCached!=1)
             {
                fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. obj=" oBitmap)
                oBitmap := trGdip_DisposeImage(oBitmap, 1)
                ; fnOutputDebug("must dispose GDI object fimCached=0 - WasMemCached=0. DONE")
             }
             If zBitmap
                oBitmap := zBitmap
          }
          thisZeit := A_TickCount - startZeit
          fnOutputDebug("MEM cached thumbs infos: " memCached " -- " hasMemThumbsCached " -- " imgThumbsCacheIDsArray[MD5name] " = " file2save)

          Gdip_GetImageDimensions(oBitmap, newW, newH)
          If (!newW || !newH)
          {
             fnOutputDebug("ThumbsMode. Faulty GDI thumbnail. File Index: " thisFileIndex ". GDI bmp: " oBitmap ".")
             oBitmap := trGdip_DisposeImage(oBitmap, 1)
             ; fnOutputDebug("ThumbsMode. Faulty GDI thumbnail object disposed.")
             Continue
          }

          If (WasMemCached!=1 && minimizeMemUsage!=1 && modus!="all")
          {
             hasNowMemCached := 1
             hasMemThumbsCached++ 
             fnOutputDebug("ThumbsMode. Memory cached GDI thumb to be disposed: " imgThumbsCacheArray[hasMemThumbsCached, 1] )
             trGdip_DisposeImage(imgThumbsCacheArray[hasMemThumbsCached, 1], 1)
             ; fnOutputDebug("ThumbsMode. A memory cached GDI thumb to be disposed... DONE")
             imgThumbsCacheIDsArray[imgThumbsCacheArray[hasMemThumbsCached, 2]] := ""
             imgThumbsCacheArray[hasMemThumbsCached] := [oBitmap, MD5name]
             imgThumbsCacheIDsArray[MD5name] := hasMemThumbsCached
             If (hasMemThumbsCached>maxMemThumbsCache)
                hasMemThumbsCached := 0
          }

          calcIMGdimensions(newW, newH, thumbsW, thumbsH, fW, fH)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5] - fW//2
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6] - fH//2
          If (fimCached!=1 && thumbCachable=1 && thisZeit>timePerImg && file2save!=file2load && enableThumbsCaching=1 && WasMemCached!=1)
          && ((newW<imgW//2) || (newH<imgH//2))
          {
             fnOutputDebug("Saving thumb for: " file2load " -- " file2save) 
             zr := Gdip_SaveBitmapToFile(oBitmap, file2save, 90)
             If zr
                fnOutputDebug("ThumbsMode. failed to save thumbnail to file: " file2save)
          }

          If (WasMemCached=1 || hasNowMemCached=1)
          {
             zBitmap := trGdip_CloneBitmap(A_ThisFunc, oBitmap)
             oBitmap := zBitmap
          }

          If (bwDithering=1 && imgFxMode=4) || (modus="all")
          {
             nullu := ""
          } Else If (usrColorDepth>1)
          {
             fnOutputDebug("ThumbsMode. Changing thumb color depth... " oBitmap)
             E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
          }

          If (modus!="all")
          {
             ; fnOutputDebug("ThumbsMode. (maybe) flipping thumb... " oBitmap)
             flipBitmapAccordingToViewPort(oBitmap)
             ; changeMcursor()
             hasUpdated := 0
             fnOutputDebug("ThumbsMode. Drawing image thumb: " oBitmap)
             r1 := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, DestPosX, DestPosY, fW - 1, fH - 1)
          }

          fnOutputDebug("ThumbsMode. Disposing GDI thumb after drawing: " oBitmap)
          oBitmap := trGdip_DisposeImage(oBitmap, 1)
          DestPosX := imgsListArrayThumbs[thisFileIndex, 5]
          DestPosY := imgsListArrayThumbs[thisFileIndex, 6]
          If (highlightAlreadySeenImages=1 && skipSeenImagesSlider=1 && modus!="all")
          {
             If retrieveSeenImageDBentry(imgPath, thisFileIndex, 1)
             {
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
                Gdip_DrawRectangle(G2, pPen5, DestPosX - thumbsW//2, DestPosY - thumbsH//2, thumbsW, thumbsH)
             }
          }

          If (markSearchMatches=1 && modus!="all")
          {
             If (!filterCoreString(imgPath, 2, userSearchString) && userSearchString)
                Gdip_FillRectangle(G2, pBrushD, DestPosX - thumbsW//2, DestPosY - thumbsH//2, Ceil(thumbsW*0.05), thumbsH - 8)
          }

          If ((A_TickCount - prevGUIupdate>350) && modus!="all")
          {
             fnOutputDebug("ThumbsMode. Redraw the whole window.")
             If (minimizeMemUsage!=1 && thumbsBitmap)
                r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)
             r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
             prevGUIupdate := A_TickCount
             If (minimizeMemUsage!=1)
                hasUpdated := 1
          }
      }
   }

    If (alterFilesIndex>1 && mustEndLoop!=1 && lapsOccured>3 && modus!="all")
    {
       mustReloadThumbsList := 1
       ; mainGdipWinThumbsGrid()
       SetTimer, ForceRefreshNowThumbsList, -350
       ; Return
    } Else If (mustDoMultiCore=1 && mustEndLoop=1 && abandonAll!=1 && modus!="all")
    {
       fnOutputDebug("ThumbsMode after. Clean GDIs mess. Cores: " limitCores)
       Loop, % limitCores
           thumbThread%A_Index%.ahkPostFunction("cleanMess", "c" A_Index)
       ; fnOutputDebug("Thumbnails generator after. Clean GDIs mess. DONE.")
    }

    executingCanceableOperation := 0
    mainEndZeit := A_TickCount
    setPriorityThread(0)
    If (modus!="all" && (minimizeMemUsage=1 || !thumbsBitmap))
    {
       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
    } Else If (modus!="all")
    {
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(thumbsBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If StrLen(zBitmap)>2
          {
             trGdip_DisposeImage(thumbsBitmap, 1)
             thumbsBitmap := zBitmap
          }
          E := Gdip_BitmapSetColorDepth(thumbsBitmap, "BW", 1)
       }

       If !isWinXP
          decideGDIPimageFX(matrix, imageAttribs, pEffect)

       fnOutputDebug("ThumbsMode end. Redraw the whole window.")
       If (pEffect || imageAttribs)
          r1 := trGdip_DrawImageFX(A_ThisFunc, glPG, thumbsBitmap, 0, 0, 0, 0, mainWidth, mainHeight, matrix, pEffect, imageAttribs)
       Else If (hasUpdated=0)
          r1 := trGdip_DrawImage(A_ThisFunc, glPG, thumbsBitmap)

       r2 := LrydWinUpdt(hGDIthumbsWin, glHDC)
    }

    If (minimizeMemUsage!=1 && thumbsBitmap)
       Gdip_DeleteGraphics(G2)

    trGdip_DisposeImage(thumbsBitmap, 1)
    Gdip_DisposeEffect(pEffect)
    Gdip_DisposeImageAttributes(imageAttribs)

    ; ToolTip, %imgW% -- %imgH% == %newW% -- %newH%
    prevFullThumbsUpdate := A_TickCount
    If (!userScrolled && !abandonAll && alterFilesIndex!=1)
    {
       mustReloadThumbsList := 0
       prevFullIndexThumbsUpdate := startPageIndex
    }

    If (abandonAll=1)
       lastLongOperationAbort := A_TickCount

    executingCanceableOperation := 0
    If (modus!="all")
       SetTimer, ResetImgLoadStatus, -25

    prevFullThumbsUpdate := A_TickCount
    addJournalEntry(maxItemsPage " thumbnails listed in " SecToHHMMSS((A_TickCount - mainStartZeit)/1000) ".")
    ; ToolTip, % lapsOccured "|"  totalLoops " | " innerLoops " | " extendedLoops " | " imgsNotCached "`nZeit: " A_TickCount - mainStartZeit , , , 2
    r := (r1!=0 || !r2 || abandonAll=1) ? 0 : 1
    If (modus="all")
       Return abandonAll
    Return r
}

cloneGDItoMem(funcu, pBitmap, W:=0, H:=0) {
    If !pBitmap
    {
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: no bitmap given")
       Return
    }

    If (!W || !H)
       Gdip_GetImageDimensions(pBitmap, W, H)

    thisImgQuality := (userimgQuality=1) ? 3 : 5
    newBitmap := trGdip_CreateBitmap(A_ThisFunc "<-" funcu, W, H, "0xE200B")
    If newBitmap
    {
       G := trGdip_GraphicsFromImage(A_ThisFunc "() invoked by " funcu, newBitmap, thisImgQuality)
       If G
          E := trGdip_DrawImage(A_ThisFunc "() invoked by " funcu, G, pBitmap, 0, 0, W, H)

       If (E="fail" || !G)
       {
          newBitmap := trGdip_DisposeImage(newBitmap, 1)
          addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create GDI+ graphics object")
       }

       Gdip_DeleteGraphics(G)
    } Else addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed: unable to create bitmap")
    Return newBitmap
}

calcIMGcoord(usePrevious, mainWidth, mainHeight, newW, newH, ByRef DestPosX, ByRef DestPosY) {
    Static orderu := {1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}
         , prevW := 1, prevH := 1, prevZoom := 0

    imgDecLX := LX := mainWidth - newW
    imgDecLY := LY := mainHeight - newH
    ; vpCenterX := 1, vpCenterY := 1
    CX := Round((mainWidth/2 - newW/2))
    CY := Round((mainHeight/2 - newH/2))

    modus := orderu[imageAligned]
    If (thumbsDisplaying=1)
       modus := 5

    If (modus=1)
    {
       DestPosX := 0
       DestPosY := LY
    } Else If (modus=2)
    {
       DestPosX := CX
       DestPosY := LY
    } Else If (modus=3)
    {
       DestPosX := LX
       DestPosY := LY
    } Else If (modus=4)
    {
       DestPosX := 0
       DestPosY := CY
    } Else If (modus=5)
    {
       DestPosX := CX
       DestPosY := CY
    } Else If (modus=6)
    {
       DestPosX := LX
       DestPosY := CY
    } Else If (modus=7)
    {
       DestPosX := DestPosY := 0
    } Else If (modus=8)
    {
       DestPosX := CX
       DestPosY := 0
    } Else If (modus=9)
    {
       DestPosX := LX
       DestPosY := 0
    } Else DestPosX := DestPosY := 0

    If (IMGlargerViewPort!=1)
    {
       IMGdecalageY := IMGdecalageY := 1
    } Else If (IMGresizingMode=4 && thumbsDisplaying!=1)
    {
       If (prevZoom!=zoomLevel && prevZoom!=0)
       {
          scaleu := newH/prevH
          IMGdecalageX := Round(IMGdecalageX*scaleu)
          IMGdecalageY := Round(IMGdecalageY*scaleu)
       } 

       factoru := (imageAligned=5) ? 2 : 1
       If (IMGdecalageX<LX//factoru) && (newW>mainWidth)
          IMGdecalageX := LX//factoru
       If (IMGdecalageY<LY//factoru) && (newH>mainHeight)
          IMGdecalageY := LY//factoru

       If (newW-5>mainWidth)
          DestPosX := DestPosX + IMGdecalageX
       Else
          IMGdecalageX := 0

       If (newH-5>mainHeight)
          DestPosY := DestPosY + IMGdecalageY
       Else
          IMGdecalageY := 0

       If (DestPosX>0) && (newW>mainWidth)
       {
          DestPosX := 0
          IMGdecalageX := (imageAligned=5) ? - LX//2 : 0
       }

       If (DestPosY>0) && (newH>mainHeight)
       {
          DestPosY := 0
          IMGdecalageY := (imageAligned=5) ? - LY//2 : 0
       }
    }

    prevW := newW
    prevH := newH
    prevZoom := zoomLevel
}

saveMainWinPos() {
   WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
   mainWinPos := winX "|" winY
   IniAction(1, "mainWinPos", "General")
}

writeMainWindowPos() {
   IniAction(1, "mainWinPos", "General")
   IniAction(1, "mainWinSize", "General")
   IniAction(1, "mainWinMaximized", "General")
}

GDIupdaterResize(eventu:=0) {
   If (A_TickCount - scriptStartTime<450)
      Return

   If (drawingShapeNow=1)
      stopDrawingShape()
   If (toolTipGuiCreated=1)
      RemoveTooltip()
   If (tempBtnVisible!="null")
      DestroyTempBtnGui("now")

   If (eventu=2)
   {
      WinGet, Stylu, Style, ahk_id %PVhwnd%
      mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
      IniAction(1, "mainWinMaximized", "General")
      ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
   } Else If (eventu!=1)
   {
      WinGetPos, winX, winY, winWidth, winHeight, ahk_id %PVhwnd%
      WinGetPos,,, winWidth, winHeight, ahk_id %hGDIwin%
      If (winX && winY && winWidth && winHeight)
      {
         mainWinPos := winX "|" winY
         mainWinSize := winWidth "|" winHeight
         WinGet, Stylu, Style, ahk_id %PVhwnd%
         mainWinMaximized := (Stylu & 0x1000000) ? 2 : 1
         ; ToolTip, % mainWinPos "==" mainWinSize "==" mainWinMaximized , , , 2
         SetTimer, writeMainWindowPos, -300
      }
   }
   SetTimer, dummyTimerReloadThisPicture, Off
   SetTimer, dummyTimerDelayiedImageDisplay, Off
   DestroyGIFuWin()
   resetSlideshowTimer(0)
   imgPath := getIDimage(currentFileIndex)
   If StrLen(UserMemBMP)>2
      thisClippyIMG := 1

   If (!imgPath || !maxFilesIndex || PrevGuiSizeEvent=1 || !CurrentSLD) && (thisClippyIMG!=1)
   {
      If (slideShowRunning=1)
         ToggleSlideShowu()

      ForceRefreshNowThumbsList()
      If (A_TickCount - lastWinDrag<350)
         Return

      If (thumbsDisplaying=1) && (!maxFilesIndex || !CurrentSLD)
         ToggleVisibilityWindow("hide", hGDIthumbsWin)
      Else
         FadeMainWindow()
      Return
   }

   If (maxFilesIndex>0 && PrevGuiSizeEvent!=1 && thumbsDisplaying!=1) && (A_TickCount - scriptStartTime>500) || (thisClippyIMG=1)
   {
      addJournalEntry("Resize window event - image view mode. ")
      delayu := (A_TickCount - lastWinDrag<450) ? 450 : 15
      filterDelayiedImageDisplay()
      ; dummyTimerDelayiedImageDisplay(delayu)
      dummyTimerReloadThisPicture(750)
      ForceRefreshNowThumbsList()
   } Else If (thumbsDisplaying=1 && maxFilesIndex>1)
   {
      addJournalEntry("Resize window event - thumbs mode. ")
      recalculateThumbsSizes()
      ; GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
      ; WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight% , ahk_id %hGDIthumbsWin%
      delayu := (A_TickCount - lastWinDrag<450) ? 550 : 325
      SetTimer, RefreshThumbsList, % -delayu
   }

   If (A_OSVersion="WIN_7" || isWinXP=1)
      GDIwindowsPosCorrections()
}

ToggleViewModeTouch() {
   zoomLevel := IMGdecalageY := IMGdecalageX := 1
   If (IMGresizingMode=1)
   {
      IMGresizingMode := 3
      ToggleImageSizingMode()
   } Else
   {
      IMGresizingMode := 0
      ToggleImageSizingMode()
   }
}

JEE_ClientToScreen(hWnd, vPosX, vPosY, ByRef vPosX2, ByRef vPosY2) {
; function by jeeswg found on:
; https://autohotkey.com/boards/viewtopic.php?t=38472

  VarSetCapacity(POINT, 8)
  NumPut(vPosX, &POINT, 0, "Int")
  NumPut(vPosY, &POINT, 4, "Int")
  DllCall("user32\ClientToScreen", "Ptr", hWnd, "Ptr", &POINT)
  vPosX2 := NumGet(&POINT, 0, "Int")
  vPosY2 := NumGet(&POINT, 4, "Int")
}


ReloadDynamicFolderz(fileNamu) {
    showTOOLtip("Refreshing files list, please wait...")
    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    listu := coreLoadDynaFolders(fileNamu)
    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue
       Else
          r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }
}

coreLoadDynaFolders(fileNamu) {
    FileRead, tehFileVar, %fileNamu%
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If (line="[FilesList]")
          Break

       If (RegExMatch(line, "i)^(DF[0-9].*\=[a-z]\:\\..)") && !RegExMatch(line, RegExFilesPattern))
          listu .= SubStr(line, InStr(line, "=")+1) "`n"
    }
 
    DynamicFoldersList := StrReplace(DynamicFoldersList, "|hexists|")
    listu .= "`n" Trimmer(DynamicFoldersList) "`n"
    changeMcursor()
    Sort, listu, UD`n
    DynamicFoldersList := listu
    Return listu
}

RegenerateEntireList() {
    If (AnyWindowOpen>0)
       CloseWindow("yes")

    If InStr(CurrentSLD, "\favourite-images-list.SLD")
    {
       retrieveFavesAsList()
       Return
    } Else If InStr(CurrentSLD, "\viewed-images-history-.SLD")
       Return

    If askAboutFileSave(" and the files list will be reloaded")
       Return

    thisIndex := currentFileIndex
    newStaticFoldersListCache := []
    startOperation := A_TickCount
    showTOOLtip("Refreshing files list, please wait...")
    If (RegExMatch(CurrentSLD, sldsPattern) && InStr(DynamicFoldersList, "|hexists|"))
       listu := coreLoadDynaFolders(CurrentSLD)
    Else If (StrLen(DynamicFoldersList)>3)
       listu := DynamicFoldersList

    listu := StrReplace(listu, "|hexists|")
    If StrLen(listu)<4
    {
       showTOOLtip("WARNING: No list of dynamic folders found...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    If StrLen(filesFilter)>1
    {
       usrFilesFilteru := filesFilter := ""
       FilterFilesIndex()
    }

    bckpResultedFilesList := []
    bckpMaxFilesIndex := 0
    renewCurrentFilesList()
    mustGenerateStaticFolders := (SLDtypeLoaded=3) ? 0 : 1
    Sort, listu, UD`n
    If (SLDtypeLoaded=3)
    {
       activeSQLdb.Exec("DELETE FROM images;")
       recreateDynaFoldersSQLdbList(listu)
       saveSlideSettingsInDB()
    }

    Loop, Parse, listu,`n
    {
       line := Trimmer(A_LoopField)
       fileTest := StrReplace(line, "|")
       If (RegExMatch(line, RegExFilesPattern) || StrLen(line)<4 || !FileExist(fileTest))
          Continue

       r := GetFilesList(line "\*")
       If (r="abandoned")
          Break
    }

    If (r="abandoned" && SLDtypeLoaded!=3)
    {
       resetMainWin2Welcome()
       showTOOLtip("Operation aborted. The files list is now empty...")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
    } Else
    {
       thisFolder := StrReplace(CurrentSLD, "|")
       If (SLDtypeLoaded=3)
          SQLdbGenerateStaticFolders()
       Else If (SLDtypeLoaded=1 && FolderExist(thisFolder))
          watchFolderDetails := getFolderDetails(thisFolder)

       GenerateRandyList()
       SoundBeep, 900, 100
       currentFileIndex := clampInRange(thisIndex, 1, maxFilesIndex)
       If (maxFilesIndex<1)
       {
          friendly := (SLDtypeLoaded=1 && FolderExist(thisFolder)) ? "No image files found in the folder:`n" thisFolder "\`n`n" : "Error refreshing files list... found nothing.`n`n"
          FadeMainWindow()
          msgBoxWrapper(appTitle ": WARNING", friendly "No indexed files, please open a file or folder...", 0, 0, "info")
          resetMainWin2Welcome()
       } Else dummyTimerDelayiedImageDisplay(50)
       ; RandomPicture()
    }
    etaTime := "Elapsed time to regenerate files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
}

sldDataBaseOpen(fileNamu) {
  activeSQLdb.CloseDB()
  activeSQLdb := new SQLiteDB
  If !activeSQLdb.OpenDB(fileNamu)
     Return -1

  startOperation := A_TickCount
  IniSLDBreadAll() ; read slideshow settings
  reorder := StrLen(prevFilesSortMode)>3 ? " ORDER BY " prevFilesSortMode ";" : ";"
  SQL := "SELECT imgfolder||'\'||imgfile AS imgPath FROM images" reorder
  RecordSet := ""
  startOperation := A_TickCount
  If !activeSQLdb.Query(SQL, RecordSet)
     Return -1

  Loop
  {
      If Row[1]
      {
         maxFilesIndex++
         resultedFilesList[maxFilesIndex] := [Row[1]] ; Row[1]
      }
      RC := RecordSet.Next(Row)
  } Until (RC<1)

  RecordSet.Free()
  RecordSet := ""
  SQL := "SELECT imgfolder FROM dynamicfolders;"
  DynamicFoldersList := ""
  activeSQLdb.Query(SQL, RecordSet)
  Loop
  {
      DynamicFoldersList .= Row[1] "`n"
      RC := RecordSet.Next(Row)
  } Until (RC < 1)
  RecordSet.Free()
  etaTime := "Elapsed time to open database files list: " SecToHHMMSS(Round((A_TickCount - startOperation)/1000, 3)) ". Files: " maxFilesIndex
  addJournalEntry(etaTime)
  If (A_TickCount - startOperation>7000) && (maxFilesIndex>2)
     SoundBeep , 900, 100

  ; MsgBox, % ("Files: " maxFilesIndex "Query: " . SQL . " done in " . (A_TickCount - Start) . " ms`n`n" resultedFilesList[10])
}

sldGenerateFilesList(readThisFile, doFilesCheck, mustRemQuotes, doOptionals:=1) {
    startZeit := A_TickCount
    FileRead, tehFileVar, %readThisFile%
    If (mustRemQuotes=1)
    {
       tehFileVar := StrReplace(tehFileVar, """-")
       tehFileVar := StrReplace(tehFileVar, """")
    }

    doStartLongOpDance()
    Loop, Parse, tehFileVar,`n,`r
    {
       line := Trimmer(A_LoopField)
       If InStr(line, "|")
       {
          doRecursive := 2
          line := StrReplace(line, "|")
       } Else doRecursive := 1

       If (determineTerminateOperation()=1)
       {
          abandonAll := 1
          Break
       }

       ; changeMcursor()
       If RegExMatch(line, RegExFilesPattern)
       {
          If (doFilesCheck=1)
          {
             If !FileRexists(line)
                Continue
          }
          maxFilesIndex++
          SLDhasFiles := 1
          resultedFilesList[maxFilesIndex] := [line]
       } Else If RegExMatch(line, "i)^(.\:\\.)") ; RegExMatch(line, "i)^(.\:\\.).*(\\)$")
       {
          line := Trimmer(line, "\")
          If FolderExist(line)
          {
             isRecursive := (doRecursive=2) ? "|" : ""
             DynamicFoldersList .= "`n" isRecursive line "`n"
             GetFilesList(line "\*", doRecursive)
          }
       }
    }

    etaTime := "Elapsed time to open TXT files list: " SecToHHMMSS(Round((A_TickCount - startZeit)/1000, 3)) ". Files: " maxFilesIndex
    addJournalEntry(etaTime)
    If (A_TickCount - startZeit>7000) && (maxFilesIndex>2)
       SoundBeep, 900, 100
    executingCanceableOperation := 0
    SetTimer, ResetImgLoadStatus, -50
    If (doOptionals=1)
    {
       If (abandonAll=1)
          showTOOLtip("Operation aborted. The files list is now empty.")
       Else If (maxFilesIndex<1)
          showTOOLtip("Found no files or folders in the SLD...`nThe files list is empty.")

       If (abandonAll=1 || maxFilesIndex<1)
       {
          lastLongOperationAbort := A_TickCount
          SetTimer, RemoveTooltip, % -msgDisplayTime
          SoundBeep, 300, 100
          Return "abandoned"
       }
    }
}

filterCoreString(stringu, behave, thisFilter, doExactFolderMatch:=0) {
  If (doExactFolderMatch=1)
  {
     zPlitPath(stringu, 1, OutFileName, OutDir)
     r := RegExMatch(OutDir "\", "i)^(" thisFilter "\\)$")
  } Else r := RegExMatch(stringu, "i)(" thisFilter ")")
  z := r ? 1 : 0
  Return (behave=2) ? !z : z
}

GetFilesList(strDir, doRecursive:=1, openFirst:=0) {
  showTOOLtip("Loading files from...`n" strDir "`n")
  If InStr(strDir, "|")
  {
     doRecursive := 2
     strDir := StrReplace(strDir, "|")
  }

  dig := (doRecursive=2) ? "" : "R"
  addedNow := 0
  startOperation := A_TickCount
  prevMSGdisplay := A_TickCount
  prevDisplay := A_TickCount
  If (SLDtypeLoaded=3)
     activeSQLdb.Exec("BEGIN TRANSACTION;")

  doStartLongOpDance()
  Loop, Files, %strDir%, %dig%
  {
      If (RegExMatch(Trimmer(A_LoopFileFullPath), RegExFilesPattern) && A_LoopFileSize>120)
      {
         addedNow++
         maxFilesIndex++
         resultedFilesList[maxFilesIndex] := [Trim(A_LoopFileFullPath)]
         If (SLDtypeLoaded=3) ; SQLite database 
            addSQLdbEntry(A_LoopFileName, A_LoopFileDir, A_LoopFileSize, A_LoopFileTimeModified, A_LoopFileTimeCreated)
      }

      If (A_TickCount - prevMSGdisplay>2000)
      {
         showTOOLtip("Loading files from...`n" strDir "`nFound " groupDigits(addedNow) " files...`nTotal indexed files: " groupDigits(maxFilesIndex))
         prevMSGdisplay := A_TickCount
      }

      changeMcursor()
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }
  }

  If (SLDtypeLoaded=3)
     activeSQLdb.Exec("COMMIT TRANSACTION;")

  executingCanceableOperation := 0
  SetTimer, ResetImgLoadStatus, -50
  If (abandonAll=1)
  {
     showTOOLtip("Files list loading aborted...")
     SetTimer, RemoveTooltip, % -msgDisplayTime
     Return "abandoned"
  }
  SetTimer, RemoveTooltip, % -msgDisplayTime
  Return loadedFirst
}

getIDimage(imgID) {
    r := resultedFilesList[imgID, 1]
    Return r
}

IDshowImage(imgID, opentehFile:=0) {
    Static prevIMGid, prevImgPath, lastInvoked := 1
    imgPath := getIDimage(imgID)
    If StrLen(imgPath)<4
    {
       addJournalEntry("Index entry error: incorrect file path:`n" imgPath " [ " imgID " ]")
       If (A_TickCount - lastInvoked>1050)
          SoundBeep, 300, 90
       lastInvoked := A_TickCount
       Return 0
    }

    isPipe := InStr(imgPath, "||")
    imgPath := StrReplace(imgPath, "||")
    If (InStr(AprevImgCall, imgPath) || InStr(BprevImgCall, imgPath) || StrLen(UserMemBMP)>2 || thumbsDisplaying=1)
       ignoreFileCheck := 1

    If (ignoreFileCheck!=1 && skipDeadFiles=1)
    {
       If (!FileRexists(imgPath) && opentehFile!=250 && imgPath!=prevImgPath)
       {
          If (autoRemDeadEntry=1 && imgID=currentFileIndex)
             remCurrentEntry(0, 1)
          Return 0
       }
    }

    If (AnyWindowOpen!=10 && resetImageViewOnChange=1 && thumbsDisplaying!=1)
    {
       newIMGid := generateThumbName(imgPath, 1)
       If (prevIMGid!=newIMGid)
       {
          prevIMGid := newIMGid
          usrColorDepth := imgFxMode := 1
          RenderOpaqueIMG := vpIMGrotation := FlipImgH := FlipImgV := 0
       }
    }

    prevImgPath := (opentehFile=0 || opentehFile=2) ? imgPath : 0
    If (opentehFile=2)
       ShowTheImage(imgPath, 2)  ; prevent down-scaled display
    Else If (opentehFile=3)
       ShowTheImage(imgPath, 2, 1)  ; force image reload
    Else
       ShowTheImage(imgPath)
    Return 1
}

PreventKeyPressBeep() {
   IfEqual,A_Gui,1,Return 0 ; prevent keystrokes for GUI 1 only
}

doSuspendu(act) {
  If (act=1)
     Suspend, On
  Else
     Suspend, Off
}

trimArray(arr) {
; Hash O(n) - function by errorseven from:
; https://stackoverflow.com/questions/46432447/how-do-i-remove-duplicates-from-an-autohotkey-array
    hash := {}
    newArr := []
    thisCounter := 0
    For k, v in arr
    {
        z := "z" StringToASC(v)
        If (hash[z]!=1)
        {
           thisCounter++
           hash[z] := 1
           newArr[thisCounter] := v
        }
    }
    Return newArr
}

ReverseListNow() {
    If StrLen(mustOpenStartFolder)>3
       currentFileIndex := doOpenStartFolder()

    If (askAboutFileSave(" and the files list will be reversed") || maxFilesIndex<3)
       Return

    showTOOLtip("Reversing files list order...")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := reverseArray(resultedFilesList)
    If StrLen(filesFilter)>1
       filteredMap2mainList := reverseArray(filteredMap2mainList)

    If InStr(backCurrentSLD, "\favourite-images-list.SLD")
       renewFavesListBasedOnIndexList()

    ForceRefreshNowThumbsList()
    CurrentSLD := backCurrentSLD
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

RandomizeListNow() {
    If StrLen(filesFilter)>1
    {
       msgResult := msgBoxWrapper(appTitle ": Randomize files list", "You currently have a files list filter applied. To randomize the list, it will be deactivated.", 4, 0, "question")
       If InStr(msgResult, "yes")
       {
          markedSelectFile := 0
          showTOOLtip("Deactivating the files list filter, please wait...")
          usrFilesFilteru := filesFilter := ""
          FilterFilesIndex()
          Sleep, 10
          RemoveTooltip()
       } Else Return
    }

    If askAboutFileSave(" and the files list will be randomized")
       Return

    showTOOLtip("Randomizing files list order...")
    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    resultedFilesList := Random_ShuffleArray(resultedFilesList)
    If InStr(backCurrentSLD, "\favourite-images-list.SLD")
       renewFavesListBasedOnIndexList()

    CurrentSLD := backCurrentSLD
    ForceRefreshNowThumbsList()
    dummyTimerDelayiedImageDisplay(50)
    SoundBeep, 900, 100
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

Random_ShuffleArray(Array) {
; function from "Facade Functional Programming Suite"
; by Shambles, from https://github.com/Shambles-Dev/AutoHotkey-Facade
; modified by Marius Șucan
; This is the Fisher–Yates shuffle.

    Result := Array.Clone()
    maxArray := Array.Count()
    Loop, % maxArray - 1
    {
        Random, J, % A_Index, % maxArray
        Temp            := Result[A_Index]
        Result[A_Index] := Result[J]
        Result[J]       := Temp
    }

    Return Result
}

reverseArray(a) {
; function inspired by RHCP from https://autohotkey.com/board/topic/97722-some-array-functions/

    aStorage := []
    maxIndexu := a.Count()
    Loop, % maxIndexu
        aStorage[A_Index] := a[maxIndexu - A_Index + 1]

    Return aStorage
}

coreResizeIMG(imgPath, newW, newH, file2save, goFX, toClippy, rotateAngle, soloMode:=1, imgW:=0, imgH:=0, batchMode:=0) {
    Static rr := "error"
    If (soloMode=1)
    {
       oBitmap := LoadBitmapFromFileu(imgPath)
       If StrLen(oBitmap)>2
       {
          Gdip_GetImageDimensions(oBitmap, imgW, imgH)
          rawFmt := Gdip_GetImageRawFormat(oBitmap)
          If (rawFmt="JPEG")
             RotateBMP2exifOrientation(oBitmap)

          If (!newW || !newH)
             mustDoRotateCoord := 1

          If !newW
             newW := imgW
          If !newH
             newH := imgH
          If (rotateAngle>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1 && mustDoRotateCoord=1)
             Gdip_GetRotatedDimensions(newW, newH, rotateAngle, newW, newH)
       } Else Return rr
    } Else oBitmap := soloMode

    If !oBitmap
       Return rr

    If (ResizeApplyEffects=1 || goFX=1)
    {
       mustDoBw := (bwDithering=1 && imgFxMode=4) ? 1 : 0
       If (imgFxMode=3 && toClippy!=1)
          AdaptiveImgLight(oBitmap, imgPath, 1, 1)

       decideGDIPimageFX(matrix, imageAttribs, pEffect)
    }

    ; to-do - if pargb - always??
    oPixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    If (toClippy=1)
       oPixFmt := (currIMGdetails.HasAlpha=1) ? "32-PARGB" : "24-RGB"

    brushRequired := !InStr(oPixFmt, "argb") ? 1 : 0
    If (InStr(oPixFmt, "argb") && RenderOpaqueIMG=1 && (goFX=1 || ResizeApplyEffects=1))
    {
       nBitmap := trGdip_RenderPixelsOpaque(oBitmap, pBrushWinBGR)
       If nBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := nBitmap
          brushRequired := must24bits := 1
       }
    }

    pixFmt := (must24bits=1) ? "0x21808" : "0x26200A"     ; 24-RGB  //  32-ARGB
    thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
    If (editingSelectionNow=1 && ResizeCropAfterRotation=1 && ResizeWithCrop=1 && rotateAngle>0)
    {
       oBitmap := coreRotateBMP(oBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
    }

    If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1 && soloMode=1)
       calcRelativeSelCoords(oBitmap, imgW, imgH)

    If (editingSelectionNow=1 && (goFX=1 || ResizeWithCrop=1))
    {
       calcImgSelection2bmp(0, imgW, imgH, newW, newH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       imgSelW := Round(imgW), imgSelH := Round(imgH)
       imgSelPx := 0, imgSelPy := 0

       zImgSelW := Round(newW), zImgSelH := Round(newH)
       zImgSelPx := 0, zImgSelPy := 0
    }

    thumbBMP := trGdip_CreateBitmap(A_ThisFunc, zImgSelW, zImgSelH, pixFmt)
    If warnUserFatalBitmapError(thumbBMP, A_ThisFunc)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    G2 := trGdip_GraphicsFromImage(A_ThisFunc, thumbBMP, thisImgQuality, 4, 2)
    If !G2
    {
       trGdip_DisposeImage(oBitmap, 1)
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    If (brushRequired=1) || (!RegExMatch(file2save, saveAlphaTypesRegEX) && toClippy!=1)
       trGdip_GraphicsClear(A_ThisFunc, G2, "0xFf" WindowBgrColor)
       ; Gdip_FillRectangle(G2, pBrushWinBGR, -2, -2, imgW + 4, imgH + 4)

    If (goFX=1 || ResizeApplyEffects=1)
    {
       setMainCanvasTransform(zImgSelW, zImgSelH, G2)
       If (bwDithering=1 && imgFxMode=4)
       {
          zBitmap := trGdip_BitmapConvertGray(oBitmap, hueAdjust, zatAdjust, lumosGrayAdjust, GammosGrayAdjust)
          If zBitmap
          {
             trGdip_DisposeImage(oBitmap, 1)
             oBitmap := zBitmap
          }

          E := Gdip_BitmapSetColorDepth(oBitmap, "BW", 1)
       } Else If (usrColorDepth>1)
          E := Gdip_BitmapSetColorDepth(oBitmap, internalColorDepth, ColorDepthDithering)
 
       If pEffect
          Gdip_BitmapApplyEffect(oBitmap, pEffect)
    }

    changeMcursor()
    E := trGdip_DrawImage(A_ThisFunc, G2, oBitmap, 0, 0, zImgSelW, zImgSelH, imgSelPx, imgSelPy, imgSelW, imgSelH,, 2, imageAttribs)
    trGdip_DisposeImage(oBitmap, 1)
    If (E="fail")
    {
       trGdip_DisposeImage(thumbBMP, 1)
       Gdip_DeleteGraphics(G2)
       Gdip_DisposeEffect(pEffect)
       Gdip_DisposeImageAttributes(imageAttribs)
       Return rr
    }

    Sleep, 0
    If (editingSelectionNow=1 && ResizeCropAfterRotation=0 && ResizeWithCrop=1 && rotateAngle>0) || (rotateAngle>0 && editingSelectionNow!=1) || (rotateAngle>0 && ResizeWithCrop!=1)
       thumbBMP := coreRotateBMP(thumbBMP, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired)

    If (toClippy!=1 && FileExist(file2save))
       Try FileSetAttrib, -R, %file2save%

    Sleep, 0
    changeMcursor()
    If StrLen(thumbBMP)>3
    {
       If (toClippy=1)
       {
          hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, thumbBMP)
          r := hBitmap ? Gdip_SetBitmapToClipboard(thumbBMP, hBitmap) : addJournalEntry("get_last_err")
       } Else
          r := Gdip_SaveBitmapToFile(thumbBMP, file2save, userJpegQuality)

       If (toClippy!=1) && (r=-2 || r=-1)
          r := SaveFIMfile(file2save, thumbBMP)
    } Else r := "err"

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeImageAttributes(imageAttribs)
    Gdip_DisposeEffect(pEffect)
    trGdip_DisposeImage(thumbBMP, 1)
    Return r
}

coreRotateBMP(whichBitmap, rotateAngle, goFX, thisImgQuality, pixFmt, brushRequired) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}

    confirmSimpleRotation := (rotateAngle=0 || rotateAngle=90 || rotateAngle=180 || rotateAngle=270) ? 1 : 0
    If (confirmSimpleRotation=1)
    {
       imgFoperation := (rotateAngle=90) ? 1 : 0
       imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
       imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
       ; If (goFX=1 || ResizeApplyEffects=1)
       ;    imgFoperation := imgOrientOpt["i" imgFoperation FlipImgH FlipImgV]
       If (imgFoperation>0)
          Gdip_ImageRotateFlip(whichBitmap, imgFoperation)
       thumbBMP := whichBitmap
    } Else
    {
       whichBrush := (brushRequired=1) ? pBrushWinBGR : ""
       zBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, rotateAngle, whichBrush, thisImgQuality, pixFmt)
       If StrLen(zBitmap)>2
       {
          trGdip_DisposeImage(whichBitmap, 1)
          thumbBMP := zBitmap
       } Else thumbBMP := zBitmap
       ; If (goFX=1 || ResizeApplyEffects=1) && (ResizeCropAfterRotation=1)
       ;    flipBitmapAccordingToViewPort(thumbBMP, 1)
    }
    Return thumbBMP
}

flipBitmapAccordingToViewPort(whichBitmap, ignoreThis:=0) {
   imgOp := (FlipImgH=1) ? 4 : 0
   imgOp := (FlipImgV=1) ? 6 : imgOp
   imgOp := (FlipImgV=1 && FlipImgH=1) || (vpIMGrotation=180 && ignoreThis=0) ? 2 : imgOp
   If (imgOp>0 && whichBitmap)
      Gdip_ImageRotateFlip(whichBitmap, imgOp)
}

calcImgSelection2bmp(noLimits, imgW, imgH, newW, newH, ByRef imgSelPx, ByRef imgSelPy, ByRef imgSelW, ByRef imgSelH, ByRef zImgSelPx, ByRef zImgSelPy, ByRef zImgSelW, ByRef zImgSelH, ByRef nImgSelX1, ByRef nImgSelY1, ByRef nImgSelX2, ByRef nImgSelY2, usePrevious:=0, givenRotation:=0, givenCoords:=0) {
   If (usePrevious=1)
   {
      nImgSelX1 := min(prevImgSelX1, prevImgSelX2)
      nImgSelY1 := min(prevImgSelY1, prevImgSelY2)
      nImgSelX2 := max(prevImgSelX1, prevImgSelX2)
      nImgSelY2 := max(prevImgSelY1, prevImgSelY2)
   } Else
   {
      nImgSelX1 := min(imgSelX1, imgSelX2)
      nImgSelY1 := min(imgSelY1, imgSelY2)
      nImgSelX2 := max(imgSelX1, imgSelX2)
      nImgSelY2 := max(imgSelY1, imgSelY2)
   }

   If InStr(givenCoords, "|")
   {
      givenCoordsObj := StrSplit(givenCoords, "|")
      nImgSelX1 := min(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY1 := min(givenCoordsObj[2], givenCoordsObj[4])
      nImgSelX2 := max(givenCoordsObj[1], givenCoordsObj[3])
      nImgSelY2 := max(givenCoordsObj[2], givenCoordsObj[4])
   }

   If (noLimits!=1)
   {
      If (nImgSelX1<0)
         nImgSelX1 := 0
      If (nImgSelY1<0)
         nImgSelY1 := 0

      If (nImgSelX2>imgW)
         nImgSelX2 := imgW
      If (nImgSelY2>imgH)
         nImgSelY2 := imgH
   }

   imgSelW := max(nImgSelX1, nImgSelX2) - min(nImgSelX1, nImgSelX2)
   imgSelH := max(nImgSelY1, nImgSelY2) - min(nImgSelY1, nImgSelY2)
   imgSelPx := min(nImgSelX1, nImgSelX2)
   imgSelPy := min(nImgSelY1, nImgSelY2)
   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(imgSelW, imgSelH, givenRotation, rimgSelW, rimgSelH)
      imgSelPx := imgSelPx - (rimgSelW - imgSelW)//2
      imgSelPy := imgSelPy - (rimgSelH - imgSelH)//2
      imgSelW := rimgSelW
      imgSelH := rimgSelH
      If (imgSelPx<1)
         imgSelPx := 0
      If (imgSelPy<1)
         imgSelPy := 0
      If (imgSelPx + imgSelW>imgW)
         imgSelW := imgW - imgSelPx
      If (imgSelPy + imgSelH>imgH)
         imgSelH := imgH - imgSelPy
   }

   If (imgSelW<2)
   {
      imgSelW := 2
      imgSelPx := (imgSelPx>=2) ? imgSelPx - 2 : 0
      nImgSelX2 := imgSelPx + imgSelW
   }

   If (imgSelH<2)
   {
      imgSelH := 2
      imgSelPy := (imgSelPy>=2) ? imgSelPy - 2 : 0
      nImgSelY2 := imgSelPy + imgSelH
   }

   nImgSelX1 := imgSelPx
   nImgSelY1 := imgSelPy

   zLv := newH/imgH
   zLh := newW/imgW
   zImgSelX1 := Floor(nImgSelX1*zLh)
   zImgSelY1 := Floor(nImgSelY1*zLv)
   zImgSelX2 := Floor(nImgSelX2*zLh)
   zImgSelY2 := Floor(nImgSelY2*zLv)
   If (noLimits!=1)
   {
      If (zImgSelX2>newW)
         zImgSelX2 := newW
      If (zImgSelY2>newH)
         zImgSelY2 := newH
   }

   zImgSelW := max(zImgSelX1, zImgSelX2) - min(zImgSelX1, zImgSelX2)
   zImgSelH := max(zImgSelY1, zImgSelY2) - min(zImgSelY1, zImgSelY2)
   zImgSelPx := min(zImgSelX1, zImgSelX2)
   zImgSelPy := min(zImgSelY1, zImgSelY2)

   If (givenRotation>0)
   {
      Gdip_GetRotatedDimensions(zimgSelW, zimgSelH, givenRotation, zrimgSelW, zrimgSelH)
      zimgSelPx := zimgSelPx - (zrimgSelW - zimgSelW)//2
      zimgSelPy := zimgSelPy - (zrimgSelH - zimgSelH)//2
      zimgSelW := zrimgSelW
      zimgSelH := zrimgSelH
      If (zimgSelPx<1)
         zimgSelPx := 0
      If (zimgSelPy<1)
         zimgSelPy := 0
      If (zimgSelPx + zimgSelW>newW)
         zimgSelW := newW - zimgSelPx
      If (zimgSelPy + zimgSelH>newH)
         zimgSelH := newH - zimgSelPy
   }

   If (zImgSelW<2)
   {
      zImgSelW := 2
      zImgSelPx := (zImgSelPx>=2) ? zImgSelPx - 2 : 0
   }

   If (zImgSelH<2)
   {
      zImgSelH := 2
      zImgSelPy := (zImgSelPy>=2) ? zImgSelPy - 2 : 0
   }
}

ResizePanelHelpBoxInfo() {
    msgBoxWrapper(appTitle ": HELP", "In «Advanced mode» there is limited support for color depths other than 24 and 32 bits. All images will be converted to 24 bits per pixel. If the alpha channel is present, the resulted file will be in 32 bits, if the format allows. When saving images in formats that do not support an alpha channel, the window background color is used.`n`nUse «Simple mode» to better preserve color depths or work with images larger than 530 MPx or than 32500 px [if the given file format allows it]. This mode supports 1-, 8-, 24-, 32-, 16- (UINT16), 48- (RGB16), 64- (RGBA16), 32- (FLOAT), 96- (RGBF) and 128- (RGBAF) bits images. High-dynamic range formats supported: .EXR, .HDR, .JXR, .HDP, .PFM and .TIFF.`n`nPlease also note, while there is full support for multi-frames/paged images [for GIFs and TIFFs only] in the viewport... on file (re)save or format conversion, only the first frame will be preserved.", -1, 0, 0)
}

OpenGitHub() {
  Static thisURL := "https://github.com/marius-sucan/Quick-Picto-Viewer"
  Try Run, % thisURL
  Catch wasError
        Sleep, 1

  If wasError
     msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the URL...`n" %thisURL%, 0, 0, "error")
}

drawViewportHelpMap() {
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    If (TouchScreenMode=1)
    {
       SetTimer, RemoveTooltip, Off
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0xEE121212")
       calculateTouchMargins(thisX, thisY, thisW, thisH)
       thisThick := imgHUDbaseUnit//10
       Penuha := Gdip_CreatePen("0x99334433", thisThick)
       BrushAa := Gdip_BrushCreateSolid(0x15EEeeEE)
       BrushBb := Gdip_BrushCreateSolid(0x20778877)
       Gdip_FillRectangle(2NDglPG, BrushAa, thisX, thisY, thisW, thisH)
       Gdip_FillRectangle(2NDglPG, BrushBb, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_FillRectangle(2NDglPG, BrushBb, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_SetClipRect(2NDglPG, thisX, thisY + thisThick, thisW, thisH - thisThick*2, 4)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisX + thisThick, thisY, thisW - thisThick*2, thisH)
       Gdip_ResetClip(2NDglPG)
       Gdip_DrawRectangle(2NDglPG, Penuha, -thisThick, -thisThick, thisX + thisThick, mainHeight + thisThick*2)
       Gdip_DrawRectangle(2NDglPG, Penuha, thisW + thisX, -thisThick, thisX + thisThick*2, mainHeight + thisThick*2)
       Gdip_DeletePen(Penuha)
       Gdip_DeleteBrush(BrushAa)
       Gdip_DeleteBrush(BrushBb)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.77)
       thisStylu := " x" thisX " y" thisY
       ERR := Gdip_TextToGraphics(2NDglPG, "Image panning area.`n`nDouble click in this area to change how the image is adapted to the viewport.`n`nShift + Left-click to create a new selection area.`n`nOne-finger swipe gestures allowed when nothing to pan - outside this rectangle they are always allowed.", thisFntSize thisStylu , "Arial", thisW, thisH)

       thisFntSize := "Bold Center vCenter cFFeeEEee s" Round(OSDfntSize*0.9)
       thisStylu := " x" thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom in", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x" thisX " y" thisY + thisH
       ERR := Gdip_TextToGraphics(2NDglPG, "Zoom out", thisFntSize thisStylu, "Arial", thisW, thisY)
       thisStylu := " x1 y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Previous`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       thisStylu := " x" thisW + thisX " y1"
       ERR := Gdip_TextToGraphics(2NDglPG, "Next`nimage", thisFntSize thisStylu, "Arial", thisX, mainHeight)
       r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
       toolTipGuiCreated := 2
    }

}

AboutWindow() {
    Global LViewOthers, listViewFilteru
    If AnyWindowOpen
       Return

    thisBtnHeight := createSettingsGUI(1, A_ThisFunc)
    Gui, Add, Button, x1 y1 h1 w1 Default gBtnCloseWindow, Close
    Gui, -DPIScale
    Gui, Font, s19 Bold, Arial, -wrap
    Gui, Add, Picture, x+10 y+10 w150 Section h-1 +0x3 gOpenGitHub, qpv-icon.ico
    Gui, Add, Text, x+20 y15, %appTitle% v%appVersion%
    Gui, Font, s10 Bold, Arial, -wrap
    Gui, Add, Link, y+5 wp, Developed by <a href="http://marius.sucan.ro/">Marius Șucan</a>.
    Gui, Font
    Gui, Add, Link, y+10 wp, Based on the prototype image viewer by <a href="http://sites.google.com/site/littlescripting/">SBC</a> from October 2010 published on <a href="https://autohotkey.com/board/topic/58226-ahk-picture-viewer/">AHK forums</a>.
    lstWid := 450
    btnWid := 100
    txtWid := 440
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 250
       btnWid := btnWid + 50
       txtWid := txtWid + 190
       Gui, Font, s%LargeUIfontValue%
    }
    drawViewportHelpMap()
    IniAction(1, "appVersion", "General")
    If wasInitFIMlib
       thisVersion := " v" FreeImage_GetVersion()

    compiled := (A_IsCompiled=1) ? "Compiled. " : "Uncompiled. "
    compiled .= (A_PtrSize=8) ? "x64. " : "x32. "
    Gui, +DPIScale
    Gui, Add, Tab3, xs, General|Keyboard shortcuts|Command line|
    Gui, Tab, 1 ; general
    Gui, Font, Bold
    Gui, Add, Text, x+15 y+15 w%txtWid%, Current version: v%appVersion% from %vReleaseDate%. Internal AHK-H version: %A_AhkVersion%. %compiled%OS: %A_OSVersion%.
    Gui, Font, Normal
    Gui, Add, Text, y+10 w%txtWid%, Dedicated to people with really large image collections and slideshow needs :-).
    Gui, Add, Text, y+10 w%txtWid%, This application contains code from various entities. You can find more details in the source code.
    Gui, Add, Text, y+10 w%txtWid%, QPV uses GDI+ [Windows APIs] to display images and FreeImage%thisVersion% to load exotic file formats. FreeImage is licensed under the GNU General Public License, v2.0 (GPLv2) or v3.0 (GPLv3), and the FreeImage Public License (FIPL)

    Gui, Add, Link, y+10 w%txtWid%, To keep the development going, <a href="https://www.paypal.me/MariusSucan/10">please donate</a> or <a href="mailto:marius.sucan@gmail.com?subject=%appTitle% v%appVersion%">send me feedback</a>.
    Gui, Add, Link, y+10 w%txtWid%, New and previous versions are available on <a href="https://github.com/marius-sucan/Quick-Picto-Viewer">GitHub</a>.

    Gui, Tab, 2 ; keyboard 
    Gui, Add, ListView, x+15 y+15 w%lstWid% r10 Grid vLViewOthers, Keys|Action|Context|Opens
    Gui, Add, Edit, xp y+10 wp -multi -wantTab gfilterListViewKbdsAbout +hwndhEditField vlistViewFilteru,

    cmdHelp := "QPV can be invoked with command line arguments. Examples:`n`n1. Open a folder:`nqpv.exe ""fd=C:\example folder\tempus""`n`nAdd a pipe ""|"" after equal ""="" to have images loaded recursively."
    cmdHelp .= "`n`n2. Specify user settings:`n`nqpv.exe set_IMGresizingMode=3 set_vpIMGrotation=45 ""C:\example folder\this-image.png""`n`nYou can find available user settings in the qpv.ini file.`n`nYou can pass up to 300 arguments`n`nPass /qpv-debug argument to have QPV send debug information to a Win32 Debug Viewer.`n`nIf one .SLD file or one folder is passed as argument, any other image file passed as argument is ignored."

    Gui, Tab, 3 ; 
    Gui, Add, Edit, x+15 y+15 w%lstWid% r13 ReadOnly, %cmdHelp%

    Gui, Tab
    Gui, Add, Button, xs y+5 h%thisBtnHeight% w105 Default gBtnCloseWindow, &Close
    Gui, Add, Button, x+5 hp wp gPanelJournalWindow, &Journal
    If !A_IsAdmin
       Gui, Add, Button, x+5 hp gRunAdminMode, &Run in admin mode
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "About " appTitle " v" appVersion)
    PopulateAboutKbdShortcutsList()
}

PopulateAboutKbdShortcutsList(listFilter:=0) {
    EM_SETCUEBANNER(hEditField, "Filter keyboard shortcuts list...", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
 
    FileRead, fileData, % mainCompiledPath "\help-keyboard-shortcuts.txt"
    startOperation := A_TickCount
    Loop, Parse, fileData, `n, `r
    {
        If (StrLen(A_LoopField)<5) || (listFilter && !InStr(A_LoopField, listFilter))
           Continue

        countThese++
        lineArru := StrSplit(A_LoopField, "|")
        LV_Add(A_Index, lineArru[1], lineArru[2], lineArru[3], lineArru[4])
    }

    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

filterListViewKbdsAbout() {
   GuiControlGet, listViewFilteru
   PopulateAboutKbdShortcutsList(listViewFilteru)
}

BtnChangeSatPlus() {
  ChangeSaturation(1)
}

BtnChangeSatMin() {
  ChangeSaturation(-1)
}

BtnChangeLumPlus() {
  ChangeLumos(1)
}

BtnChangeLumMin() {
  ChangeLumos(-1)
}

BtnChangeGammPlus() {
  ChangeGammos(1)
}

BtnChangeGammMin() {
  ChangeGammos(-1)
}

PanelsCheckFileExists() {
   If (currentFileIndex=0)
      Return 0

   imgPath := getIDimage(currentFileIndex)
   zPlitPath(imgPath, 0, fileNamu, folderu)
   If !FileRexists(imgPath)
   {
      showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return 0
   } Else Return 1
}

PanelResolutionSorting() {
   If AnyWindowOpen
      Return

   widthu := (PrefsLargeFonts=1) ? 650 : 450
   fakeWinCreator(20, A_ThisFunc, 1)
   msgResult := msgBoxWrapper("panelu|Choose sorting mode: " appTitle, "Each file will be read to identify the image resolution, in pixels.`n`nThis operation can take a lot of time with many files.", "&Sort list|C&ancel", 1, "image-file", "Reverse list", 0, "Resolution (MPx)`f`fImage width`fImage height`fAspect ratio (W/H)", nullEdit, nullEdit, 2, widthu)
   If InStr(msgResult.btn, "sort")
   {
      If (msgResult.list=1)
         ActSortResolution()
      Else If (msgResult.list=2)
         ActSortimgW()
      Else If (msgResult.list=3)
         ActSortimgH()
      Else If (msgResult.list=4)
         ActSortImgWHratio()

      If (msgResult.check=1)
         ReverseListNow()
   }
}

PanelJpegPerformOperation() {
    Global mainBtnACT

    If !PanelsCheckFileExists()
       Return

    filesElected := getSelectedFiles(0, 1)
    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    thisBtnHeight := createSettingsGUI(12, A_ThisFunc)
    btnWid := 110
    txtWid := slideWid := 280

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 100
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    If (editingSelectionNow!=1)
       jpegDoCrop := 0

    Gui, Add, Text, x15 y15 Section, Please choose a JPEG lossless operation...
    Gui, Add, DropDownList, y+10 Section w%txtWid% AltSubmit Choose%jpegDesiredOperation% vjpegDesiredOperation, None|Flip Horizontally|Flip Vertically|Transpose|Transverse|Rotate 90°|Rotate 180°|Rotate -90° [270°]
    Gui, Add, Checkbox, y+10 Checked%jpegDoCrop% vjpegDoCrop, Crop image(s) to selected area (irreversible)
    If (filesElected>1)
       Gui, Add, Text, y+20, %filesElected% files are selected.
    If (editingSelectionNow!=1)
       GuiControl, Disable, jpegDoCrop

    If (filesElected<2)
    {
       Gui, Add, Button, xs y+10 h%thisBtnHeight% w%btnWid% gBTNautoCropRealtime, &Auto-crop selection
       Gui, Add, Button, x+5 hp w%btnWid% gPanelImgAutoCrop, &Configure auto-crop
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnPerformJpegOp vmainBtnACT, &Perform operation
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% Default gBtnPerformJpegOp, &Perform operation
 
    Gui, Add, Button, x+5 hp w80 gBtnCloseWindow, C&lose
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "JPEG lossless operations: " appTitle)
}

BtnPerformJpegOp() {
    Static lastInvoked := 1
    GuiControlGet, jpegDesiredOperation
    GuiControlGet, jpegDoCrop
    GuiControlGet, mainBtnACT
    If (A_TickCount - lastInvoked < 150) || (jpegDesiredOperation=1 && jpegDoCrop=0)
    {
       showTOOLtip("WARNING: No operations selected to perform...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    imgPath := getIDimage(currentFileIndex)
    initFIMGmodule()
    If !wasInitFIMlib
    {
       msgBoxWrapper(appTitle ": ERROR", "Unable to initialize the FreeImage library module...`n`nThis functionality is currently unavailable...", 0, 0, "error")
       Return
    }

    lastInvoked := A_TickCount
    ForceRefreshNowThumbsList()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchJpegLLoperations()
       Return
    } Else If (currIMGdetails.HasAlpha!=1)
    {
       destroyGDIfileCache()
       r := coreJpegLossLessAction(imgPath, jpegDesiredOperation, jpegDoCrop)
    }

    GuiControl, SettingsGUIA: Disable, mainBtnACT
    SetTimer, reactivateMainBtnACT, -800
    If r
    {
       resultedFilesList[currentFileIndex, 4] := 1
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("JPEG operation completed succesfully.")
       RefreshImageFile()
    } Else
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The JPEG operation has failed. The file might not be a JPEG as the file extension suggests...", 0, 0, "error")
    }
    lastInvoked := A_TickCount
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

reactivatemainBtnACT() {
    If (AnyWindowOpen=12 || AnyWindowOpen=18 || AnyWindowOpen=17)
    {
       If (imageLoading=1)
          SetTimer, reactivatemainBtnACT, -600
       Else
          GuiControl, SettingsGUIA: Enable, mainBtnACT
    }
}

batchJpegLLoperations() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && jpegDoCrop=1) || (filesElected>150)
   {
      msgInfos := (jpegDoCrop=1) ? "`n`nThe crop operation IS irreversible!" : ""
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Are you sure you want to perform the JPEG transformations on the selected files? There are currently " filesElected " selected files. " msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
 
   CloseWindow("yes")
   Sleep, 25
   showTOOLtip("Performing JPEG lossless operations on " filesElected " files, please wait...")
   prevMSGdisplay := A_TickCount
   failedFiles := countFilez := countTFilez := 0

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>3) ? 1 : 0
   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresJpegLL(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("File format conversion: failed to initialize multi-threaded processing...")

   prevMSGdisplay := A_TickCount
   startOperation := A_TickCount
   doStartLongOpDance()
   CurrentSLD := ""
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      file2rem := getIDimage(thisFileIndex)
      If (InStr(file2rem, "||") || !file2rem)
         Continue
 
      If (A_TickCount - prevMSGdisplay>3000)
      {
         If (failedFiles>0)
            someErrors := "`nFor " failedFiles " files, the operations failed..."
         If (skippedFiles>0)
            someErrors .= "`n" skippedFiles " files were skipped"

         zeitOperation := A_TickCount - startOperation
         percDone := " ( " Round((countTFilez / filesElected) * 100) "% )"
         percLeft := (1 - countTFilez / filesElected) * 100
         zeitLeft := (zeitOperation/countTFilez) * filesElected - zeitOperation
         etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
         etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
         showTOOLtip("Performing JPEG lossless operations on " countTFilez "/" filesElected " files, please wait..." someErrors etaTime, 0, 0, countTFilez / filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      countTFilez++
      If !RegExMatch(file2rem, "i)(.\.(jpeg|jpg|jpe))$")
      {
         skippedFiles++
         Continue
      }

      r := coreJpegLossLessAction(file2rem, jpegDesiredOperation, jpegDoCrop)
      If r
      {
         resultedFilesList[thisFileIndex, 4] := 1
         countFilez++
      } Else failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFor " failedFiles " files, the operations failed..."
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped"

   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip(countFilez " out of " countTFilez " selected JPEG files were processed" someErrors)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
   Return
}

coreJpegLossLessAction(imgPath, jpegOperation, mustCrop) {
    FileGetTime, originalMtime, % imgPath, M
    FileGetTime, originalCtime, % imgPath, C
    FileSetAttrib, -R, %imgPath%
    Sleep, 1
    changeMcursor()
    If (mustCrop=1 && editingSelectionNow=1) || (mustCrop=1 && hasInitSpecialMode=1)
    {
       r1 := GetImgFileDimension(imgPath, imgW, imgH)
       If (relativeImgSelCoords=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       r := FreeImage_JPEGTransformCombined(imgPath, imgPath, jpegOperation - 1, X1, Y1, X2, Y2)
    } Else
    {
       Sleep, -1
       r := FreeImage_JPEGTransform(imgPath, imgPath, jpegOperation - 1)
    }

    If originalMtime
    {
       Sleep, 0
       FileSetTime, % originalMtime, % imgPath, M
       FileSetTime, % originalCtime, % imgPath, C
    }
    Return r
}

toggleImgEditPanelWindow(dummy:="") {
   Static Width := 0, Height := 0, lastInvoked := A_TickCount
   If (AnyWindowOpen!=10 && imgEditPanelOpened!=1 && dummy!="forced") || (A_TickCount - lastInvoked<350)
      Return

   ; WinGetPos, , , nWidth, nHeight, ahk_id %hSetWinGui%
   thisHeight := imgHUDbaseUnit//4 + 2
   thisWidth := imgHUDbaseUnit//2 + 2
   ; If (Width<nWidth-5) || (Height<nHeigh-5)
   ;    panelWinCollapsed := 1

   If (panelWinCollapsed=0)
   {
      Gui, SettingsGUIA: Show, NoActivate w%thisWidth% h%thisHeight%
      Gui, SettingsGUIA: -SysMenu
      WinActivate, ahk_id %PVhwnd%
      WinSet, Transparent, 190, ahk_id %hSetWinGui%
      WinSet, Style, -0xC00000, ahk_id %hSetWinGui%
      ; WinGetPos, , , Width, Height, ahk_id %hSetWinGui%
      ; WinSet, Disable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 1
   } Else 
   {
      WinSet, Transparent, 255, ahk_id %hSetWinGui%
      WinSet, Style, +0xC00000, ahk_id %hSetWinGui%
      Gui, SettingsGUIA: Show, AutoSize
      Gui, SettingsGUIA: +SysMenu
      ; WinSet, Enable,, ahk_id %hSetWinGui%
      panelWinCollapsed := 0
   }
   lastInvoked := A_TickCount
   interfaceThread.ahkassign("panelWinCollapsed", panelWinCollapsed)
}

PanelColorsAdjusterWindow() {
    Global sliderBright, sliderContrst, sliderSatu, realTimePreview, CustomZoomCB, infoImgZoom, infolummyAdjust
         , infoBright, infoContrst, infoSatu, BtnLumPlus, BtnLumMin, BtnFlipH, infoZatAdjust, UIvpImgAlignCenter
         , BtnGammPlus, BtnGammMin, BtnSatPlus, BtnSatMin, ResizeModeDL, BtnFlipV, infohueAdjust
         , infoRGBchnls, RGBcbList := "-3.0|-2.0|-1.5|-1.0|-0.9|-0.8|-0.7|-0.6|-0.5|-0.4|-0.3|-0.2|-0.1|0.0|0.1|0.2|0.3|0.4|0.5|0.6|0.7|0.8|0.9|1.0|1.5|2.0|3.0"
         , infoRealGammos, infoThreshold, UIimgThreshold, UIrealGammos, infoImgRotation, UIdoubleZoom

    If (thumbsDisplaying=1 || StrLen(gdiBitmap)<4 || openingPanelNow=1)
       Return

    ; If (editingSelectionNow=1)
    ;    toggleImgSelection()
    openingPanelNow := 1
    setImageLoading()
    showTOOLtip("Opening colors adjustments panel, please wait...")
    imgEditPanelOpened := 1
    thisBtnHeight := createSettingsGUI(10, A_ThisFunc)
    ForceNoColorMatrix := 0
    If (usrColorDepth=0)
       usrColorDepth := 1

    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 180
    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       slide2Wid := slide2Wid + 65
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }

    thisZL := Round(zoomLevel*100) "%"
    UIdoubleZoom := (zoomLevel>4.99) ? 1 : 0
    UIimgThreshold := imgThreshold*100
    UIrealGammos := realGammos*100
    UIvpImgAlignCenter := (imageAligned=5) ? 1 : 0
    Gui, Add, Tab3, gBtnTabsInfoUpdate AltSubmit vCurrentPanelTab Choose%CurrentPanelTab%, Color matrix|More adjustments|Other options
    Gui, Tab, 1 ; general
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%imgFxMode% vimgFxMode, Original image colors|Personalized colors|Auto-adjusted colors|Grayscale|Red channel|Green channel|Blue channel|Alpha channel|Inverted colors|Sepia
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%autoAdjustMode% vAutoAdjustMode, Adaptive mixed mode|Increase brightness|Increase contrast
    Gui, Add, ComboBox, x+1 w90 gColorPanelTriggerImageUpdate vusrAdaptiveThreshold, -2000|-100|-50|-2|1|2|50|1000|2000|%usrAdaptiveThreshold%||
    Gui, Add, Checkbox, xs y+2 w%txtWid% gColorPanelTriggerImageUpdate Checked%doSatAdjusts% vdoSatAdjusts, Auto-adjust image saturation level
    Gui, Add, Checkbox, x+5 w90 gColorPanelTriggerImageUpdate Checked%bwDithering% vbwDithering, B/W
    Gui, Add, Text, xs y+8 w%txtWid% gBtnResetBrightness vinfoBright, Brightness: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderBright Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeLumPlus vBtnLumPlus, +
    Gui, Add, Button, x+1 hp wp gBtnChangeLumMin vBtnLumMin, -
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetContrast vinfoContrst, Contrast: ----
    Gui, Add, Slider, y+1 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderContrst Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeGammPlus vBtnGammPlus, -
    Gui, Add, Button, x+1 hp wp gBtnChangeGammMin vBtnGammMin, +
    Gui, Add, Text, xs y+2 w%txtWid% gBtnResetSaturation vinfoSatu, Saturation: ----
    Gui, Add, Slider, y+5 AltSubmit ToolTip NoTicks w%slideWid% gColorPanelTriggerImageUpdate vsliderSatu Range-100-100, 1
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatPlus vBtnSatPlus, +
    Gui, Add, Button, x+1 hp w45 gBtnChangeSatMin vBtnSatMin, -
    Gui, Add, Text, xs y+2 w%slide2Wid% gBtnResetRealGamma vinfoRealGammos, Gamma: ----
    Gui, Add, Text, x+5 w%slide2Wid% gBtnResetThreshold vinfoThreshold, Threshold: ----
    Gui, Add, Slider, xs y+2 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIrealGammos Range0-800, % UIrealGammos
    Gui, Add, Slider, x+5 AltSubmit NoTicks ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vUIimgThreshold Range0-100, % UIimgThreshold
    ; Gui, Add, Checkbox, xs y+15 gColorPanelTriggerImageUpdate Checked%realTimePreview% vrealTimePreview, Update image in real time
    Gui, Add, Text, xs y+8 gBtnResetCHNdec vinfoRGBchnls, RGB channels balance:
    Gui, Add, ComboBox, x+5 w65 gColorPanelTriggerImageUpdate vchnRdecalage, %RGBcbList%|%chnRdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnGdecalage, %RGBcbList%|%chnGdecalage%||
    Gui, Add, ComboBox, x+5 wp gColorPanelTriggerImageUpdate vchnBdecalage, %RGBcbList%|%chnBdecalage%||


    slide3wid := slide2wid - 42
    Gui, Tab, 2 ; more
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%specialColorFXmode% vspecialColorFXmode, None|Blur|Sharpen|Brightness / Contrast|Hue / Saturation / Lightness|Levels adjust|Color tint|Colors balance|Color curve per channel
    Gui, Add, DropDownList, xs y+2 w%slide3Wid% gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXmode% vuiColorCurveFXmode, Brightness (density)|Contrast|Highlights|Shadows|Mid-tones|White saturation|Black saturation
    Gui, Add, DropDownList, x+2 wp gColorPanelTriggerImageUpdate AltSubmit Choose%uiColorCurveFXchannel% vuiColorCurveFXchannel, Red|Green|Blue|Apply on all channels

    Gui, Add, Text, xs y+10 w%slideWid% gBtnResetHue vinfohueAdjust, Hue: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit NoTicks ToolTip gColorPanelTriggerImageUpdate vhueAdjust Range-300-300, % hueAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetVibrance vinfoZatAdjust, Vibrance: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit NoTicks ToolTip gColorPanelTriggerImageUpdate vzatAdjust Range-300-300, % zatAdjust
    Gui, Add, Text, xs y+10 wp gBtnResetLummy vinfolummyAdjust, Lightness: ----
    Gui, Add, Slider, xs y+2 wp AltSubmit NoTicks ToolTip gColorPanelTriggerImageUpdate vlummyAdjust Range-300-300, % lummyAdjust

    Gui, Tab, 3 ; others
    Gui, Add, DropDownList, x+15 y+15 Section w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%IMGresizingMode% vIMGresizingMode, Adapt all images into view|Adapt only large images into view|Original resolution (100`%)|Custom zoom level|Stretched to window size
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%UIvpImgAlignCenter% vUIvpImgAlignCenter, Centered
    Gui, Add, DropDownList, xs y+5 w%txtWid% gColorPanelTriggerImageUpdate AltSubmit Choose%usrColorDepth% vusrColorDepth, Simulate color depth|2 bits [4 colors]|3 bits [8 colors]|4 bits [16 colors]|5 bits [32 colors]|6 bits [64 colors]|7 bits [128 colors]|8 bits [256 colors]|16 bits [65536 colors]
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%ColorDepthDithering% vColorDepthDithering, Dithering
    Gui, Add, Text, xs y+10 w%slide2Wid% gBtnResetRotation vinfoImgRotation, Image rotation: ----
    Gui, Add, Checkbox, x+5 gColorPanelTriggerImageUpdate Checked%UIdoubleZoom% vUIdoubleZoom, 2x
    Gui, Add, Text, x+1 w%slide2Wid% gBtnResetZoom vinfoImgZoom, Image zoom: ----
    Gui, Add, Slider, xs y+10 ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vvpIMGrotation Range0-360, % Round(vpIMGrotation)
    Gui, Add, Slider, x+5 ToolTip w%slide2Wid% gColorPanelTriggerImageUpdate vCustomZoomCB Range1-500, % thisZL
    Gui, Add, Text, xs y+10 h%thisBtnHeight% +0x200, Flip viewport:
    Gui, Add, Checkbox, x+10 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgV% vFlipImgV, vertically
    Gui, Add, Checkbox, x+5 +0x1000 hp gColorPanelTriggerImageUpdate Checked%FlipImgH% vFlipImgH, horizontally
    Gui, Add, Text, xs y+10, Display histogram:
    Gui, Add, DropDownList, x+10 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%showHistogram% vshowHistogram, None|Luminance|Red|Green|Blue|All mixed
    Gui, Add, DropDownList, x+6 w%btnWid% gColorPanelTriggerImageUpdate AltSubmit Choose%histogramMode% vhistogramMode, Lows|Balanced|Peaks
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%RenderOpaqueIMG% vRenderOpaqueIMG, Remove alpha channel [for RGBA images]
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%userimgQuality% vuserimgQuality, High quality image resampling
    Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%usrTextureBGR% vusrTextureBGR, Auto-generated ambiental textured viewport background
    Gui, Add, Checkbox, xs y+10 gToggleAutoResetImageView Checked%resetImageViewOnChange% vresetImageViewOnChange, Deactivate and reset image adjustments on image file change
    ; Gui, Add, Checkbox, xs y+10 gColorPanelTriggerImageUpdate Checked%showHistogram% vshowHistogram, Display the image luminance histogram
    Gui, Add, Text, xs y+10, TIP: right click on the viewport for more options.

    Gui, Tab
    Gui, Add, Button, xs-10 y+15 h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>
    Gui, Add, Button, x+5 hp wp gtoggleImgEditPanelWindow, ▲
    ; Gui, Add, Button, x+5 hp w%btnWid% gCopyImage2clip, &Copy to clipboard
    Gui, Add, Button, x+5 hp w%btnWid% gBtnSaveIMGadjustPanel, &Save or copy
    Gui, Add, Button, x+5 hp wp-25 gBtnResetImageView, &Reset all
    ; Gui, Add, Button, x+5 hp w80 Default gBtnCloseWindow, C&lose
    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust viewport image view: " appTitle, winPos)
    Sleep, 1
    updatePanelColorsInfo()
    updatePanelColorSliderz()
    SetTimer, resetOpeningPanel, -300
    SetTimer, RemoveTooltip, -100
    SetTimer, ResetImgLoadStatus, -50
}

resetOpeningPanel() {
    openingPanelNow := 0
}

BtnResetBrightness() {
  lumosAdjust := lumosGrayAdjust := 1
  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.000
  GuiControl, SettingsGUIA:, sliderBright, 1
  INIaction(1, "lumosAdjust", "General")
  INIaction(1, "lumosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetContrast() {
  GammosAdjust := GammosGrayAdjust := 0
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, sliderContrst, 0
  INIaction(1, "GammosAdjust", "General")
  INIaction(1, "GammosGrayAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetSaturation() {
  satAdjust := 1
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, sliderSatu, 0
  INIaction(1, "satAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetVibrance() {
  zatAdjust := 0
  GuiControl, SettingsGUIA:, infoZatAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  INIaction(1, "zatAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetLummy() {
  lummyAdjust := 0
  GuiControl, SettingsGUIA:, infoLummyAdjust, 0
  GuiControl, SettingsGUIA:, lummyAdjust, 0
  INIaction(1, "lummyAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetHue() {
  thisValue := (specialColorFXmode=6) ? 100 : 0
  hueAdjust := thisValue
  GuiControl, SettingsGUIA:, infohueAdjust, % thisValue
  GuiControl, SettingsGUIA:, hueAdjust, % thisValue
  INIaction(1, "hueAdjust", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRealGamma() {
  realGammos := 1
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.000 
  GuiControl, SettingsGUIA:, UIrealGammos, 100
  INIaction(1, "realGammos", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetThreshold() {
  imgThreshold := 0
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  INIaction(1, "imgThreshold", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetCHNdec() {
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  INIaction(1, "chnRdecalage", "General")
  INIaction(1, "chnGdecalage", "General")
  INIaction(1, "chnBdecalage", "General")
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetZoom() {
  zoomLevel := 1
  GuiControl, SettingsGUIA:, UIdoubleZoom, 0
  GuiControl, SettingsGUIA:, infoImgZoom, Image zoom: 100 `%
  GuiControl, SettingsGUIA:, CustomZoomCB, 100
  dummyTimerDelayiedImageDisplay(50)
}

BtnResetRotation() {
  If (vpIMGrotation=0)
     Return

  vpIMGrotation := 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, infoImgRotation, Image rotation: 0°
  GuiControl, SettingsGUIA: Enable, usrTextureBGR
  INIaction(1, "vpIMGrotation", "General")
  RefreshImageFile()
}

BtnSaveIMGadjustPanel() {
   ForceNoColorMatrix := 0
   CloseWindow()
   dummyTimerDelayiedImageDisplay(50)
   PanelSaveImg()
}

BtnNextImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  NextPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

BtnPrevImg() {
  If (maxFilesIndex<2 || !maxFilesIndex)
     Return

  ForceNoColorMatrix := 0
  PreviousPicture()
  If (imgFxMode=3)
  {
     updatePanelColorsInfo()
     updatePanelColorSliderz()
  }
}

updatePanelColorSliderz() {
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }
   If (AnyWindowOpen!=10)
      Return

   ; GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   If (imgFxMode=1 || imgFxMode=2 || imgFxMode=3)
   {
      infoSliderBright := (lumosAdjust>1) ? Floor((lumosAdjust - 1)/14*100) : - Floor((1 - lumosAdjust)*100)
      infoSliderContrst := (GammosAdjust<0) ? Floor(Abs(GammosAdjust)/15*100) : - Floor((Abs(GammosAdjust))*100)
      infoSliderSatu := (satAdjust>1) ? Floor((satAdjust - 1)/2*100) : - Floor((1 - satAdjust)*100)
      realGammosInfo := realGammos*100
      GuiControl, SettingsGUIA:, sliderSatu, % infoSliderSatu 
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, UIrealGammos, % realGammosInfo
   } Else If (imgFxMode=4)
   {
      infoSliderBright := (lumosGrayAdjust>1) ? Floor((lumosGrayAdjust - 1)/14*100) :  - Floor((1 - lumosGrayAdjust)*100)
      infoSliderContrst := (GammosGrayAdjust<0) ? Floor(Abs(GammosGrayAdjust)/15*100) : - Floor((Abs(GammosGrayAdjust))*100)
      GuiControl, SettingsGUIA:, sliderBright, % infoSliderBright
      GuiControl, SettingsGUIA:, sliderContrst, % infoSliderContrst
      GuiControl, SettingsGUIA:, sliderSatu, 0
   }

   GuiControl, SettingsGUIA:, UIvpImgAlignCenter, % (imageAligned=5) ? 1 : 0
   lastInvoked := A_TickCount
}

updatePanelColorsInfo() {
   Static colorzFXinfoz := 0, colorzFXminz := 0, colorzFXmaxz := 0
   Static lastInvoked := 1
   If (A_TickCount - lastInvoked < 100)
   {
      SetTimer, % A_ThisFunc, -110
      Return
   }

   If (AnyWindowOpen!=10)
      Return

   If !IsObject(colorzFXinfoz)
   {
      colorzFXinfoz := []
      colorzFXinfoz[1] := ["-", "-", "-"]
      colorzFXinfoz[2] := ["Blur radius", "-", "-"]
      colorzFXinfoz[3] := ["Sharpen radius", "Sharpen amount", "-"]
      colorzFXinfoz[4] := ["Brightness", "Contrast", "-"]
      colorzFXinfoz[5] := ["Hue", "Saturation", "Lightness"]
      colorzFXinfoz[6] := ["Highlights", "Midtones", "Shadows"]
      colorzFXinfoz[7] := ["Hue", "Amount", "-"]
      colorzFXinfoz[8] := ["Cyan / Red", "Magenta / Green", "Yellow / Blue"]
      colorzFXinfoz[9] := ["-", "-", "Amount"]
      colorzFXminz := []
      colorzFXminz[1] := [-300, -300, -300]
      colorzFXminz[2] := [0, -300, -300]
      colorzFXminz[3] := [0, 0, -300]
      colorzFXminz[4] := [-255, -100, -300]
      colorzFXminz[5] := [-180, -100, -100]
      colorzFXminz[6] := [0, -100, 0]
      colorzFXminz[7] := [-180, 0, -300]
      colorzFXminz[8] := [-100, -100, -100]
      colorzFXminz[9] := [-300, -300, -100]
      colorzFXmaxz := []
      colorzFXmaxz[1] := [300, 300, 300]
      colorzFXmaxz[2] := [255, 300, 300]
      colorzFXmaxz[3] := [255, 100, 300]
      colorzFXmaxz[4] := [255, 100, 300]
      colorzFXmaxz[5] := [180, 100, 100]
      colorzFXmaxz[6] := [100, 100, 100]
      colorzFXmaxz[7] := [180, 100, 300]
      colorzFXmaxz[8] := [100, 100, 100]
      colorzFXmaxz[9] := [300, 300, 100]
   }

   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, imgFxMode, SettingsGUIA:, imgFxMode
   GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   thisMinA := colorzFXminz[specialColorFXmode, 1]
   thisMinB := colorzFXminz[specialColorFXmode, 2]
   thisMinC := colorzFXminz[specialColorFXmode, 3]
   thisMaxA := colorzFXmaxz[specialColorFXmode, 1]
   thisMaxB := colorzFXmaxz[specialColorFXmode, 2]
   thisMaxC := colorzFXmaxz[specialColorFXmode, 3]
   If (specialColorFXmode=9 && uiColorCurveFXmode=1)
   {
      thisMaxC := 255
      thisMinC := -255
   } Else If (specialColorFXmode=9 && uiColorCurveFXmode>=6)
   {
      thisMaxC := 255
      thisMinC := 0
   }

   GuiControl, SettingsGUIA: +Range%thisMinA%-%thisMaxA%, hueAdjust
   GuiControl, SettingsGUIA: +Range%thisMinB%-%thisMaxB%, zatAdjust
   GuiControl, SettingsGUIA: +Range%thisMinC%-%thisMaxC%, lummyAdjust

   infolumosAdjust := (imgFxMode=4) ? Round(lumosGrayAdjust, 3) : Round(lumosAdjust, 3)
   infoGammosAdjust := (imgFxMode=4) ? Round(GammosGrayAdjust, 3) : Round(GammosAdjust, 3)
   infoSatAdjust := Round(satAdjust, 3)
   infoZoom := Round(zoomLevel*100)
   GuiControl, SettingsGUIA:, infoBright, % "Brightness: " infolumosAdjust
   GuiControl, SettingsGUIA:, infoContrst, % "Contrast: " infoGammosAdjust
   GuiControl, SettingsGUIA:, infoSatu, % "Saturation: " infoSatAdjust
   GuiControl, SettingsGUIA:, infoRealGammos, % "Gamma: " realGammos
   GuiControl, SettingsGUIA:, infoThreshold, % "Threshold: " imgThreshold
   GuiControl, SettingsGUIA:, infoImgZoom, % "Image zoom: " infoZoom " %"
   GuiControl, SettingsGUIA:, infoImgRotation, % "Image rotation: " vpIMGrotation "° "

   GuiControl, SettingsGUIA:, infohueAdjust, % colorzFXinfoz[specialColorFXmode, 1] ": " hueAdjust
   GuiControl, SettingsGUIA:, infoZatAdjust, % colorzFXinfoz[specialColorFXmode, 2] ": " zatAdjust
   GuiControl, SettingsGUIA:, infoLummyAdjust, % colorzFXinfoz[specialColorFXmode, 3] ": " lummyAdjust

   If (vpIMGrotation=0 || vpIMGrotation=90 || vpIMGrotation=180 || vpIMGrotation=270)
      GuiControl, SettingsGUIA: Enable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Disable, usrTextureBGR

   If (usrColorDepth>1)
   {
      GuiControl, SettingsGUIA: Disable, RenderOpaqueIMG
      GuiControl, SettingsGUIA: Enable, ColorDepthDithering
   } Else
   {
      GuiControl, SettingsGUIA: Enable, RenderOpaqueIMG
      GuiControl, SettingsGUIA: Disable, ColorDepthDithering
   }

   If (IMGresizingMode=4)
   {
      GuiControl, SettingsGUIA: Enable, CustomZoomCB
      GuiControl, SettingsGUIA: Enable, UIdoubleZoom
      GuiControl, SettingsGUIA: Enable, infoImgZoom
   } Else
   {
      GuiControl, SettingsGUIA: Disable, UIdoubleZoom
      GuiControl, SettingsGUIA: Disable, infoImgZoom
      GuiControl, SettingsGUIA: Disable, CustomZoomCB
   }

   o_bwDithering := (imgFxMode=4 && bwDithering=1) ? 1 : 0
   If (imgFxMode=2) || (imgFxMode=4 && o_bwDithering=0) || (imgFxMode=9) || (imgFxMode=10)
   {
      GuiControl, SettingsGUIA: Enable, infoRealGammos
      GuiControl, SettingsGUIA: Enable, UIrealGammos
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoRealGammos
      GuiControl, SettingsGUIA: Disable, UIrealGammos
   }

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, usrTextureBGR
   Else
      GuiControl, SettingsGUIA: Enable, usrTextureBGR

   If (IMGresizingMode=5)
      GuiControl, SettingsGUIA: Disable, UIvpImgAlignCenter
   Else
      GuiControl, SettingsGUIA: Enable, UIvpImgAlignCenter

   If (imgFxMode=2)
   {
      GuiControl, SettingsGUIA: Enable, sliderSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Enable, BtnSatPlus
      GuiControl, SettingsGUIA: Enable, BtnSatMin
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Enable, infoSatu
   } Else If (imgFxMode=4 && o_bwDithering=0)
   {
      GuiControl, SettingsGUIA: Enable, infoBright
      GuiControl, SettingsGUIA: Enable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Enable, sliderBright
      GuiControl, SettingsGUIA: Enable, sliderContrst
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Enable, BtnLumPlus
      GuiControl, SettingsGUIA: Enable, BtnLumMin
      GuiControl, SettingsGUIA: Enable, BtnGammPlus
      GuiControl, SettingsGUIA: Enable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoBright
      GuiControl, SettingsGUIA: Disable, infoContrst
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, infoSatu
      GuiControl, SettingsGUIA: Disable, BtnLumPlus
      GuiControl, SettingsGUIA: Disable, BtnLumMin
      GuiControl, SettingsGUIA: Disable, BtnGammPlus
      GuiControl, SettingsGUIA: Disable, BtnGammMin
      GuiControl, SettingsGUIA: Disable, BtnSatPlus
      GuiControl, SettingsGUIA: Disable, BtnSatMin
      GuiControl, SettingsGUIA: Disable, sliderSatu
      GuiControl, SettingsGUIA: Disable, sliderBright
      GuiControl, SettingsGUIA: Disable, sliderContrst
   }

   If (imgFxMode=4)
      GuiControl, SettingsGUIA: Enable, bwDithering
   Else
      GuiControl, SettingsGUIA: Disable, bwDithering

   If (imgFxMode=2 || imgFxMode=3 || imgFxMode=4 || imgFxMode=9 || imgFxMode=10) && (o_bwDithering=0)
   {
      GuiControl, SettingsGUIA: Enable, zatAdjust
      GuiControl, SettingsGUIA: Enable, infoZatAdjust
      GuiControl, SettingsGUIA: Enable, hueAdjust
      GuiControl, SettingsGUIA: Enable, infohueAdjust
      GuiControl, SettingsGUIA: Enable, lummyAdjust
      GuiControl, SettingsGUIA: Enable, infoLummyAdjust
      GuiControl, SettingsGUIA: Enable, specialColorFXmode
      GuiControl, SettingsGUIA: Enable, UIimgThreshold
      GuiControl, SettingsGUIA: Enable, infoThreshold
      canEnableThese := 1
   } Else
   {
      canEnableThese := 0
      GuiControl, SettingsGUIA: Disable, zatAdjust
      GuiControl, SettingsGUIA: Disable, infoZatAdjust
      GuiControl, SettingsGUIA: Disable, hueAdjust
      GuiControl, SettingsGUIA: Disable, infohueAdjust
      GuiControl, SettingsGUIA: Disable, lummyAdjust
      GuiControl, SettingsGUIA: Disable, infoLummyAdjust
      GuiControl, SettingsGUIA: Disable, specialColorFXmode
      GuiControl, SettingsGUIA: Disable, UIimgThreshold
      GuiControl, SettingsGUIA: Disable, infoThreshold
   }

   If (specialColorFXmode=9 && canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, uiColorCurveFXmode
      GuiControl, SettingsGUIA: Enable, uiColorCurveFXchannel
   } Else
   {
      GuiControl, SettingsGUIA: Disable, uiColorCurveFXmode
      GuiControl, SettingsGUIA: Disable, uiColorCurveFXchannel
   }

   If (imgFxMode=2 || imgFxMode=3)
   {
      GuiControl, SettingsGUIA: Enable, infoRGBchnls
      GuiControl, SettingsGUIA: Enable, chnRdecalage
      GuiControl, SettingsGUIA: Enable, chnGdecalage
      GuiControl, SettingsGUIA: Enable, chnBdecalage
   } Else
   {
      GuiControl, SettingsGUIA: Disable, infoRGBchnls
      GuiControl, SettingsGUIA: Disable, chnRdecalage
      GuiControl, SettingsGUIA: Disable, chnGdecalage
      GuiControl, SettingsGUIA: Disable, chnBdecalage
   }

   If (imgFxMode=3)
   {
      GuiControl, SettingsGUIA: Enable, autoAdjustMode
      GuiControl, SettingsGUIA: Enable, usrAdaptiveThreshold
      GuiControl, SettingsGUIA: Enable, doSatAdjusts
   } Else
   {
      GuiControl, SettingsGUIA: Disable, autoAdjustMode
      GuiControl, SettingsGUIA: Disable, usrAdaptiveThreshold
      GuiControl, SettingsGUIA: Disable, doSatAdjusts
   }

   If (colorzFXinfoz[specialColorFXmode, 1]="-")
   {
      GuiControl, SettingsGUIA: Disable, infohueAdjust
      GuiControl, SettingsGUIA: Disable, hueAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infohueAdjust
      GuiControl, SettingsGUIA: Enable, hueAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 2]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoZatAdjust
      GuiControl, SettingsGUIA: Disable, zatAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoZatAdjust
      GuiControl, SettingsGUIA: Enable, zatAdjust
   }

   If (colorzFXinfoz[specialColorFXmode, 3]="-")
   {
      GuiControl, SettingsGUIA: Disable, infoLummyAdjust
      GuiControl, SettingsGUIA: Disable, lummyAdjust
   } Else If (canEnableThese=1)
   {
      GuiControl, SettingsGUIA: Enable, infoLummyAdjust
      GuiControl, SettingsGUIA: Enable, lummyAdjust
   }

   lastInvoked := A_TickCount
}

btnResetImageView() {
  ; GuiControlGet, realTimePreview
  ForceNoColorMatrix := 0
  GuiControl, SettingsGUIA: Choose, imgFxMode, 1
  GuiControl, SettingsGUIA: Choose, usrColorDepth, 1
  GuiControl, SettingsGUIA: Choose, usrAdaptiveThreshold, 5
  GuiControl, SettingsGUIA: Choose, chnRdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnGdecalage, 14
  GuiControl, SettingsGUIA: Choose, chnBdecalage, 14
  GuiControl, SettingsGUIA: Choose, IMGresizingMode, 1
  GuiControl, SettingsGUIA: Choose, specialColorFXmode, 1
  GuiControl, SettingsGUIA:, bwDithering, 0
  ColorDepthDithering := usrColorDepth := IMGresizingMode := imgFxMode := satAdjust := lumosAdjust := lumosGrayAdjust := specialColorFXmode := 1
  vpIMGrotation := zatAdjust := hueAdjust := GammosAdjust := GammosGrayAdjust := 0
  chnRdecalage := chnGdecalage := chnBdecalage := 0.0
  updatePanelColorsInfo()
  UIrealGammos := realGammos := usrAdaptiveThreshold := infoBright := infoSatu := 1
  bwDithering := infoContrst := sliderSatu := sliderBright := sliderContrst := 0
  FlipImgV := FlipImgH := usrTextureBGR := vpIMGrotation := UIimgThreshold := imgThreshold := 0

  GuiControl, SettingsGUIA:, infoBright, Brightness: 1.009
  GuiControl, SettingsGUIA:, infoContrst, Contrast: 0.000
  GuiControl, SettingsGUIA:, infoSatu, Saturation: 1.000
  GuiControl, SettingsGUIA:, infoThreshold, Threshold: 0.00
  GuiControl, SettingsGUIA:, infoRealGammos, Gamma: 1.00
  GuiControl, SettingsGUIA:, hueAdjust, 0
  GuiControl, SettingsGUIA:, zatAdjust, 0
  GuiControl, SettingsGUIA:, UIrealGammos, 100
  GuiControl, SettingsGUIA:, UIimgThreshold, 0
  GuiControl, SettingsGUIA:, sliderSatu, 0
  GuiControl, SettingsGUIA:, sliderBright, 0
  GuiControl, SettingsGUIA:, sliderContrst, 0
  GuiControl, SettingsGUIA:, vpIMGrotation, 0
  GuiControl, SettingsGUIA:, usrTextureBGR, 0
  GuiControl, SettingsGUIA:, RenderOpaqueIMG, 0
  GuiControl, SettingsGUIA:, FlipImgV, 0
  GuiControl, SettingsGUIA:, FlipImgH, 0
  GuiControl, SettingsGUIA:, ColorDepthDithering, 1
  defineColorDepth()
  SetTimer, WriteSettingsColorAdjustments, -90
  dummyTimerDelayiedImageDisplay(50)
}

ColorPanelTriggerImageUpdate(dummy:=0) {
   Critical, On
   GuiControlGet, imgFxMode, SettingsGUIA:, imgFxMode
   GuiControlGet, usrAdaptiveThreshold, SettingsGUIA:, usrAdaptiveThreshold
   GuiControlGet, doSatAdjusts, SettingsGUIA:, doSatAdjusts
   GuiControlGet, autoAdjustMode, SettingsGUIA:, autoAdjustMode
   GuiControlGet, showHistogram, SettingsGUIA:, showHistogram
   GuiControlGet, sliderBright, SettingsGUIA:, sliderBright
   GuiControlGet, sliderContrst, SettingsGUIA:, sliderContrst
   GuiControlGet, sliderSatu, SettingsGUIA:, sliderSatu
   GuiControlGet, bwDithering, SettingsGUIA:, bwDithering
   GuiControlGet, RenderOpaqueIMG, SettingsGUIA:, RenderOpaqueIMG
   GuiControlGet, UIvpImgAlignCenter, SettingsGUIA:, UIvpImgAlignCenter
   GuiControlGet, FlipImgV, SettingsGUIA:, FlipImgV
   GuiControlGet, FlipImgH, SettingsGUIA:, FlipImgH
   GuiControlGet, CustomZoomCB, SettingsGUIA:, CustomZoomCB
   GuiControlGet, chnRdecalage, SettingsGUIA:, chnRdecalage
   GuiControlGet, chnGdecalage, SettingsGUIA:, chnGdecalage
   GuiControlGet, chnBdecalage, SettingsGUIA:, chnBdecalage
   GuiControlGet, zatAdjust, SettingsGUIA:, zatAdjust
   GuiControlGet, hueAdjust, SettingsGUIA:, hueAdjust
   GuiControlGet, lummyAdjust, SettingsGUIA:, lummyAdjust
   GuiControlGet, uiColorCurveFXchannel, SettingsGUIA:, uiColorCurveFXchannel
   GuiControlGet, uiColorCurveFXmode, SettingsGUIA:, uiColorCurveFXmode
   GuiControlGet, specialColorFXmode, SettingsGUIA:, specialColorFXmode
   GuiControlGet, UIimgThreshold, SettingsGUIA:, UIimgThreshold
   GuiControlGet, UIrealGammos, SettingsGUIA:, UIrealGammos
   GuiControlGet, userimgQuality, SettingsGUIA:, userimgQuality
   GuiControlGet, vpIMGrotation, SettingsGUIA:, vpIMGrotation
   GuiControlGet, UIdoubleZoom, SettingsGUIA:, UIdoubleZoom
   GuiControlGet, usrTextureBGR, SettingsGUIA:, usrTextureBGR
   GuiControlGet, usrColorDepth, SettingsGUIA:, usrColorDepth
   GuiControlGet, ColorDepthDithering, SettingsGUIA:, ColorDepthDithering
   GuiControlGet, histogramMode, SettingsGUIA:, histogramMode

   ; GuiControlGet, realTimePreview
   If (dummy!="ignore-zoom")
   {
      GuiControlGet, IMGresizingMode, SettingsGUIA:, IMGresizingMode
      imageAligned := (UIvpImgAlignCenter=1) ? 5 : 1
      zoomLevel := (UIdoubleZoom=1) ? (2*CustomZoomCB)/100 + 2 : CustomZoomCB/100
   }

   defineColorDepth()
   ForceNoColorMatrix := 0
   If (vpIMGrotation=1 || vpIMGrotation>358)
      vpIMGrotation := 0

   imgThreshold := Round(UIimgThreshold/100, 3)
   If (imgFxMode!=3 && imgFxMode!=1)
      realGammos := Round(UIrealGammos/100, 3)

   If (imgFxMode=2)
   {
      lumosAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
      satAdjust := (sliderSatu>0) ? 0.02*sliderSatu + 1 : 0.01*Abs(sliderSatu + 100)
   } Else If (imgFxMode=4)
   {
      lumosGrayAdjust := (sliderBright>0) ? 0.14*sliderBright + 1 : 0.01*Abs(sliderBright + 100)
      GammosGrayAdjust := (sliderContrst>0) ? -0.14*sliderContrst : 0.01*Abs(sliderContrst)
   }

   If (imgFxMode=3)
   {
      imgPath := getIDimage(currentFileIndex)
      AdaptiveImgLight(useGdiBitmap(), imgPath, 1, 1)
      updatePanelColorSliderz()
   }

   If (imgFxMode!=4)
   {
      GuiControl, SettingsGUIA:, bwDithering, 0
      bwDithering := 0
   }

   If (prevvpIMGrotation!=vpIMGrotation)
   {
      mustReloadIMG := 1
      prevvpIMGrotation := vpIMGrotation
   }

   updatePanelColorsInfo()
   filterDelayiedImageDisplay()
   SetTimer, WriteSettingsColorAdjustments, -150
}

PanelFileFormatConverter() {
    Global btnFldr, IDbtnConvert, editF5
    filesElected := getSelectedFiles(0, 1)
    thisBtnHeight := createSettingsGUI(15, A_ThisFunc)
    btnWid := 110
    txtWid := 280
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 155
       Gui, Font, s%LargeUIfontValue%
    }

    initFIMGmodule()
    ReadSettingsFormatConvert()
    Gui, Add, Text, x15 y15 Section, Destination format:
    Gui, Add, DropDownList, x+10 w85 gTglDesiredSaveFormat AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
    Gui, Add, Text, xs y+10, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 AltSubmit gTglOverwriteFiles Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    Gui, Add, Checkbox, xs y+10 gTglKeepOriginals Checked%OnConvertKeepOriginals% vOnConvertKeepOriginals, &Keep original file[s]
    Gui, Add, Checkbox, y+7 Checked%PreserveDateTimeOnSave% vPreserveDateTimeOnSave, &Preserve original file date and time
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder:
    Gui, Add, Edit, xp+10 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to convert: %filesElected%.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y+15 h%thisBtnHeight% w90 gBTNconvertNow Default vIDbtnConvert, &Convert
    Gui, Add, Button, x+5 hp wp gBTNconvertHelp, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Image file format conversion: " appTitle)
}

BTNconvertHelp() {
    msgBoxWrapper(appTitle ": HELP", "File format conversion relies primarly on the FreeImage library.`n`nOn conversion, images will be converted to 24 bits or 32 bits.`n`nFailures can occur if the images are very large (above 250 MPx) and the destination format does not allow such large images, if there is insufficient system memory or... if file access is denied when attempting to write files.`n`nQuality option applies for JPG, JP2, J2K, JXR and WEBP file formats.", -1, 0, 0)
}

TglKeepOriginals() {
    GuiControlGet, OnConvertKeepOriginals
    INIaction(1, "OnConvertKeepOriginals", "General")
}

TglOverwriteFiles() {
    GuiControlGet, userActionConflictingFile
    INIaction(1, "userActionConflictingFile", "General")
}

TglDesiredSaveFormat() {
    GuiControlGet, userDesireWriteFMT
    INIaction(1, "userDesireWriteFMT", "General")
}

BTNconvertNow() {
   GuiControlGet, ResizeDestFolder
   GuiControlGet, OnConvertKeepOriginals
   GuiControlGet, userActionConflictingFile
   GuiControlGet, userDesireWriteFMT
   GuiControlGet, PreserveDateTimeOnSave
   GuiControlGet, userJpegQuality

   rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
   If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize...", 0, 0, "error")
      Return
   }

   userJpegQuality := clampInRange(userJpegQuality, 1, 100)
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "OnConvertKeepOriginals", "General")
   INIaction(1, "PreserveDateTimeOnSave", "General")
   INIaction(1, "userActionConflictingFile", "General")
   INIaction(1, "userDesireWriteFMT", "General")
   If (markedSelectFile>1)
   {
      CloseWindow()
      batchConvert2format()
   } Else convert2format()
}

PanelAdjustImageCanvasSize() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight
         , userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter

    If (thumbsDisplaying=1 || AnyWindowOpen)
       Return

    thisBtnHeight := createSettingsGUI(28, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    INIaction(0, "ResizeKeepAratio", "General")
    INIaction(0, "ResizeInPercentage", "General")
    INIaction(0, "adjustCanvasMode", "General")
    INIaction(0, "adjustCanvasCentered", "General")
    INIaction(0, "adjustCanvasNoBgr", "General")
    INIaction(0, "FillAreaColor", "General")
    INIaction(0, "FillAreaOpacity", "General")

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    r1 := Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If r1
    {
       CloseWindow()
       SoundBeep, 300, 100
       showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    Gui, Add, Text, x15 y15 Section, Original image size: %oImgW% x %oImgH% pixels.
    Gui, Add, Edit, x15 y15 w1 r1 limit7 -multi -wrap, -
    Gui, Add, Text, xs y+10, Set new canvas dimensions (W x H):
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit7 -multi number -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, Use `% percentages
    Gui, Add, Checkbox, xs+15 y+5 hp gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp Checked%adjustCanvasCentered% vadjustCanvasCentered, Centered image

    Gui, Add, Text, xs y+15, Resulted dimensions and background color:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % oImgW
    Gui, Add, Edit, x+5 wp r1 Disabled -wrap vResultEditHeight, % oImgH
    Gui, Add, ListView, x+5 wp hp %CCLVO% Background%FillAreaColor% vFillAreaColor hwndhLVfillColor,
    Gui, Add, ComboBox, x+5 wp vFillAreaOpacity, 25|50|75|100|150|200|255|%FillAreaOpacity%||
    Gui, Add, Button, x+5 hp w25 gStartPickingColor vPickuFillAreaColor, P

    Gui, Add, Checkbox, xs y+10 hp Checked%adjustCanvasNoBgr% vadjustCanvasNoBgr gupdateUIadjustCanvasPanel, Transparent background 
    Gui, Add, Checkbox, xs y+10 Section hp Checked%adjustCanvasMode% vadjustCanvasMode gupdateUIadjustCanvasPanel, Add margins to current image dimensions:
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddTop, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddLeft, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddCenter, 0
    Gui, Add, Edit, x+5 wp r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddRight, 0

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled +0x0800, -
    Gui, Add, Edit, x+5 w%editWid% r1 limit6 -multi number -wrap gEditCanvasMargins vuserAddBottom, 0
    Gui, Add, Edit, x+5 wp r1 Disabled +0x0800, -

    Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% w%btnWid% gBTNadjustCanvasAction Default, &Adjust canvas
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Adjust image canvas size: " appTitle)
    updateUIadjustCanvasPanel()
}

EditCanvasMargins() {
   GuiControlGet, userAddTop
   GuiControlGet, userAddBottom
   GuiControlGet, userAddCenter
   GuiControlGet, userAddLeft
   GuiControlGet, userAddRight
   If (!userAddTop || userAddTop<0)
      userAddTop := 0
   If (!userAddBottom || userAddBottom<0)
      userAddBottom := 0
   If (!userAddCenter || userAddCenter<0)
      userAddCenter := 0
   If (!userAddLeft || userAddLeft<0)
      userAddLeft := 0
   If (!userAddRight || userAddRight<0)
      userAddRight := 0

   whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
   Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   thisWidth := oImgW + userAddLeft + userAddRight + userAddCenter
   thisHeight := oImgH + userAddTop + userAddBottom + userAddCenter
   GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
   GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
}

updateUIadjustCanvasPanel() {
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode

    If (adjustCanvasMode=1)
    {
       EditCanvasMargins()
       GuiControl, SettingsGUIA: Disable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
       GuiControl, SettingsGUIA: Disable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Disable, userEditHeight
       GuiControl, SettingsGUIA: Disable, userEditWidth
       GuiControl, SettingsGUIA: Enable, userAddCenter
       GuiControl, SettingsGUIA: Enable, userAddTop
       GuiControl, SettingsGUIA: Enable, userAddBottom
       GuiControl, SettingsGUIA: Enable, userAddLeft
       GuiControl, SettingsGUIA: Enable, userAddRight
    } Else
    {
       EditResizeWidth()
       GuiControl, SettingsGUIA: Disable, userAddCenter
       GuiControl, SettingsGUIA: Disable, userAddTop
       GuiControl, SettingsGUIA: Disable, userAddBottom
       GuiControl, SettingsGUIA: Disable, userAddLeft
       GuiControl, SettingsGUIA: Disable, userAddRight
       GuiControl, SettingsGUIA: Enable, ResizeKeepAratio
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
       GuiControl, SettingsGUIA: Enable, adjustCanvasCentered
       GuiControl, SettingsGUIA: Enable, userEditHeight
       GuiControl, SettingsGUIA: Enable, userEditWidth
    }

    If (adjustCanvasNoBgr=1)
    {
       GuiControl, SettingsGUIA: Disable, FillAreaColor
       GuiControl, SettingsGUIA: Disable, FillAreaOpacity
    } Else
    {
       GuiControl, SettingsGUIA: Enable, FillAreaColor
       GuiControl, SettingsGUIA: Enable, FillAreaOpacity
    }

    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
}

BTNadjustCanvasAction() {
    GuiControlGet, adjustCanvasCentered
    GuiControlGet, adjustCanvasNoBgr
    GuiControlGet, adjustCanvasMode
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, FillAreaOpacity
    GuiControlGet, userAddTop
    GuiControlGet, userAddBottom
    GuiControlGet, userAddCenter
    GuiControlGet, userAddLeft
    GuiControlGet, userAddRight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResultEditWidth

    If (!userAddTop || userAddTop<0)
       userAddTop := 0
    If (!userAddBottom || userAddBottom<0)
       userAddBottom := 0
    If (!userAddCenter || userAddCenter<0)
       userAddCenter := 0
    If (!userAddLeft || userAddLeft<0)
       userAddLeft := 0
    If (!userAddRight || userAddRight<0)
       userAddRight := 0

    whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
    Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
    If (ResultEditWidth=oImgW && ResultEditHeight=oImgH)
    {
       showTOOLtip("WARNING: The new dimension is equal with the initial one...")
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime//2
       Return
    }

    If (ResultEditWidth*ResultEditHeight>maxGDIbmpSize) || (ResultEditWidth>32500) || (ResultEditHeight>32500)
    {
       showTOOLtip("ERROR: The document dimensions exceed the maximum limits...")
       SoundBeep, 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    }

    INIaction(1, "ResizeKeepAratio", "General")
    INIaction(1, "ResizeInPercentage", "General")
    INIaction(1, "adjustCanvasMode", "General")
    INIaction(1, "adjustCanvasCentered", "General")
    INIaction(1, "adjustCanvasNoBgr", "General")
    INIaction(1, "FillAreaColor", "General")
    FillAreaOpacity := Trimmer(FillAreaOpacity)
    FillAreaOpacity := StrReplace(FillAreaOpacity, "%")
    FillAreaOpacity := StrReplace(FillAreaOpacity, A_Space)
    If !isNumber(FillAreaOpacity)
       FillAreaOpacity := 255

    clampInRange(FillAreaOpacity, 5, 255)
    INIaction(1, "FillAreaOpacity", "General")
  
    CloseWindow()
    ToggleEditImgSelection("show-edit")
    ChangeImageCanvasSize(ResultEditWidth, ResultEditHeight, userAddTop, userAddBottom, userAddLeft, userAddRight, userAddCenter, 0)
}

PanelResizeImageWindow() {
    Global userEditWidth, userEditHeight, ResultEditWidth, ResultEditHeight, btnFldr, editF5

    ToolTip, Please wait...
    filesElected := getSelectedFiles(0, 1)
    multipleFilesMode := (filesElected>1) ? 1 : 0
    If (multipleFilesMode=0 && !PanelsCheckFileExists())
    {
       ToolTip
       Return
    }

    thisBtnHeight := createSettingsGUI(4, A_ThisFunc)
    btnWid := 110
    txtWid := 265
    editWid := 45
    If (PrefsLargeFonts=1)
    {
       editWid := editWid + 30
       btnWid := btnWid + 70
       txtWid := txtWid + 170
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsImageProcessing()
    img2resizePath := getIDimage(currentFileIndex)
    If (multipleFilesMode=0)
    {
       zPlitPath(img2resizePath, 0, fileNamu, folderu)
       r1 := GetImgFileDimension(img2resizePath, oImgW, oImgH)
       FileGetSize, fileSizu, % img2resizePath, K
       If !r1
       {
          CloseWindow()
          showTOOLtip("ERROR: File not found or access denied...`n" fileNamu "`n" folderu "\")
          SoundBeep, 300, 100
          img2resizePath := ""
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    } Else
    {
       oImgW := ResolutionWidth
       oImgH := ResolutionHeight
    }

    initFIMGmodule()
    If (editingSelectionNow!=1)
       ResizeWithCrop := 0

    If (resetImageViewOnChange=1)
       ResizeApplyEffects := 0

    Gui, Add, Tab3, , General|File(s) destination
    Gui, Tab, 1
    If (multipleFilesMode=1)
    {
       Gui, Add, Text, x+15 y+15 Section, Resize image to (W x H)
    } Else
    {
       Gui, Add, Text, x+15 y+15 Section, Original image dimensions:
       Gui, Add, Text, xs+15 y+5, %oImgW% x %oImgH% pixels. %fileSizu% kilobytes.
       Gui, Add, Text, xs y+10, Resize image to (W x H)
    }

    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeWidth vuserEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap gEditResizeHeight vuserEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp +0x1000 gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    If (multipleFilesMode!=1)
       Gui, Add, Text, xs y+15, Result (W x H) in pixels
    Gui, Add, Edit, xs+15 y+5 w%editWid% r1 Disabled -wrap vResultEditWidth, % (multipleFilesMode=1) ? "--" : oImgW
    Gui, Add, Edit, x+5 w%editWid% r1 Disabled -wrap vResultEditHeight, % (multipleFilesMode=1) ? "--" : oImgH
    thisRotation := (vpIMGrotation=0) ? ResizeRotationUser : vpIMGrotation
    otherRotation := (vpIMGrotation=thisRotation) ? ResizeRotationUser : vpIMGrotation
    Gui, Add, ComboBox, x+5 wp+30 gTglRszRotation vResizeRotationUser, Rotate: 0°|45°|90°|135°|180°|225°|270°|315°|%thisRotation%°||%otherRotation%°
    Gui, Add, Checkbox, xs y+10 hp +0x1000 gTglRszKeepAratio Checked%ResizeKeepAratio% vResizeKeepAratio, Keep aspect ratio
    Gui, Add, Checkbox, x+5 hp +0x1000 gTglRszQualityHigh Checked%ResizeQualityHigh% vResizeQualityHigh, High quality resampling
    Gui, Add, Checkbox, xs y+10 gTglRszCropping Checked%ResizeWithCrop% vResizeWithCrop, Crop image(s) to the viewport selection
    Gui, Add, Checkbox, xp+10 y+10 gTglRszCropping Checked%ResizeCropAfterRotation% vResizeCropAfterRotation, Perform image crop after image rotation (as in the viewport)
    Gui, Add, Checkbox, xs y+10 gTglRszApplyEffects Checked%ResizeApplyEffects% vResizeApplyEffects, Apply color adjustments and image mirroring`nactivated in the main window

    Gui, Tab, 2
    Gui, Add, Text, x+15 y+15, If no destination folder is chosen,`nthe original files may be overwritten.
    Gui, Add, Checkbox, y+10 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the following folder
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 , On file name conflicts
    Gui, Add, DropDownList, x+5 w150 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality
    If (multipleFilesMode=1)
    {
       Gui, Add, DropDownList, xs y+10 w%txtWid% gTglRszUnsprtFrmt AltSubmit Choose%userUnsprtWriteFMT% vuserUnsprtWriteFMT, Skip files in unsupported write formats|Try to preserve file formats, convert unsupported to...|Convert all the files to...
       Gui, Add, DropDownList, xs y+5 w85 AltSubmit Choose%userDesireWriteFMT% vuserDesireWriteFMT, .BMP|.GIF|.HDP|.J2K|.JFIF|.JNG|.JP2|.JPG|.JXR|.PNG|.PPM|.TGA|.TIF|.WDP|.WEBP|.XPM
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }

    If (resetImageViewOnChange=1)
       GuiControl, Disable, ResizeApplyEffects

    If (editingSelectionNow!=1)
    {
       GuiControl, Disable, ResizeWithCrop
       GuiControl, Disable, ResizeCropAfterRotation
    }

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Tab
    If (multipleFilesMode=1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs-15 y+10, %filesElected% files are selected for processing.`nMulti-threaded processing not yet implemented.
       Gui, Font, Normal
       Gui, Add, Button, xp y+10 h%thisBtnHeight% w%btnWid% Default gBTNsaveResizedIMG, &Process images
       Gui, Add, Button, x+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       If (userUnsprtWriteFMT=1)
          GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
    } Else
    {
       Gui, Add, Button, xs-15 y+20 h%thisBtnHeight% w%btnWid% gBtnCopy2ClipResizedIMG, &Copy to clipboard
       Gui, Add, Button, x+5 hp wp Default gBTNsaveResizedIMG, &Save image as...
       Gui, Add, Button, xs-15 y+5 hp w%btnWid% gBtnInvokePanelSimpleResizeRotate, &Simple mode
       Gui, Add, Button, x+5 hp w85 gResizePanelHelpBoxInfo, Help
    }
    ToolTip
    Gui, Add, Button, x+5 hp w85 gBtnCloseWindow, C&ancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / rotate / crop image(s): " appTitle)
}

BtnInvokePanelSimpleResizeRotate() {
   CloseWindow("yes")
   Sleep, 25
   PanelSimpleResizeRotate("forced")
}

BTNchangeResizeDestFolder() {
   If (AnyWindowOpen=4)
      EditResizeWidth()

   SelectImg := openFoldersDialogWrapper("S2", ResizeDestFolder)
   OutDir := Trimmer(SelectImg)
   If !FolderExist(OutDir)
   {
      WinActivate, ahk_id %hSetWinGui%
      Return
   } Else
   {
      GuiControl, , ResizeDestFolder, % OutDir
      ResizeDestFolder := OutDir
      INIaction(1, "ResizeDestFolder", "General")
   }
}

setForceRefreshThumbsFilesIndex(onlySelected) {
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1 && onlySelected=1)
         Continue

      resultedFilesList[A_Index, 4] := 1
   }
   ForceRefreshNowThumbsList()
}

batchIMGresizer(desiredW, desiredH, isPercntg) {
   cleanResizeUserOptionsVars()
   If (!desiredH || !desiredW
   || desiredW<1 || desiredH<1)
   || ((desiredW<5 || desiredH<5) && (isPercntg!=1))
   {
      showTOOLtip("WARNING: Incorrect dimensions given...")
      SoundBeep, 300, 100
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1)
   {
      overwriteWarning := (ResizeUseDestDir!=1) ? "`n`nWARNING: All the original files will be overwritten!" : "`n`nThe files will be saved in " ResizeDestFolder "\"
      msgResult := msgBoxWrapper(appTitle ": Confirmation", "Please confirm you want to process multiple images in one go. There are " filesElected " selected files for this operation. " overwriteWarning, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   } Else Return

   CloseWindow("yes")
   destroyGDIfileCache()
   backCurrentSLD := CurrentSLD
   startOperation := A_TickCount
   CurrentSLD := ""
   thisImgQuality := (ResizeQualityHigh=1) ? 7 : 5
   If (ResizeKeepAratio=1 && isPercntg=1)
      desiredW := desiredH

   showTOOLtip("Processing " filesElected " images, please wait...")
   prevMSGdisplay := A_TickCount
   countTFilez := countFilez := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   failedFiles := countFilez := skippedFiles := 0
   destroyGDIfileCache()
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      countTFilez++
      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (!FileExist(imgPath) || !imgPath) || (!RegExMatch(imgPath, saveTypesRegEX) && userUnsprtWriteFMT=1)
      {
         skippedFiles++
         Continue
      }

      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>2000)
      {
         If (failedFiles>0)
            someErrors := "`nFailed to process " failedFiles " files..."
         If (skippedFiles>0)
            someErrors .= "`n" skippedFiles "files were skipped."

         zeitOperation := A_TickCount - startOperation
         percDone := " ( " Round((countTFilez / markedSelectFile) * 100) "% )"
         percLeft := (1 - countTFilez / markedSelectFile) * 100
         zeitLeft := (zeitOperation/countTFilez) * markedSelectFile - zeitOperation
         etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
         etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
         showTOOLtip("Processing " countTFilez " / " filesElected " images, please wait..." etaTime someErrors, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, fileEXT)
      fOutDir := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      If (userUnsprtWriteFMT=3)
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else If (userUnsprtWriteFMT=2 && !RegExMatch(imgPath, saveTypesRegEX))
         destImgPath := fOutDir "\" OutNameNoExt "." rDesireWriteFMT
      Else
         destImgPath := fOutDir "\" OutFileName

      If (userUnsprtWriteFMT!=1 || ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      oBitmap := LoadBitmapFromFileu(imgPath)
      If StrLen(oBitmap)<3
      {
         failedFiles++
         Continue
      }

      Gdip_GetImageDimensions(oBitmap, imgW, imgH)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      If (relativeImgSelCoords=1 && editingSelectionNow=1 && ResizeWithCrop=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, ResizeKeepAratio, newW, newH)
      If (z=-1 || z=1)
      {
         failedFiles++
         trGdip_DisposeImage(oBitmap, 1)
         Continue
      }

      r := coreResizeIMG(imgPath, newW, newH, destImgPath, 0, 0, ResizeRotationUser, oBitmap, imgW, imgH, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If (failedFiles>0)
      someErrors := "`nFailed to process " failedFiles " files..."
   If (skippedFiles>0)
      someErrors .= "`n" skippedFiles " files were skipped."

   If (editingSelectionNow=1 && relativeImgSelCoords=1)
      calcRelativeSelCoords(0, prevMaxSelX, prevMaxSelY)

   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip("Finished processing " countFilez " out of " filesElected " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

WriteSettingsResizePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "ResizeApplyEffects", "General")
  INIaction(1, "ResizeCropAfterRotation", "General")
  INIaction(1, "ResizeInPercentage", "General")
  INIaction(1, "ResizeKeepAratio", "General")
  INIaction(1, "ResizeRotationUser", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeWithCrop", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

WriteSettingsResizeSimplePanel() {
  INIaction(1, "userActionConflictingFile", "General")
  INIaction(1, "SimpleOperationsFlipV", "General")
  INIaction(1, "SimpleOperationsFlipH", "General")
  INIaction(1, "SimpleOperationsDoCrop", "General")
  INIaction(1, "SimpleOperationsRotateAngle", "General")
  INIaction(1, "SimpleOperationsScaleXimgFactor", "General")
  INIaction(1, "SimpleOperationsScaleYimgFactor", "General")
  INIaction(1, "ResizeMustPerform", "General")
  INIaction(1, "ResizeQualityHigh", "General")
  INIaction(1, "ResizeDestFolder", "General")
  INIaction(1, "ResizeUseDestDir", "General")
}

calcNewImgDimensions(imgW, imgH, desiredW, desiredH, isPercntg, isKeepRatio, ByRef newW, ByRef newH) {
   r := 0
   If (isPercntg=1)
   {
      newW := Round((imgW/100)*desiredW)
      newH := Round((imgH/100)*desiredH)
      If (newW<10 && newH<10)
         r := -1
   } Else If (isKeepRatio=1)
   {
      calcIMGdimensions(imgW, imgH, desiredW, desiredH, newW, newH)
      If (newW<10 && newH<10)
         r := -1
   } Else
   {
      newW := desiredW
      newH := desiredH
   }

   If (newW*newH>536848912) || (newW>32100) || (newH>32100)
      r := 1
   Return r
}

batchApplyColorsOnFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>1 && imgFxMode>1)
   {
      msgResult := msgBoxWrapper(appTitle ": Apply colors", "All the images in supported writing formats will be processed accordingly to the color adjustments of the viewport. The original files will be overwritten. Do you want to continue?", 4, 0, "question")
      If !InStr(msgResult, "yes")
         Return

      ResizeMustPerform := ResizeUseDestDir := 0
      ResizeInPercentage := ResizeApplyEffects := 1
      userActionConflictingFile := userUnsprtWriteFMT := 1
      ResizeWithCrop := ResizeRotationUser := simpleOpRotationAngle := 0
      ResultEditWidth := ResultEditHeight := 100
      WriteSettingsResizePanel()
      batchIMGresizer(100, 100, ResizeInPercentage)
      Return
   }
}

BTNsaveResizedIMG() {
    GuiControlGet, ResultEditWidth
    GuiControlGet, ResultEditHeight
    GuiControlGet, userEditWidth
    GuiControlGet, userEditHeight
    GuiControlGet, ResultEditHeight
    GuiControlGet, ResizeApplyEffects
    GuiControlGet, ResizeCropAfterRotation
    GuiControlGet, ResizeDestFolder
    GuiControlGet, ResizeInPercentage
    GuiControlGet, ResizeKeepAratio
    GuiControlGet, ResizeQualityHigh
    GuiControlGet, ResizeRotationUser
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeWithCrop
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    EditResizeWidth()
    cleanResizeUserOptionsVars()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       GuiControlGet, userDesireWriteFMT
       GuiControlGet, userUnsprtWriteFMT
       rDesireWriteFMT := saveImgFormatsList[userDesireWriteFMT]
       If (!RegExMatch(rDesireWriteFMT, "i)(bmp|png|tiff|tif|gif|jpg|jpeg)$") && wasInitFIMlib!=1)
       {
          SoundBeep, 300, 100
          msgBoxWrapper(appTitle ": ERROR", "The ." rDesireWriteFMT " format is currently unsupported. The FreeImage library failed to properly initialize...", 0, 0, "error")
          Return
       }

       WriteSettingsResizePanel()
       If (ResizeUseDestDir=1)
          INIaction(1, "ResizeDestFolder", "General")

       batchIMGresizer(userEditWidth, userEditHeight, ResizeInPercentage)
       Return
    }

   If (!ResultEditHeight || !ResultEditWidth
   || ResultEditWidth<5 || ResultEditHeight<5)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   }

   If (ResultEditWidth*ResultEditHeight>536848912) || (ResultEditWidth>32100) || (ResultEditHeight>32100)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+...`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutFileNameNoExt, fileEXT)
   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : OutDir "\" OutFileNameNoExt
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, Parse, dialogSaveFptrn, |
   {
        If InStr(A_LoopField, "." fileEXT)
           defFMTindex := A_Index
   }

   file2save := openFileDialogWrapper("S", "PathMustExist", startPath, "Save processed image as...", dialogSaveFptrn, dialogFmtIndex, defFMTindex)
   If file2save
   {
      zPlitPath(img2resizePath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." dialogSaveIndexes[dialogFmtIndex]

      If !RegExMatch(file2save, saveTypesRegEX)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      zPlitPath(file2save, 0, OutFileName, OutDir)
      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      GetImgFileDimension(img2resizePath, imgW, imgH, 0)
      If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
         Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

      z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
      If (z=-1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
         Return
      } Else If (z=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceed the limits of GDI+...`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
         Return
      }

      If FileExist(file2save)
      {
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      SetTimer, WriteSettingsResizePanel, -90
      r := coreResizeIMG(img2resizePath, newW, newH, file2save, 0, 0, ResizeRotationUser, 1, imgW, imgH)
      If r
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... Unknown error.`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         Return
      }

      SoundBeep, 900, 100
      showTOOLtip("Processed image saved...`n" OutFileName "`n`n" OutDir "\")
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

BtnCopy2ClipResizedIMG() {
   GuiControlGet, ResultEditWidth
   GuiControlGet, ResultEditHeight
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeQualityHigh
   GuiControlGet, ResizeApplyEffects
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation

   EditResizeWidth()
   cleanResizeUserOptionsVars()

   GetImgFileDimension(img2resizePath, imgW, imgH, 0)
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1 && ResizeCropAfterRotation=1)
      Gdip_GetRotatedDimensions(imgW, imgH, ResizeRotationUser, imgW, imgH)

   z := calcNewImgDimensions(imgW, imgH, userEditWidth, userEditHeight, ResizeInPercentage, ResizeKeepAratio, newW, newH)
   If (z=-1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
      Return
   } Else If (z=1)
   {
      SoundBeep, 300, 100
      msgBoxWrapper(appTitle ": ERROR", "Image dimensions exceeds the limits of GDI+...`nYou can try «Simple mode» if the file format allows such dimensions.", 0, 0, "error")
      Return
   }

   message := "Processing image, please wait..."
   showTOOLtip(message)
   r := coreResizeIMG(img2resizePath, newW, newH, "--", 0, 1, ResizeRotationUser, 1, imgW, imgH)
   SoundBeep, % r ? 300 : 900, 100
   ToolTip
   If !r
      showTOOLtip("Processed image copied to clipboard")
   Else 
      msgBoxWrapper(appTitle ": ERROR", "Unable to copy the processed image to the clipboard... error code: " r, 0, 0, "error")

   SetTimer, RemoveTooltip, % -msgDisplayTime//3
   SetTimer, ResetImgLoadStatus, -150
}

EditResizeWidth() {
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   GuiControlGet, ResizeRotationUser
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser
   
   If (A_TickCount - lastEditRHChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRWChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditHeight, % Round(userEditWidth)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditWidth<1 || !userEditWidth)
      userEditWidth := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRWChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      calcIMGdimensions(oImgW, oImgH, thisWidth, 90000*oImgH, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newH/oimgH)*100) : newH
      GuiControl, SettingsGUIA:, userEditHeight, % Round(newValue)

      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

EditResizeHeight() {
   GuiControlGet, userEditWidth
   GuiControlGet, userEditHeight
   GuiControlGet, ResizeKeepAratio
   GuiControlGet, ResizeInPercentage
   If (AnyWindowOpen!=28)
      GuiControlGet, ResizeRotationUser

   If (A_TickCount - lastEditRWChange < 200)
      Return

   If (AnyWindowOpen!=28)
      cleanResizeUserOptionsVars()
   filesElected := getSelectedFiles()
   If (filesElected>1 && ResizeKeepAratio=1 && ResizeInPercentage=1)
   {
      Global lastEditRHChange := A_TickCount
      GuiControl, SettingsGUIA:, userEditWidth, % Round(userEditHeight)
      Return
   }

   If (filesElected>1)
      Return

   If (userEditHeight<1 || !userEditHeight)
      userEditHeight := 1

   If (AnyWindowOpen=28)
   {
      whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
      Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
   } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

   Global lastEditRHChange := A_TickCount
   Sleep, 5
   If (ResizeKeepAratio=1)
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      calcIMGdimensions(oImgW, oImgH, 90000*oImgW, thisHeight, newW, newH)
      newValue := (ResizeInPercentage=1) ? Round((newW/oimgW)*100) : newW
      GuiControl, SettingsGUIA:, userEditWidth, % Round(newValue)
      Gdip_GetRotatedDimensions(newW, newH, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   } Else
   {
      thisHeight := (ResizeInPercentage=1) ? (oImgH/100)*userEditHeight : userEditHeight
      thisWidth := (ResizeInPercentage=1) ? (oImgW/100)*userEditWidth : userEditWidth
      Gdip_GetRotatedDimensions(thisWidth, thisHeight, ResizeRotationUser, thisWidth, thisHeight)
      GuiControl, SettingsGUIA:, ResultEditWidth, % Round(thisWidth)
      GuiControl, SettingsGUIA:, ResultEditHeight, % Round(thisHeight)
   }
}

TglRszInPercentage() {
   GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
   If (AnyWindowOpen!=18)
   {
      filesElected := getSelectedFiles()
      If (filesElected>1)
      {
         oImgW := ResolutionWidth
         oImgH := ResolutionHeight
      } Else If (AnyWindowOpen=28)
      {
         whichBitmap := StrLen(UserMemBMP)>2 ? UserMemBMP : gdiBitmap
         Gdip_GetImageDimensions(whichBitmap, oImgW, oImgH)
      } Else GetImgFileDimension(img2resizePath, oImgW, oImgH, 0)

      GuiControl, SettingsGUIA:, userEditWidth, % (ResizeInPercentage=1) ? 100 : oImgW
      GuiControl, SettingsGUIA:, userEditHeight, % (ResizeInPercentage=1) ? 100 : oImgH
      If (filesElected<2)
         EditResizeWidth()
   }

   INIaction(1, "ResizeInPercentage", "General")
}

TglRszKeepAratio() {
   GuiControlGet, userEditWidth
   GuiControlGet, ResizeKeepAratio
   If (!markedSelectFile || ResizeKeepAratio=1 && ResizeInPercentage=1)
      EditResizeWidth()
   INIaction(1, "ResizeKeepAratio", "General")
}

TglRszUnsprtFrmt() {
   GuiControlGet, userUnsprtWriteFMT
   GuiControlGet, userDesireWriteFMT
   If (userUnsprtWriteFMT>1)
      GuiControl, SettingsGUIA: Enable, userDesireWriteFMT
   Else
      GuiControl, SettingsGUIA: Disable, userDesireWriteFMT
   INIaction(1, "userDesireWriteFMT", "General")
}

cleanResizeUserOptionsVars() {
    ResizeRotationUser := StrReplace(ResizeRotationUser, ":")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "°")
    ResizeRotationUser := StrReplace(ResizeRotationUser, "rotate")
    ResizeRotationUser := Trimmer(ResizeRotationUser)

    If (SimpleOperationsRotateAngle=2)
       simpleOpRotationAngle := 90
    Else If (SimpleOperationsRotateAngle=3)
       simpleOpRotationAngle := 180
    Else If (SimpleOperationsRotateAngle=4)
       simpleOpRotationAngle := 270
    Else
       simpleOpRotationAngle := 0
}

TglRszRotation() {
   GuiControlGet, ResizeRotationUser
   GuiControlGet, ResizeWithCrop
   cleanResizeUserOptionsVars()
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation

   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeRotationUser", "General")
}

TglRszCropping() {
   GuiControlGet, ResizeWithCrop
   GuiControlGet, ResizeCropAfterRotation
   If (ResizeRotationUser>0 && ResizeWithCrop=1 && editingSelectionNow=1)
      GuiControl, SettingsGUIA: Enable, ResizeCropAfterRotation
   Else If (editingSelectionNow=1)
      GuiControl, SettingsGUIA: Disable, ResizeCropAfterRotation
   EditResizeWidth()
   INIaction(1, "ResizeWithCrop", "General")
   INIaction(1, "ResizeCropAfterRotation", "General")
}

TglRszDestFoldr() {
   GuiControlGet, ResizeUseDestDir
   If !ResizeUseDestDir
   {
      GuiControl, SettingsGUIA: Disable, btnFldr
      GuiControl, SettingsGUIA: Disable, ResizeDestFolder
   } Else
   {
      GuiControl, SettingsGUIA: Enable, btnFldr
      GuiControl, SettingsGUIA: Enable, ResizeDestFolder
   }
   INIaction(1, "ResizeUseDestDir", "General")
}

TglRszQualityHigh() {
   GuiControlGet, ResizeQualityHigh
   INIaction(1, "ResizeQualityHigh", "General")
}

TglRszApplyEffects() {
   GuiControlGet, ResizeApplyEffects
   INIaction(1, "ResizeApplyEffects", "General")
   If (ResizeApplyEffects=1)
   {
      infoMirroring := defineIMGmirroring()
      If (usrColorDepth>1)
         infoColorDepth := "`nSimulated color depth: " defineColorDepth()
      If (imgFxMode>1)
         infoColors := "`nColors display mode: " DefineFXmodes() " [" currIMGdetails.PixelFormat "]"
      If (RenderOpaqueIMG=1)
         infoRenderOpaque .= "`nAlpha channel: REMOVED"
 
      entireString := infoMirroring infoColors infoColorDepth infoRenderOpaque
      entireString := (entireString) ?  "Effects currently activated: " entireString : "No effects currently activated."
      msgBoxWrapper(appTitle, entireString, 0, 0, "info")
   }
}

invokePanelStaticFoldersContextMenu() {
   Try Menu, PanelStaticMenu, Delete
   Sleep, 2

   Menu, PanelStaticMenu, Add, &Rescan folder, BTNupdateSelectedStaticFolder
   Menu, PanelStaticMenu, Add, &Erase indexed files, BTNremFilesStaticFolder
   Menu, PanelStaticMenu, Add, &Open folder in Explorer, BTNopenDynaFolder
   Menu, PanelStaticMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelStaticMenu, Add, &Ignore date change, BTNignoreSelFolder
   If (SLDtypeLoaded=2)
      Menu, PanelStaticMenu, Add, Rename inde&x entry, PanelRenameStaticFolder
   Menu, PanelStaticMenu, Add, &Filter list to selected folder, MenuFolderzFilterList
   Menu, PanelStaticMenu, Add,
   Menu, PanelStaticMenu, Add, &Copy entire list, BTNcopyAllStaticFolderPaths
   showThisMenu("PanelStaticMenu")
}

invokePanelDynaFoldersContextMenu() {
   Try Menu, PanelDynaMenu, Delete
   Sleep, 2

   Menu, PanelDynaMenu, Add, &Rescan folder, BTNrescanDynaFolder
   Menu, PanelDynaMenu, Add, &Remove from the list, RemDynaSelFolder
   Menu, PanelDynaMenu, Add, &Open folder in Explorer, BTNopenDynaFolder
   Menu, PanelDynaMenu, Add, &Copy folder path, BTNcopyStaticFolderPath
   Menu, PanelDynaMenu, Add, &Toggle recursive folder scan, InvertRecurseDynaFolder
   Menu, PanelDynaMenu, Add, &Filter list to selected folder, MenuFolderzFilterList
   showThisMenu("PanelDynaMenu")
}

PanelStaticFolderzManager() {
    Global LViewOthers, listViewFilteru
    If !(RegExMatch(CurrentSLD, sldsPattern) && mustGenerateStaticFolders!=1 && SLDcacheFilesList=1)
       Return

    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(2, A_ThisFunc)
    btnWid := 115
    txtWid := 360
    lstWid := 545
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 255
       btnWid := btnWid + 95
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    btnWid2 := (PrefsLargeFonts=1) ? 140 : 95
    btnWid3 := (PrefsLargeFonts=1) ? 95 : 55
    btnWid4 := (PrefsLargeFonts=1) ? 160 : 90
    CountFilesFolderzList := 0
    widthu := (SLDtypeLoaded=3) ? "w1" : ""
    Gui, Add, Text, x15 y15, This folders list was generated based on the indexed files.
    Gui, Add, ListView, xp y+10 w%lstWid% -multi AltSubmit gFolderzFilterListBTN r12 Grid vLViewOthers +hwndhLVmainu, #|Date|(?)|Folder path|Files
    Gui, Add, Edit, xs y+10 wp-50 -multi -wantTab gfilterListViewStaticFoldersList +hwndhEditField vlistViewFilteru,
    Gui, Add, Button, x+1 hp w50 gBTNhelpStaticFolderz, [ ? ]
    Gui, Add, Checkbox, xs y+10 gToggleRecursiveStaticRescan vRecursiveStaticRescan Checked%RecursiveStaticRescan%, &Perform recursive (in sub-folders) rescan

    Gui, Add, Button, xs+0 y+15 h%thisBtnHeight% w%btnWid2% gBTNupdateSelectedStaticFolder, &Rescan folder
    Gui, Add, Button, x+5 hp w%btnWid% gSQLdbGenerateStaticFolders , I&gnore all changes
    Gui, Add, Button, x+5 hp wp+40 gRegenerateEntireList, &Regenerate entire index
    Gui, Add, Button, x+5 hp w70 ginvokePanelStaticFoldersContextMenu, &More

    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Cached folders list updater: " appTitle)
    Sleep, 25
    If (SLDtypeLoaded=3)
       PopulateStaticSQLfolderzList()
    Else
       PopulateStaticFolderzList()
}

BTNhelpStaticFolderz() {
   msgBoxWrapper(appTitle ": HELP", "Please select the folder you want updated.`nFolders marked with (*) are changed since the last scan, based on folder modified date.`n`nWhen you choose to «remove file entries» for a specific folder, the files indexed pertaining to the selected will be removed ONLY from the index/list, NOT from the disk.", -1, 0, 0)
}

EM_SETCUEBANNER(handle, string, option := true) {
; ===============================================================================================================================
; Message ..................:  EM_SETCUEBANNER
; Minimum supported client .:  Windows Vista
; Minimum supported server .:  Windows Server 2003
; Links ....................:  https://docs.microsoft.com/en-us/windows/win32/controls/em-setcuebanner
; Description ..............:  Sets the textual cue, or tip, that is displayed by the edit control to prompt the user for information.
; Options ..................:  True  -> if the cue banner should show even when the edit control has focus
;                              False -> if the cue banner disappears when the user clicks in the control
; ===============================================================================================================================
   static ECM_FIRST       := 0x1500 
        , EM_SETCUEBANNER := ECM_FIRST + 1
   if (DllCall("user32\SendMessage", "ptr", handle, "uint", EM_SETCUEBANNER, "int", option, "str", string, "int"))
      return true
   return false
}

PanelDynamicFolderzWindow() {
    Static LViewDynas
    If askAboutFileSave(" if any action will be performed in the invoked panel")
       Return

    thisBtnHeight := createSettingsGUI(3, A_ThisFunc)
    btnWid := 120
    txtWid := 360
    lstWid := 535
    If (PrefsLargeFonts=1)
    {
       lstWid := lstWid + 175
       btnWid := btnWid + 85
       txtWid := txtWid + 105
       Gui, Font, s%LargeUIfontValue%
    }
    Gui, Add, Text, x15 y15,This folders list is used to generate the files list index.
    Gui, Add, ListView, y+10 w%lstWid% gFolderzFilterListBTN -multi r12 Grid vLViewDynas +hwndhLVmainu, #|(?)|Folder path

    btnWid2 := (PrefsLargeFonts=1) ? 95 : 60
    btnWid3 := (PrefsLargeFonts=1) ? 120 : 90
    Gui, Add, Button, xs+0 y+5 h%thisBtnHeight% w60 gBTNaddNewFolder2list, &Add
    Gui, Add, Button, x+5 hp w%btnWid2% gRemDynaSelFolder, &Remove
    Gui, Add, Button, x+5 hp wp+30 gRegenerateEntireList, R&escan all
    Gui, Add, Button, x+5 hp w%btnWid2% gBTNcopyDynaFoldersList, &Copy list
    Gui, Add, Button, x+5 hp wp+5 gBTNpasteDynaFoldersList, &Paste list
    Gui, Add, Button, x+5 hp wp+5 ginvokePanelDynaFoldersContextMenu, &More
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Dynamic folders list: " appTitle)
    Sleep, 25
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    PopulateDynamicFolderzList()
}

ToggleCountFilesFoldersList() {
  GuiControlGet, CountFilesFolderzList
  If (AnyWindowOpen=3)
     PanelDynamicFolderzWindow()
  Else If (AnyWindowOpen=2)
     PanelStaticFolderzManager()
}

ToggleRecursiveStaticRescan() {
  GuiControlGet, RecursiveStaticRescan
}

BTNaddNewFolder2list() {
    CloseWindow()
    Sleep, 10
    r := addNewFolder2list()
    Sleep, 10
    SetTimer, PanelDynamicFolderzWindow, -50
}

BTNignoreSelFolder(dummy:=0) {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    If (dummy="update-all")
       RowNumber := 1

    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    }

    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }
    Sleep, 25
    If AnyWindowOpen
       CloseWindow("yes")
    Sleep, 25

    doAll := (dummy="update-all") ? 1 : 0
    updateCachedStaticFolders(folderu, 1, doAll)
    showTOOLtip("Folders list information updated")
    SetTimer, RemoveTooltip, % -msgDisplayTime
    Sleep, 50
    PanelStaticFolderzManager()
}


BTNcopyStaticFolderPath() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=2) ? 4 : 3
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return
    
    Try Clipboard := folderu
    Catch wasError

    If wasError
       showTOOLtip("Failed to copy path to clipboard...")
    Else
       showTOOLtip("Folder path copied to clipboard.")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNcopyAllStaticFolderPaths() {
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Loop, % countStaticFolders
          finalListu .= arrayList[A_Index, 1] "`n"

    Try Clipboard := finalListu
    Catch wasError

    If wasError
       showTOOLtip("Failed to copy folder paths to clipboard...")
    Else
       showTOOLtip("Folder paths copied to clipboard.")

    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNremFilesStaticFolder() {
    GuiControlGet, RecursiveStaticRescan
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (RecursiveStaticRescan=1)
       friendly := "(and its sub-folders)"

    recursive := (RecursiveStaticRescan=1) ? "" : "|"
    msgResult := msgBoxWrapper(appTitle ": Remove files associated to static folder", "Please confirm that you want to remove the files from the index/list pertaining to the static folder " friendly " selected:`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       CloseWindow("yes")
       Sleep, 10
       coreRemFilesStaticFolder(folderu, recursive)
       Sleep, 50
       PanelStaticFolderzManager()
    } Else Return
}

coreRemFilesStaticFolder(folderu, recursive) {
    remFilesFromList(recursive folderu)
    If (maxFilesIndex>0)
    {
       GenerateRandyList()
       SoundBeep, 900, 100
       RandomPicture()
    } Else drawWelcomeImg()
}

BTNcopyDynaFoldersList() {
    foldersListu := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || line="|hexists|" || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    Try Clipboard := newFoldersList
    Catch wasError

    ResetImgLoadStatus()
    If !wasError
       showTOOLtip("Dynamic folders list copied to clipboard...")

    SetTimer, RemoveTooltip, % msgDisplayTime
}

BTNpasteDynaFoldersList() {
    CloseWindow("yes")
    Sleep, 50
    foldersListu := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
    foldersListu .= SubStr(Clipboard, 1, 50432)
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || line="|hexists|" || !RegExMatch(fileTest, "i)^(.\:\\.)"))
           Continue

        newFoldersList .= line "`n"
    }

    mustOpenStartFolder := ""
    Sort, newFoldersList, UD`n
    DynamicFoldersList := newFoldersList
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

RemDynaSelFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    CloseWindow("yes")
    Sleep, 50
    mustOpenStartFolder := ""
    foldersListu := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || line="|hexists|" || !RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    DynamicFoldersList := newFoldersList
    If (SLDtypeLoaded=3)
       recreateDynaFoldersSQLdbList(newFoldersList)

    msgResult := msgBoxWrapper(appTitle ": Remove dynamic folder", "Would you like to remove the files from the index/list pertaining to the removed dynamic folder as well ?`n`n" folderu "\", 4, 0, "question")
    If (msgResult="yes")
    {
       remFilesFromList(folderu)
       If (maxFilesIndex>0)
       {
          GenerateRandyList()
          SoundBeep, 900, 100
          RandomPicture()
       } Else drawWelcomeImg()
    }

    Sleep, 50
    ResetImgLoadStatus()
    PanelDynamicFolderzWindow()
}

LV_EX_GetNextItem(HLV, nRow, lParam:=0x0001) {
; Description ..: Get the next item in the target ListView.
; Parameters ...: HLV  - External ListView hwnd
; ..............: nRow   - Row where to start the search for the next item (0-based index).
; ..............: lParam - Status of the searched item. Common statuses are:
; ..............:          LVNI_ALL         - 0x0000
; ..............:          LVNI_FOCUSED     - 0x0001
; ..............:          LVNI_SELECTED    - 0x0002
; ..............:          LVNI_CUT         - 0x0004
; ..............:          LVNI_DROPHILITED - 0x0008
; Info .........: LVM_GETNEXTITEM - http://msdn.microsoft.com/en-us/library/windows/desktop/bb761057%28v=vs.85%29.aspx
; Return .......: Item content as a string.

    ; LVM_GETNEXTITEM = LVM_FIRST (0x1000) + 12 = 0x100C.
    SendMessage, 0x100C, %nRow%, %lParam%,, % "ahk_id " HLV
    Return ErrorLevel
}

LV_EX_GetItemsCount(HLV, ByRef rows, ByRef cols) {
    ; LVM_GETITEMCOUNT = LVM_FIRST (0x1000) + 4 = 0x1004.
    SendMessage, 0x1004, 0, 0,, % "ahk_id " hlv
    rows := ErrorLevel

    ; LVM_GETHEADER = LVM_FIRST (0x1000) + 31 = 0x101F.
    SendMessage, 0x101F, 0, 0,, % "ahk_id " hlv
    hhdr := ErrorLevel

    ; HDM_GETITEMCOUNT = HDM_FIRST (0x1200) + 0 = 0x1200.
    SendMessage, 0x1200, 0, 0,, % "ahk_id " hhdr
    cols := ErrorLevel
}

LV_EX_LVITEM(ByRef LVITEM, Mask := 0, Row := 1, Col := 1) {
   Static LVITEMSize := 48 + (A_PtrSize * 3)
   VarSetCapacity(LVITEM, LVITEMSize, 0)
   NumPut(Mask, LVITEM, 0, "UInt"), NumPut(Row - 1, LVITEM, 4, "Int"), NumPut(Col - 1, LVITEM, 8, "Int")
}

LV_EX_GetSubItemText(HLV, Row, Column := 1, MaxChars := 1024) {
; function by «just me»
; found on https://github.com/AHK-just-me/

   ; LVM_GETITEMTEXT -> http://msdn.microsoft.com/en-us/library/bb761055(v=vs.85).aspx
   Static LVM_GETITEMTEXT := A_IsUnicode ? 0x1073 : 0x102D ; LVM_GETITEMTEXTW : LVM_GETITEMTEXTA
   Static OffText := 16 + A_PtrSize
   Static OffTextMax := OffText + A_PtrSize
   VarSetCapacity(ItemText, MaxChars << !!A_IsUnicode, 0)
   LV_EX_LVITEM(LVITEM, , Row, Column)
   NumPut(&ItemText, LVITEM, OffText, "Ptr")
   NumPut(MaxChars, LVITEM, OffTextMax, "Int")
   SendMessage, % LVM_GETITEMTEXT, % (Row - 1), % &LVITEM, , % "ahk_id " . HLV
   VarSetCapacity(ItemText, -1)
   Return ItemText
}

BTNopenDynaFolder() {
    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    colNum := (AnyWindowOpen=3) ? 3 : 4
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1) ; LV_GetNext(0, "F")
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    ; LV_GetText(folderu, RowNumber, colNum)
    ; ToolTip, % RowNumber "==" A_GuiEventInfo "`n" folderu , , , 2
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    folderu := StrReplace(folderu, "|")
    Try Run, "%folderu%"
    Catch wasError
          Sleep, 1

    If wasError
       msgBoxWrapper(appTitle ": ERROR", "An unknown error occured opening the folder: `n" folderu, 0, 0, "error")
}

FolderzFilterListBTN(dummy:=0) {
    whichLV := (AnyWindowOpen=3) ? "LViewDynas" : "LViewOthers"
    Gui, SettingsGUIA: ListView, % whichLV
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    colNum := (AnyWindowOpen=3) ? 3 : 4
    indexu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum - 3)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum)
    files := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, colNum + 1)

    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If ((A_GuiEvent="Normal" || A_GuiEvent="K") && files="" && whichLV="LViewOthers")
    {
       countedFiles := 0
       ; startZeit := A_TickCount
       Loop, % maxFilesIndex
       {
          imgPath := resultedFilesList[A_Index, 1]
          ; If QPV_InStr(imgPath, folderu)
          If InStr(imgPath, folderu)
             countedFiles++
       }
       ; ToolTip, % A_TickCount - startZeit , , , 2
       newStaticFoldersListCache[indexu, 3] := countedFiles
       LV_Modify(RowNumber + 1, "Col" colNum+1, countedFiles)
       LV_ModifyCol(colNum + 1, "AutoHdr Left")
       Return
    }

    If (A_GuiEvent!="DoubleClick" && dummy!="menu-mode")
       Return

    doExactMatch := (AnyWindowOpen=3) ? 0 : 1
    CloseWindow("yes")
    folderu := StrReplace(folderu, "|")
    coreEnableFiltru(folderu, doExactMatch)
}

MenuFolderzFilterList() {
   FolderzFilterListBTN("menu-mode")
}

InvertRecurseDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    CloseWindow("yes")
    Sleep, 25
    foldersListu := InStr(DynamicFoldersList, "|hexists|") ? coreLoadDynaFolders(CurrentSLD) : DynamicFoldersList
    Loop, Parse, foldersListu, `n
    {
        line := Trimmer(A_LoopField)
        fileTest := StrReplace(line, "|")
        If (!FolderExist(fileTest) || line="|hexists|" || !RegExMatch(fileTest, "i)^(.\:\\.)") || folderu=line)
           Continue

        newFoldersList .= line "`n"
    }

    isPipe := InStr(folderu, "|") ? 1 : 0
    folderu := StrReplace(folderu, "|")
    If (isPipe!=1)
       folderu := "|" folderu

    newFoldersList .= folderu "`n"
    Sort, newFoldersList, UD`n
    DynamicFoldersList := newFoldersList
    Sleep, 15
    PanelDynamicFolderzWindow()
    Sleep, 15
    showTOOLtip("You need to rescan folder for the effect to take place...")
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNrescanDynaFolder() {
    Gui, SettingsGUIA: ListView, LViewDynas
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 3)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    CloseWindow("yes")
    Sleep, 25
    ; msgbox, % folderu
    mustOpenStartFolder := ""
    showTOOLtip("Preparing files list, please wait.`n" folderu "\")
    If InStr(folderu, "|")
    {
       fileTest := StrReplace(folderu, "|")
       remFilesFromList(fileTest)
    }

    coreAddNewFolder(folderu, 1)
    If (RegExMatch(CurrentSLD, sldsPattern) && SLDtypeLoaded=2)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
       If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1 || InStr(folderu, "|"))
          good2go := "null"
    } Else good2go := "null"
    If (SLDtypeLoaded=3)
       good2go := 0

    If (mustGenerateStaticFolders=0 && good2go!="null" && RegExMatch(CurrentSLD, sldsPattern))
       updateCachedStaticFolders(folderu, 0)

    Sleep, 250
    PanelDynamicFolderzWindow()
}

updateCachedStaticFolders(mainFolderu, onlyMainFolder, updateAllDates:=0) {
   thisIndex := 0
   showTOOLtip("Updating static folders list...")
   arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
   Loop, % countStaticFolders
         foldersListu .= "Fi" A_Index "=" arrayList[A_Index, 2] "*&*" arrayList[A_Index, 1] "`n"

   FileGetTime, dirDate, % mainFolderu, M
   newEntry := dirDate "*&*" mainFolderu "`n"

   If (onlyMainFolder!=1)
   {
      Loop, Files, %mainFolderu%\*, RD
      {
          FileGetTime, dirDate, %A_LoopFileFullPath%, M
          MoreNewFileFolders .= dirDate "*&*" A_LoopFileFullPath "`n"
          ; Tooltip, % MoreNewFileFolders
      }
   }

   Loop, Parse, foldersListu, `n
   {
       lineArru := StrSplit(A_LoopField, "*&*")
       folderu := lineArru[2], oldDateu := lineArru[1]
       If !FolderExist(folderu) || (folderu=mainFolderu) || InStr(MoreNewFileFolders, "*&*" folderu "`n")
          Continue

       oldDateu := SubStr(oldDateu, InStr(oldDateu, "=")+1)
       If (updateAllDates=1)
          FileGetTime, oldDateu, % folderu, M
       newFoldersList .= oldDateu "*&*" folderu "`n"
   }

   FinalStaticFoldersList := newFoldersList "`n" MoreNewFileFolders "`n" newEntry
   Sort, FinalStaticFoldersList, U D`n
   If (SLDtypeLoaded=3)
   {
      activeSQLdb.Exec("BEGIN TRANSACTION;")
      activeSQLdb.Exec("DELETE FROM staticfolders;")
      Loop, Parse, FinalStaticFoldersList, `n
      {
          If StrLen(A_LoopField)>2
             lineArru := StrSplit(A_LoopField, "*&*")
          Else
             Continue

          folderu := lineArru[2]
          oldDateu := lineArru[1]
          addStaticFolderSQLdb(folderu, oldDateu, 0)
      }
      activeSQLdb.Exec("COMMIT TRANSACTION;")
      Return
   }

   thisIndex := 0
   newStaticFoldersListCache := []
   Loop, Parse, FinalStaticFoldersList, `n
   {
        If StrLen(A_LoopField)<5
           Continue

        thisIndex++
        lineArru := StrSplit(A_LoopField, "*&*")
        newStaticFoldersListCache[thisIndex] := [lineArru[2], lineArru[1]]
   }
}

remFilesFromList(SelectedDir, silentus:=0) {
    If (silentus=0)
       showTOOLtip("Removing files from the list pertaining to...`n" SelectedDir "\`n")

    backCurrentSLD := CurrentSLD
    CurrentSLD := ""
    markedSelectFile := 0
    If StrLen(filesFilter)>1
    {
       usrFilesFilteru := filesFilter := ""
       FilterFilesIndex()
    }

    oldMaxy := maxFilesIndex
    isPipe := InStr(SelectedDir, "|") ? 1 : 0
    SelectedDir := StrReplace(SelectedDir, "|")
    newArrayu := []
    Loop, % maxFilesIndex + 1
    {
        r := getIDimage(A_Index)
        If (InStr(r, "||") || !r)
           Continue
        If !isPipe
        {
           If InStr(r, SelectedDir "\")
              Continue
        } Else If (isPipe=1)
        {
           rT := StrReplace(r, SelectedDir "\")
           If !InStr(rT, "\")
              Continue
        }
        countFiles++
        newArrayu[countFiles] := [r]
    }

    If (SLDtypeLoaded=3)
    {
       activeSQLdb.Exec("BEGIN TRANSACTION;")
       thisR := (isPipe=1) ? SelectedDir : SelectedDir "%"
       thisR := StrReplace(thisR, "_", "@_")
       SQLstr := "DELETE FROM images WHERE imgfolder LIKE '" thisR "' ESCAPE '@';"
       If !activeSQLdb.Exec(SQLStr)
       {
          stringA:= thisR
          activeSQLdb.EscapeStr(stringA)
          SQLstr := "DELETE FROM images WHERE imgfolder LIKE " stringA " ESCAPE '@';"
          activeSQLdb.Exec(SQLStr)
       }
       activeSQLdb.Exec("COMMIT TRANSACTION;")
    }
    renewCurrentFilesList()
    maxFilesIndex := countFiles
    resultedFilesList := newArrayu.Clone()
    ForceRefreshNowThumbsList()
    filesRemoved := oldMaxy - maxFilesIndex
    If (filesRemoved<1)
       filesRemoved := 0
    If (silentus=0)
       showTOOLtip("Finished removing " filesRemoved " files from the list...")
    CurrentSLD := backCurrentSLD
    Sleep, 25
    SetTimer, RemoveTooltip, % -msgDisplayTime
}

PanelRenameStaticFolder() {
    ; Global newFileName, idFolder, remFilesFromFolder, doRemRecursively
    ; GuiControlGet, RecursiveStaticRescan
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return
 
    FileReadLine, firstLine, % CurrentSLD, 1
    IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }

   Sleep, 15
   msgResult := msgBoxWrapper("Rename static folder entry: " appTitle, "Please type the new folder path...", "&Rename folder entry|C&ancel", 1, "modify-entry", "Re&move the index entries associated with the initial static folder path", 1, 0, "limit9050 w850", folderu)
   If InStr(msgResult.btn, "Rename")
   {
      remFilesFromFolder := msgResult.check
      newFileName := Trimmer(msgResult.edit)
      newFileName := StrReplace(newFileName, "/", "\")
      newFileName := Trimmer(newFileName, "\")
      newFileName := RegExReplace(newFileName, "\\{2,}", "\")
      If (!newFileName || newFileName=folderu)
         Return

      If (!RegExMatch(newFileName, "i)^(.\:\\.)") || !newFileName)
      {
         showTOOLtip("WARNING: Incorrect folder path provided...")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      If !FileExist(newFileName)
      {
         showTOOLtip("WARNING: Inexistent folder path provided...")
         SoundBeep , 300, 100
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      CloseWindow("yes")
      If (remFilesFromFolder=1)
         coreRemFilesStaticFolder(folderu, recursive)

      newName := newFileName
      showTOOLtip("Updating static folders list...")
      arrayList := LoadStaticFoldersCached(CurrentSLD, totalStaticFolders, 1)
      Loop, % totalStaticFolders
      {
         If (arrayList[A_Index, 1]=folderu)
            arrayList[A_Index, 1] := newName
      }

      newStaticFoldersListCache := []
      newStaticFoldersListCache := arrayList.Clone()
      SetTimer, RemoveTooltip, % -msgDisplayTime
      ; MsgBox, % firstPart "`n" newName "`n" indexSelected
      PanelStaticFolderzManager()
    }
}

BTNupdateSelectedStaticFolder() {
    Gui, SettingsGUIA: ListView, LViewOthers
    RowNumber := LV_EX_GetNextItem(hLVmainu, -1)
    folderu := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 4)
    indexSelected := LV_EX_GetSubItemText(hLVmainu, RowNumber + 1, 1)
    If (StrLen(folderu)<3 || folderu="folder path")
       Return

    If (SLDtypeLoaded!=3)
    {
       FileReadLine, firstLine, % CurrentSLD, 1
       IniRead, tstSLDcacheFilesList, % CurrentSLD, General, SLDcacheFilesList, @
    }

    If (!InStr(firstLine, "[General]") || tstSLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "The loaded .SLD file does not seem to be in the correct format. Operation aborted.`n`n" CurrentSLD, 0, 0, "error")
       Return
    }

    If (RecursiveStaticRescan!=1)
       isRecursive := "|"

    If AnyWindowOpen
       CloseWindow("yes")

    Sleep, 5
    showTOOLtip("Preparing files list, please wait.`n" isRecursive folderu "\")
    coreAddNewFolder(isRecursive folderu, 0, 1)
    modus := isRecursive ? 1 : 0
    updateCachedStaticFolders(folderu, modus)
    Sleep, 5
    SetTimer, RemoveTooltip, % -msgDisplayTime
    PanelStaticFolderzManager()
}

filterListViewStaticFoldersList() {
   GuiControlGet, listViewFilteru
   If (imageLoading=1)
      Return

   If (SLDtypeLoaded=3)
      PopulateStaticSQLfolderzList(listViewFilteru)
   Else
      PopulateStaticFolderzList(listViewFilteru)
}

PopulateStaticSQLfolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    Tooltip, Gathering folders list - please wait
    EM_SETCUEBANNER(hEditField, "Gathering folders list - please wait...", 0)
    startOperation := A_TickCount
    setImageLoading()
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    doStartLongOpDance()

    RecordSet := ""
    SQL := "SELECT imgfolder, COUNT(*) FROM images GROUP BY imgfolder;"
    If !activeSQLdb.Query(SQL, RecordSet)
       Return 0

    arrayList := []
    fCountThese := countThese := 0
    Loop
    {
        ; If (Row[1] && Row[2])
        ; {
           fCountThese++
           arrayList[fCountThese] := [Row[1], Row[2]]
        ; }
        RC := RecordSet.Next(Row)
    } Until (RC<1)
    RecordSet.Free()

    foldersDatesArray := []
    SQL := "SELECT imgfolder, fmodified FROM staticfolders;"
    If !activeSQLdb.Query(SQL, RecordSet)
       Return 0

    Loop
    {
        foldersDatesArray[CalcStringHash(Row[1], 0x8003)] := [Row[2], Row[1]]
        RC := RecordSet.Next(Row)
    } Until (RC<1)
    RecordSet.Free()

    startOperation := A_TickCount
    Loop, % fCountThese
    {
        folderu := Trimmer(arrayList[A_Index, 1])
        If (StrLen(folderu)<5) || (listFilter && !InStr(folderu, listFilter))
           Continue

        countThese++
        hashu := CalcStringHash(folderu, 0x8003)
        oldDateu := foldersDatesArray[hashu, 1]
        foldersDatesArray[hashu] := "done"
        FileGetTime, dirDate, % folderu, M
        statusu := (dirDate!=oldDateu) ? "(*)" : "_"
        dirDate := oldDateu
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 2]

        LV_Add(A_Index, A_Index, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           msgbox, % folderu "`n" countFiles
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
/*
    countTheseB := 0
    For gey, balue in foldersDatesArray
    {
         If (balue="done")
            Continue

        folderu := balue[2]
        If (StrLen(folderu)<3 || (listFilter && !InStr(folderu, listFilter)))
           Continue

        oldDateu := balue[1]
        FileGetTime, dirDate, % folderu, M
        statusu := (dirDate!=oldDateu) ? "(*)" : "_"
        dirDate := oldDateu
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := 0
        countTheseB++
        LV_Add(A_Index, countThese + countTheseB, dirDate, statusu, folderu, countFiles)
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
*/
    EM_SETCUEBANNER(hEditField, "Filter folders list...", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    Tooltip
}

PopulateStaticFolderzList(listFilter:=0) {
    If (mustGenerateStaticFolders=1 || SLDcacheFilesList!=1) && (SLDtypeLoaded!=3)
       Return

    EM_SETCUEBANNER(hEditField, "Preparing folders list - please wait...", 0)
    startOperation := A_TickCount
    setImageLoading()
    Tooltip, Preparing folders list - please wait.
    arrayList := LoadStaticFoldersCached(CurrentSLD, countStaticFolders, 1)
    Gui, SettingsGUIA: ListView, LViewOthers
    LV_Delete()
    startZeit := A_TickCount
    If (CountFilesFolderzList=1)
       dropFilesSelection(1)

    LV_ModifyCol(5, "Integer")
    LV_ModifyCol(1, "Integer")
    LV_ModifyCol(0, "Integer")
    doStartLongOpDance()
    startOperation := A_TickCount
    thisIndex := foldersCount := 0
/*
    tempArray := []
    countedFilesArray := []
    Loop, Parse, foldersListu, `n,`r
    {
       If (StrLen(A_LoopField)<2) || (listFilter && !InStr(A_LoopField, listFilter))
          Continue

       thisFolder := SubStr(A_LoopField, InStr(A_LoopField, "*&*")+3) "\"
       thisIndex := A_Index
       tempArray[thisIndex] := thisFolder
       countedFilesArray[thisIndex] := 0
       foldersCount++
    }

    Loop, % maxFilesIndex
    {
       imgPath := resultedFilesList[A_Index, 1]
       Loop, % foldersCount
       {
           If InStr(imgPath, tempArray[A_Index])
              countedFilesArray[A_Index] += 1
       }
    }
*/

    Tooltip, Listing folders now - please wait...
    Loop, % countStaticFolders
    {
        thisIndex := A_Index
        folderu := arrayList[A_Index, 1]
        If (StrLen(folderu)<2) || (listFilter && !InStr(folderu, listFilter))
           Continue

        If (determineTerminateOperation()=1)
        {
           abandonAll := 1
           CountFilesFolderzList := 0
           Break
        }

        oldDateu := arrayList[A_Index, 2]
        FileGetTime, dirDateO, % folderu, M
        statusu := (dirDateO!=oldDateu) ? "(*)" : "_"
        dirDate := SubStr(dirDateO, 1, StrLen(dirDate)-2)
        FormatTime, dirDate, % dirDate, yyyy/MM/dd-HH:mm
        countFiles := arrayList[A_Index, 3] ; countedFilesArray[countThese] ; : "-"

        LV_Add(A_Index, thisIndex, dirDate, statusu, folderu, countFiles)
        If (A_Index=5)
        {
           Loop, 5
               LV_ModifyCol(A_Index, "AutoHdr Left")
        }
    }
    ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 

    EM_SETCUEBANNER(hEditField, "Filter folders list...", 0)
    executingCanceableOperation := 0
    Loop, 5
        LV_ModifyCol(A_Index, "AutoHdr Left")

    LV_ModifyCol(3, "Sort")
    SetTimer, ResetImgLoadStatus, -25
    If (CountFilesFolderzList=1)
    {
       SoundBeep, 900, 100
       CountFilesFolderzList := 0
       GuiControl, SettingsGUIA:, CountFilesFolderzList, 0
    }
    Tooltip
}

StrPutVar(string, ByRef var, encoding) {
    ; Ensure capacity.
    ; StrPut returns char count, but VarSetCapacity needs bytes.
    VarSetCapacity(var, StrPut(string, encoding) * ((encoding="utf-16"||encoding="cp1200") ? 2 : 1))
    ; Copy or convert the string.
    return StrPut(string, &var, encoding)
}

PopulateDynamicFolderzList() {
    If InStr(DynamicFoldersList, "|hexists|")
       DynamicFoldersList := coreLoadDynaFolders(CurrentSLD)

    Gui, SettingsGUIA: ListView, LViewDynas
    Loop, Parse, DynamicFoldersList, `n
    {
        line := Trimmer(A_LoopField)
        If (StrLen(line)<2 || line="|hexists|")
           Continue

        counteru++
        statusu := InStr(line, "|") ? "_" : "[R]"
        LV_Add(A_Index, counteru, statusu, line)
    }

    Loop, 3
        LV_ModifyCol(A_Index, "AutoHdr Left")

    ResetImgLoadStatus()
}

CloseWindow(forceIT:=0, cleanCaches:=1) {
    Critical, on
    If (toolTipGuiCreated=2)
       SetTimer, RemoveTooltip, -9500
    isFakeWin := prevOpenedWindow[5]
    If (isFakeWin && AnyWindowOpen)
    {
       AnyWindowOpen := 0
       interfaceThread.ahkassign("AnyWindowOpen", AnyWindowOpen)
       SetTimer, CloseMsgBox2Win, Delete
       SetTimer, WatchMsgBox2Win, Delete
       MsgBox2Result := "win_closed"
       MsgBox2InputHook.Stop()
       Gui, WinMsgBox: Destroy
       MsgBox2hwnd := ""
       Sleep, 25
       Return
    }

    If (forceIT!="yes")
    {
       If (A_TickCount - lastLongOperationAbort < 1000)
          Return
    }

    If (imgEditPanelOpened!=1)
       ResetImgLoadStatus()

    If (AnyWindowOpen>0 && imgEditPanelOpened=1)
       Try WinGetPos, prevSetWinPosX, prevSetWinPosY,,, ahk_id %hSetWinGui%

    Global lastOtherWinClose := A_TickCount
    interfaceThread.ahkassign("AnyWindowOpen", 0)
    interfaceThread.ahkassign("lastOtherWinClose", lastOtherWinClose)
    ForceNoColorMatrix := 0
    DestroyGIFuWin()
    Gui, SettingsGUIA: Destroy
    WinActivate, ahk_id %PVhwnd%
    interfaceThread.ahkassign("imgEditPanelOpened", 0)
    If globalhFIFimg
    {
       FreeImage_UnLoad(globalhFIFimg)
       globalhFIFimg := ""
    }

    If (imgEditPanelOpened=1)
    {
       editingSelectionNow := prevOpenedWindow[4]
       TriggerMenuBarUpdate()
       livePreviewInsertTextinArea("kill")
       If (cleanCaches!=0)
       {
          coreFillSelectedArea("kill")
          corePasteInPlaceActNow("kill")
       }
       SetTimer, dummyRefreshImgSelectionWindow, -200
    }

    imgEditPanelOpened := AnyWindowOpen := 0
}

CreateOSDinfoLine(msg:=0, killWin:=0, forceDarker:=0, perc:=0) {
    ; Critical, On
    Static prevMsg, preventKill, lastInvoked := 1

    If (killWin=1 || StrLen(msg)<3)
    {
       If (A_TickCount - lastInvoked<msgDisplayTime + 900) && (preventKill=1)
       || (A_TickCount - lastInvoked<350) && (killWin=1 && slideShowRunning!=1)
       {
          SetTimer, RemoveTooltip, -400
          Return
       }

       toolTipGuiCreated := 0
       interfaceThread.ahkassign("toolTipGuiCreated", 0)
       clearGivenGDIwin(2NDglPG, 2NDglHDC, hGDIinfosWin)
       preventKill := 0
       Return
    }

    If (A_TickCount - lastInvoked<95) && (forceDarker!=1)
    {
       SetTimer, dummyShowToolTip, -200
       Return
    }
    If (A_TickCount - lastInvoked<msgDisplayTime - 300) && (preventKill=1 && prevMsg!=msg && runningLongOperation!=1)
       msgBoxWrapper(appTitle ": ERROR", prevMsg, 0, 0, "error")

    addJournalEntry("OSD: " msg)
    If (!CurrentSLD && currentFileIndex!=0) || (forceDarker=1)
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x66" WindowBgrColor, 1)
    Else
       trGdip_GraphicsClear(A_ThisFunc, 2NDglPG, "0x00" WindowBgrColor, 1)

    preventKill := 0
    If RegExMatch(msg, "i)^(error|failed)")
    {
       preventKill := 1
       uBrushA := Gdip_BrushCreateSolid("0xEEFF2200")
    } Else If RegExMatch(msg, "i)^(WARNING|operation aborted)")
       uBrushA := Gdip_BrushCreateSolid("0xEEFFDE21")

    knobSize := imgHUDbaseUnit//3.5
    posXu := uBrushA ? knobSize : 0
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    BoxBMP := drawTextInBox(msg, OSDFontName, OSDfntSize, Round(mainWidth*0.8), Round(mainHeight*0.8), OSDtextColor, OSDbgrColor, 0)
    If !BoxBMP
    {
       Gdip_DeleteBrush(uBrushA)
       Return
    }

    Gdip_GetImageDimensions(BoxBMP, imgW, imgH)
    posYu := perc ? knobSize//2 : 0
    trGdip_DrawImage(A_ThisFunc, 2NDglPG, BoxBMP, posXu, posYu, imgW, imgH)
    If uBrushA
    {
       Gdip_FillRectangle(2NDglPG, uBrushA, 0, posYu, knobSize, imgH)
       Gdip_FillRectangle(2NDglPG, uBrushA, imgW + posXu, posYu, knobSize, imgH)
    }

    If perc
    {
       percW := Round(mainWidth*perc)
       Gdip_FillRectangle(2NDglPG, pBrushE, percW, 0, mainWidth - percW + 1, knobSize//2)
       Gdip_FillRectangle(2NDglPG, pBrushB, 0, knobSize//2, mainWidth, 3)
       Gdip_FillRectangle(2NDglPG, pBrushD, 0, 0, percW, knobSize//2)
    }

    r2 := LrydWinUpdt(hGDIinfosWin, 2NDglHDC)
    trGdip_DisposeImage(BoxBMP, 1)
    Gdip_DeleteBrush(uBrushA)
    toolTipGuiCreated := 1
    prevMsg := msg
    If (prevMsg!=msg)
       lastInvoked := A_TickCount

    If (forceDarker!=1)
       interfaceThread.ahkassign("toolTipGuiCreated", 1)
}

BlackedCreator(thisOpacity, killWin:=0) {
    Critical, On
    Static lastInvoked := 1
    If (killWin=1)
    {
       Gui, BlackGuia: Destroy
       Return
    }

    If (A_TickCount - lastInvoked<250)
       Return

    lastInvoked := A_TickCount
    Gui, BlackGuia: Destroy
    Sleep, 5
    GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)
    Gui, BlackGuia: -DPIScale -Caption +Owner%PVhwnd% +ToolWindow +E0x80000 +E0x20 +hwndhGuiBlack
    Gui, BlackGuia: Color, c%OSDbgrColor%
    Gui, BlackGuia: Margin, 0, 0
    Gui, BlackGuia: Add, Text,+0x80 c%OSDtextColor% w%mainWidth% h%mainHeight% gRemoveTooltip, %msg%
    JEE_ClientToScreen(hPicOnGui1, 1, 1, GuiX, GuiY)
    WinSet, Transparent, %thisOpacity%, ahk_id %hGuiBlack%
    WinSet, Region, 0-0 R6-6 w%mainWidth% h%mainHeight%, ahk_id %hGuiBlack%
    ; GuiX := GuiY := 0
    Gui, BlackGuia: Show, NoActivate AutoSize x%GuiX% y%GuiY%, GuiBlackedWin
    ; SetParentID(PVhwnd, hGuiBlack)
}

DestroyGIFuWin() {
    If (slideShowRunning=1 || animGIFplaying=1)
       SetTimer, ResetImgLoadStatus, -15

    autoChangeDesiredFrame("stop")
}

; =================================================================================================
; Function......: GetModuleFileNameEx
; DLL...........: Kernel32.dll / Psapi.dll
; Library.......: Kernel32.lib / Psapi.lib
; U/ANSI........: GetModuleFileNameExW (Unicode) and GetModuleFileNameExA (ANSI)
; Author........: jNizM
; Modified......:
; Links.........: http://msdn.microsoft.com/en-us/library/windows/desktop/ms683198(v=vs.85).aspx
; =================================================================================================

GetModuleFileNameEx(PID) {
; found on: https://autohotkey.com/board/topic/109557-processid-a-scriptfullpath/

    hProcess := DllCall("Kernel32.dll\OpenProcess", "UInt", 0x001F0FFF, "UInt", 0, "UInt", PID)
    If (ErrorLevel || hProcess = 0)
       Return
    Static lpFilename, nSize := 260, int := VarSetCapacity(lpFilename, nSize, 0)
    DllCall("Psapi.dll\GetModuleFileNameEx", "Ptr", hProcess, "Ptr", 0, "Str", lpFilename, "UInt", nSize)
    DllCall("Kernel32.dll\CloseHandle", "Ptr", hProcess)
    Return lpFilename
}

GetCurrentProcessId() {
    Return DllCall("Kernel32.dll\GetCurrentProcessId")
}

Fnt_GetListOfFonts() {
; function stripped down from Font Library 3.0 by jballi
; from https://autohotkey.com/boards/viewtopic.php?t=4379

    Static Dummy65612414
          ,HWND_DESKTOP := 0   ;-- Device constants
          ,LF_FACESIZE  := 32  ;-- In TCHARS - LOGFONT constants

    ;-- Initialize and populate LOGFONT structure
    Fnt_EnumFontFamExProc_List := ""
    p_CharSet := 1
    p_Flags := 0x800
    VarSetCapacity(LOGFONT,A_IsUnicode ? 92:60,0)
    NumPut(p_CharSet,LOGFONT,23,"UChar")                ;-- lfCharSet

    ;-- Enumerate fonts
    EFFEP := RegisterCallback("Fnt_EnumFontFamExProc","F")
    hDC := Gdi_GetDC(HWND_DESKTOP)
    DllCall("gdi32\EnumFontFamiliesExW"
       ,"Ptr", hDC                                      ;-- hdc
       ,"Ptr", &LOGFONT                                 ;-- lpLogfont
       ,"Ptr", EFFEP                                    ;-- lpEnumFontFamExProc
       ,"Ptr", p_Flags                                  ;-- lParam
       ,"UInt", 0)                                      ;-- dwFlags (must be 0)

    DllCall("user32\ReleaseDC","Ptr",HWND_DESKTOP,"Ptr",hDC)
    DllCall("GlobalFree", "Ptr", EFFEP)
    Return Fnt_EnumFontFamExProc_List
}

Fnt_EnumFontFamExProc(lpelfe,lpntme,FontType,p_Flags) {
    Fnt_EnumFontFamExProc_List := 0
    Static Dummy62479817
          ,LF_FACESIZE := 32     ;-- In TCHARS - LOGFONT constants

    l_FaceName := StrGet(lpelfe+28,LF_FACESIZE)
    FontList.Push(l_FaceName)    ;-- Append the font name to the list
    Return 1                     ;-- Continue enumeration
}

ST_Insert(insert,input,pos=1) {
  Length := StrLen(input)
  ((pos > 0) ? (pos2 := pos - 1) : (((pos = 0) ? (pos2 := StrLen(input),Length := 0) : (pos2 := pos))))
  output := SubStr(input, 1, pos2) . insert . SubStr(input, pos, Length)
  If (StrLen(output) > StrLen(input) + StrLen(insert))
     ((Abs(pos) <= StrLen(input)/2) ? (output := SubStr(output, 1, pos2 - 1) . SubStr(output, pos + 1, StrLen(input)))
     : (output := SubStr(output, 1, pos2 - StrLen(insert) - 2) . SubStr(output, pos - StrLen(insert), StrLen(input))))
  Return output
}

SetVolume(val:=100, r:="") {
; Function by Drugwash
  v := Round(val*655.35)
  vr := r="" ? v : Round(r*655.35)
  Try DllCall("winmm\waveOutSetVolume", "UInt", 0, "UInt", (v|vr<<16))
}

initCompiled(mode) {
   fullPath2exe := GetModuleFileNameEx(QPVpid)
   If (mode=1)
   {
      zPlitPath(fullPath2exe, 0, OutFileName, OutDir)
      mainCompiledExe := OutFileName
      mainCompiledPath := OutDir
      thumbsCacheFolder := OutDir "\thumbs-cache"
      mainSettingsFile := OutDir "\" mainSettingsFile
      mainRecentsFile := OutDir "\" mainRecentsFile
      mainFavesFile := OutDir "\" mainFavesFile
   } Else
   {
      mainCompiledPath := A_ScriptDir
      unCompiledExePath := Chr(34) fullPath2exe Chr(34) A_Space Chr(34) A_ScriptFullPath Chr(34)
   }
}

RunAdminMode() {
  If !A_IsAdmin
  {
      Try {
         If A_IsCompiled
            Run *RunAs "%fullPath2exe%" /restart
         Else
            Run *RunAs "%A_AhkPath%" /restart "%A_ScriptFullPath%"

         ExitApp
      }
  }
}

FileAssociate(Label,Ext,Cmd,Icon:="", batchMode:=0) {
; by Ħakito: https://autohotkey.com/boards/viewtopic.php?f=6&t=55638 
; modified by Marius Șucan to AHK v1.1

  ; Weeds out faulty extensions, which must start with a period, and contain more than 1 character
  iF (SubStr(Ext,1,1)!="." || StrLen(Ext)<=1)
     Return 0

  ; Weeds out faulty labels such as ".exe" which is an extension and not a label
  iF (SubStr(Label,1,1)=".")
     Return 0

  If Label
     RegRead, CheckLabel, HKEY_CLASSES_ROOT\%Label%, FriendlyTypeName

  ; Do not allow the modification of some important registry labels
  iF (Cmd!="" && CheckLabel)
     Return 0

  regFile := "Windows Registry Editor Version 5.00`n`n"
  ; Note that "HKEY_CLASSES_ROOT" actually writes to "HKEY_LOCAL_MACHINE\SOFTWARE\Classes"
  ; If the command is just a simple path, then convert it into a proper run command
  iF (SubStr(Cmd,2,2)=":\" && FileExist(Cmd))
     Cmd := """" Cmd """" A_Space """" "%1" """"
  Else
     Return 0

  Cmd := StrReplace(Cmd, "\", "\\")
  Cmd := StrReplace(Cmd, """", "\""")
  regFile .= "[HKEY_CLASSES_ROOT\" Ext "]`n@=" """" Label """" "`n"
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "]`n@=" """" Label """" "`n"
  regFile .= "`n[HKEY_CLASSES_ROOT\" Label "\Shell\Open\Command]`n@=" """" Cmd """" "`n"
  regFile .= "`n[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\UserChoice]`n""ProgId""=" """" Label """" "`n"
  regFile .= "`n[-HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" Ext "\OpenWithProgids]`n"
  regFile .= "`n[-HKEY_CLASSES_ROOT\" Ext "\OpenWithProgids]`n`n"

  If Icon
     regFile .= "`n[HKEY_CLASSES_ROOT\" QPVslideshow "\DefaultIcon]`n@=" Icon "`n`n"

  If !FolderExist(mainCompiledPath "\regFiles")
  {
     FileCreateDir, %mainCompiledPath%\regFiles
     Sleep, 1
  }

  iExt := StrReplace(Ext, ".")
  FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
  Sleep, 1
  FileAppend, % regFile, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
  runTarget := "Reg Import """ mainCompiledPath "\regFiles\RegFormat" iExt ".reg" """" "`n"
  If !InStr("|WIN_7|WIN_8|WIN_8.1|WIN_VISTA|WIN_2003|WIN_XP|WIN_2000|", "|" A_OSVersion "|")
     runTarget .= """" mainCompiledPath "\SetUserFTA.exe""" A_Space Ext A_Space Label "`n"
  FileAppend, % runTarget, %mainCompiledPath%\regFiles\runThis.bat
  If (batchMode!=1)
  {
     Sleep, 1
     RunWait, *RunAs "%mainCompiledPath%\regFiles\runThis.bat"
     FileDelete, %mainCompiledPath%\regFiles\RegFormat%iExt%.reg
     FileDelete, %mainCompiledPath%\regFiles\runThis.bat
  }

  return 1
}

; ==================================================================================================================================
; function by «just me», source https://www.autohotkey.com/boards/viewtopic.php?t=18081
;
; Creates an 'open with' menu for the passed file.
; Parameters:
;     FilePath    -  Fully qualified path of a single file.
;     Recommended -  Show only recommended apps (True/False).
;                    Default: True
;     ShowMenu    -  Immediately show the menu (True/False).
;                    Default: False
;     MenuName    -  The name of the menu.
;                    Default: OpenWithMenu
;     Others      -  Name of the submenu holding not recommended apps (if Recommended has been set to False).
;                    Default: Others
; Return values:
;     On success the function returns the menu's name unless ShowMenu has been set to True.
;     If the menu couldn't be created, the function returns False.
; Remarks:
;     Requires AHK 1.1.23.07+ and Win Vista+!!!
;     The function registers itself as the menu handler.
; Credits:
;     Based on code by querty12 -> autohotkey.com/boards/viewtopic.php?p=86709#p86709.
;     I hadn't even heard anything about the related API functions before.
; MSDN:
;     SHAssocEnumHandlers -> msdn.microsoft.com/en-us/library/bb762109%28v=vs.85%29.aspx
;     SHCreateItemFromParsingName -> msdn.microsoft.com/en-us/library/bb762134%28v=vs.85%29.aspx
; ==================================================================================================================================
CreateOpenWithMenu(FilePath, Recommended := 1, ShowMenu := 0, MenuName := "OpenWithMenu", Others := "Others") {
   Static RecommendedHandlers := []
        , OtherHandlers := []
        , HandlerID := A_TickCount
        , HandlerFunc := 0
        , ThisMenuName := ""
        , ThisOthers := ""
   ; -------------------------------------------------------------------------------------------------------------------------------
   Static IID_IShellItem := 0, BHID_DataObject := 0, IID_IDataObject := 0
        , Init := VarSetCapacity(IID_IShellItem, 16, 0) . VarSetCapacity(BHID_DataObject, 16, 0)
          . VarSetCapacity(IID_IDataObject, 16, 0)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}", "Ptr", &BHID_DataObject)
          . DllCall("Ole32.dll\IIDFromString", "WStr", "{0000010e-0000-0000-C000-000000000046}", "Ptr", &IID_IDataObject)
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; Handler call
   If (Recommended = HandlerID) {
      AssocHandlers := A_ThisMenu = ThisMenuName ? RecommendedHandlers : OtherHandlers
      If (AssocHandler := AssocHandlers[A_ThisMenuItemPos]) && FileExist(FilePath) {
         AssocHandlerInvoke := NumGet(NumGet(AssocHandler + 0, "UPtr"), A_PtrSize * 8, "UPtr")
         If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", FilePath, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", Item) {
            BindToHandler := NumGet(NumGet(Item + 0, "UPtr"), A_PtrSize * 3, "UPtr")
            If !DllCall(BindToHandler, "Ptr", Item, "Ptr", 0, "Ptr", &BHID_DataObject, "Ptr", &IID_IDataObject, "PtrP", DataObj) {
               DllCall(AssocHandlerInvoke, "Ptr", AssocHandler, "Ptr", DataObj)
               ObjRelease(DataObj)
            }
            ObjRelease(Item)
         }
      }
      Try Menu, %ThisMenuName%, DeleteAll
      For Each, AssocHandler In RecommendedHandlers
         ObjRelease(AssocHandler)
      For Each, AssocHandler In OtherHandlers
         ObjRelease(AssocHandler)
      RecommendedHandlers := []
      OtherHandlers := []
      Return
   }
   ; -------------------------------------------------------------------------------------------------------------------------------
   ; User call
   If !FileExist(FilePath)
      Return 0

   ThisMenuName := MenuName
   ThisOthers := Others
   SplitPath, FilePath, , , Ext
   For Each, AssocHandler In RecommendedHandlers
      ObjRelease(AssocHandler)
   For Each, AssocHandler In OtherHandlers
      ObjRelease(AssocHandler)
   RecommendedHandlers:= []
   OtherHandlers:= []
   Try Menu, %ThisMenuName%, DeleteAll
   Try Menu, %ThisOthers%, DeleteAll
   ; Try to get the default association
   Size := VarSetCapacity(FriendlyName, 520, 0) // 2
   DllCall("Shlwapi.dll\AssocQueryString", "UInt", 0, "UInt", 4, "Str", "." . Ext, "Ptr", 0, "Str", FriendlyName, "UIntP", Size)
   HandlerID := A_TickCount
   HandlerFunc := Func(A_ThisFunc).Bind(FilePath, HandlerID)
   Filter := !!Recommended ; ASSOC_FILTER_NONE = 0, ASSOC_FILTER_RECOMMENDED = 1
   ; Enumerate the apps and build the menu
   If DllCall("Shell32.dll\SHAssocEnumHandlers", "WStr", "." . Ext, "UInt", Filter, "PtrP", EnumHandler)
      Return 0

   EnumHandlerNext := NumGet(NumGet(EnumHandler + 0, "UPtr"), A_PtrSize * 3, "UPtr")
   While (!DllCall(EnumHandlerNext, "Ptr", EnumHandler, "UInt", 1, "PtrP", AssocHandler, "UIntP", Fetched) && Fetched)
   {
      VTBL := NumGet(AssocHandler + 0, "UPtr")
      AssocHandlerGetUIName := NumGet(VTBL + 0, A_PtrSize * 4, "UPtr")
      AssocHandlerGetIconLocation := NumGet(VTBL + 0, A_PtrSize * 5, "UPtr")
      AssocHandlerIsRecommended := NumGet(VTBL + 0, A_PtrSize * 6, "UPtr")
      UIName := ""
      If !DllCall(AssocHandlerGetUIName, "Ptr", AssocHandler, "PtrP", StrPtr, "UInt")
      {
         UIName := StrGet(StrPtr, "UTF-16")
         DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
      } Else UIName := AssocHandler

      If (UIName!="")
      {
         If !DllCall(AssocHandlerGetIconLocation, "Ptr", AssocHandler, "PtrP", StrPtr, "IntP", IconIndex := 0, "UInt")
         {
            IconPath := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         If (SubStr(IconPath, 1, 1) = "@")
         {
            VarSetCapacity(Resource, 4096, 0)
            If !DllCall("Shlwapi.dll\SHLoadIndirectString", "WStr", IconPath, "Ptr", &Resource, "UInt", 2048, "PtrP", 0)
               IconPath := StrGet(&Resource, "UTF-16")
         }
         ItemName := StrReplace(UIName, "&", "&&")
         If (Recommended || !DllCall(AssocHandlerIsRecommended, "Ptr", AssocHandler, "UInt"))
         {
            If (UIName=FriendlyName)
            {
               If RecommendedHandlers.Count()
               {
                  Menu, %ThisMenuName%, Insert, 1&, %ItemName%, % HandlerFunc
                  RecommendedHandlers.InsertAt(1, AssocHandler)
               } Else
               {
                  Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
                  RecommendedHandlers.Push(AssocHandler)
               }
         ;      Menu, %ThisMenuName%, Default, %ItemName%
            } Else
            {
               Menu, %ThisMenuName%, Add, %ItemName%, % HandlerFunc
               RecommendedHandlers.Push(AssocHandler)
            }
            Try Menu, %ThisMenuName%, Icon, %ItemName%, %IconPath%, %IconIndex%
         } Else
         {
            Menu, %ThisOthers%, Add, %ItemName%, % HandlerFunc
            OtherHandlers.Push(AssocHandler)
            Try Menu, %ThisOthers%, Icon, %ItemName%, %IconPath%, %IconIndex%
         }
      } Else ObjRelease(AssocHandler)
   }

   ObjRelease(EnumHandler)
   ; All done
   If !RecommendedHandlers.Count() && !OtherHandlers.Count()
      Return 0

   If OtherHandlers.Count()
      Menu, %ThisMenuName%, Add, %ThisOthers%, :%ThisOthers%

   If (ShowMenu=1)
      Menu, %ThisMenuName%, Show
   Else
      Return ThisMenuName
}

invokeSHopenWith() {
; function by zcooler
; source:  https://www.autohotkey.com/boards/viewtopic.php?t=17850

  ; msdn.microsoft.com/en-us/library/windows/desktop/bb762234(v=vs.85).aspx
  ; OAIF_ALLOW_REGISTRATION   0x00000001 - Enable the "always use this program" checkbox. If not passed, it will be disabled.
  ; OAIF_REGISTER_EXT         0x00000002 - Do the registration after the user hits the OK button.
  ; OAIF_EXEC                 0x00000004 - Execute file after registering.
  OAIF := {ALLOW_REGISTRATION: 0x00000001, REGISTER_EXT: 0x00000002, EXEC: 0x00000004}
  imgPath := getIDimage(currentFileIndex)
  VarSetCapacity(OPENASINFO, A_PtrSize * 3, 0)
  NumPut(&imgPath, OPENASINFO, 0, "Ptr")
  NumPut(0x04, OPENASINFO, A_PtrSize * 2, "UInt")
  DllCall("Shell32.dll\SHOpenWithDialog", "Ptr", 0, "Ptr", &OPENASINFO)
}

ReadSettingsAutoCropPanel() {
    IniRead, tstAutoCropAdaptiveMode, % mainSettingsFile, General, AutoCropAdaptiveMode, @
    IniRead, tstResizeDestFolder, % mainSettingsFile, General, ResizeDestFolder, @
    IniRead, tstResizeUseDestDir, % mainSettingsFile, General, ResizeUseDestDir, @
    IniRead, tstUIcropThreshold, % mainSettingsFile, General, UIcropThreshold, @
    IniRead, tstuserActionConflictingFile, % mainSettingsFile, General, userActionConflictingFile, @
    IniRead, tstuserJpegQuality, % mainSettingsFile, General, userJpegQuality, @
    IniRead, tstusrAutoCropColorTolerance, % mainSettingsFile, General, usrAutoCropColorTolerance, @
    IniRead, tstusrAutoCropDeviation, % mainSettingsFile, General, usrAutoCropDeviation, @
    IniRead, tstusrAutoCropDeviationPixels, % mainSettingsFile, General, usrAutoCropDeviationPixels, @
    IniRead, tstusrAutoCropDeviationSnap, % mainSettingsFile, General, usrAutoCropDeviationSnap, @
    IniRead, tstusrAutoCropGenerateSelection, % mainSettingsFile, General, usrAutoCropGenerateSelection, @

    If IsNumber(tstusrAutoCropColorTolerance)
       usrAutoCropColorTolerance := clampInRange(tstusrAutoCropColorTolerance, 0, 255)
    If IsNumber(tstusrAutoCropDeviation)
       usrAutoCropDeviation := clampInRange(tstusrAutoCropDeviation, -50, 50)
    If IsNumber(tstUIcropThreshold)
       UIcropThreshold := clampInRange(tstUIcropThreshold, 0, 99)
    If (tstuserJpegQuality!="@")
       userJpegQuality := clampInRange(tstuserJpegQuality, 1, 100)
    If (StrLen(tstResizeDestFolder)>3)
       ResizeDestFolder := tstResizeDestFolder
    If (tstResizeUseDestDir=1 || tstResizeUseDestDir=0)
       ResizeUseDestDir := tstResizeUseDestDir
    If (isInRange(tstuserActionConflictingFile, 1, 3) && tstuserActionConflictingFile!="@")
       userActionConflictingFile := tstuserActionConflictingFile
    If (tstAutoCropAdaptiveMode=1 || tstAutoCropAdaptiveMode=0)
       AutoCropAdaptiveMode := tstAutoCropAdaptiveMode
    If (tstusrAutoCropGenerateSelection=1 || tstusrAutoCropGenerateSelection=0)
       usrAutoCropGenerateSelection := tstusrAutoCropGenerateSelection
    If (tstusrAutoCropDeviationSnap=1 || tstusrAutoCropDeviationSnap=0)
       usrAutoCropDeviationSnap := tstusrAutoCropDeviationSnap
    If (tstusrAutoCropDeviationPixels=1 || tstusrAutoCropDeviationPixels=0)
       usrAutoCropDeviationPixels := tstusrAutoCropDeviationPixels
}

PanelImgAutoCrop() {
    Global UIcropThreshold, btnFldr, infoCropTolerance, infoCropThreshold, infoCropDeviation, mainBtnACT, editF5
    If (thumbsDisplaying=1)
       ToggleThumbsMode()

    If (vpIMGrotation>0)
    {
       vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    }

    thisBtnHeight := createSettingsGUI(17, A_ThisFunc)
    btnWid := 100
    txtWid := slideWid := 280
    slide2Wid := 220

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       slide2Wid := slide2Wid + 75
       Gui, Font, s%LargeUIfontValue%
    }

    ReadSettingsAutoCropPanel()
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    filesElected := getSelectedFiles(0, 1)
    UIcropThreshold := Round(usrAutoCropImgThreshold * 100)
    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       usrAutoCropGenerateSelection := 1

    Gui, Add, Text, x15 y15 Section, Please adjust the following parameters for best results.
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    Gui, Add, Text, x+1 yp, Image corners preview
    Gui, -DPIScale
    Gui, Add, Text, xp+1 y+1 w220 h220 +0xE gTglAutoCropBorderzSize +hwndhCropCornersPic, -
    Gui, +DPIScale
    Gui, Add, Slider, xs yp+1 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropColorTolerance Range0-254, % usrAutoCropColorTolerance
    Gui, Add, Text, xs y+8 w%slide2Wid% vinfoCropThreshold, Image threshold: %UIcropThreshold%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vUIcropThreshold Range0-99, % UIcropThreshold
    Gui, Add, Text, xs y+8 w%slide2Wid% gresetAutoCropDeviation vinfoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    Gui, Add, Slider, xs y+5 AltSubmit NoTicks gUpdateAutoCropParams ToolTip w%slide2Wid% vusrAutoCropDeviation Range-50-50, %usrAutoCropDeviation%

    Gui, Add, Checkbox, y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropDeviationSnap% vusrAutoCropDeviationSnap, Snap to original image edges
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%usrAutoCropDeviationPixels% vusrAutoCropDeviationPixels, Deviation factor in pixels
    Gui, Add, Checkbox, xs y+10 w%slide2Wid% gUpdateAutoCropParams Checked%usrAutoCropGenerateSelection% vusrAutoCropGenerateSelection, Generate an image selection
    Gui, Add, Checkbox, x+1 gUpdateAutoCropParams Checked%AutoCropAdaptiveMode% vAutoCropAdaptiveMode, Adaptive color variations
 
    thisW := (filesElected>1) ? "" : "w1"
    thisH := (filesElected>1) ? "" : "h1"
    thisY := (filesElected>1) ? "+20" : "p-20"
    Gui, Add, Checkbox, xs y+10 gTglRszDestFoldr %thisW% %thisH% Checked%ResizeUseDestDir% vResizeUseDestDir, Save file[s] in the specified destination folder: 
    Gui, Add, Edit, xp+10 y+5 wp %thisH% r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 %thisW% %thisH% gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs y+7 %thisW% %thisH%, On file name conflicts
    Gui, Add, DropDownList, x+5 w150 %thisW% %thisH% gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite
    Gui, Add, Text, xs y+10 %thisW% %thisH%, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 %thisH% number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    if (StrLen(UserMemBMP)>2 && !markedSelectFile)
       GuiControl, Disable, usrAutoCropGenerateSelection

    If (filesElected>1)
    {
       Gui, Font, Bold
       Gui, Add, Text, xs y+15 Section, Files selected to process: %filesElected%.`nMulti-threaded processing not yet implemented.`nFiles in unsupported write formats will be skipped.
       Gui, Font, Normal
    } 

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    Gui, Add, Button, xs y%thisY% h%thisBtnHeight% w35 gBtnPrevImg, <<
    Gui, Add, Button, x+5 hp wp gBtnNextImg, >>

    If (filesElected>1)
    {
       Gui, Add, Button, x+5 hp w%btnWid% Default gBTNautoCropRealtime vmainBtnACT, &Viewport preview
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Process files...
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&ancel
    } Else
    {
       Gui, Add, Button, x+5 hp w90 Default gBTNautoCropRealtime vmainBtnACT, &Apply
       Gui, Add, Button, x+5 hp w%btnWid% gBTNsaveAutoCroppedFile, &Save image
       Gui, Add, Button, x+5 hp w90 gBtnCloseWindow, C&lose
    }

    winPos := (prevSetWinPosY && prevSetWinPosX && thumbsDisplaying!=1) ? " x" prevSetWinPosX " y" prevSetWinPosY : ""
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Automatic image crop: " appTitle, winPos)
    Sleep, 1
    captureImgCorners(useGdiBitmap())
    ResetImgLoadStatus()
}

resetAutoCropDeviation() {
    GuiControl, SettingsGUIA:, usrAutoCropDeviation, 0
    UpdateAutoCropParams()
}

UpdateAutoCropParams() {
    GuiControlGet, UIcropThreshold
    GuiControlGet, usrAutoCropColorTolerance
    GuiControlGet, usrAutoCropGenerateSelection
    GuiControlGet, usrAutoCropDeviation
    GuiControlGet, usrAutoCropDeviationSnap
    GuiControlGet, usrAutoCropDeviationPixels
    GuiControlGet, AutoCropAdaptiveMode
    GuiControlGet, ResizeUseDestDir
    GuiControlGet, ResizeDestFolder
    GuiControlGet, userActionConflictingFile
    GuiControlGet, userJpegQuality

    usrAutoCropImgThreshold := UIcropThreshold/100
    measureUnit := (usrAutoCropDeviationPixels=1) ? " px" : " %"
    GuiControl, SettingsGUIA:, infoCropTolerance, Color variation tolerance: %usrAutoCropColorTolerance%
    GuiControl, SettingsGUIA:, infoCropThreshold, Image threshold: %UIcropThreshold%
    GuiControl, SettingsGUIA:, infoCropDeviation, Margins deviation factor: %usrAutoCropDeviation%%measureUnit%
    SetTimer, WriteSettingsAutoCropPanel, -200
}

WriteSettingsAutoCropPanel() {
   INIaction(1, "ResizeUseDestDir", "General")
   INIaction(1, "ResizeDestFolder", "General")
   INIaction(1, "AutoCropAdaptiveMode", "General")
   INIaction(1, "usrAutoCropDeviationPixels", "General")
   INIaction(1, "usrAutoCropDeviationSnap", "General")
   INIaction(1, "usrAutoCropDeviation", "General")
   INIaction(1, "usrAutoCropGenerateSelection", "General")
   INIaction(1, "usrAutoCropColorTolerance", "General")
   INIaction(1, "UIcropThreshold", "General")
   INIaction(1, "userJpegQuality", "General")
   INIaction(1, "userActionConflictingFile", "General")
}

TglAutoCropBorderzSize() {
    Static lastInvoked := 1
    If (A_TickCount - lastInvoked < 900) && (AutoCropBordersSize!=5)
       AutoCropBordersSize := 5
    Else
       AutoCropBordersSize := (AutoCropBordersSize=15) ? 30 : 15
    captureImgCorners(useGdiBitmap())
    lastInvoked := A_TickCount
}

captureImgCorners(whichBmp) {
   If !whichBmp
      Return

   cornersBMP2 := coreCaptureImgCorners(whichBmp)
   hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, cornersBMP2)
   SetImage(hCropCornersPic, hBitmap)
   trGdip_DisposeImage(cornersBMP2, 1)
   Gdi_DeleteObject(hBitmap)
}

coreCaptureImgCorners(whichBmp, thisSize:=0, thisBoxSize:=0) {
    boxSize := (thisBoxSize=0) ? 220 : thisBoxSize
    realSize := (thisSize=0) ? AutoCropBordersSize : thisSize
    cornersBMP := trGdip_CreateBitmap(A_ThisFunc, boxSize, boxSize, "0xE200B")
    If !cornersBMP
       Return

    G := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP, 3)
    If !G
    {
       trGdip_DisposeImage(cornersBMP, 1)
       Return
    }

    Gdip_GetImageDimensions(whichBmp, imgW, imgH)
    If (editingSelectionNow=1)
    {
       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
    } Else
    {
       X1 := Y1 := 0
       X2 := ImgSelW := imgW
       Y2 := ImgSelH := imgH
    }

    Loop, 3
    {
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, 0, boxSize//2, boxSize//2, X1, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, 0, boxSize//2, boxSize//2, X2 - realSize, Y1, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, 0, boxSize//2, boxSize//2, boxSize//2, X1, Y2 - realSize, realSize, realSize)
        r1 := trGdip_DrawImage(A_ThisFunc, G, whichBmp, boxSize//2, boxSize//2, boxSize//2, boxSize//2, X2 - realSize, Y2 - realSize, realSize, realSize)
    }

    Static borderSize := 8
    Gdip_DeleteGraphics(G)
    cornersBMP2 := trGdip_CreateBitmap(A_ThisFunc, boxSize+borderSize, boxSize+borderSize, "0xE200B")
    If cornersBMP2
    {
       G2 := trGdip_GraphicsFromImage(A_ThisFunc, cornersBMP2, 3)
       If G2
       {
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          Gdip_FillRectangle(G2, pBrushE, 0, 0, boxSize*2, boxSize*2)
          r1 := trGdip_DrawImage(A_ThisFunc, G2, cornersBMP, borderSize//2, borderSize//2)
       }
    }

    Gdip_DeleteGraphics(G2)
    trGdip_DisposeImage(cornersBMP, 1)
    Return cornersBMP2
}

AutoCropAction(zBitmap, varTolerance, threshold, silentMode:=0, forceNoSel:=0) {
   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... step 0", 0, 0, 0.001)

   aBitmap := trGdip_BitmapConvertGray(zBitmap)
   If !aBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping...")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   Gdip_GetImageDimensions(aBitmap, Width, Height)
   pBitmap := trGdip_ResizeBitmap(A_ThisFunc, aBitmap, Width//2, Height//2, 0)
   trGdip_DisposeImage(aBitmap, 1)
   If !pBitmap
   {
      If (silentMode=0)
      {
         showTOOLtip("Failed to process image for auto-cropping...")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   ; pBitmap := aBitmap
   alphaUniform := Gdip_TestBitmapUniformity(pBitmap, 3, maxLevelIndex, maxLevelPixels)
   If (alphaUniform=1)
   {
      If (silentMode=0)
      {
         showTOOLtip("The image seems to be uniformly colored...")
         SoundBeep, 900, 100
         SetTimer, RemoveTooltip, -900
      }
      Return
   }

   selCoords := CoreAutoCropAlgo(pBitmap, varTolerance, threshold)
   trGdip_DisposeImage(pBitmap, 1)
   If (selCoords="error")
   {
      SoundBeep, 300, 100
      showTOOLtip("Auto-crop processing aborted by user...")
      SetTimer, RemoveTooltip, % -msgDisplayTime
      Return
   }

   selCoords := StrSplit(selCoords, ",")
   X1 := selCoords[1], Y1 := selCoords[2]
   X2 := selCoords[3], Y2 := selCoords[4]

   If (silentMode=0)
   {
      SoundBeep, 900, 100
      SetTimer, RemoveTooltip, -500
   }

   If (usrAutoCropGenerateSelection=0 || forceNoSel=1)
   {
      newW := X2 - X1
      newH := Y2 - Y1
      kBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, zBitmap, X1, Y1, newW, newH)
      return kBitmap
   } Else
   {
      vPselRotation := EllipseSelectMode := 0
      ImgSelX1 := X1, ImgSelY1 := Y1
      ImgSelX2 := X2, ImgSelY2 := Y2
      defineRelativeSelCoords(Width, Height)
   }
}

CoreAutoCropAlgo(pBitmap, varTolerance, threshold, silentMode:=0) {
   If !pBitmap
   {
      addJournalEntry(A_ThisFunc "(): no bitmap given for auto-cropping...")
      Return "error"
   }

   interfaceThread.ahkassign("canCancelImageLoad", 1)
   Gdip_GetImageDimensions(pBitmap, Width, Height)
   maxThresholdHitsW := Round(Width*threshold) + 1
   If (maxThresholdHitsW>Width//2)
      maxThresholdHitsW := Width//2

   maxThresholdHitsH := Round(Height*threshold) + 1
   If (maxThresholdHitsH>Height//2)
      maxThresholdHitsH := Height//2

   If (threshold=0)
      maxThresholdHitsW := maxThresholdHitsH := 1

   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E1
      Return "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... step 1 - Y1", 0, 0, 0.1)

   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := abortImgLoad := 0
   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
     ;  sleep, 10
      ;    ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW " [" varTolerance "]" "`n" firstR1 ", " primeR1a ", " primeR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.2, R1 + varTolerance//1.2) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y1
      {
         Y1 := y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... step 2 - X1", 0, 0, 0.3)

   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X1 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X1
      {
         X1 := x - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... step 3 - Y2", 0, 0, 0.5)

   Gdip_UnlockBits(pBitmap, BitmapData1)
   Gdip_ImageRotateFlip(pBitmap, 2)
   c := Gdip_GetPixelColor(pBitmap, 1, 1, 2)
   c := StrSplit(c, ",")
   prevR1 := firstR1 := c[1]
   x := y := ToleranceHits := 0
   E2 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
   If E2
      Return "error"

   Loop %Height%
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      y++
      vX := 0, vY := y - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vX := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Width%
      {
         pX := A_Index-1, pY := y - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsW "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsW)
         {
            ToleranceHits++
         } Else
         {
            Y2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If Y2
      {
         Y2 := Height - y - 1
         Break
      }
   }

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... step 4 - X2", 0, 0, 0.8)
   prevR1 := firstR1
   x := y := ToleranceHits := 0
   Loop %Width% 
   {
      If (AnyWindowOpen>0)
         abortImgLoad := interfaceThread.ahkgetvar.canCancelImageLoad
      If (abortImgLoad>1)
         Break

      x++
      vY := 0, vX := x - 1
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1a, G1, B1)
      vY := 2
      Gdip_FromARGB(NumGet(Scan01+0, (vX*4)+(vY*Stride1), "UInt"), A1, primeR1b, G1, B1)
      primeR1 := Round((primeR1a + primeR1b)/2)
      Loop %Height%
      {
         pY := A_Index-1, pX := x - 1
         R1 := Gdip_RFromARGB(NumGet(Scan01+0, (pX*4)+(pY*Stride1), "UInt"))
         ; ToolTip, % px ", " py "`n" ToleranceHits "," maxThresholdHitsH "`n" prevR1 ", " R1,,, 2
         If (isInRange(primeR1a, R1 - varTolerance//10, R1 + varTolerance//10) || isInRange(primeR1, R1 - varTolerance, R1 + varTolerance))
         || (isInRange(prevR1, R1 - varTolerance//1.5, R1 + varTolerance//1.5) && AutoCropAdaptiveMode=1)
         {
            prevR1 := R1
         } Else If (ToleranceHits<maxThresholdHitsH)
         {
            ToleranceHits++
         } Else
         {
            X2 := "ok"
            Break
         }
      }
      ToleranceHits := 0
      If X2
      {
         X2 := Width - x - 1
         Break
      }
   }

   deviationW := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Width/100)*usrAutoCropDeviation)
   deviationH := (usrAutoCropDeviationPixels=1) ? usrAutoCropDeviation : Round((Height/100)*usrAutoCropDeviation)
   If (usrAutoCropDeviationSnap=1 && X1>2) || (usrAutoCropDeviationSnap=0)
      X1 -= deviationW
   If (usrAutoCropDeviationSnap=1 && Y1>2) || (usrAutoCropDeviationSnap=0)
      Y1 -= deviationH
   If (usrAutoCropDeviationSnap=1 && X2<Width-3) || (usrAutoCropDeviationSnap=0)
      X2 += deviationW
   If (usrAutoCropDeviationSnap=1 && Y2<Height-3) || (usrAutoCropDeviationSnap=0)
      Y2 += deviationH

   ; ToolTip, % X1 "," Y1 "--" X2 "," Y2 "`n" maxThresholdHitsW "--" maxThresholdHitsH "--" firstR1, , , 2
   If (X1="" || X1>Width - 2)
      X1 := Width - 3
   If (Y1="" || Y1>Height - 2)
      Y1 := Height - 3
   If (X2="" || X2<3)
      X2 := 3
   If (Y2="" || Y2<3)
      Y2 := 3

   X2 := X2*2, Y2 := Y2*2
   X1 := X1*2, Y1 := Y1*2
   If (X2 < X1 - 2)
      X2 := X1 + 2
   If (Y2 < Y1 - 2)
      Y2 := Y1 + 2

   selCoords := x1 "," y1 "," x2 "," y2
   Gdip_UnlockBits(pBitmap, BitmapData1)
   If (abortImgLoad>1)
      selCoords := "error"

   If (silentMode=0)
      showTOOLtip("Calculating auto-cropped region... DONE", 0, 0, 0.99)
   interfaceThread.ahkassign("canCancelImageLoad", 0)
   Return selCoords
}

BTNsaveAutoCroppedFile() {
    UpdateAutoCropParams()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       batchAutoCropFiles()
       Return
    }

   BTNautoCropRealtime()
   CloseWindow("yes")
   PanelSaveImg()
}

coreAutoCropFileProcessing(imgPath, file2save, silentMode) {
    oBitmap := LoadBitmapFromFileu(imgPath)
    If !oBitmap
       Return -3

    Gdip_GetImageDimensions(oBitmap, oImgW, oImgH)
    pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    kBitmap := AutoCropAction(oBitmap, usrAutoCropColorTolerance, usrAutoCropImgThreshold, silentMode, 1)
    trGdip_DisposeImage(oBitmap, 1)
    If !kBitmap
       Return -1

    Gdip_GetImageDimensions(kBitmap, imgW, imgH)
    If (imgW>oImgW-1) && (imgH>oImgH-1)
       Return -2

    If InStr(pixFmt, "argb")
    {
       isUniform := Gdip_TestBitmapUniformity(kBitmap, 7, maxLevelIndex)
       If (isUniform=1 && (isInRange(maxLevelIndex, 0, 5) || isInRange(maxLevelIndex, 250, 255)))
          Gdip_BitmapSetColorDepth(kBitmap, 24)
    } Else Gdip_BitmapSetColorDepth(kBitmap, 24)

    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 1
    }

    r := Gdip_SaveBitmapToFile(kBitmap, file2save, 90)
    If (r=-2 || r=-1)
       r := SaveFIMfile(file2save, kBitmap)

    trGdip_DisposeImage(kBitmap, 1)
    Return r
}

batchAutoCropFiles() {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to crop " filesElected " files? The auto-crop algorithm may take some time to finish going through all of them. Hold ESC to abandon it."
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"

      If (userActionConflictingFile=3)
         msgInfos .= "`n`nOn file name collision(s), destination file(s) will be OVERWRITTEN."

      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }

   CloseWindow("yes")
   Sleep, 25
   showTOOLtip("Performing image auto-crop on " filesElected " files, please wait...")
   prevMSGdisplay := A_TickCount
   doStartLongOpDance()
   countFilez := countTFilez := skippedFiles := failedFiles := 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      executingCanceableOperation := A_TickCount
      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      imgPath := StrReplace(imgPath, "||")
      If (A_TickCount - prevMSGdisplay>3000)
      {
         If failedFiles
            someErrors := "`nErrors occured for " failedFiles "files..."
         If skippedFiles
            someErrors .= "`n" skippedFiles "files were skipped"

         showTOOLtip("Performing image auto-crop on " countTFilez "/" filesElected " files, please wait..." someErrors, 0, 0, (countTFilez + skippedFiles)/filesElected)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (!RegExMatch(imgPath, saveTypesRegEX) || StrLen(imgPath)<2)
      {
         skippedFiles++
         Continue
      }

      If (ResizeUseDestDir=1)
      {
         zPlitPath(imgPath, 0, OutFileName, OutDir)
         destImgPath := ResizeDestFolder "\" OutFileName
      } Else destImgPath := imgPath

      If (ResizeUseDestDir=1)
      {
         If (FileExist(destImgPath) && !FolderExist(destImgPath))
            destImgPath := askAboutFileCollision(imgPath, destImgPath, 1, 0, userActionConflictingFile, performOverwrite)
      }

      countTFilez++
      If !destImgPath
      {
         skippedFiles++
         Continue
      }

      changeMcursor()
      r := coreAutoCropFileProcessing(imgPath, destImgPath, 0)
      If !r
         countFilez++
      Else
         failedFiles++
   }

   If failedFiles
      someErrors := "`nErrors occured for " failedFiles "files..."
   If skippedFiles
      someErrors .= "`n" skippedFiles "files were skipped"
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " countFilez " out of " filesElected " selected files were processed until now..." someErrors)
   Else
      showTOOLtip(countFilez " out of " countTFilez " selected images were automatically cropped" someErrors)
   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

BTNautoCropRealtime() {
  Static wasAutoCropped := 0

  GuiControl, SettingsGUIA: Disable, mainBtnACT
  SetTimer, reactivateMainBtnACT, -350
  If (AnyWindowOpen=17)
     UpdateAutoCropParams()
  Else If (AnyWindowOpen=12)
     usrAutoCropGenerateSelection := 1

  If (usrAutoCropGenerateSelection=0)
  {
     editingSelectionNow := 0
     wasAutoCropped := performAutoCropNow := 1
     updateUIctrl()
     RefreshImageFile()
     MouseMoveResponder()
  } Else
  {
     resultu := getIDimage(currentFileIndex)
     If FileExist(resultu)
     {
        thumbBMP := LoadBitmapFromFileu(resultu)
        FlipImgV := FlipImgH := vpIMGrotation := performAutoCropNow := 0
        If thumbBMP
        {
           AutoCropAction(thumbBMP, usrAutoCropColorTolerance, usrAutoCropImgThreshold)
           trGdip_DisposeImage(thumbBMP, 1)
        }

        editingSelectionNow := performAutoCropNow := 1
        If (wasAutoCropped=0)
           dummyTimerDelayiedImageDisplay(50)
        Else
           RefreshImageFile()
     }
  }

  If (AnyWindowOpen=17)
  {
     captureImgCorners(useGdiBitmap())
  } Else If (editingSelectionNow=1 && AnyWindowOpen=12)
  {
     GuiControl, SettingsGUIA: Enable, jpegDoCrop
     GuiControl, SettingsGUIA: , jpegDoCrop, 1
  }
}

coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   Try wiaImg := WIA_LoadImage(imgPath)
   If !IsObject(wiaImg)
   {
      addJournalEntry("Failed to load and process image file using WIA...`n" imgPath)
      Return 0
   }

   imgW := wiaImg.Width, imgH := wiaImg.Height
   If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
   {
      If (relativeImgSelCoords=1 && editingSelectionNow=1)
         calcRelativeSelCoords(oBitmap, imgW, imgH)

      calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
      wiaImg := WIA_CropImage(wiaImg, X1, Y1, X2, Y2)
   }

   If (rotateAngle!=0 && isNumber(rotateAngle))
      wiaImg := WIA_RotateImage(wiaImg, rotateAngle)

   If (SimpleOperationsFlipH=1)
      wiaImg := Wia_FlipImage(wiaImg, "Horizontal")
   If (SimpleOperationsFlipV=1)
      wiaImg := Wia_FlipImage(wiaImg, "Vertical")

   imgW := wiaImg.Width, imgH := wiaImg.Height
   thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
   thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
   changeMcursor()
   If (IsObject(wiaImg) && ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
      Try wiaImg := WIA_ScaleImage(wiaImg, thisW, thisH, 0)

    If (FileExist(file2save) && IsObject(wiaImg))
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    If IsObject(wiaImg)
       r := WIA_SaveImage(wiaImg, file2save)
    Else r := 0

    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       r := 0
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

   wiaImg := ""
   Return !r
}

coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Static imgOrientOpt := {"i000":0, "i100":1, "i200":2, "i300":3, "i010":4, "i110":5, "i210":6, "i310":7, "i001":6, "i101":7, "i201":4, "i301":5, "i011":2, "i111":3, "i211":0, "i311":1}
    oBitmap := trGdip_CreateBitmapFromFile(imgPath)
    If StrLen(oBitmap)>2
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       pixFmt := Gdip_GetImagePixelFormat(oBitmap, 2)
    } Else mustOpenWithWia := 1

    capMaxGDIbmpSize32bits()
    If (imgW<1) || (imgH<1) || InStr(pixFmt, "0x") || (imgW*imgH>maxGDIbmpSize - 10) || (imgW>32100) || (imgH>32100)
       mustOpenWithWia := 1

    If (mustOpenWithWia=1)
    {
       addJournalEntry("Failed to load and process image file using GDI+...`n" imgPath)
       trGdip_DisposeImage(oBitmap, 1)
       r := coreWIAsimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
       Return r
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords(oBitmap, imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       zBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc, oBitmap, imgSelPx, imgSelPy, imgSelW, imgSelH, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    imgFoperation := (rotateAngle=90) ? 1 : 0
    imgFoperation := (rotateAngle=180) ? 2 : imgFoperation
    imgFoperation := (rotateAngle=270) ? 3 : imgFoperation
    imgFoperation := imgOrientOpt["i" imgFoperation SimpleOperationsFlipH SimpleOperationsFlipV]
    If (imgFoperation>0)
       flipErr := Gdip_ImageRotateFlip(oBitmap, imgFoperation)

    If flipErr
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       Gdip_GetImageDimensions(oBitmap, imgW, imgH)
       newPixFmt := InStr(pixFmt, "argb") ? "0x26200A" : "0x21808"   ; 32-bits // 24-bits
       resizeFilter := (ResizeQualityHigh=1) ? 7 : 5
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       zBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, thisW, thisH, 0, resizeFilter, newPixFmt)
       If zBitmap
       {
          trGdip_DisposeImage(oBitmap, 1)
          oBitmap := zBitmap
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       trGdip_DisposeImage(oBitmap, 1)
       Return "err"
    }

    If StrLen(oBitmap)>2
    {
       tempFileExists := "r"
       If FileExist(file2save)
       {
          Try FileSetAttrib, -R, % file2save
          Sleep, 0
          FileMove, % file2save, % file2save "-tmp"
          If !ErrorLevel
             tempFileExists := 1
          Sleep, 0
       }

       r := Gdip_SaveBitmapToFile(oBitmap, file2save, 90)
       If (r=-2 || r=-1)
          r := SaveFIMfile(file2save, oBitmap)

       If (r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
       {
          FileDelete, % file2save
          Sleep, 0
          FileMove, % file2save "-tmp", % file2save
       } Else If (tempFileExists=1)
          FileDelete, % file2save "-tmp"

       trGdip_DisposeImage(oBitmap, 1)
    } Else r := 1

    Return r
}

coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
  If (RegExMatch(imgPath, RegExFIMformPtrn) || (RegExMatch(imgPath, "i)(.\.(png|tiff|tif))$") && (wasInitFIMlib=1)))
     r := coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Else
     r := coreGdipSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
  Return r
}

coreFreeImageSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor) {
    Sleep, 0
    loadArgs := 0
    GFT := FreeImage_GetFileType(imgPath)
    If (GFT=34)
       loadArgs := (userHQraw=1) ? 0 : 5
    Else If (GFT=2)
       loadArgs := 8

    hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs)
    If !hFIFimgA
    {
       addJournalEntry("Failed to load and process image file using FreeImage library...`n" imgPath)
       Return "err"
    }

    If (SimpleOperationsDoCrop=1 && editingSelectionNow=1)
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       If (relativeImgSelCoords=1 && editingSelectionNow=1)
          calcRelativeSelCoords("--", imgW, imgH)

       calcImgSelection2bmp(0, imgW, imgH, imgW, imgH, imgSelPx, imgSelPy, imgSelW, imgSelH, zImgSelPx, zImgSelPy, zImgSelW, zImgSelH, X1, Y1, X2, Y2)
       x1 := Round(X1), y1 := Round(Y1)
       x2 := Round(X2), y2 := Round(Y2)
       changeMcursor()
       hFIFimgB := FreeImage_Copy(hFIFimgA, X1, Y1, X2, Y2)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (rotateAngle>0)
    {
       changeMcursor()
       hFIFimgB := FreeImage_Rotate(hFIFimgA, rotateAngle)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    If (SimpleOperationsFlipH=1)
       FreeImage_FlipHorizontal(hFIFimgA)
    If (SimpleOperationsFlipV=1)
       FreeImage_FlipVertical(hFIFimgA)

    If (ResizeMustPerform=1 && XscaleImgFactor>0 && YscaleImgFactor>0 && (XscaleImgFactor!=1 || YscaleImgFactor!=1))
    {
       FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
       resizeFilter := (ResizeQualityHigh=1) ? 4 : 0
       thisW := (ResizeInPercentage=1) ? Round(imgW*XscaleImgFactor) : XscaleImgFactor
       thisH := (ResizeInPercentage=1) ? Round(imgH*YscaleImgFactor) : YscaleImgFactor
       changeMcursor()
       hFIFimgB := FreeImage_Rescale(hFIFimgA, thisW, thisH, resizeFilter)
       If hFIFimgB
       {
          FreeImage_UnLoad(hFIFimgA)
          hFIFimgA := hFIFimgB
       } Else hasFailed := 1
    }

    If (hasFailed=1)
    {
       FreeImage_UnLoad(hFIFimgA)
       Return "err"
    }

    tempFileExists := "r"
    If FileExist(file2save)
    {
       Try FileSetAttrib, -R, % file2save
       Sleep, 0
       FileMove, % file2save, % file2save "-tmp"
       If !ErrorLevel
          tempFileExists := 1
       Sleep, 0
    }

    saveArg := 0
    If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
       saveArg := clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
    Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
       saveArg := clampInRange(Round(userJpegQuality), 1, 100)

    changeMcursor()
    r := FreeImage_Save(hFIFimgA, file2save, saveArg)

    FreeImage_UnLoad(hFIFimgA)
    If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
    {
       FileDelete, % file2save
       Sleep, 0
       FileMove, % file2save "-tmp", % file2save
    } Else If (tempFileExists=1)
       FileDelete, % file2save "-tmp"

    Return !r
}

PanelSimpleResizeRotate(modus:="") {
    Global mainBtnACT, btnFldr, editF5
    If !PanelsCheckFileExists()
       Return

    If (vpIMGrotation>0)
    {
       FlipImgV := FlipImgH := vpIMGrotation := 0
       showTOOLtip("Image rotation: 0°")
       RefreshImageFile()
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Sleep, 250
    } Else If (FlipImgH=1 || FlipImgV=1)
    {
       FlipImgV := FlipImgH := 0
       dummyTimerDelayiedImageDisplay(50)
    } 

    imgPath := getIDimage(currentFileIndex)
    filesElected := getSelectedFiles(0, 1)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    If (!filesElected && !RegExMatch(imgPath, thisRegEX) && modus!="forced")
    {
       CloseWindow()
       Sleep, 5
       PanelResizeImageWindow()
       Return
    }

    thisBtnHeight := createSettingsGUI(18, A_ThisFunc)
    ReadSettingsImageProcessing()
    btnWid := 100
    txtWid := slideWid := 280
    If (editingSelectionNow!=1)
       SimpleOperationsDoCrop := 0

    If (PrefsLargeFonts=1)
    {
       slideWid := slideWid + 135
       btnWid := btnWid + 70
       txtWid := txtWid + 135
       Gui, Font, s%LargeUIfontValue%
    }
    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    Gui, Add, Text, x15 y15 Section, Rotate / flip:
    Gui, Add, DropDownList, x+5 w100 AltSubmit Choose%SimpleOperationsRotateAngle% vSimpleOperationsRotateAngle, 0°|90°|180°|-90° [270°]
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipV% vSimpleOperationsFlipV, Vertical
    Gui, Add, Checkbox, x+5 hp +0x1000 Checked%SimpleOperationsFlipH% vSimpleOperationsFlipH, Horizontal
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleXimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleXimgFactor%||
    ; Gui, Add, ComboBox, x+5 w100 vSimpleOperationsScaleYimgFactor, 5 `%|10 `%|20 `%|50 `%|75 `%|100 `%|200 `%|500 `%|950 `%|%SimpleOperationsScaleYimgFactor%||
    Gui, Add, Checkbox, xs y+10 gTglRszMustPerformResize Checked%ResizeMustPerform% vResizeMustPerform, Perform image resizing (W x H):
    Gui, Add, Edit, xs+15 y+5 w100 r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleXimgFactor, % (ResizeInPercentage=1) ? 100 : oImgW
    Gui, Add, Edit, x+5 wp r1 limit9 -multi number -wantCtrlA -wantReturn -wantTab -wrap vSimpleOperationsScaleYimgFactor, % (ResizeInPercentage=1) ? 100 : oImgH
    Gui, Add, Checkbox, x+5 wp+30 hp gTglRszInPercentage Checked%ResizeInPercentage% vResizeInPercentage, in `% perc.
    Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsDoCrop% vSimpleOperationsDoCrop, Crop image(s) to selected area in viewport
    Gui, Add, Checkbox, xs y+10 Checked%ResizeQualityHigh% vResizeQualityHigh, High quality image resampling
    Gui, Add, Checkbox, xs y+15 gTglRszDestFoldr Checked%ResizeUseDestDir% vResizeUseDestDir, Save file(s) in the specified destination folder:
    Gui, Add, Edit, xp+15 y+5 wp r1 +0x0800 -wrap vResizeDestFolder, % ResizeDestFolder
    Gui, Add, Button, x+5 hp w90 gBTNchangeResizeDestFolder vbtnFldr, C&hoose
    Gui, Add, Text, xs+15 y+7 , In destination folder, on file name conflicts
    Gui, Add, DropDownList, x+5 w140 gTglOverwriteFiles AltSubmit Choose%userActionConflictingFile% vuserActionConflictingFile, Skip files|Auto-rename|Overwrite

    Gui, Add, Text, xs y+10, Quality (1`% - 100`%):
    Gui, Add, Edit, x+5 w70 number -multi limit3 veditF5, % userJpegQuality
    Gui, Add, UpDown, vuserJpegQuality Range1-100, % userJpegQuality

    If !ResizeUseDestDir
    {
       GuiControl, Disable, btnFldr
       GuiControl, Disable, ResizeDestFolder
    }

    ; Gui, Add, Checkbox, xs y+10 Checked%SimpleOperationsNoPromptOnSave% vSimpleOperationsNoPromptOnSave, Do not prompt on file save
    If (editingSelectionNow!=1)
       GuiControl, Disable, SimpleOperationsDoCrop

    If (filesElected>1)
    {
       msgFriendly := filesElected " files are selected for processing."
       Gui, Font, Bold
       Gui, Add, Text, xs y+20 w%txtWid%, % msgFriendly
       Gui, Font, Normal
       Gui, Add, Text, xs y+10 w%txtWid%, Files in unsupported write formats will be skipped.
    }

    If (filesElected<2)
    {
       Gui, Add, Button, xs+0 y+25 h%thisBtnHeight% w35 gPreviousPicture, <<
       Gui, Add, Button, x+5 hp wp gNextPicture, >>
       ; Gui, Add, Button, x+5 hp w%btnWid%  gBtnSaveNowSimpleProcessing , &Save image
       Gui, Add, Button, x+5 hp w%btnWid% Default gBtnSaveAsSimpleProcessing vmainBtnACT, &Save image as...
    } Else Gui, Add, Button, xs+0 y+20 h%thisBtnHeight% wp Default gBtnPerformSimpleProcessing, &Perform operations on the files

    Gui, Add, Button, xs y+5 h%thisBtnHeight% w%btnWid% gBtnInvokePanelResizeImageWindow, &Advanced mode
    Gui, Add, Button, x+5 hp w80 gResizePanelHelpBoxInfo, &Help
    Gui, Add, Button, x+5 hp wp gBtnCloseWindow, &Cancel
    repositionWindowCenter("SettingsGUIA", hSetWinGui, PVhwnd, "Resize / crop / rotate image [simple mode]: " appTitle)
    ResetImgLoadStatus()
    SetTimer, TglRszMustPerformResize, -300
}

BtnInvokePanelResizeImageWindow() {
   CloseWindow("yes")
   Sleep, 10
   PanelResizeImageWindow()
}

BtnSaveAsSimpleProcessing() {
    SimpleOperationsNoPromptOnSave := 0
    BtnPerformSimpleProcessing()
}

BtnSaveNowSimpleProcessing() {
    SimpleOperationsNoPromptOnSave := 1
    BtnPerformSimpleProcessing()
}

TglRszMustPerformResize() {
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
    If (ResizeMustPerform!=1)
    {
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Disable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Disable, ResizeInPercentage
    } Else
    {
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleXimgFactor
       GuiControl, SettingsGUIA: Enable, SimpleOperationsScaleYimgFactor
       GuiControl, SettingsGUIA: Enable, ResizeInPercentage
    }
}

BtnPerformSimpleProcessing() {
    GuiControlGet, ResizeMustPerform, SettingsGUIA:, ResizeMustPerform
    GuiControlGet, SimpleOperationsFlipV, SettingsGUIA:, SimpleOperationsFlipV
    GuiControlGet, SimpleOperationsFlipH, SettingsGUIA:, SimpleOperationsFlipH
    GuiControlGet, SimpleOperationsDoCrop, SettingsGUIA:, SimpleOperationsDoCrop
    GuiControlGet, SimpleOperationsRotateAngle, SettingsGUIA:, SimpleOperationsRotateAngle
    GuiControlGet, SimpleOperationsScaleXimgFactor, SettingsGUIA:, SimpleOperationsScaleXimgFactor
    GuiControlGet, SimpleOperationsScaleYimgFactor, SettingsGUIA:, SimpleOperationsScaleYimgFactor
    GuiControlGet, ResizeQualityHigh, SettingsGUIA:, ResizeQualityHigh
    GuiControlGet, ResizeDestFolder, SettingsGUIA:, ResizeDestFolder
    GuiControlGet, ResizeUseDestDir, SettingsGUIA:, ResizeUseDestDir
    GuiControlGet, ResizeInPercentage, SettingsGUIA:, ResizeInPercentage
    GuiControlGet, userJpegQuality, SettingsGUIA:, userJpegQuality
    GuiControlGet, userActionConflictingFile, SettingsGUIA:, userActionConflictingFile

    userJpegQuality := clampInRange(userJpegQuality, 1, 100)
    INIaction(1, "userJpegQuality", "General")
    cleanResizeUserOptionsVars()
    If (ResizeMustPerform=0 && SimpleOperationsRotateAngle=1 && SimpleOperationsFlipV=0 && SimpleOperationsFlipH=0 && SimpleOperationsDoCrop=0)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": WARNING", "No image transformations selected or activated to perform...", 0, 0, "exclamation")
       Return
    }

    If ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
    || SimpleOperationsScaleXimgFactor<5 || SimpleOperationsScaleYimgFactor<5) && (ResizeMustPerform=1 && ResizeInPercentage=0))
    || ((!SimpleOperationsScaleXimgFactor || !SimpleOperationsScaleYimgFactor
    || SimpleOperationsScaleXimgFactor<1 || SimpleOperationsScaleYimgFactor<1) && (ResizeMustPerform=1 && ResizeInPercentage=1))
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "Incorrect image dimensions given. Increase the values, please.", 0, 0, "error")
       Return
    }
 
    initFIMGmodule()
    filesElected := getSelectedFiles(0, 1)
    If (filesElected>1)
    {
       WriteSettingsResizeSimplePanel()
       batchSimpleProcessing(simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
       Return
    }

    Gdip_GetImageDimensions(useGdiBitmap(), oImgW, oImgH)
    oImgW := (ResizeInPercentage=1) ? Round(oImgW*(SimpleOperationsScaleXimgFactor/100)) : SimpleOperationsScaleXimgFactor
    oImgH := (ResizeInPercentage=1) ? Round(oImgH*(SimpleOperationsScaleYimgFactor/100)) : SimpleOperationsScaleYimgFactor
    newImgSize := oImgH*oImgW
    If ((newImgSize>536848912) || (oImgW>32100) || (oImgH>32100) && ResizeMustPerform=1)
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": WARNING", "The resulting image dimensions are very large... the resizing might fail, depending on the file format.`n`nW x H: " oImgW " x " oImgH " pixels.", 0, 0, "Exclamation")
    }

    imgPath := getIDimage(currentFileIndex)
    thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
    zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
    If (!filesElected && !RegExMatch(imgPath, thisRegEX))
    {
       SoundBeep, 300, 100
       msgBoxWrapper(appTitle ": ERROR", "This file format (." oExt ") cannot be processed in «Simple mode». Please use the «Advanced mode» which allows file format conversions.", 0, 0, "exclamation")
       Return
    }

   startPath := (ResizeUseDestDir=1) ? ResizeDestFolder "\" OutFileName : imgPath
   If (SimpleOperationsNoPromptOnSave=1)
      file2save := imgPath
   Else
      file2save := openFileDialogWrapper("S", "FileMustExist", startPath, "Save processed image as...", oExt " images (*." oExt ")")

   If file2save
   {
      zPlitPath(imgPath, 0, OutFileName, OutDir, OutNameNoExt, oExt)
      zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
      If !nExt
         file2save .= "." oExt

      If !RegExMatch(file2save, thisRegEX)
      {
         SoundBeep, 300, 100
         If (SimpleOperationsNoPromptOnSave!=1)
            msgBoxWrapper(appTitle ": ERROR", "Please save the file using one of the supported file format extensions: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Else
            msgBoxWrapper(appTitle ": ERROR", "Unsupported file write format. Please use one of the allowed image file formats: .EXR, .HDR, .PFM, " saveTypesFriendly ". ", 0, 0, "error")
         Return
      }

      If (nExt!=oExt && StrLen(nExt)>0)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "You cannot change the image file format from ." oExt " to ." nExt ". If you want to do this, please use the «Advanced mode».", 0, 0, "exclamation")
         Return
      }

      If (!RegExMatch(file2save, "i)(.\.(bmp|png|tif|tiff|gif|jpg|jpeg))$") && wasInitFIMlib!=1)
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "This format is currently unsupported, because the FreeImage library failed to properly initialize.`n`n" OutFileName, 0, 0, "error")
         Return
      }

      If FileExist(file2save)
      {
         zPlitPath(file2save, 0, OutFileName, OutDir, OutNameNoExt, nExt)
         msgResult := msgBoxWrapper(appTitle ": Confirmation", "The selected file already exists. Do you want to overwrite the file?`n`n" OutFileName "`n`n" OutDir "\", 4, 0, "question")
         If (msgResult!="Yes")
            Return
      }

      destroyGDIfileCache()
      GuiControl, SettingsGUIA: Disable, mainBtnACT
      SetTimer, reactivateMainBtnACT, -950
      showTOOLtip("Processing image, please wait...")
      r := coreSimpleFileProcessing(imgPath, file2save, simpleOpRotationAngle, SimpleOperationsScaleXimgFactor/100, SimpleOperationsScaleYimgFactor/100)
      If r
      {
         SoundBeep, 300, 100
         msgBoxWrapper(appTitle ": ERROR", "Unable to save file... error code: " r ".`n`n" OutFileName "`n`n" OutDir "\", 0, 0, "error")
         SetTimer, RemoveTooltip, % -msgDisplayTime
         Return
      }

      SetTimer, WriteSettingsResizeSimplePanel, -90
      SoundBeep, 900, 100
      showTOOLtip("Processed image saved...")
      If (SimpleOperationsNoPromptOnSave=1)
         SetTimer, RefreshImageFile, -150
      SetTimer, RemoveTooltip, % -msgDisplayTime
   }
}

batchSimpleProcessing(rotateAngle, XscaleImgFactor, YscaleImgFactor) {
   filesElected := getSelectedFiles(0, 1)
   If (filesElected>50)
   {
      msgInfos := "Are you sure you want to process " filesElected " files?"
      If (ResizeUseDestDir=1)
         msgInfos .= "`n`nThe files will be saved in " ResizeDestFolder "\"
      Else
         msgInfos .= "`n`nThe files will be will be OVERWRITTEN."
      msgResult := msgBoxWrapper(appTitle ": Confirmation", msgInfos, 4, 0, "question")
      If (msgResult!="Yes")
         Return
   }
   CloseWindow("yes")
   backCurrentSLD := CurrentSLD
   setImageLoading()
   showTOOLtip("Processing " filesElected " images, please wait...")

   filesPerCore := filesElected//realSystemCores
   If (filesPerCore<2 && realSystemCores>1)
   {
      systemCores := filesElected//2
      filesPerCore := filesElected//systemCores
   } Else systemCores := realSystemCores

   destroyGDIfileCache()
   mustDoMultiCore := (allowMultiCoreMode=1 && systemCores>1 && filesPerCore>2) ? 1 : 0
   If (!FolderExist(ResizeDestFolder) && ResizeUseDestDir=1)
      FileCreateDir, % ResizeDestFolder

   If (mustDoMultiCore=1)
   {
      setPriorityThread(-2)
      infoResult := WorkLoadMultiCoresSimpleImgProcessing(filesElected)
      setPriorityThread(0)
      If (infoResult!="single-core")
         Return
   }

   If (infoResult="single-core")
      addJournalEntry("Image processing in batch: failed to initialize multi-threaded processing...")

   CurrentSLD := ""
   prevMSGdisplay := A_TickCount
   thisRegEX := StrReplace(saveTypesRegEX, "|xpm))$", "|hdr|exr|pfm|xpm))$")
   countTFilez := failedFiles := filesConverted := skippedFiles := 0
   doStartLongOpDance()
   startOperation := A_TickCount
   Loop, % maxFilesIndex
   {
      isSelected := resultedFilesList[A_Index, 2]
      If (isSelected!=1)
         Continue

      thisFileIndex := A_Index
      imgPath := getIDimage(thisFileIndex)
      If !RegExMatch(imgPath, thisRegEX)
      {
         skippedFiles++
         Continue
      }

      countTFilez++
      executingCanceableOperation := A_TickCount
      If (A_TickCount - prevMSGdisplay>3000)
      {
         zeitOperation := A_TickCount - startOperation
         percDone := " ( " Round((countTFilez / markedSelectFile) * 100) "% )"
         percLeft := (1 - countTFilez / markedSelectFile) * 100
         zeitLeft := (zeitOperation/countFilez) * markedSelectFile - zeitOperation
         etaTime := "`nEstimated time left: " SecToHHMMSS(Round(zeitLeft/1000, 3))
         etaTime .= "`nElapsed time: " SecToHHMMSS(Round(zeitOperation/1000, 3)) percDone
         If failedFiles
            someErrors := "`nFailed to process " failedFiles " files..."
         If skippedFiles
            someErrors .= "`n" skippedFiles " files were skipped..."

         showTOOLtip("Processing " countTFilez "/" filesElected " files, please wait..." someErrors etaTime, 0, 0, countTFilez / markedSelectFile)
         prevMSGdisplay := A_TickCount
         someErrors := ""
      }

      If (determineTerminateOperation()=1)
      {
         abandonAll := 1
         Break
      }

      imgPath := StrReplace(imgPath, "||")
      zPlitPath(imgPath, 0, OutFileName, OutDir)
      destImgPath := (ResizeUseDestDir=1) ? ResizeDestFolder : OutDir
      file2save := destImgPath "\" OutFileName

      If (ResizeUseDestDir=1)
      {
         If (FileExist(file2save) && !FolderExist(file2save))
            file2save := askAboutFileCollision(imgPath, file2save, 1, 0, userActionConflictingFile, performOverwrite)
      }

      If !file2save
      {
         skippedFiles++
         Continue
      }

      r := coreSimpleFileProcessing(imgPath, file2save, rotateAngle, XscaleImgFactor, YscaleImgFactor)
      If r
         failedFiles++
      Else
         filesConverted++
   }

   If failedFiles
      someErrors := "`nFailed to process " failedFiles " files..."
   If skippedFiles
      someErrors .= "`n" skippedFiles " files were skipped..."

   executingCanceableOperation := 0
   CurrentSLD := backCurrentSLD
   ForceRefreshNowThumbsList()
   dummyTimerDelayiedImageDisplay(100)
   If (abandonAll=1)
      showTOOLtip("Operation aborted. " filesConverted " out of " filesElected " selected files were processed." someErrors)
   Else
      showTOOLtip("Finished processing " filesConverted " out of " filesElected " selected files" someErrors)

   SetTimer, ResetImgLoadStatus, -50
   SoundBeep, % (abandonAll=1) ? 300 : 900, 100
   SetTimer, RemoveTooltip, % -msgDisplayTime
}

printLargeStrArray(whichArray, maxList, delim) {
  startZeit := A_TickCount
  trenchSize := 25000
  changeMcursor()
  If (maxList<trenchSize)
  {
     Loop, % maxList
     {
          rA := whichArray[A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu .= r delim
     }
     Return filesListu
  }

  doStartLongOpDance()
  splitParts := maxList//trenchSize
  Loop, % splitParts - 1
  {
      If (A_TickCount - startZeit>2500)
         executingCanceableOperation := A_TickCount

      changeMcursor()
      thisIndex := A_Index
      Loop, % trenchSize
      {
          rA := whichArray[trenchSize*(thisIndex-1) + A_Index]
          r := rA[1]
          If (InStr(r, "||") || !r)
             Continue

          filesListu%thisIndex% .= r delim
      }

      If (determineTerminateOperation()=1) ; && (A_TickCount - startZeit>2500)
      {
         abandonAll := 1
         Break
      }
  }

  If (abandonAll=1)
  {
     SoundBeep, 300, 100
     lastLongOperationAbort := A_TickCount
     Return
  }

  Loop, % maxList - trenchSize*(splitParts - 1)
  {
      rA := whichArray[trenchSize*(splitParts - 1) + A_Index]
      r := rA[1]
      If (InStr(r, "||") || !r)
         Continue

      filesListu%splitParts% .= r delim
  }

  filesListu%splitParts% := Trimmer(filesListu%splitParts%)
  Loop, % splitParts
      result .= filesListu%A_Index%

  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) 
  Return result
}

GetRes(ByRef bin, lib, res, type) {
  If !A_IsCompiled
     Return 0

  hL := 0
  If lib
     hM := DllCall("kernel32\GetModuleHandleW", "Str", lib, "Ptr")

  If !lib
  {
     hM := 0  ; current module
  } Else If !hM
  {
     If (!hL := hM := DllCall("kernel32\LoadLibraryW", "Str", lib, "Ptr"))
        Return
  }

  dt := (type+0 != "") ? "UInt" : "Str"
  hR := DllCall("kernel32\FindResourceW"
      , "Ptr" , hM
      , "Str" , res
      , dt , type
      , "Ptr")

  If !hR
  {
     fnOutputDebug("GetRes() ERR " FormatMessage(A_ThisFunc "(" lib ", " res ", " type ", " l ")", A_LastError))
     Return
  }

  hD := DllCall("kernel32\LoadResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "Ptr")
  hB := DllCall("kernel32\LockResource"
      , "Ptr" , hD
      , "Ptr")
  sz := DllCall("kernel32\SizeofResource"
      , "Ptr" , hM
      , "Ptr" , hR
      , "UInt")
  If !sz
  {
     fnOutputDebug("Error: resource size 0 in  " A_ThisFunc " ( " lib " ,  " res " ,  " type " )")
     DllCall("kernel32\FreeResource", "Ptr" , hD)
     If hL
        DllCall("kernel32\FreeLibrary", "Ptr", hL)
     Return
  }

  VarSetCapacity(bin, 0), VarSetCapacity(bin, sz, 0)
  DllCall("ntdll\RtlMoveMemory", "Ptr", &bin, "Ptr", hB, "UInt", sz)
  DllCall("kernel32\FreeResource", "Ptr" , hD)

  If hL
     DllCall("kernel32\FreeLibrary", "Ptr", hL)

  Return sz
}

FormatMessage(ctx, msg, arg="") {
  Global
  Local txt, buf
  SetFormat, Integer, H
  msg+=0
  SetFormat, Integer, D
  frmMsg := DllCall("kernel32\FormatMessageW"
          , "UInt" , 0x1100 ; FORMAT_MESSAGE_FROM_SYSTEM/ALLOCATE_BUFFER
          , "Ptr"  , 0      ; lpSource
          , "UInt" , msg    ; dwMessageId
          , "UInt" , 0      ; dwLanguageId (0x0418=RO)
          , "PtrP" , buf    ; lpBuffer
          , "UInt" , 0      ; nSize
          , "Str"  , arg)   ; Arguments

  txt := StrGet(buf, "UTF-16")
  lF := DllCall("kernel32\LocalFree", "Ptr", buf)
  Result := "Error " msg " in " ctx ":`n" txt
  Return Result
}

calcHistoAvgFile(xBitmap, SortCriterion, thisImgQuality) {
    If StrLen(xBitmap)<2
       Return 0

    Gdip_GetImageDimensions(xBitmap, cImgW, cImgH)
    R := Gdip_GetHistogram(xBitmap, 3, brLvlArray, 0, 0)
    If R
       Return 0

    TotalPixelz := cImgW * cImgH
    sumTotalBr := nrPixelz := medianValue := thisSum := 0
    lookValue := stringHistoArray := ""
    Loop, 256
    {
        thisIndex := A_Index - 1
        nrPixelz := brLvlArray[thisIndex]
        If (nrPixelz="")
           Continue

        If InStr(SortCriterion, "median")
           stringHistoArray .= (thisIndex+1) "." nrPixelz "`n"

        sumTotalBr += nrPixelz * (thisIndex+1)
    }

    If InStr(SortCriterion, "median")
    {
       Loop, 256
       {
           lookValue := ST_ReadLine(stringHistoArray, A_Index)
           lookValue := StrSplit(lookValue, ".")
           thisSum += lookValue[2]
           If (thisSum>TotalPixelz//2)
           {
              medianValue := lookValue[1] - 1
              Break
           }
       }
    }

    SortBy := InStr(SortCriterion, "median") ? medianValue ".01" : Round((sumTotalBr/TotalPixelz - 1)/2, 3)
    Return SortBy
}

SaveFIMfile(file2save, pBitmap) {
  initFIMGmodule()
  If !wasInitFIMlib
     Return 1

  hFIFimgA := ConvertPBITMAPtoFIM(pBitmap)
  If !hFIFimgA
  {
     SoundBeep , 300, 100
     message := "Failed to convert GDI+ image object to FreeImage object..."
     addJournalEntry(message)
     Return message 
  }

  If FileExist(file2save)
  {
     Try FileSetAttrib, -R, % file2save
     Sleep, 0
     FileMove, % file2save, % file2save "-tmp"
     If !ErrorLevel
        tempFileExists := 1

     Sleep, 0
  }

  saveArg := 0
  If RegExMatch(file2save, "i)(.\.(jp2|j2c|j2k))$")
     saveArg :=  clampInRange(512 - Round(userJpegQuality/100*512), 1, 512)
  Else If RegExMatch(file2save, "i)(.\.(jpg|jpeg|jxr|webp))$")
     saveArg :=  clampInRange(Round(userJpegQuality), 1, 100)

  If RegExMatch(file2save, "i)(.\.(gif|jng|jif|jfif|jpg|jpe|jpeg|ppm|wbm|xpm))$")
  {
     hFIFimgB := FreeImage_ConvertTo(hFIFimgA, "24Bits")
     changeMcursor()
     r := FreeImage_Save(hFIFimgB, file2save, saveArg)
     FreeImage_UnLoad(hFIFimgB)
  } Else r := FreeImage_Save(hFIFimgA, file2save, saveArg)

  FreeImage_UnLoad(hFIFimgA)
  If (!r && tempFileExists=1) || (!FileRexists(file2save) && tempFileExists=1)
  {
     r := 0
     FileDelete, % file2save
     Sleep, 0
     FileMove, % file2save "-tmp", % file2save
  } Else If (tempFileExists=1)
     FileDelete, % file2save "-tmp"

  Return !r
}

initFIMGmodule() {
  Static firstTimer := 1
  If (wasInitFIMlib!=1)
  {
     r := FreeImage_FoxInit(1) ; Load the FreeImage Dll
     wasInitFIMlib := r ? 1 : 0
     If wasInitFIMlib
        addJournalEntry("FreeImage library initialized: v" FreeImage_GetVersion())
  }

  If InStr(r, "err - ")
  {
     alwaysOpenwithFIM := 0
     FIMfailed2init := 1
     If InStr(r, "err - 126")
        friendly := "`n`nPlease install the Runtime Redistributable Packages of Visual Studio 2013."
     Else If InStr(r, "err - 404")
        friendly := "`n`nThe FreeImage.dll file seems to be missing..."
     If (firstTimer=1 && hasInitSpecialMode!=1)
     {
        SoundBeep, 300, 100
        msgBoxWrapper(appTitle ": ERROR", "The FreeImage library failed to properly initialize. Some image file formats will no longer be supported. Error code: " r "." friendly, 0, 0, "error")
     }
  } Else FIMfailed2init := 0

  firstTimer := 0
  Return r
}

GlobalMemoryStatusEx() {
; https://msdn.microsoft.com/en-us/library/aa366589(v=vs.85).aspx 
; by jNizM
; https://github.com/jNizM/MemoryInfo/blob/master/src/MemoryInfo.ahk
    static MSEX, init := NumPut(VarSetCapacity(MSEX, 64, 0), MSEX, "uint")
    if !(DllCall("GlobalMemoryStatusEx", "ptr", &MSEX))
       Return 0
       ;  throw Exception("Call to GlobalMemoryStatusEx failed: " A_LastError, -1)
    return { MemoryLoad: NumGet(MSEX, 4, "uint"), TotalPhys: NumGet(MSEX, 8, "uint64"), AvailPhys: NumGet(MSEX, 16, "uint64") }
}

GetProcessMemoryUsage(ProcessID) {
; by jNizM
; https://www.autohotkey.com/boards/viewtopic.php?t=62848
; modified by Marius Șucan

   static PMC_EX, size := NumPut(VarSetCapacity(PMC_EX, 8 + A_PtrSize * 9, 0), PMC_EX, "uint")

   if (hProcess := DllCall("OpenProcess", "uint", 0x1000, "int", 0, "uint", ProcessID))
   {
      if !(DllCall("GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
      {
         if !(DllCall("psapi\GetProcessMemoryInfo", "ptr", hProcess, "ptr", &PMC_EX, "uint", size))
            return (ErrorLevel := 2) & 0, DllCall("CloseHandle", "ptr", hProcess)
      }
      DllCall("CloseHandle", "ptr", hProcess)
      infos := []
      infos[0] := NumGet(PMC_EX, A_PtrSize, "uptr")   ; peak working set bytes
      infos[1] := NumGet(PMC_EX, 8 + A_PtrSize, "uptr")   ; working set bytes
      infos[8] := NumGet(PMC_EX, 8 + A_PtrSize*8, "uptr") ; private bytes
      Return infos
   }
   return (ErrorLevel := 1) & 0
}

LoadFimFile(imgPath, noBPPconv) {
  Critical, on
  sTime := A_tickcount  
  initFIMGmodule()
  If !wasInitFIMlib
     Return

  loadArgs := (noBPPconv=1) ? -1 : 0   ; FIF_LOAD_NOPIXELS
  GFT := FreeImage_GetFileType(imgPath)
  If (GFT=34 && loadArgs=0)
     loadArgs := (userHQraw=1 && thumbsDisplaying=0) ? 0 : 5
  Else If (GFT=2 && loadArgs=0)
     loadArgs := 8

  setWindowTitle("Loading file using the FreeImage library")
  changeMcursor()
  hFIFimgA := FreeImage_Load(imgPath, -1, loadArgs) ; load image
  If !hFIFimgA
  {
     addJournalEntry("Failed to load image file using FreeImage library...")
     Return
  }

  imgBPP := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgA), "-"))
  ColorsType := FreeImage_GetColorType(hFIFimgA)
  If (noBPPconv=0)
     alphaBitmap := FreeImage_GetChannel(hFIFimgA, 4)

  capMaxGDIbmpSize32bits()
  mustApplyToneMapping := (imgBPP>32 && !InStr(ColorsType, "rgba")) || (imgBPP>64) ? 1 : 0
  toneMapped := ""
  If (mustApplyToneMapping=1 && noBPPconv=0)
  {
     setWindowTitle("Applying adaptive logarithmic tone mapping to display high color depth image")
     changeMcursor()
     hFIFimgB := FreeImage_ToneMapping(hFIFimgA, cmrRAWtoneMapAlgo - 1, cmrRAWtoneMapParamA, cmrRAWtoneMapParamB)
     toneMapped := " (TONE-MAPPED)"
  }

  fileType := FreeImage_GetFileType(imgPath, 1)
  If (fileType="raw" && userHQraw!=1)
     fileType .= " [LOW QUALITY]"

  imgType := FreeImage_GetImageType(hFIFimgA, 1)
  FreeImage_GetImageDimensions(hFIFimgA, imgW, imgH)
  mainLoadedIMGdetails.File := imgPath
  mainLoadedIMGdetails.Width := imgW
  mainLoadedIMGdetails.Height := imgH
  mainLoadedIMGdetails.Frames := FreeImage_GetPageCount(hFIFimgA) - 1
  mainLoadedIMGdetails.HasAlpha := InStr(ColorsType, "rgba") ? 1 : 0
  mainLoadedIMGdetails.RawFormat := fileType " | " imgType
  mainLoadedIMGdetails.PixelFormat := imgBPP "-" ColorsType toneMapped
  mainLoadedIMGdetails.OpenedWith := "FreeImage library v" FreeImage_GetVersion()
  mainLoadedIMGdetails.TooLargeGDI := 0

  hFIFimgZ := hFIFimgB ? hFIFimgB : hFIFimgA
  hFIFimgC := hFIFimgZ ? hFIFimgZ : hFIFimgA
  FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)

  If (noBPPconv=0)
  {
     If (imgW*imgH>maxGDIbmpSize)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits...")
        calcIMGdimensions(imgW, imgH, Round(Sqrt(maxGDIbmpSize)), Round(Sqrt(maxGDIbmpSize)), nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     } Else If (imgW>32500 || imgH>32500)
     {
        setWindowTitle("Rescaling image to fit the GDI+ maximum image dimensions limits...")
        calcIMGdimensions(imgW, imgH, 32500, 32500, nImgW, nImgH)
        changeMcursor()
        hFIFimgKO := FreeImage_Rescale(hFIFimgC, nimgW, nimgH, 0)
     }

     If StrLen(hFIFimgKO)>2
     {
        hFIFimgC := hFIFimgKO
        mainLoadedIMGdetails.TooLargeGDI := 1
        FreeImage_GetImageDimensions(hFIFimgC, imgW, imgH)
     }

     setWindowTitle("Converting FreeImage object to GDI+ image bitmap")
     imgBPPc := Trimmer(StrReplace(FreeImage_GetBPP(hFIFimgC), "-"))
     If (imgBPPc!=32)
        hFIFimgD := FreeImage_ConvertTo(hFIFimgC, "32Bits")

     hFIFimgE := hFIFimgD ? hFIFimgD : hFIFimgC
     If alphaBitmap
     {
        hFIFimgXu := FreeImage_ConvertTo(alphaBitmap, "Greyscale")
        eRR := FreeImage_GetHistogram(hFIFimgXu, 5, histoArray)
        mustInvert := eRR
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && A_Index>2)
               mustInvert := 0
        }
        HasAlpha := 0
        Loop, 256
        {
            If (histoArray[A_Index - 1]>5 && isInRange(A_Index, 3, 254))
               HasAlpha := 1
        }

        ; ToolTip, % lola " = " eRR " - " mustInvert  " / " HasAlpha , , , 2
        If (mustInvert=1)
        {
           FreeImage_Invert(hFIFimgXu)
           FreeImage_SetChannel(hFIFimgE, hFIFimgXu, 4)
        }

        mainLoadedIMGdetails.HasAlpha := HasAlpha
        FreeImage_UnLoad(hFIFimgXu)
        FreeImage_UnLoad(alphaBitmap)
     }
     ; FreeImage_PreMultiplyWithAlpha(hFIFimgE)
     pBitmap := ConvertFIMtoPBITMAP(hFIFimgE)
  } Else pBitmap := trGdip_CreateBitmap(A_ThisFunc, imgW, imgH, "0xE200B")

  ; Gdip_GetImageDimensions(pBitmap, imgW2, imgH2)
  imgIDs := hFIFimgA "|" hFIFimgB "|" hFIFimgC "|" hFIFimgKO "|" hFIFimgD "|" hFIFimgE "|" hFIFimgZ
  Sort, imgIDs, UD|
  Loop, Parse, imgIDs, |
  {
      If A_LoopField
         FreeImage_UnLoad(A_LoopField)
  }

  eTime := A_TickCount - sTime
  ; ToolTip, % imgW ", " imgW2,,,2
  ; Tooltip, % etime "; " noPixels "; " GFT
  ; Tooltip, %r1% -- %r2% -- %pBits% ms ---`n %pbitmap% -- %hbitmap% -- %hfifimg%
  ; ToolTip, % Gdip_GetImagePixelFormat(pBitmap, 2) , , , 2
  Return pBitmap
}

changeMcursor(whichCursor:=0) {
  Static lastInvoked := 1, prevCursor := "none"
  If ((drawingShapeNow=1 || slideShowRunning=1 || animGIFplaying=1 || (A_TickCount - zeitSillyPrevent<300) || hasInitSpecialMode=1) && imageLoading!=1)
     Return

  If (whichCursor)
  {
     prevCursor := whichCursor
     interfaceThread.ahkPostFunction("changeMcursor", whichCursor)
  } Else If (A_TickCount - lastInvoked > 500) ; && (imageLoading!=1)
  {
     interfaceThread.ahkPostFunction("changeMcursor", "busy")
     ; interfaceThread.ahkassign("imageLoading", 1)
     ; Try DllCall("user32\SetCursor", "Ptr", hCursBusy)
     lastInvoked := A_TickCount
  }
}

GetImgFileDimension(imgPath, ByRef W, ByRef H, fastWay:=1) {
   Static prevImgPath, prevW, prevH
   thisImgPath := generateThumbName(imgPath, 1) fastWay
   If (prevImgPath=thisImgPath && prevH>1 && prevW>1)
   {
      W := prevW
      H := prevH
      Return 1
   }

   prevImgPath := thisImgPath
   changeMcursor()
   pBitmap := LoadBitmapFromFileu(imgPath, fastWay)
   prevW := W := mainLoadedIMGdetails.Width
   prevH := H := mainLoadedIMGdetails.Height
   trGdip_DisposeImage(pBitmap, 1)

   changeMcursor("normal")
   r := (w>1 && h>1) ? 1 : 0
   Return r
}

isInRange(value, inputA, inputB) {
    If (value=inputA || value=inputB)
       Return 1

    testRange := 0
    pointA := min(inputA, inputB)
    pointB := max(inputA, inputB)
    testRange := (value>=pointA && value<=pointB) ? 1 : 0
    Return testRange
}

ST_ReadLine(String, line, delim="`n", exclude="`r") {
   String := Trimmer(String, delim)
   StringReplace, String, String, %delim%, %delim%, UseErrorLevel
   TotalLcount := ErrorLevel + 1

   If (abs(line)>TotalLCount && (line!="L" || line!="R" || line!="M"))
      Return 0

   If (Line="R")
      Random, Rand, 1, %TotalLcount%
   Else If (line<=0)
      line := TotalLcount + line

   Loop, Parse, String, %delim%, %exclude%
   {
      out := (Line="R" && A_Index=Rand) ? A_LoopField
           : (Line="M" && A_Index=TotalLcount//2) ? A_LoopField
           : (Line="L" && A_Index=TotalLcount) ? A_LoopField
           : (A_Index=Line) ? A_LoopField : -1
      If (out!=-1) ; Something was found so stop searching.
         Break
   }
   Return out
}

triggerOwnDialogs() {
  If AnyWindowOpen
     Gui, SettingsGUIA: +OwnDialogs
  Else
     Gui, 1: +OwnDialogs
}

checkThumbExists(MD5name, imgPath, ByRef file2load) {
   file2save := thumbsCacheFolder "\" thumbsSizeQuality "-" MD5name ".jpg"
   If FileExist(file2save)
   {
      FileGetSize, fileSizu, % file2save
      If (fileSizu<3)
         Return 0

      file2load := file2save
      Return 1
   } Else If (thumbsSizeQuality>755)
   {
      file2load := imgPath
      Return 0
   } Else If (thumbsSizeQuality>=500)
   {
      file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : imgPath
   } Else If (thumbsSizeQuality>=245)
   {
      file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : imgPath
      }
   } Else If (thumbsSizeQuality>124)
   {
      file2test := thumbsCacheFolder "\245-" MD5name ".jpg"
      file2load := FileExist(file2test) ? file2test : 0
      If !file2load
      {
         file2test := thumbsCacheFolder "\500-" MD5name ".jpg"
         file2load := FileExist(file2test) ? file2test : 0
         If !file2load
         {
            file2test := thumbsCacheFolder "\755-" MD5name ".jpg"
            file2load := FileExist(file2test) ? file2test : imgPath
         }
      }
   }
   FileGetSize, fileSizu, % file2load
   r := (imgPath=file2load || fileSizu<3) ? 0 : 1
   Return r
}

generateThumbName(imgPath, forceThis:=0, thumbsSizer:=0) {
   Static lastInvoked := 1, prevMD5name, prevImgPath := "null"

   If (A_TickCount - lastInvoked<50) && (imgPath=prevImgPath)
      Return prevMD5name

   If (enableThumbsCaching!=1 && forceThis=0)
      Return

   FileGetSize, fileSizu, % imgPath
   FileGetTime, FileDateM, % imgPath, M
   fileInfos := imgPath fileSizu FileDateM
   MD5name := CalcStringHash(fileInfos, 0x8003)
   ; If (thumbsSizer=1)
   ;    MD5name := thumbsSizeQuality "-" MD5name
   lastInvoked := A_TickCount
   prevMD5name := MD5name
   Return MD5name
}

CalcStringHash(string, algid, encoding = "UTF-8", byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; this calculates the MD5 hash
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    chrlength := (encoding = "CP1200" || encoding = "UTF-16") ? 2 : 1
    length := (StrPut(string, encoding) - 1) * chrlength
    VarSetCapacity(data, length, 0)
    StrPut(string, &data, floor(length / chrlength), encoding)
    Result := CalcAddrHash(&data, length, algid, hash, hashlength)
    Return Result
}

CalcAddrHash(addr, length, algid, byref hash = 0, byref hashlength = 0) {
; function by jNizM and Bentschi
; taken from https://github.com/jNizM/HashCalc
; function under MIT License: https://raw.githubusercontent.com/jNizM/AHK_Network_Management/master/LICENSE

    Static h := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f"]
         , b := h.minIndex()
    hProv := hHash := o := ""
    CAC := DllCall("advapi32\CryptAcquireContext", "Ptr*", hProv, "Ptr", 0, "Ptr", 0, "UInt", 24, "UInt", 0xf0000000)
    If CAC
    {
       CCH := DllCall("advapi32\CryptCreateHash", "Ptr", hProv, "UInt", algid, "UInt", 0, "UInt", 0, "Ptr*", hHash)
       If CCH
       {
          CHD := DllCall("advapi32\CryptHashData", "Ptr", hHash, "Ptr", addr, "UInt", length, "UInt", 0)
          If CHD
          {
             CGP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", 0, "UInt*", hashlength, "UInt", 0)
             If CGP
             {
                VarSetCapacity(hash, hashlength, 0)
                CGHP := DllCall("advapi32\CryptGetHashParam", "Ptr", hHash, "UInt", 2, "Ptr", &hash, "UInt*", hashlength, "UInt", 0)
                If CGHP
                {
                   Loop, %hashlength%
                   {
                      v := NumGet(hash, A_Index - 1, "UChar")
                      o .= h[(v >> 4) + b] h[(v & 0xf) + b]
                   }
                }
             }
          }
          CDH := DllCall("advapi32\CryptDestroyHash", "Ptr", hHash)
       }
       CRC := DllCall("advapi32\CryptReleaseContext", "Ptr", hProv, "UInt", 0)
    }
    Return o
}









HammingDistance(stringA, stringB) {
    If (StrLen(stringA) != StrLen(stringB))
       Return -1

    countDiffs := 0
    Loop, % StrLen(stringA)
    {
       If (SubStr(stringA, A_Index, 1)!=SubStr(stringB, A_Index, 1))
          countDiffs++
    }
    Return countDiffs
}

HammingDistanceBugz(a,b) {
; by Bugz000
    loop % 17
      s.=(c:="0." substr(a,(A_index)*16-15,16))+(d:="0." substr(b,(A_index)*16-15,16))
    z:=strsplit(s,"1")
    return % z.count()-1
}


HammingDistance3(a,b) {
; by Bugz000
    Loop, Parse, a
    {
       If (A_loopfield!=SubStr(b, A_Index, 1))
          i += 1
    }
    return % i
}

HammingDistanceRust(a, b) {
     r := DllCall("hamming_distance.dll\harming_distance_bytes", "astr", a, "astr", b)
     Return r
}

testAlgoSingle() {
   imgPath := getIDimage(currentFileIndex)
     hashA := Gdip_ImageDhash(imgPath)
 imgPath := getIDimage(currentFileIndex + 1)
     hashB := Gdip_ImageDhash(imgPath)
r1 := HammingDistanceRust(hashA, hashB)
r2 := HammingDistance(hashA, hashB)

MsgBox, % r1 "--" r2 "`n" hashA "`n" hashB

}


Gdip_ImageDhash(imgPath) {
   Width := 9*2, Height := 8*2
   oBitmap := LoadBitmapFromFileu(imgPath)
   If oBitmap
   {
      xBitmap := trGdip_ResizeBitmap(A_ThisFunc, oBitmap, Width, Height, 0, 3)
      lBitmap := trGdip_BitmapConvertGray(xBitmap, 0, -20)
      trGdip_DisposeImage(oBitmap, 1)
   }

   E1 := Gdip_LockBits(lBitmap, 0, 0, Width, Height, Stride, Scan0, BitmapData)
   dHash := z := 0
   Loop %Height%
   {
      y++
      Loop % Width - 1
      {
         pX := A_Index - 1, pY := y - 1
         Gdip_FromARGB(NumGet(Scan0+0, (pX*4)+(pY*Stride), "UInt"), A1, R1, G1, B1)
         Gdip_FromARGB(NumGet(Scan0+0, ((pX+1)*4)+(pY*Stride), "UInt"), A2, R2, G2, B2)
         dHash .= (R1<R2) ? 1 : 0
      }
   }

   Gdip_UnlockBits(lBitmap, BitmapData)
   trGdip_DisposeImage(lBitmap, 1)
   trGdip_DisposeImage(xBitmap, 1)
   return dHash
}

testAlgo() {
  SoundBeep 
  thisCounter := 0
  startZeit := A_TickCount
  hashesListArray := []
  ; create hashes for images in the resultedFilesList Array
  Loop, % maxFilesIndex
  {
      imgPath := getIDimage(A_Index)
      If !FileRexists(imgPath)
         Continue

      thisCounter++
      newHash := (cachedHashes[imgPath]!="") ? cachedHashes[imgPath] : Gdip_ImageDhash(imgPath)
      cachedHashes[imgPath] := newHash
      ; hashesList .= newHash "`n"
      hashesListArray[thisCounter] := newHash
      hashesListIDsArray[newHash] := imgPath
  }

  thresholdu := 1   
  countAll := countThese := newFilesIndex := 0
  hashesList := Trimmer(hashesList)
  newFilesList := []
  distCombinationsA := []
  distCombinationsB := []
  distCombinations := []
  ; hashesListArray := []
  ; hashesListArray := StrSplit(hashesList, "`n")
  ; MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) "`n" hashesListArray.count()
  ; SoundBeep 

  DllPath := FreeImage_FoxGetDllPath("hamming_distance.dll")
  lalala := DllCall("LoadLibraryW", "WStr", DllPath, "UPtr")

  Loop, % hashesListArray.Count()
  {
      thisHash := hashesListArray[A_Index]
      If !thisHash
         Continue
      countAll++
      thisIndex := A_Index
      Loop, % thisIndex - 1
      {
          countThese++
    ;      distCombinations[A_Index] := hashesListArray[A_Index]
          hDistances := HammingDistanceRust(thisHash, hashesListArray[A_Index])
      }
  }

/*

  Loop, % hashesListArray.MaxIndex()
  {
    originalIndex := A_Index
    startPoint := StrSplit(hashesListArray[originalIndex], "|:|")
    startPointV := startPoint[1]


  Loop, % hashesListArray.MaxIndex() ; - originalIndex
  {
      thisThing := hashesListArray[originalIndex + A_Index - thresholdu]
      If !thisThing
         Continue

      thisIndex := StrSplit(thisThing, "|:|")
      If isInRange(thisIndex[1], startPointV - thresholdu, startPointV + thresholdu)
      {
         newFilesIndex++
         newFilesList[newFilesIndex] := thisIndex[2]
 ;        tooltip, % newFilesIndex "--" thisIndex[1] "--" thisIndex[2]
      }
  }
}

   newFilesList := trimArray(newFilesList)
   filteredMap2mainList := []
   resultedFilesList := newFilesList.Clone()
   maxFilesIndex := newFilesIndex
   newFilesList := []
   newMappingList := []
   GenerateRandyList()
   ForceRefreshNowThumbsList()
*/

SoundBeep 
  MsgBox, % SecToHHMMSS((A_TickCount - startZeit)/1000) "`n" countThese "--" countAll "`n" hashesListArray.count()


  dummyTimerReloadThisPicture(50)
  
 ; Clipboard := hashesList
}

OpenNewExternalCoreThread(thisIndex, args, thisList) {
   pidThread := 0
   Try FileDelete, %thumbsCacheFolder%\tempList%thisIndex%.txt
   Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
   Sleep, 0
   Try FileAppend, % thisList, %thumbsCacheFolder%\tempFilesList.txt, utf-16
   Catch wasErrorA
         Sleep, 1

   If wasErrorA
      Return 0

   Sleep, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadJob%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
   RegWrite, REG_SZ, %QPVregEntry%\multicore, threadParams, %thisIndex%||%args%

   thisPath := A_IsCompiled ? Chr(34) fullPath2exe Chr(34) : unCompiledExePath
   Try Run, %thisPath%,,, pidThread
   Catch wasErrorB
       Sleep, 0

   If (wasErrorB || !pidThread)
   {
      Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
      Return 0
   } Else
   {
      WinWait, ahk_pid %pidThread%,,2
      WinGet, hwndThread, ID, ahk_pid %pidThread%
      Sleep, 10
      Loop, 500
      {
          RegRead, thisThreadStarted, %QPVregEntry%\multicore, ThreadRunning%thisIndex%
          If (thisThreadStarted=1 || thisThreadStarted=2 || thisThreadStarted=-1)
             Break
          Else
             Sleep, 15
      }

      allGood := (thisThreadStarted=1 || thisThreadStarted=2) ? 1 : 0
      If (allGood!=1)
      {
         Process, Close, % pidThread
         RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%thisIndex%, 0
         Try FileDelete, %thumbsCacheFolder%\tempFilesList.txt
         Return 0
      }
      Return pidThread
   }
}

initExternalCoreMode() {
  Critical, on
  hasInitSpecialMode := 1
  RegRead, mainThreadHwnd, %QPVregEntry%\multicore, mainThreadHwnd
  If !WinExist("ahk_id" mainThreadHwnd)
  {
     RegWrite, REG_SZ, %QPVregEntry%, Running, 0
     fatalError := 1
  }

  RegRead, threadParams, %QPVregEntry%\multicore, threadParams
  If !threadParams
     fatalError := 1

  args := StrSplit(threadParams, "||")
  coreThread := args[1]

  Try FileRead, filesList, %thumbsCacheFolder%\tempFilesList.txt
  If !filesList
     fatalError := 1

  If (fatalError=1)
  {
     RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, -1
     ForceExitNow()
     Return
  }

  RegWrite, REG_SZ, %QPVregEntry%\multicore, ThreadRunning%coreThread%, 1
  initFIMGmodule()
  RegRead, hGDIwin, %QPVregEntry%\multicore, mainWindowID
     ; MsgBox, % args[1] "--" args[3]
  If (args[2]="batch-sort-histo")
     multiCoresListSorter(args[1], args[3], filesList)
  Else If (args[2]="batch-jpegll")
     multiCoresJpegLL(args[1], args[3], filesList)
  Else If (args[2]="batch-simpleimgproc")
     multiCoresSimpleImgProcessing(args[1], args[3], filesList)
  Else If (args[2]="batch-fmtconv")
     multiCoresFormatConvert(args[1], filesList)

  ; msgbox, killaaaa
  ForceExitNow()
  Return
}



testResourcesMemoryLeaks() {
  Loop, 4500
  {
       pEffect3 := Gdip_CreateEffect(1, 20, 0, 0)
       Gdip_DisposeEffect(pEffect3)

       lolBrush := Gdip_BrushCreateSolid("0x77898898")
       Gdip_DeleteBrush(lolBrush)

       lolPen1 := Gdip_CreatePen("0xCCbbccbb", 5)
       Gdip_DeletePen(lolPen1)


       lolPath := Gdip_CreatePath()
       Gdip_AddPathEllipse(lolPath, 30, 30, 200, 200)
       Gdip_DeletePath(lolPath)

       ; lola := drawTextInBox("loWooWol", "Arial", 99, 1500, 1500, "ff0099", "EEff0099", 0)
       pBitmap := trGdip_CreateBitmap(A_ThisFunc, 900, 900, "0xE200B")
       G3 := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4)
       txtOptions := "x30 y30 center cEEff0099 r4 s10 Bold" 
       dimensions := Gdip_TextToGraphics(G3, "loooool", txtOptions, "Arial", 400, 400, 0, 0, 2)
       Gdip_DeleteGraphics(G3)
       trGdip_DisposeImage(pBitmap)
       trGdip_DisposeImage(lola)
  }
  MsgBox, lololol
}

GetInstalledPrinters(Delimiter="|",Default=True) {
;  Run, rundll32    shimgvw.dll    ImageView_PrintTo /pt   xxx.png   "printer name"
;  Run, mspaint /pt [image filename]


  if (Default = True)
  {
    regread,defaultPrinter,HKCU,Software\Microsoft\Windows NT\CurrentVersion\Windows,device
    stringsplit,defaultName,defaultPrinter,`,
    defaultName := defaultName1
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      if (A_LoopRegName = defaultname)
      printerlist = %printerlist%%A_loopRegName%%Delimiter%%Delimiter%
      else printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  else
  {
    printerlist =
    loop,HKCU,Software\Microsoft\Windows NT\CurrentVersion\devices
    {
      printerlist = %printerlist%%A_loopRegName%%Delimiter%
    }
  }
  StringTrimRight, printerlist, printerlist, StrLen(Delimiter)
  return %printerlist%
}

PrinterGetMatchingBitmap(width, height, color:="0xffFFFFFF") {
  ; set background-color (default is white)
  pBitmap := trGdip_CreateBitmap(A_ThisFunc, width, height)
  If StrLen(pBitmap)<3
     Return

  G := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
  If G
     trGdip_GraphicsClear(A_ThisFunc, G, color)

  Gdip_DeleteGraphics(G)
  return pBitmap
}

printImageNow(mainBMP, PrintOptions, previewMode) {
   If StrLen(mainBMP)<3
      Return

   pPrinterName := PrintOptions.pPrinterName
   adaptFit := PrintOptions.adaptFit
   userImgX := PrintOptions.userImgX
   userImgY := PrintOptions.userImgY
   userImgW := PrintOptions.userImgW
   userImgH := PrintOptions.userImgH
   colorsMode := PrintOptions.colorsMode
   imgOrient := PrintOptions.imgOrient
   copiez := PrintOptions.copiez
   flipuV := PrintOptions.flipuV
   flipuH := PrintOptions.flipuH
   applyFX := PrintOptions.applyFX

   ; pPrinterName := SGDIPrint_GetDefaultPrinter()
   ; hdcObj := SGDIPrint_GetHDCfromPrintDlg(PVhwnd)
   hdcObj := SGDIPrint_GetHDCfromPrinterName(pPrinterName, 1, Round(colorsMode + 1), copiez, PVhwnd)
   If (previewMode=1)
   {
      calcIMGdimensions(hdcObj.HDC_Width, hdcObj.HDC_Height, 248, 351, ResizedW, ResizedH)
   } Else
   {
      ResizedW := hdcObj.HDC_Width
      ResizedH := hdcObj.HDC_Height
   }

   ; - "print" to bitmap -
   pBitmap := trGdip_CreateBitmap(A_ThisFunc, ResizedW, ResizedH, "0xE200B")
   If (previewMode!=1)
   {
      If warnUserFatalBitmapError(pBitmap, A_ThisFunc)
         Return
   }

   gPrint := trGdip_GraphicsFromImage(A_ThisFunc, pBitmap, 7, 4, 2)
   E := trGdip_GraphicsClear(A_ThisFunc, gPrint, "0xFFffFFff")
   If (!pBitmap || !gPrint || E="fail")
      Return

   If (applyFX=1)
      decideGDIPimageFX(matrix, imageAttribs, pEffect)

   Gdip_GetImageDimensions(pBitmap, pageW, pageH)
   imgPosX := Round(pageW*(userImgX/100))
   imgPosY := Round(pageH*(userImgY/100))
   imgNewW := Round(pageW*(userImgW/100))
   imgNewH := Round(pageH*(userImgH/100))
   If (adaptFit=1)
   {
      imgNewH := pageH
      imgNewW := pageW
      imgPosX := imgPosY := 0
   }

   ; mainBMP := useGdiBitmap()
   If isInRange(imgOrient, 1, 359)
   {
      If (previewMode=1)
         imgToPrint := trGdip_ResizeBitmap(A_ThisFunc, mainBMP, 600, 600, 1, 3, -1)
      whichBitmap := StrLen(imgToPrint)>3 ? imgToPrint : mainBMP
      newBitmap := trGdip_RotateBitmapAtCenter(A_ThisFunc, whichBitmap, imgOrient, 1)
      If StrLen(imgToPrint)>3
         imgToPrint := trGdip_DisposeImage(imgToPrint, 1)

      If StrLen(newBitmap)>3
      {
         hasRotated := 1
         imgToPrint := newBitmap
      }
   } 

   whichBitmap := (hasRotated=1) ? imgToPrint : mainBMP
   Gdip_GetImageDimensions(whichBitmap, realImgW, realImgH)
   calcIMGdimensions(realImgW, realImgH, imgNewW, imgNewH, imgNewW, imgNewH)
   ; Gdip_GetRotatedDimensions(imgNewW, imgNewH, imgOrient, rotImgW, rotImgH)
   newBitmap := trGdip_ResizeBitmap(A_ThisFunc, whichBitmap, imgNewW, imgNewH, 1)
   If StrLen(imgToPrint)>3
      trGdip_DisposeImage(imgToPrint, 1)

   failedResize := 0
   If StrLen(newBitmap)>3
      imgToPrint := newBitmap
   Else failedResize := 1

   If pEffect
   {
      Gdip_BitmapApplyEffect(imgToPrint, pEffect)
      Gdip_DisposeEffect(pEffect)
   }

   If (colorsMode!=1)
   {
      newBitmap := trGdip_BitmapConvertGray(imgToPrint)
      If StrLen(newBitmap)>3
      {
         trGdip_DisposeImage(imgToPrint, 1)
         imgToPrint := newBitmap
      }
   }
   If (flipuV=1)
      Gdip_ImageRotateFlip(imgToPrint, 6)
   If (flipuH=1)
      Gdip_ImageRotateFlip(imgToPrint, 4)

   If (adaptFit=1)
   {
      Gdip_GetImageDimensions(imgToPrint, imgNewW, imgNewH)
      imgPosX := (pageW - imgNewW)//2
      imgPosY := (pageH - imgNewH)//2
   }

   r4 := trGdip_DrawImage(A_ThisFunc, gPrint, imgToPrint, imgPosX, imgPosY,,,,,,,,, imageAttribs)
   previewScale := ResizedW / hdcObj.HDC_Width
   If StrLen(PrintOptions.text)>0
   {
      If (TextInAreaFontBold=1)
         thisStylu .= "Bold "
      If (TextInAreaFontItalic=1)
         thisStylu .= "Italic "
      If (TextInAreaFontUline=1)
         thisStylu .= "Underline "

      If (TextInAreaAlign=1)
         thisTxtAlignu := "Left "
      Else If (TextInAreaAlign=2)
         thisTxtAlignu := "Center "
      Else If (TextInAreaAlign=3)
         thisTxtAlignu := "Right "

      If (TextInAreaValign=1)
         thisTxtvAlignu := "Top "
      Else If (TextInAreaValign=2)
         thisTxtvAlignu := "vCenter "
      Else If (TextInAreaValign=3)
         thisTxtvAlignu := "Bottom "
      ; SoundBeep 
      ERR := Gdip_TextToGraphics(gPrint, PrintOptions.text, thisTxtAlignu thisTxtvAlignu thisStylu " s" Round(PrintTxtSize*previewScale) " cFF" TextInAreaFontColor, TextInAreaFontName, pageW, pageH)
      ; ToolTip, % ERR " == "  PrintOptions.text "`n" thisTxtAlignu thisTxtvAlignu " s" TextInAreaFontSize " c" TextInAreaFontColor " == " TextInAreaFontName " == " pageW " == " pageH , , , 2
   }

   If (previewMode!=1 && r4!="fail" && failedResize!=1)
   {
      r := SGDIPrint_BeginDocument(hdcObj.HDC_ptr, appTitle " image file")
      If r
      {
         SGDIPrint_CopyBitmapToPrinterHDC(pBitmap, hdcObj.HDC_ptr, hdcObj.HDC_Width, hdcObj.HDC_Height)
         SGDIPrint_EndDocument(hdcObj.HDC_ptr) ; starts printing
      }
   } Else If (previewMode=1)
   {
      marginuX := hdcObj.HDC_PHYSICALOFFSETX/hdcObj.HDC_PHYSICALWIDTH
      marginuY := hdcObj.HDC_PHYSICALOFFSETY/hdcObj.HDC_PHYSICALHEIGHT
      marginuX := Ceil(ResizedW * marginuX)
      marginuY := Ceil(ResizedH * marginuY)
      newBitmap := SGDIPrint_GetMatchingBitmap(ResizedW + marginuX*2, ResizedH + marginuY*2)
      If newBitmap
      {
         gU := trGdip_GraphicsFromImage(A_ThisFunc, newBitmap)
         If gU
         {
            r4 := trGdip_DrawImage(A_ThisFunc, gU, pBitmap, marginuX, marginuY)
            If (r4!="fail")
            {
               hBitmap := trGdip_CreateHBITMAPFromBitmap(A_ThisFunc, newBitmap)
               SetImage(hCropCornersPic, hBitmap)
               Gdi_DeleteObject(hBitmap)
            }
            Gdip_DeleteGraphics(gU)
         }
         trGdip_DisposeImage(newBitmap, 1)
      }
      pageDPI := Round((hdcObj.hdc_xdpi + hdcObj.hdc_ydpi)/2)
      pageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi, 1)
      pageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi, 1)
      MMpageWr := Round(hdcObj.HDC_Width/hdcObj.hdc_xdpi * 25.4)
      MMpageHr := Round(hdcObj.HDC_Height/hdcObj.hdc_ydpi * 25.4)
      GuiControl, SettingsGUIA:, PrinterPageInfos, % "Page details:`n" pageWr " x " pageHr " in`n" MMpageWr " x " MMpageHr " mm`n" pageDPI " DPI"
   }

   Gdip_DeleteGraphics(gPrint)
   trGdip_DisposeImage(pBitmap, 1)
   Gdip_DisposeImageAttributes(imageAttribs)
   trGdip_DisposeImage(imgToPrint, 1)
}

AcquireWIAimage() {
    Static clippyCount
    If askAboutFileSave(" and the dialog to acquire an image from a WIA-ready device will open")
       Return

    setImageLoading()
    showTOOLtip("Acquiring image, please wait...")
    terminateIMGediting()
    Try hbmp := WIA_AcquireImage()
    Catch errMsg
       Sleep, 1

    If StrLen(hbmp)<4
    {
       ResetImgLoadStatus()
       showTOOLtip("Failed to acquire image...`n" errMsg.message)
       SoundBeep , 300, 100
       SetTimer, RemoveTooltip, % -msgDisplayTime
       Return
    } Else SoundBeep , 900, 100

    If hbmp
    {
       Gdip_GetImageDimensions(hbmp, imgW, imgH)
       If (imgW<5 || imgH<5)
       {
          ResetImgLoadStatus()
          hbmp := trGdip_DisposeImage(hbmp, 1)
          showTOOLtip("Failed to acquire image...`nMalformed image.")
          SoundBeep , 300, 100
          SetTimer, RemoveTooltip, % -msgDisplayTime
          Return
       }
    }

    UserMemBMP := hbmp
    clippyCount++
    If (!currentFileIndex || !CurrentSLD || !maxFilesIndex)
    {
       maxFilesIndex := currentFileIndex := 0
       resultedFilesList[currentFileIndex, 1] := "\Temporary Memory Object\WIA-Acquired-" clippyCount ".img"
    }

    imgIndexEditing := currentFileIndex
    usrColorDepth := imgFxMode := 1
    currIMGdetails.HasAlpha := 0
    vpIMGrotation := FlipImgH := FlipImgV := 0
    dropFilesSelection(1)
    RemoveTooltip()
    Gdi_DeleteObject(hbmp)
    SetTimer, ResetImgLoadStatus, -50
    SetTimer, RefreshImageFile, -50
}














testWICwhatever() {
/*
   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   GetWinClientSize(mainWidth, mainHeight, PVhwnd, 0)

   IWICImagingFactory_Initialize(pWICimgFactory, 1)
   IWICImagingFactory_CreateDecoderFromFilename(pWICimgFactory, imgPath,,,, ppIDecoder)
   IWICImagingFactory_CreateBitmapScaler(pWICimgFactory, ppIBitmapScaler)
   IWICImagingFactory_CreateFormatConverter(pWICimgFactory, ppIFormatConverter)

   IWICBitmapDecoder_GetFrameCount(ppIDecoder, fCount)
   IWICBitmapDecoder_GetFrame(ppIDecoder, 0, ppIBitmapSourceFrame)
   IWICBitmapScaler_Initialize(ppIBitmapScaler, ppIBitmapSourceFrame, mainWidth, mainHeight)
   ; IWICFormatConverter_Initialize(ppIFormatConverter, ppIBitmapScaler, "GUID_WICPixelFormat32bppBGR", 0, NULL, 0.1, 0)
*/

   MsgBox, % pWICimgFactory "`n" ppIDecoder "`n" fcount "`n" ppIBitmapSourceFrame "`nBMPscale" ppIBitmapScaler "`nFmtConv" ppIFormatConverter "`n" 
}

xxtestwhatever() {

   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x2
ppIDecoder := "lodekl"
   destroyGDIfileCache()
   wzFileName := getIDimage(currentFileIndex)

   thisObj := ComObjCreate("{cacaf262-9370-4615-a13b-9f5539da4c0a}", "{ec5ec8a9-c395-4314-9c77-54d7a935ff70}")
      thisObj.ThrowHRerrors := 1

   ; hr := DllCall(NumGet(NumGet(thisObj+0)+14*A_PtrSize), "ptr", thisObj, "ptr*", ppIWICStream)
   ;    WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)


   ; hr := DllCall(NumGet(NumGet(thisObj+0)+15*A_PtrSize), "ptr", thisObj, "str", wzFileName, "uint", dwDesiredAccess)
   ; if hr or ErrorLevel
   ;    WIC_hr(hr, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)

/*
   hr := DllCall(vtable(thisObj, 3)
         ,"ptr", thisObj
         ,"str", wzFilename
         ,"ptr", NULL ; WIC_GUID(GUID,pguidVendor)
         ,"uint", dwDesiredAccess
         ,"uint", metadataOptions
         ,"ptr*", ppIDecoder)
      WIC_hr(hr, ErrorLevel, A_ThisFunc) ; "`nErrorLevel: " ErrorLevel)
   MsgBox, % thisObj "`n" ppIDecoder "`n" vtable(thisObj, 3) ;  "`n" WIC_hr(HR, "init")
*/
}


gtestwhatever() {
; # dwDesiredAccess
; WIC_GENERIC_READ = 0x80000000
; WIC_GENERIC_WRITE = 0x40000000

; # WICBitmapCreateCacheOption
; WICBitmapNoCache = 0x0
; WICBitmapCacheOnDemand = 0x1
; WICBitmapCacheOnLoad = 0x2

; # WICDecodeOptions
; WICDecodeMetadataCacheOnDemand = 0x0
; WICDecodeMetadataCacheOnLoad = 0x1


   Static WinCodecSKDversion := 566 ; 0x236
        , dwDesiredAccess := 0x80000000
        , metadataOptions := 0x1

   destroyGDIfileCache()
   imgPath := getIDimage(currentFileIndex)
   DllCall("windowscodecs.dll\WICCreateImagingFactory_Proxy", "Uint", WinCodecSKDversion, "UPtr*", pWICimgFactory)

   HR := DllCall("windowscodecs.dll\IWICImagingFactory_CreateDecoderFromFilename_Proxy", "UPtr", pWICimgFactory, "Wstr", imgPath, "Ptr", GuidVendor, "Uint", dwDesiredAccess, "Uint", metadataOptions, "UPtr*", ppIDecoder)
   MsgBox, % pWICimgFactory "`n" ppIDecoder
}

SelectFolderEx(StartingFolder:="", DlgTitle:="", OwnerHwnd:=0, OkBtnLabel:="", comboList:="", desiredDefault:=1, comboLabel:="", CustomPlaces:="", pickFoldersOnly:=1, usrFilters:="", defIndexFilter:=1, FileMustExist:=1, defaultEditField:="") {
; ==================================================================================================================================
; Shows a dialog to select a folder.
; Depending on the OS version the function will use either the built-in FileSelectFolder command (XP and previous)
; or the Common Item Dialog (Vista and later).
;
; Parameter:
;     StartingFolder -  the full path of a folder which will be preselected.
;     DlgTitle       -  a text used as window title (Common Item Dialog) or as text displayed withing the dialog.
;     FileMustExist  -  [bool] to allow or not opening files that do not exist
;     ----------------  Common Item Dialog only:
;     OwnerHwnd      -  HWND of the Gui which owns the dialog. If you pass a valid HWND the dialog will become modal.
;     BtnLabel       -  a text to be used as caption for the apply button.
;     comboList      -  a string with possible drop-down options, separated by `n [new line]
;     desiredDefault -  the default selected drop-down row
;     comboLabel     -  the drop-down label to display
;     CustomPlaces   -  custom directories that will be displayed in the left pane of the dialog; missing directories will be omitted; a string separated by `n [newline]
;     pickFoldersOnly - boolean option [0, 1]
;     defaultEditField - the text to display in the edit field by default when the open dialog shows up
;
;  Return values:
;     On success the function returns an object with the full path of the selected/file folder
;     and combobox selected [if any]; otherwise it returns an empty string.
;
; MSDN:
;     Common Item Dialog -> msdn.microsoft.com/en-us/library/bb776913%28v=vs.85%29.aspx
;     IFileDialog        -> msdn.microsoft.com/en-us/library/bb775966%28v=vs.85%29.aspx
;     IShellItem         -> msdn.microsoft.com/en-us/library/bb761140%28v=vs.85%29.aspx
; ==================================================================================================================================
; Source https://www.autohotkey.com/boards/viewtopic.php?f=6&t=18939
; by «just me»
; modified by Marius Șucan on jeudi 7 mai 2020
; to allow ComboBox and CustomPlaces
;
; options flags
; FOS_OVERWRITEPROMPT  = 0x2,
; FOS_STRICTFILETYPES  = 0x4,
; FOS_NOCHANGEDIR  = 0x8,
; FOS_PICKFOLDERS  = 0x20,
; FOS_FORCEFILESYSTEM  = 0x40,
; FOS_ALLNONSTORAGEITEMS  = 0x80,
; FOS_NOVALIDATE  = 0x100,
; FOS_ALLOWMULTISELECT  = 0x200,
; FOS_PATHMUSTEXIST  = 0x800,
; FOS_FILEMUSTEXIST  = 0x1000,
; FOS_CREATEPROMPT  = 0x2000,
; FOS_SHAREAWARE  = 0x4000,
; FOS_NOREADONLYRETURN  = 0x8000,
; FOS_NOTESTFILECREATE  = 0x10000,
; FOS_HIDEMRUPLACES  = 0x20000,
; FOS_HIDEPINNEDPLACES  = 0x40000,
; FOS_NODEREFERENCELINKS  = 0x100000,
; FOS_OKBUTTONNEEDSINTERACTION  = 0x200000,
; FOS_DONTADDTORECENT  = 0x2000000,
; FOS_FORCESHOWHIDDEN  = 0x10000000,
; FOS_DEFAULTNOMINIMODE  = 0x20000000,
; FOS_FORCEPREVIEWPANEON  = 0x40000000,
; FOS_SUPPORTSTREAMABLEITEMS  = 0x80000000

; IFileDialog vtable offsets
; 0   QueryInterface
; 1   AddRef 
; 2   Release 
; 3   Show 
; 4   SetFileTypes 
; 5   SetFileTypeIndex 
; 6   GetFileTypeIndex 
; 7   Advise 
; 8   Unadvise 
; 9   SetOptions 
; 10  GetOptions 
; 11  SetDefaultFolder 
; 12  SetFolder 
; 13  GetFolder 
; 14  GetCurrentSelection 
; 15  SetFileName 
; 16  GetFileName 
; 17  SetTitle 
; 18  SetOkButtonLabel 
; 19  SetFileNameLabel 
; 20  GetResult 
; 21  AddPlace 
; 22  SetDefaultExtension 
; 23  Close 
; 24  SetClientGuid 
; 25  ClearClientData 
; 26  SetFilter


   Static OsVersion := DllCall("GetVersion", "UChar")
        , IID_IShellItem := 0
        , InitIID := VarSetCapacity(IID_IShellItem, 16, 0)
                  & DllCall("Ole32.dll\IIDFromString", "WStr", "{43826d1e-e718-42ee-bc55-a1e261c37bfe}", "Ptr", &IID_IShellItem)
        , ShowDialog := A_PtrSize * 3
        , SetFileTypes := A_PtrSize * 4
        , SetFileTypeIndex := A_PtrSize * 5
        , SetOptions := A_PtrSize * 9
        , SetFolder := A_PtrSize * 12
        , SetDefaultEdit := A_PtrSize * 15 ; SetFileName
        , SetWinTitle := A_PtrSize * 17
        , SetOkButtonLabel := A_PtrSize * 18
        , GetResult := A_PtrSize * 20
        , AddPlaces := A_PtrSize * 21
        , ComDlgObj := {COMDLG_FILTERSPEC: ""}

   SelectedFolder := ""
   OwnerHwnd := DllCall("IsWindow", "Ptr", OwnerHwnd, "UInt") ? OwnerHwnd : 0
   Try FileDialog := ComObjCreate("{DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7}", "{42f85136-db7e-439c-85f1-e4075d135fc8}")
   If !FileDialog
   {
      thisOption := (FileMustExist=1) ? 3 : 2
      FileSelectFolder, SelectedFolder, *%StartingFolder%, % thisOption, % DlgTitle
      Return SelectedFolder
   }

   VTBL := NumGet(FileDialog + 0, "UPtr") ; virtual table addresses
   dialogOptions := 0x8 | 0x800  ;  FOS_NOCHANGEDIR | FOS_PATHMUSTEXIST
   If (pickFoldersOnly=1)
      dialogOptions |= 0x20      ; FOS_PICKFOLDERS

   If (FileMustExist=1)
      dialogOptions |=  0x1000   ; FOS_FILEMUSTEXIST

   DllCall(NumGet(VTBL + SetOptions, "UPtr"), "Ptr", FileDialog, "UInt", dialogOptions, "UInt")
   If StartingFolder
   {
      If !DllCall("Shell32.dll\SHCreateItemFromParsingName", "WStr", StartingFolder, "Ptr", 0, "Ptr", &IID_IShellItem, "PtrP", FolderItem)
         DllCall(NumGet(VTBL + SetFolder, "UPtr"), "Ptr", FileDialog, "Ptr", FolderItem, "UInt")
   }

   If DlgTitle
      DllCall(NumGet(VTBL + SetWinTitle, "UPtr"), "Ptr", FileDialog, "WStr", DlgTitle, "UInt")
   If OkBtnLabel
      DllCall(NumGet(VTBL + SetOkButtonLabel, "UPtr"), "Ptr", FileDialog, "WStr", OkBtnLabel, "UInt")

   If (pickFoldersOnly!=1)
   {
       Filters := IsObject(usrFilters) ? usrFilters : {"All files": "*.*"}
       ObjSetCapacity(ComDlgObj, "COMDLG_FILTERSPEC", 2*Filters.Count() * A_PtrSize)
       for Description, FileTypes in Filters
       {
           ObjRawSet(ComDlgObj, "#" . A_Index, Trimmer(Description))
           , ObjRawSet(ComDlgObj, "@" . A_Index, Trimmer(StrReplace(FileTypes,"`n")))
           , NumPut(ObjGetAddress(ComDlgObj,"#" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * 2*(A_Index-1))        ; COMDLG_FILTERSPEC.pszName
           , NumPut(ObjGetAddress(ComDlgObj,"@" . A_Index)
           , ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC") + A_PtrSize * (2*(A_Index-1)+1))    ; COMDLG_FILTERSPEC.pszSpec
       }

       ; IFileDialog::SetFileName method 
       ; https://docs.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ifiledialog-setfilename
       If defaultEditField
          DllCall(NumGet(VTBL + SetDefaultEdit), "UPtr", FileDialog, "WStr", defaultEditField)

       ; IFileDialog::SetFileTypes method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775980(v=vs.85).aspx
       DllCall(NumGet(VTBL + SetFileTypes), "UPtr", FileDialog, "UInt", Filters.Count(), "UPtr", ObjGetAddress(ComDlgObj,"COMDLG_FILTERSPEC"))

       ; IFileDialog::SetFileTypeIndex method
       ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775978(v=vs.85).aspx
       If defIndexFilter
          DllCall(NumGet(VTBL + SetFileTypeIndex), "UPtr", FileDialog, "UInt", defIndexFilter)
   }

   If CustomPlaces
   {
      Loop, Parse, CustomPlaces, `n
      {
          Directory := Trim(A_LoopField, "`r `n `t`f`v`b")
          If FolderExist(Directory)
          {
             foo := 1
             DllCall("Shell32.dll\SHParseDisplayName", "UPtr", &Directory, "Ptr", 0, "UPtrP", PIDL, "UInt", 0, "UInt", 0)
             DllCall("Shell32.dll\SHCreateShellItem", "Ptr", 0, "Ptr", 0, "UPtr", PIDL, "UPtrP", IShellItem)
             ObjRawSet(ComDlgObj, IShellItem, PIDL)
             ; IFileDialog::AddPlace method
             ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775946(v=vs.85).aspx
             DllCall(NumGet(VTBL + AddPlaces), "UPtr", FileDialog, "UPtr", IShellItem, "UInt", foo)
          }
      }
   }

   If (comboList && comboLabel)
   {
      Try If ((FileDialogCustomize := ComObjQuery(FileDialog, "{e6fdd21a-163f-4975-9c8c-a69f1ba37034}")))
      {
         groupId := 616 ; arbitrarily chosen IDs
         comboboxId := 93270
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+26*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", groupId, "WStr", comboLabel) ; IFileDialogCustomize::StartVisualGroup
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+6*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId) ; IFileDialogCustomize::AddComboBox
         ; DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", itemOneId, "WStr", "Current folder") ; IFileDialogCustomize::AddControlItem
         
         entriesArray := []
         Loop, Parse, comboList,`n
         {
             elementu := Trim(A_LoopField, "`r `n `t`f`v`b")
             If elementu
             {
                Random, varA, 2, 900
                Random, varB, 2, 900
                thisID := varA varB
                If (A_Index=desiredDefault)
                   desiredIDdefault := thisID

                entriesArray[thisId] := elementu
                DllCall(NumGet(NumGet(FileDialogCustomize+0)+19*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", thisID, "WStr", elementu)
             }
         }

         DllCall(NumGet(NumGet(FileDialogCustomize+0)+25*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt", desiredIDdefault) ; IFileDialogCustomize::SetSelectedControlItem
         DllCall(NumGet(NumGet(FileDialogCustomize+0)+27*A_PtrSize), "Ptr", FileDialogCustomize) ; IFileDialogCustomize::EndVisualGroup
      }

   }

   If !DllCall(NumGet(VTBL + ShowDialog, "UPtr"), "Ptr", FileDialog, "Ptr", OwnerHwnd, "UInt")
   {
      If !DllCall(NumGet(VTBL + GetResult, "UPtr"), "Ptr", FileDialog, "PtrP", ShellItem, "UInt")
      {
         GetDisplayName := NumGet(NumGet(ShellItem + 0, "UPtr"), A_PtrSize * 5, "UPtr")
         If !DllCall(GetDisplayName, "Ptr", ShellItem, "UInt", 0x80028000, "PtrP", StrPtr) ; SIGDN_DESKTOPABSOLUTEPARSING
         {
            SelectedFolder := StrGet(StrPtr, "UTF-16")
            DllCall("Ole32.dll\CoTaskMemFree", "Ptr", StrPtr)
         }

         ObjRelease(ShellItem)
         if (FileDialogCustomize && entriesArray.Count())
         {
            if (DllCall(NumGet(NumGet(FileDialogCustomize+0)+24*A_PtrSize), "Ptr", FileDialogCustomize, "UInt", comboboxId, "UInt*", selectedItemId) == 0)
            { ; IFileDialogCustomize::GetSelectedControlItem
               if selectedItemId
                  thisComboSelected := entriesArray[selectedItemId]
            }   
         }
      }
   }
   If (FolderItem)
      ObjRelease(FolderItem)

   if (FileDialogCustomize)
      ObjRelease(FileDialogCustomize)

   ObjRelease(FileDialog)
   r := []
   r.SelectedDir := SelectedFolder
   r.SelectedCombo := thisComboSelected
   Return r
}

recentOpenedFolders() {
   If (allowRecordHistory=1)
   {
      historyList := readRecentEntries()
      historyList .= readRecentFileDesties()
      Loop, Parse, historyList, `n
      {
         If (A_Index>30)
            Break

         entryu := StrReplace(A_LoopField, "|")
         If (!entryu || RegExMatch(entryu, sldsPattern))
            Continue

         If FolderExist(entryu)
            entriesList .= entryu "`n"
      }
      Sort, entriesList, UD`n
   }
   Return Trimmer(entriesList)
}


;------------------------------
;
; Function: Dlg_OpenSaveFile
;
; Description:
;
;   Internal function used by <Dlg_OpenFile> and <Dlg_SaveFile> to create an
;   Open or Save dialog.
;
; Type:
;
;   Internal function.  Subject to change.  Do not call directly.
;
; Parameters:
;
;   p_Type - [Internal function only] Set to "O" or "Open" to create a Open
;       dialog.  Set to "S" or "Save" to create a Save dialog.
;
;   hOwner - A handle to the window that owns the dialog box.  This parameter
;       can be any valid window handle or it can be set to 0 or null if the
;       dialog box has no owner.  Note: A valid window handle must be specified
;       if the OFN_SHOWHELP flag is included (explicitly or implicitly).
;
;   p_Title - A string to be placed in the title bar of the dialog box.  If set
;       to null (the default), the system uses the default title (that is,
;       "Open" or "Save As").
;
;   p_Filter - One or more filter strings that determine which files are
;       displayed. [Optional] Each filter string is composed of two parts.
;       The first part describes the filter.  For example: "Text Files".  The
;       second part specifies the filter pattern and must be enclosed in
;       parenthesis.  For example "(*.txt)".  To specify multiple filter
;       patterns for a single display string, use a semicolon to separate the
;       patterns.  For example: "(*.txt;*.doc;*.bak)".  A pattern string can be
;       a combination of valid file name characters and the asterisk ("*")
;       wildcard character.  Do not include spaces in the pattern string.
;       Multiple filter strings are delimited by the "|" character.  For
;       example: "Text Files (*.txt)|Backup Files (*.bak)".
;
;   p_FilterIndex - 1-based filter index.  If set to null (the default), 1 is
;       used.  The index determines which filter string is pre-selected in the
;       "File Types" control.
;
;   p_Root - Root (startup) directory and/or default file name.  To specify a
;       root directory only, include the full path of the directory with a
;       trailing "\" character.  Ex: "C:\Program Files\".  To specify a startup
;       directory and a default file, include the full path of the default file.
;       Ex: "C:\My Stuff\My Program.html".  To specify a default file only,
;       include the file name without the path.  Ex: "My Program.html".  If a
;       default file name is included, the file name (sans the path) is shown in
;       the dialog's "File name:" edit field. If this parameter is set to null
;       (the default), the startup directory will be set using the OS default
;       for this dialog.  See the documentation for the OPENFILENAME structure
;       (lpstrInitialDir member) for more information.
;
;   p_DfltExt - Extension to append when none is given.  Ex: "txt".  The string
;       should not contain a period (".").  If this parameter is null (the
;       default) and the user fails to type an extension, no extension is
;       appended.
;
;   r_Flags - Flags used to initialize the dialog. [Optional, Input/Output] See
;       the *Flags* section for the details.
;
;   p_HelpHandler - Name of a developer-created function that is called when the
;       the user presses the Help button on the dialog. [Optional] See the *Help
;       Handler* section for the details.  Note: The OFN_SHOWHELP flag is
;       automatically added if this parameter contains a valid function name.
;
; Flags:
;
;   On input, the r_Flags parameter contains flags that are used to initialize
;   and/or determine the behavior of the dialog.  If set to 0 or null and
;   p_Type="O" (Open dialog), the OFN_FILEMUSTEXIST and OFN_HIDEREADONLY flags
;   are added automatically.  If r_Flag contains an interger value, the
;   parameter is assumed to contain bit flags.  See the function's static
;   variables for a list a valid bit flags.  Otherwise, text flags are assumed.
;   The following space-delimited text flags can be used.
;
;   AllowMultiSelect - Specifies that the File Name list box allows multiple
;       selections.
;
;   CreatePrompt - [Open dialog only] If the user specifies a file that does not
;       exist, this flag causes the dialog to prompt the user for permission to
;       create the file.
;
;   DontAddToRecent - Prevents the system from adding a link to the selected
;       file in the file system directory that contains the user's most recently
;       used documents.
;
;   Ex_NoPlacesBar - If specified, the places bar is not displayed.  If not
;       specified, Explorer-style dialog boxes include a places bar containing
;       icons for commonly-used folders, such as Favorites and Desktop.
;
;   FileMustExist - [Open dialog only (with implicit exceptions)] This flag
;       ensures that the user can only type names of existing files in the File
;       Name entry.  A message box is generated if an invalid file is entered.
;       Opinion: This flag should be specified in most circumstances.
;       IMPORTANT: If this flag is specified (explicitly or implicitly), the
;       PathMustExist flag is also used.  See the PathMustExist flag for the
;       rules that are enforced for both the Open and Save dialogs.
;
;   ForceShowHidden - Forces the showing of system and hidden files, thus
;       overriding the user setting to show or not show hidden files.  However,
;       a file that is marked both system and hidden is not shown.  Observation:
;       This flag does not work as expected on Windows XP (may also occur on
;       other (or all) versions of Windows).  When a directory that includes a
;       hidden file is first displayed (including the initial directory), hidden
;       files are not shown.  Clicking on the "Open" or "Save" button without
;       selecting a file will redisplay the list of files to include the hidden
;       file(s).
;
;   HideReadOnly - [Open dialog only] Hides the Read Only check box.  This flag
;       should be specified in most circumstances.
;
;   NoChangeDir - Restores the current directory to its original value if the
;       user changed the directory while searching for files.
;
;   NoDereferenceLinks - Directs the dialog box to return the path and file name
;       of the selected shortcut (.LNK) file.  If this value is not specified,
;       the dialog box returns the path and file name of the file referenced by
;       the shortcut.  Observation: For shortcuts to OS files, this works as
;       expected.  However, for other types of shortcuts, Ex: shortcuts to a web
;       site, the return value may not be what is expected.  Test thoroughly
;       before using.
;
;   NoReadOnlyReturn - [Save dialog only] Prevents the dialog from returning
;       names of existing files that have the read-only attribute.  If a
;       read-only file is selected, a message dialog is generated.  The dialog
;       will persist until the selection does not include a file with read-only
;       attribute.
;
;   NoTestFileCreate - By default, the dialog box creates a zero-length test
;       file to determine whether a new file can be created in the selected
;       directory.  Set this flag to prevent the creation of this test file.
;       This flag should be specified if the application saves the file on a
;       network drive with Create but no Modify privileges.
;
;   NoValidate - Specifies that the common dialog boxes allow invalid characters
;       in the returned file name.
;
;   OverwritePrompt - [Save dialog only] Causes the dialog to generate a message
;       box if the selected file already exists.  The user must confirm whether
;       to overwrite the file.
;
;   PathMustExist - Specifies that the user can type only existing paths in the
;       File Name entry.  A message box is generated if an invalid path is
;       entered.  Note: This flag is automatically added if the FileMustExist
;       flag is used.
;
;   ReadOnly - [Open dialog only] Causes the Read Only check box to be selected
;       initially when the dialog box is created.
;
;   ShowHelp - Causes the dialog to display the Help button.
;
;   On output, the r_Flag parameter may contain bit flags that inform the
;   developer of conditions of the dialog at the time the dialog was closed.
;   The following bit flags can be set.
;
;   OFN_READONLY (0x1) - [Open dialog only] This flag is set if the Read Only
;       check box was checked when the dialog was closed.
;
;   OFN_EXTENSIONDIFFERENT (0x400) - This flag is set if the p_DfltExt parameter
;       is not null and the user selected or typed a file name extension that
;       differs from the p_DfltExt parameter.  Exception: This flag is not set
;       if multiple files are selected.
;
; Returns:
;
;   Selected file name(s) or null if cancelled.  If more then one file is
;   selected, each file is delimited by a new line ("`n") character.
;
; Remarks:
;
;   If the user changes the directory while using the Open or Save dialog, the
;   script's working directory will also be changed.  If desired, use the
;   "NoChangeDir" flag (r_Flags parameter) to prevent this from occurring or use
;   the *SetWorkingDir* command to restore the working directory after calling
;   this function.
;
; Help Handler:
;
;   The "Help Handler" is an optional developer-created function that is called
;   when the user presses the Help button on the dialog.
;
;   The handler function must have at least 2 parameters.  Additional parameters
;   are allowed but must be optional (defined with a default value).  The
;   required parameters are defined/used as follows, and in the following order:
;
;       hDialog - The handle to the dialog window.
;
;       lpInitStructure - A pointer to the initialization structure for the
;           common dialog box. For this handler, the pointer is to a
;           OPENFILENAME structure.
;
;   It's up to the developer to determine what commands are performed in this
;   function but displaying some sort of help message/document is what is
;   expected.
;
;   To avoid interference with the operation of the dialog, the handler should
;   either 1) finish quickly or 2) any dialogs displayed via the handler should
;   be modal.  See the scripts included with this project for an example.
;
;-------------------------------------------------------------------------------
Dlg_OpenSaveFile(p_Type,hOwner:=0,p_Title:="",p_Filter:="",p_FilterIndex:="",p_Root:="",p_DfltExt:="",ByRef r_Flags:=0,p_HelpHandler:="") {
; function source: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=462
; by jballi

    Static Dummy16963733
          ,s_strFileMaxSize:=32768
                ;-- This is the ANSI byte limit.  For consistency, this value
                ;   is also used to set the the maximum number characters that
                ;   used in Unicode.  Note: Only the first entry contains the
                ;   folder name so 32K characters can hold a very large number
                ;   of file names.

          ,HELPMSGSTRING:="commdlg_help"
                ;-- Registered message string for the Help button on common
                ;   dialogs

          ,OPENFILENAME
                ;-- Static OPENFILENAME structure.  Also used by the hook
                ;   callback and the help message.

          ;-- Open File Name flags
          ,OFN_ALLOWMULTISELECT    :=0x200
          ,OFN_CREATEPROMPT        :=0x2000
          ,OFN_DONTADDTORECENT     :=0x2000000
          ,OFN_ENABLEHOOK          :=0x20

          ,OFN_EXPLORER            :=0x80000
                ;-- This flag is set by default.  This function does not work
                ;   with the old-style dialog box.

          ,OFN_EXTENSIONDIFFERENT  :=0x400
                ;-- Output flag only.

          ,OFN_FILEMUSTEXIST       :=0x1000
          ,OFN_FORCESHOWHIDDEN     :=0x10000000
          ,OFN_HIDEREADONLY        :=0x4

          ,OFN_NOCHANGEDIR         :=0x8
          ,OFN_NODEREFERENCELINKS  :=0x100000

          ,OFN_NOREADONLYRETURN    :=0x8000
          ,OFN_NOTESTFILECREATE    :=0x10000
          ,OFN_NOVALIDATE          :=0x100
          ,OFN_OVERWRITEPROMPT     :=0x2
          ,OFN_PATHMUSTEXIST       :=0x800
          ,OFN_READONLY            :=0x1
          ,OFN_SHOWHELP            :=0x10

          ;-- Open File Name extended flags
          ,OFN_EX_NOPLACESBAR      :=0x1
                ;-- Note: This flag is only available as a text flag, i.e.
                ;   "NoPlacesBar".

          ;-- Misc.
          ,TCharSize:=A_IsUnicode ? 2:1

    ;[==============]
    ;[  Parameters  ]
    ;[==============]
    ;-- Type
    p_Type:=SubStr(p_Type,1,1)
    StringUpper p_Type,p_Type
        ;-- Convert to uppercase to simplify processing

    if p_Type not in O,S
        p_Type:="O"

    ;-- Filter
    if p_Filter is Space
        p_Filter:="All Files (*.*)"

    ;-- Flags
    l_Flags  :=OFN_EXPLORER
    l_FlagsEx:=0
    if not r_Flags  ;-- Zero, blank, or null
    {
        if (p_Type="O")  ;-- Open dialog only
            l_Flags|=OFN_FILEMUSTEXIST|OFN_HIDEREADONLY
    } else
    {
        ;-- Bit flags
        if r_Flags is Integer
        {
            l_Flags|=r_Flags
        } else
        {
            ;-- Convert text flags into bit flags
            Loop Parse,r_Flags,%A_Tab%%A_Space%,%A_Tab%%A_Space%
            {
                if A_LoopField is not Space
                {
                    if OFN_%A_LoopField% is Integer
                    {
                        if InStr(A_LoopField,"ex_")
                            l_FlagsEx|=OFN_%A_LoopField%
                        else
                            l_Flags|=OFN_%A_LoopField%
                    }
                }
            }
        }
    }

    if IsFunc(p_HelpHandler)
        l_Flags|=OFN_SHOWHELP

    ; if (p_Type="O") and (l_Flags & OFN_ALLOWMULTISELECT)
    ;     l_Flags|=OFN_ENABLEHOOK

    ;-- Create and, if needed, populate the buffer used to initialize the
    ;   File Name Edit control.  The dialog will also use this buffer to return
    ;   the file(s) selected.
    VarSetCapacity(strFile,s_strFileMaxSize*TCharSize,0)
    SplitPath p_Root,l_RootFileName,l_RootDir
    if l_RootFileName is not Space
    {
        DllCall("RtlMoveMemory"
            ,"Str",strFile
            ,"Str",l_RootFileName
            ,"UInt",(StrLen(l_RootFileName)+1)*TCharSize)
    }

    ;-- Convert p_Filter into the format required by the API
    VarSetCapacity(strFilter,StrLen(p_Filter)*(A_IsUnicode ? 5:3),0)
        ;-- Enough space for the full description _and_ file pattern(s) of all
        ;   filter strings (ANSI and Unicode) plus null characters between all
        ;   of the pieces and a double null at the end.

    l_Offset:=&strFilter
    Loop Parse,p_Filter,|
    {
        ;-- Break the filter string into 2 parts
        l_LoopField:=Trim(A_LoopField," `f`n`r`t`v")
            ;-- Assign and remove all leading/trailing white space

        l_Part1:=l_LoopField
            ;-- Part 1: The entire filter string which includes the description
            ;   and the file pattern(s) in parenthesis.  This is what is
            ;   displayed in  the "File Of Types" or the "Save As Type"
            ;   drop-down.

        l_Part2:=SubStr(l_LoopField,InStr(l_LoopField,"(")+1,-1)
            ;-- Part 2: File pattern(s) sans parenthesis.  The dialog uses this
            ;   to filter the files that are displayed.

        ;-- Calculate the length of the pieces
        l_lenPart1:=(StrLen(l_LoopField)+1)*TCharSize
            ;-- Size includes terminating null

        l_lenPart2:=(StrLen(l_Part2)+1)*TCharSize
            ;-- Size includes terminating null

        ;-- Copy the pieces to the filter string.  Each piece includes a
        ;   terminating null character.
        DllCall("RtlMoveMemory","Ptr",l_Offset,"Str",l_Part1,"UInt",l_lenPart1)
        DllCall("RtlMoveMemory","Ptr",l_Offset+l_lenPart1,"Str",l_Part2,"UInt",l_lenPart2)                          ;-- Length

        ;-- Calculate the offset of the next filter string
        l_Offset+=l_lenPart1+l_lenPart2
    }

    ;[==================]
    ;[  Pre-Processing  ]
    ;[==================]
    ;-- Create and populate the OPENFILENAME structure
    lStructSize:=VarSetCapacity(OPENFILENAME,(A_PtrSize=8) ? 152:88,0)
    NumPut(lStructSize,OPENFILENAME,0,"UInt")
        ;-- lStructSize
    NumPut(hOwner,OPENFILENAME,(A_PtrSize=8) ? 8:4,"Ptr")
        ;-- hwndOwner
    NumPut(&strFilter,OPENFILENAME,(A_PtrSize=8) ? 24:12,"Ptr")
        ;-- lpstrFilter
    NumPut(p_FilterIndex,OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
        ;-- nFilterIndex
    NumPut(&strFile,OPENFILENAME,(A_PtrSize=8) ? 48:28,"Ptr")
        ;-- lpstrFile
    NumPut(s_strFileMaxSize,OPENFILENAME,(A_PtrSize=8) ? 56:32,"UInt")
        ;-- nMaxFile
    NumPut(&l_RootDir,OPENFILENAME,(A_PtrSize=8) ? 80:44,"Ptr")
        ;-- lpstrInitialDir
    NumPut(&p_Title,OPENFILENAME,(A_PtrSize=8) ? 88:48,"Ptr")
        ;-- lpstrTitle
    NumPut(l_Flags,OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
        ;-- Flags
    NumPut(&p_DfltExt,OPENFILENAME,(A_PtrSize=8) ? 104:60,"Ptr")
        ;-- lpstrDefExt
    NumPut(l_FlagsEx,OPENFILENAME,(A_PtrSize=8) ? 148:84,"UInt")
        ;-- FlagsEx

    ;[===============]
    ;[  Show dialog  ]
    ;[===============]
    if (p_type="O")
        RC:=DllCall("comdlg32\GetOpenFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)
    else
        RC:=DllCall("comdlg32\GetSaveFileName" . (A_IsUnicode ? "W":"A"),"Ptr",&OPENFILENAME)

    ;[===================]
    ;[  Post-Processing  ]
    ;[===================]
    ;-- If needed, turn off monitoring of help message
    if l_HelpMsg
        OnMessage(l_HelpMsg,"")  ;-- Turn off monitoring

    ;-- Dialog canceled?
    if (RC=0)
        Return

    ;-- Rebuild r_Flags for output
    r_Flags  :=0
    l_Flags:=NumGet(OPENFILENAME,(A_PtrSize=8) ? 96:52,"UInt")
    n_FilterIndex := NumGet(OPENFILENAME,(A_PtrSize=8) ? 44:24,"UInt")
    ;-- Flags

    if p_DfltExt is not Space  ;-- Flag is ignored unless p_DfltExt contains a value
    {
        if l_Flags & OFN_EXTENSIONDIFFERENT
            r_Flags|=OFN_EXTENSIONDIFFERENT
    }

    if (p_Type="O")  ;-- i.e. flag is ignored if using the Save dialog
    {
        if l_Flags & OFN_ALLOWMULTISELECT
        {
            ; Hook was used to collect ReadOnly status.  Collect the ReadOnly
            ; status from the hook function.
            Sleep, 1
            ; if Dlg_OFNHookCallback("GetReadOnly","","","")
            ; r_Flags|=OFN_READONLY
        } else
        {
            ;-- Hook was NOT used to collect ReadOnly status.  Determine status from l_Flags
            if l_Flags & OFN_READONLY
                r_Flags|=OFN_READONLY
        }
    }

    ;-- Extract file(s) from the buffer
    l_FileList:=""
    l_Offset  :=&strFile
    Loop
    {
        ;-- Get next
        l_Next:=StrGet(l_Offset,-1)

        ;-- End of list?
        if not StrLen(l_Next)
        {
            ;-- If end-of-list occurs on the 2nd iteration, it means that only
            ;   one file was selected
            if (A_Index=2)
                l_FileList:=l_FileName
            Break
        }

        ;-- Assign to working variable
        l_FileName:=l_Next

        ;-- Update the offset for the next iteration
        l_Offset+=(StrLen(l_FileName)+1)*TCharSize

        ;-- If this is the first iteration, we have to wait until the next loop
        ;   before we can determine if this is a directory or file and if a
        ;   file, if it is the only file selected.
        if (A_Index=1)
        {
            l_Dir:=l_FileName
            ;-- Windows adds "\" character when in root of the drive but doesn't
            ;   add it otherwise.  Adjust if needed.
            if (StrLen(l_Dir)<>3)
                l_Dir.="\"

            ;-- Continue to next
            Continue
        }

        ;-- Add the file to the list
        l_FileList.=(StrLen(l_FileList) ? "`n":"") . l_Dir . l_FileName
    }
    ; ToolTip, % n_FilterIndex , , , 2
    ;-Return to sender
    Return l_FileList
}

SHGetKnownFolderPath(FOLDERID, KF_FLAG:=0) {                  ;   By SKAN on D356 @ tiny.cc/t-75602 
   ; FOLDERID_AccountPictures         := "{008ca0b1-55b4-4c56-b8a8-4de4b299d3be}" ; Windows  8
   ; FOLDERID_AddNewPrograms          := "{de61d971-5ebc-4f02-a3a9-6c82895e5c04}"  
   ; FOLDERID_AdminTools              := "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"  
   ; FOLDERID_AppDataDesktop          := "{B2C5E279-7ADD-439F-B28C-C41FE1BBF672}" ; Windows  10, version 1709
   ; FOLDERID_AppDataDocuments        := "{7BE16610-1F7F-44AC-BFF0-83E15F2FFCA1}" ; Windows  10, version 1709
   ; FOLDERID_AppDataFavorites        := "{7CFBEFBC-DE1F-45AA-B843-A542AC536CC9}" ; Windows  10, version 1709
   ; FOLDERID_AppDataProgramData      := "{559D40A3-A036-40FA-AF61-84CB430A4D34}" ; Windows  10, version 1709
   ; FOLDERID_ApplicationShortcuts    := "{A3918781-E5F2-4890-B3D9-A7E54332328C}" ; Windows  8
   ; FOLDERID_AppsFolder              := "{1e87508d-89c2-42f0-8a7e-645a0f50ca58}" ; Windows  8
   ; FOLDERID_AppUpdates              := "{a305ce99-f527-492b-8b1a-7e76fa98d6e4}"  
   ; FOLDERID_CameraRoll              := "{AB5FB87B-7CE2-4F83-915D-550846C9537B}" ; Windows  8.1
   ; FOLDERID_CDBurning               := "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"  
   ; FOLDERID_ChangeRemovePrograms    := "{df7266ac-9274-4867-8d55-3bd661de872d}"  
   ; FOLDERID_CommonAdminTools        := "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"  
   ; FOLDERID_CommonOEMLinks          := "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"  
   ; FOLDERID_CommonPrograms          := "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"  
   ; FOLDERID_CommonStartMenu         := "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"  
   ; FOLDERID_CommonStartup           := "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"  
   ; FOLDERID_CommonTemplates         := "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"  
   ; FOLDERID_ComputerFolder          := "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"  
   ; FOLDERID_ConflictFolder          := "{4bfefb45-347d-4006-a5be-ac0cb0567192}" ; Windows  Vista
   ; FOLDERID_ConnectionsFolder       := "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"  
   ; FOLDERID_Contacts                := "{56784854-C6CB-462b-8169-88E350ACB882}" ; Windows  Vista
   ; FOLDERID_ControlPanelFolder      := "{82A74AEB-AEB4-465C-A014-D097EE346D63}"  
   ; FOLDERID_Cookies                 := "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"  
   ; FOLDERID_Desktop                 := "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"  
   ; FOLDERID_DeviceMetadataStore     := "{5CE4A5E9-E4EB-479D-B89F-130C02886155}" ; Windows  7
   ; FOLDERID_Documents               := "{FDD39AD0-238F-46AF-ADB4-6C85480369C7}"  
   ; FOLDERID_DocumentsLibrary        := "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}" ; Windows  7
   ; FOLDERID_Downloads               := "{374DE290-123F-4565-9164-39C4925E467B}"  
   ; FOLDERID_Favorites               := "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"  
   ; FOLDERID_Fonts                   := "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"  
   ; FOLDERID_Games                   := "{CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}"  
   ; FOLDERID_GameTasks               := "{054FAE61-4DD8-4787-80B6-090220C4B700}" ; Windows  Vista
   ; FOLDERID_History                 := "{D9DC8A3B-B784-432E-A781-5A1130A75963}"  
   ; FOLDERID_HomeGroup               := "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}" ; Windows  7
   ; FOLDERID_HomeGroupCurrentUser    := "{9B74B6A3-0DFD-4f11-9E78-5F7800F2E772}" ; Windows  8
   ; FOLDERID_ImplicitAppShortcuts    := "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}" ; Windows  7
   ; FOLDERID_InternetCache           := "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"  
   ; FOLDERID_InternetFolder          := "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"  
   ; FOLDERID_Libraries               := "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}" ; Windows  7
   ; FOLDERID_Links                   := "{bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}"  
   ; FOLDERID_LocalAppData            := "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"  
   ; FOLDERID_LocalAppDataLow         := "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"  
   ; FOLDERID_LocalizedResourcesDir   := "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"  
   ; FOLDERID_Music                   := "{4BD8D571-6D19-48D3-BE97-422220080E43}"  
   ; FOLDERID_MusicLibrary            := "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}" ; Windows  7
   ; FOLDERID_NetHood                 := "{C5ABBF53-E17F-4121-8900-86626FC2C973}"  
   ; FOLDERID_NetworkFolder           := "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"  
   ; FOLDERID_Objects3D               := "{31C0DD25-9439-4F12-BF41-7FF4EDA38722}" ; Windows  10, version 1703
   ; FOLDERID_OriginalImages          := "{2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}" ; Windows  Vista
   ; FOLDERID_PhotoAlbums             := "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}" ; Windows  Vista
   ; FOLDERID_PicturesLibrary         := "{A990AE9F-A03B-4E80-94BC-9912D7504104}" ; Windows  7
   ; FOLDERID_Pictures                := "{33E28130-4E1E-4676-835A-98395C3BC3BB}"  
   ; FOLDERID_Playlists               := "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"  
   ; FOLDERID_PrintersFolder          := "{76FC4E2D-D6AD-4519-A663-37BD56068185}"  
   ; FOLDERID_PrintHood               := "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"  
   ; FOLDERID_Profile                 := "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"  
   ; FOLDERID_ProgramData             := "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"  
   ; FOLDERID_ProgramFiles            := "{905e63b6-c1bf-494e-b29c-65b732d3d21a}"  
   ; FOLDERID_ProgramFilesX64         := "{6D809377-6AF0-444b-8957-A3773F02200E}"  
   ; FOLDERID_ProgramFilesX86         := "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"  
   ; FOLDERID_ProgramFilesCommon      := "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"  
   ; FOLDERID_ProgramFilesCommonX64   := "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"  
   ; FOLDERID_ProgramFilesCommonX86   := "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"  
   ; FOLDERID_Programs                := "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"  
   ; FOLDERID_Public                  := "{DFDF76A2-C82A-4D63-906A-5644AC457385}"  
   ; FOLDERID_PublicDesktop           := "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"  
   ; FOLDERID_PublicDocuments         := "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"  
   ; FOLDERID_PublicDownloads         := "{3D644C9B-1FB8-4f30-9B45-F670235F79C0}" ; Windows  Vista
   ; FOLDERID_PublicGameTasks         := "{DEBF2536-E1A8-4c59-B6A2-414586476AEA}" ; Windows  Vista
   ; FOLDERID_PublicLibraries         := "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}" ; Windows  7
   ; FOLDERID_PublicMusic             := "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"  
   ; FOLDERID_PublicPictures          := "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"  
   ; FOLDERID_PublicRingtones         := "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}" ; Windows  7
   ; FOLDERID_PublicUserTiles         := "{0482af6c-08f1-4c34-8c90-e17ec98b1e17}" ; Windows  8
   ; FOLDERID_PublicVideos            := "{2400183A-6185-49FB-A2D8-4A392A602BA3}"  
   ; FOLDERID_QuickLaunch             := "{52a4f021-7b75-48a9-9f6b-4b87a210bc8f}"  
   ; FOLDERID_Recent                  := "{AE50C081-EBD2-438A-8655-8A092E34987A}"  
   ; FOLDERID_RecordedTV              := "{1A6FDBA2-F42D-4358-A798-B74D745926C5}" ; Windows  7
   ; FOLDERID_RecycleBinFolder        := "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"  
   ; FOLDERID_ResourceDir             := "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"  
   ; FOLDERID_Ringtones               := "{C870044B-F49E-4126-A9C3-B52A1FF411E8}" ; Windows  7
   ; FOLDERID_RoamingAppData          := "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"  
   ; FOLDERID_RoamedTileImages        := "{AAA8D5A5-F1D6-4259-BAA8-78E7EF60835E}" ; Windows  8
   ; FOLDERID_RoamingTiles            := "{00BCFC5A-ED94-4e48-96A1-3F6217F21990}" ; Windows  8
   ; FOLDERID_SampleMusic             := "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"  
   ; FOLDERID_SamplePictures          := "{C4900540-2379-4C75-844B-64E6FAF8716B}"  
   ; FOLDERID_SamplePlaylists         := "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}" ; Windows  Vista
   ; FOLDERID_SampleVideos            := "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"  
   ; FOLDERID_SavedGames              := "{4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}" ; Windows  Vista
   ; FOLDERID_SavedPictures           := "{3B193882-D3AD-4eab-965A-69829D1FB59F}"  
   ; FOLDERID_SavedPicturesLibrary    := "{E25B5812-BE88-4bd9-94B0-29233477B6C3}"  
   ; FOLDERID_SavedSearches           := "{7d1d3a04-debb-4115-95cf-2f29da2920da}"  
   ; FOLDERID_Screenshots             := "{b7bede81-df94-4682-a7d8-57a52620b86f}" ; Windows  8
   ; FOLDERID_SEARCH_CSC              := "{ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}"  
   ; FOLDERID_SearchHistory           := "{0D4C3DB6-03A3-462F-A0E6-08924C41B5D4}" ; Windows  8.1
   ; FOLDERID_SearchHome              := "{190337d1-b8ca-4121-a639-6d472d16972a}"  
   ; FOLDERID_SEARCH_MAPI             := "{98ec0e18-2098-4d44-8644-66979315a281}"  
   ; FOLDERID_SearchTemplates         := "{7E636BFE-DFA9-4D5E-B456-D7B39851D8A9}" ; Windows  8.1
   ; FOLDERID_SendTo                  := "{8983036C-27C0-404B-8F08-102D10DCFD74}"  
   ; FOLDERID_SidebarDefaultParts     := "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"  
   ; FOLDERID_SidebarParts            := "{A75D362E-50FC-4fb7-AC2C-A8BEAA314493}"  
   ; FOLDERID_SkyDrive                := "{A52BBA46-E9E1-435f-B3D9-28DAA648C0F6}" ; Windows  8.1
   ; FOLDERID_SkyDriveCameraRoll      := "{767E6811-49CB-4273-87C2-20F355E1085B}" ; Windows  8.1
   ; FOLDERID_SkyDriveDocuments       := "{24D89E24-2F19-4534-9DDE-6A6671FBB8FE}" ; Windows  8.1
   ; FOLDERID_SkyDrivePictures        := "{339719B5-8C47-4894-94C2-D8F77ADD44A6}" ; Windows  8.1
   ; FOLDERID_StartMenu               := "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"  
   ; FOLDERID_Startup                 := "{B97D20BB-F46A-4C97-BA10-5E3608430854}"  
   ; FOLDERID_SyncManagerFolder       := "{43668BF8-C14E-49B2-97C9-747784D784B7}" ; Windows  Vista
   ; FOLDERID_SyncResultsFolder       := "{289a9a43-be44-4057-a41b-587a76d7e7f9}" ; Windows  Vista
   ; FOLDERID_SyncSetupFolder         := "{0F214138-B1D3-4a90-BBA9-27CBC0C5389A}" ; Windows  Vista
   ; FOLDERID_System                  := "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"  
   ; FOLDERID_SystemX86               := "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"  
   ; FOLDERID_Templates               := "{A63293E8-664E-48DB-A079-DF759E0509F7}"  
   ; FOLDERID_TreeProperties          := "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}" ; Windows  7
   ; FOLDERID_UserProfiles            := "{0762D272-C50A-4BB0-A382-697DCD729B80}"  
   ; FOLDERID_UserProgramFiles        := "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}" ; Windows  7
   ; FOLDERID_UserProgramFilesCommon  := "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}" ; Windows  7
   ; FOLDERID_UsersFiles              := "{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}"  
   ; FOLDERID_UsersLibraries          := "{A302545D-DEFF-464b-ABE8-61C8648D939B}" ; Windows  7
   ; FOLDERID_Videos                  := "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"  
   ; FOLDERID_VideosLibrary           := "{491E922F-5643-4AF4-A7EB-4E7A138D8174}" ; Windows  7
   ; FOLDERID_Windows                 := "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"  
   ; function by Skan: https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75602&sid=f29192e2e8a74e847f62a152afa55aa1
   Local CLSID, pPath:=""                                        ; Thanks teadrinker @ tiny.cc/p286094
   Return Format("{4:}", VarSetCapacity(CLSID, 16, 0)
        , DllCall("ole32\CLSIDFromString", "Str",FOLDERID, "Ptr",&CLSID)
        , DllCall("shell32\SHGetKnownFolderPath", "Ptr",&CLSID, "UInt",KF_FLAG, "Ptr",0, "PtrP",pPath)
        , StrGet(pPath, "utf-16")
        , DllCall("ole32\CoTaskMemFree", "Ptr",pPath))

}

processFlags(n, b:=32, d:="`n", f:="") {
; by SKAN @ tiny.cc/t-75877
; https://www.autohotkey.com/boards/viewtopic.php?f=6&t=75877

   Loop %b%
   {
       f .= Format( n & 1 ? "0x{1:x}{2:}"  : ""
                  , n & 1 ? 2**(A_Index-1) : 0, d, n >>= 1)
   }
   Return RTrim(f, d) 
}

testArkive() {
 
lola := Gdip_GetImageFlags(gdiBitmap)
MsgBox, % lola "`n" processFlags(lola, 128)

    ;     loop, files, E:\Sucan twins\_small-apps\AutoHotkey\other scripts\flipeador-Library-AutoHotkey-master\Library-AutoHotkey-master\graphics\Gdiplus\*, R
;     {
;           If (A_LoopFileExt="ahk")
;           {
;              FileRead, filecontent, % A_LoopFileLongPath
;              concat .= filecontent "`n`n"
;           }
; }
;           FileAppend, % concat, % mainCompiledPath "\mergedFiles.ahk"
;     SoundBeep 
}



Class IDesktopWallpaper 
{
; class created by Flipeador
; source https://github.com/flipeador/Library-AutoHotkey/blob/master/device/IDesktopWallpaper.ahk

    ; ===================================================================================================================
    ; CONSTRUCTOR
    ; ===================================================================================================================
    __New() {
        this.IDesktopWallpaper := ComObjCreate("{C2CF3110-460E-4fc1-B9D0-8A1C0C9CC4BD}", "{B92B56A9-8B55-4E14-9A89-0199BBB6F93B}")

        For Each, Method in ["SetWallpaper","GetWallpaper","GetMonitorDevicePathAt","GetMonitorDevicePathCount","GetMonitorRECT","SetBackgroundColor","GetBackgroundColor","SetPosition","GetPosition","SetSlideshow", "GetSlideshow","SetSlideshowOptions","GetSlideshowOptions","AdvanceSlideshow","GetStatus","Enable"]
            ObjRawSet(this, "p" . Method, NumGet(NumGet(this.IDesktopWallpaper), (2 + A_Index) * A_PtrSize))
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/bb775771(v=vs.85).aspx

    ; ===================================================================================================================
    ; DESTRUCTOR
    ; ===================================================================================================================
    __Delete() {
        Return ObjRelease(this.IDesktopWallpaper)
    }

    ; ===================================================================================================================
    ; PRIVATE METHODS
    ; ===================================================================================================================
    _R(R, pBuffer, ByRef Var := "", Error := "") {
        If (R == 0)
        {
            If (IsByRef(Var))
                Var := StrGet(pBuffer, "UTF-16")
            DllCall("Kernel32.dll\GlobalFree", "UPtr", pBuffer, "UPtr")
        }
        Else If (IsByRef(Var))
            Var := Error
        Return R
    }

    ; ===================================================================================================================
    ; PUBLIC METHODS
    ; ===================================================================================================================
    /*
        Establece el fondo de escritorio.
        Parámetros:
            MonitorID: El identificador del monitor. Este valor se puede obtener a través de GetMonitorDevicePathAt. Establezca este valor en NULL para establecer la imagen en todos los monitores.
            Wallpaper: La ruta completa del archivo de imagen de fondo de pantalla.
    */
    SetWallpaper(MonitorID, Wallpaper) {
        Return DllCall(this.pSetWallpaper, "UPtr", this.IDesktopWallpaper, "Ptr", MonitorID, "UPtr", &Wallpaper, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706962(v=vs.85).aspx

    /*
        Recupera el identificador de uno de los monitores del sistema.
        Parámetros:
            MonitorIndex: El número del monitor. LLame a GetMonitorDevicePathCount para determinar el número total de monitores.
            MonitorID   : Recibe el identificador del monitor.
    */
    GetMonitorDevicePathAt(MonitorIndex, ByRef MonitorID) {
        Return this._R(DllCall(this.pGetMonitorDevicePathAt, "UPtr", this.IDesktopWallpaper, "UInt", MonitorIndex, "UPtrP", pBuffer, "UInt"), pBuffer, MonitorID)
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706950(v=vs.85).aspx

    /*
        Recupera la cantidad de monitores que están asociados con el sistema.
        Parámetros:
            Count: Recibe la cantidad de monitores.
    */
    GetMonitorDevicePathCount(ByRef Count) {
        Return DllCall(this.pGetMonitorDevicePathCount, "UPtr", this.IDesktopWallpaper, "UIntP", Count, "UInt")
    } ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706951(v=vs.85).aspx

} ; https://msdn.microsoft.com/en-us/library/windows/desktop/hh706946(v=vs.85).aspx




testeGDIspeed() {
   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(2)
   pa := A_TickCount - startZeit

   startZeit := A_TickCount
   Loop, 100
      GdipCleanMain(10)

   pb := A_TickCount - startZeit
   MsgBox, % pa "`n" pb
}

isFileLocked(imgPath) {
   If !FileRexists(imgPath)
      Return -1

   myFile := fileOpen(imgPath, "a")
   If IsObject(myFile)
   {
      myFile.Close()
      Return 0
   } Else Return 1
}

trGdip_CreateBitmap(funcu, Width, Height, PixelFormat:=0, Stride:=0, Scan0:=0) {
    PixelFormat := (PixelFormat="0xE200B") ? coreDesiredPixFmt : PixelFormat
    r := Gdip_CreateBitmap(Width, Height, PixelFormat, Stride, Scan0)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() called by " funcu "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() called by " funcu "() using w" Width " - h" Height " - pixFmt" PixelFormat " failed: " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateBitmapFromFile(sFile, IconNumber:=1, IconSize:="", useICM:=0) {
    r := Gdip_CreateBitmapFromFile(sFile, IconNumber, IconSize, useICM)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() error: " Gdip_ErrorHandler(gdipLastError, 0) "`nFile to load:" sFile)

    Return r
}

trGdip_CreateBitmapFromHBITMAP(hBitmap, hPalette:=0) {
    r := Gdip_CreateBitmapFromHBITMAP(hBitmap, hPalette)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
       addJournalEntry(A_ThisFunc "() has created possibly a faulty object: " Gdip_ErrorHandler(gdipLastError, 0))

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, hBitmap = " hBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateHBITMAPFromBitmap(funcu, pBitmap, bgr:=0) {
    r := Gdip_CreateHBITMAPFromBitmap(pBitmap, bgr)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If !r
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CreateARGBBitmapFromHBITMAP(hBitmap) {
    r := Gdip_CreateARGBBitmapFromHBITMAP(hBitmap)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed to create pBitmap from hBitmap = " hBitmap)

    Return r
}

trGdip_BitmapConvertGray(pBitmap, hue:=0, vibrance:=-40, brightness:=1, contrast:=0, KeepPixelFormat:=0) {
    r := Gdip_BitmapConvertGray(pBitmap, hue, vibrance, brightness, contrast, KeepPixelFormat)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "(): failed, pBitmap = " pBitmap)
    Return r
}

trGdip_CloneBitmapArea(funcu, pBitmap, x:="", y:="", w:=0, h:=0, PixelFormat:="0xE200B", KeepPixelFormat:=0) {
    r := Gdip_CloneBitmapArea(pBitmap, x, y, w, h, PixelFormat, KeepPixelFormat)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_CloneBitmap(funcu, pBitmap) {
    r := Gdip_CloneBitmap(pBitmap)
    If (gdipLastError=1 && A_LastError=8)
       gdipLastError := 3

    If (gdipLastError && r)
    {
       addJournalEntry(A_ThisFunc "() called by " funcu "() has failed - disposing obj=" r " info: " Gdip_ErrorHandler(gdipLastError, 0))
       trGdip_DisposeImage(r, 1)
       Return
    }

    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Else
       addJournalEntry(A_ThisFunc "() invoked by " funcu "() failed, pBitmap = " pBitmap ": " Gdip_ErrorHandler(gdipLastError, 0))

    Return r
}

trGdip_BlurBitmap(pBitmap, BlurAmount, usePARGB:=0, quality:=7) {
    If !pBitmap
       addJournalEntry("WARNING: no bitmap given to blur...")

    r := Gdip_BlurBitmap(pBitmap, BlurAmount, usePARGB, quality)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RenderPixelsOpaque(pBitmap, pBrush:=0, alphaLevel:=0) {
    r := Gdip_RenderPixelsOpaque(pBitmap, pBrush, alphaLevel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Else
       addJournalEntry(A_ThisFunc "() failed, pBitmap = " pBitmap)
    Return r
}

trGdip_RetrieveBitmapChannel(pBitmap, channel) {
    r := Gdip_RetrieveBitmapChannel(pBitmap, channel, coreDesiredPixFmt)
    If r
       createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc]
    Return r
}

trGdip_ResizeBitmap(funcu, pBitmap, givenW, givenH, KeepRatio, InterpolationMode:="", KeepPixelFormat:=0, checkTooLarge:=0) {
    thisPixFmt := (KeepPixelFormat=-1) ? coreDesiredPixFmt : KeepPixelFormat
    r := Gdip_ResizeBitmap(pBitmap, givenW, givenH, KeepRatio, InterpolationMode, thisPixFmt, checkTooLarge)
    If StrLen(r)<3
    {
       baseMsg := "Unable to resize internal bitmap to given size: W" givenW " - H" givenH " for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error. "
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Return r
}

trGdip_RotateBitmapAtCenter(funcu, pBitmap, Angle, pBrush:=0, InterpolationMode:=7, PixelFormat:=0) {
    If !Angle
    {
       newBitmap := Gdip_CloneBmpPargbArea(A_ThisFunc "() initially invoked by " funcu "()", pBitmap)
       Return newBitmap
    }

    thisPixFmt := (PixelFormat=-1) ? coreDesiredPixFmt : PixelFormat
    r := Gdip_RotateBitmapAtCenter(pBitmap, Angle, pBrush, InterpolationMode, thisPixFmt)
    If StrLen(r)<3
    {
       baseMsg := "Unable to rotate internal bitmap to given angle: " angle "° for obj=" pBitmap ".`n`nError occured in " A_ThisFunc "() called by " funcu "()`n`nUnknown error."
       generalInternalErrorMsgBox(gdipLastError, baseMsg)
       Return
    } Else createdGDIobjsArray["x" r] := [r, "bmp", 1, A_ThisFunc "<-" funcu]
    Return r
}

trGdip_DisposeImage(pBitmap, noErr:=1) {
    ; If (createdGDIobjsArray["x" pBitmap, 3]=1 && createdGDIobjsArray["x" pBitmap, 2]="bmp")
       r := Gdip_DisposeImage(pBitmap, 1)

    If pBitmap
       createdGDIobjsArray["x" pBitmap] := [pBitmap, "bmp", 0, 0]
    Return r
}

gdipObjectsStats(killAll:=0, filteru:=0) {
   For Key, Value in createdGDIobjsArray
   {
      If (value[2]="bmp")
      {
         totalBMPs++
         If (value[3]=1)
         {
            If (killAll=1)
            {
               If (!InStr(value[4], filteru) && filteru)
                  Continue

               If !filteru
                  fnOutputDebug("Possible memory leak: " value[4])
               trGdip_DisposeImage(value[1], 1)
            }
            UnremovedBMPs++
         }
      }
   }

   If (killAll=1 && !filteru)
   {
      imgThumbsCacheArray := []
      imgThumbsCacheIDsArray := []
      imgsListArrayThumbs := []
   }

   If (killAll!=1)
      msgbox, % totalBMPs " // " UnremovedBMPs
}
